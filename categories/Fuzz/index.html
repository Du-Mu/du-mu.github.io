<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="browsermode" content="application">
<meta name="apple-touch-fullscreen" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="V3rdant's Blog">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="msapplication-navbutton-color" content="#666666">
<meta name= "format-detection" content="telephone=no" />




  <meta name="keywords" content="pwn" />



<link rel="apple-touch-startup-image" media="(device-width: 375px)" href="assets/apple-launch-1125x2436.png">
<link rel="apple-touch-startup-image" media="(orientation: landscape)" href="assets/apple-touch-startup-image-2048x1496.png">

<link rel="stylesheet" href="/style/style.css">

<script>
  var nlviconfig = {
    title: "V3rdant's Blog",
    author: "V3rdant",
    baseUrl: "/",
    theme: {
      scheme: "banderole",
      lightbox: true,
      animate: true,
      search: true,
      friends: false,
      reward: false,
      pjax: false,
      lazy: false,
      toc: true
    }
  }
</script>




    
<link rel="stylesheet" href="/script/lib/lightbox/css/lightbox.min.css">





    
<link rel="stylesheet" href="/syuanpi/syuanpi.min.css">
















<style>
@font-face {
  font-family: "Allura";
  src: url('/font/allura/allura.ttf');
}
</style>

  <title>
  
</title>
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="V3rdant's Blog" type="application/atom+xml">
</head>
<body>
  <div class="container">
    <header class="header" id="header">
  <div class="header-wrapper">
    <div class="logo">
  <div class="logo-inner syuanpi tvIn" style="display:none;">
    <h1><a href="/">V3rdant's Blog</a></h1>
    
  </div>
</div>

    <nav class="main-nav">
  
  <ul class="main-nav-list syuanpi tvIn">
  
    <li class="menu-item">
      <a href="javascript:;" id="search-btn" aria-label="Search">
        <i class="iconfont icon-search"></i>
      </a>
    </li>
  
  
  
    
  
    <li class="menu-item">
      <a href="/" id="article">
        <span class="base-name">
          
            ARTICLE
          
        </span>
      </a>
    </li>
  
  
    
  
    <li class="menu-item">
      <a href="/archives" id="archives">
        <span class="base-name">
          
            ARCHIVES
          
        </span>
      </a>
    </li>
  
  
    
  
    <li class="menu-item">
      <a href="javascript:;" id="tags">
        <span class="base-name">
          
            TAGS
          
        </span>
      </a>
    </li>
  
  
    
  
    <li class="menu-item">
      <a href="/about" id="about">
        <span class="base-name">
          
            ABOUT
          
        </span>
      </a>
    </li>
  
  
  </ul>
  
</nav>

  </div>
</header>
<div class="mobile-header" id="mobile-header">
  <div class="mobile-header-nav">
    <div class="mobile-header-item" id="mobile-left">
      <div class="header-menu-item">
        <div class="header-menu-line"></div>
      </div>
    </div>
    <h1 class="mobile-header-title">
      <a href="/">V3rdant's Blog</a>
    </h1>
    <div class="mobile-header-item"></div>
  </div>
  <div class="mobile-header-body">
    <ul class="mobile-header-list">
      
        <li class="mobile-nav-item syuanpi fadeInRightShort back-0">
          <a href="/" >
            
              ARTICLE
            
          </a>
        </li>
      
        <li class="mobile-nav-item syuanpi fadeInRightShort back-1">
          <a href="/archives" >
            
              ARCHIVES
            
          </a>
        </li>
      
        <li class="mobile-nav-item syuanpi fadeInRightShort back-2">
          <a href="javascript:;" id="mobile-tags">
            
              TAGS
            
          </a>
        </li>
      
        <li class="mobile-nav-item syuanpi fadeInRightShort back-3">
          <a href="/about" >
            
              ABOUT
            
          </a>
        </li>
      
    </ul>
  </div>
</div>



    <div class="container-inner" style="display:none;">
      <main class="main" id="main">
        <div class="main-wrapper">
          
    
  <div class="archive syuanpi fadeInRightShort" id="archive">
    
      <span class="archive-title"> now in </span>
      <span class="archive-name"> — Fuzz</span>
    
      
      
        
          </section>
        
        <div class="archive-post">
          <div class="archive-post-content">
            
              <h1 id="overview">overview</h1>
<p>对于AFL代码的重新阅读，笔者之前曾经阅读过一次AFL代码，但是比较粗糙，所以决定重新阅读一遍，理解其中比较细节的部分。</p>
<p>首先简单介绍一下AFL，AFL是一个覆盖率引导的fuzz 工具。</p>
<p>它将一个无跳转的顺序执行流程看成一个基本块，并通过一个bitmap记录运行时每一个输入对应的标准块。</p>
<p>通过基本块的覆盖率引导对于输入种子的变异，从而不断变换输入，进行测试，来挖掘漏洞。</p>
<h1 id="afl-gcc-afl-as-代码插桩">afl-gcc/afl-as | 代码插桩</h1>
<p>为了能够得到运行时代码覆盖率，AFL需要在编译时对产生的汇编代码进行插桩，在每个块前插入的桩代码能够写入对应bitmap</p>
<p>这是通过对afl-gcc的封装实现的</p>
<p><strong>afl-gcc</strong> 的核心逻辑很简单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>))</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-cc &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    be_quiet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\n&quot;</span></span><br><span class="line">         <span class="string">&quot;for gcc or clang, letting you recompile third-party code with the required\n&quot;</span></span><br><span class="line">         <span class="string">&quot;runtime instrumentation. A common use pattern would be one of the following:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;  CC=%s/afl-gcc ./configure\n&quot;</span></span><br><span class="line">         <span class="string">&quot;  CXX=%s/afl-g++ ./configure\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\n&quot;</span></span><br><span class="line">         <span class="string">&quot;Setting AFL_HARDEN enables hardening optimizations in the compiled code.\n\n&quot;</span>,</span><br><span class="line">         BIN_PATH, BIN_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  find_as(argv[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// 首先找到封装的afl-as</span></span><br><span class="line">  edit_params(argc, argv);</span><br><span class="line">  <span class="comment">// 然后对于参数进行处理传给真正的编译器</span></span><br><span class="line">  execvp(cc_params[<span class="number">0</span>], (<span class="type">char</span> **)cc_params);</span><br><span class="line">  <span class="comment">// 然后运行编译器</span></span><br><span class="line">  FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, cc_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后是<strong>afl-as</strong>，他是as的封装，插桩就是在此完成的,  这里主要关注插装的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">  s32 pid;</span><br><span class="line">  u32 rand_seed;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  u8* inst_ratio_str = getenv(<span class="string">&quot;AFL_INST_RATIO&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span></span><br><span class="line"></span><br><span class="line">  clang_mode = !!getenv(CLANG_ENV_VAR);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-as &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It is a wrapper around GNU &#x27;as&#x27;,\n&quot;</span></span><br><span class="line">         <span class="string">&quot;executed by the toolchain whenever using afl-gcc or afl-clang. You probably\n&quot;</span></span><br><span class="line">         <span class="string">&quot;don&#x27;t want to run this program directly.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;Rarely, when dealing with extremely complex projects, it may be advisable to\n&quot;</span></span><br><span class="line">         <span class="string">&quot;set AFL_INST_RATIO to a value less than 100 in order to reduce the odds of\n&quot;</span></span><br><span class="line">         <span class="string">&quot;instrumenting every discovered branch.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;tv, &amp;tz);</span><br><span class="line"></span><br><span class="line">  rand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();</span><br><span class="line"></span><br><span class="line">  srandom(rand_seed);</span><br><span class="line"></span><br><span class="line">  edit_params(argc, argv);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (inst_ratio_str) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(inst_ratio_str, <span class="string">&quot;%u&quot;</span>, &amp;inst_ratio) != <span class="number">1</span> || inst_ratio &gt; <span class="number">100</span>) </span><br><span class="line">      FATAL(<span class="string">&quot;Bad value of AFL_INST_RATIO (must be between 0 and 100)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(AS_LOOP_ENV_VAR))</span><br><span class="line">    FATAL(<span class="string">&quot;Endless loop when calling &#x27;as&#x27; (remove &#x27;.&#x27; from your PATH)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  setenv(AS_LOOP_ENV_VAR, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When compiling with ASAN, we don&#x27;t have a particularly elegant way to skip</span></span><br><span class="line"><span class="comment">     ASAN-specific branches. But we can probabilistically compensate for</span></span><br><span class="line"><span class="comment">     that... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_ASAN&quot;</span>) || getenv(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) &#123;</span><br><span class="line">    sanitizer = <span class="number">1</span>;</span><br><span class="line">    inst_ratio /= <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!just_version) add_instrumentation();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(pid = fork())) &#123;</span><br><span class="line"></span><br><span class="line">    execvp(as_params[<span class="number">0</span>], (<span class="type">char</span>**)as_params);</span><br><span class="line">    FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, as_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt;= <span class="number">0</span>) PFATAL(<span class="string">&quot;waitpid() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!getenv(<span class="string">&quot;AFL_KEEP_ASSEMBLY&quot;</span>)) unlink(modified_file);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(WEXITSTATUS(status));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插装的核心在于调用的 <code>add_instrumentation</code> 函数</p>
<h2 id="add-instrumentation">add_instrumentation</h2>
<p>首先打开input文件和output文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">add_instrumentation</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8 line[MAX_LINE];</span><br><span class="line"></span><br><span class="line">  FILE* inf;</span><br><span class="line">  FILE* outf;</span><br><span class="line">  s32 outfd;</span><br><span class="line">  u32 ins_lines = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  u8  instr_ok = <span class="number">0</span>, skip_csect = <span class="number">0</span>, skip_next_label = <span class="number">0</span>,</span><br><span class="line">      skip_intel = <span class="number">0</span>, skip_app = <span class="number">0</span>, instrument_next = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">  u8* colon_pos;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (input_file) &#123;</span><br><span class="line"></span><br><span class="line">    inf = fopen(input_file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!inf) PFATAL(<span class="string">&quot;Unable to read &#x27;%s&#x27;&quot;</span>, input_file);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> inf = <span class="built_in">stdin</span>;</span><br><span class="line"></span><br><span class="line">  outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (outfd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to write to &#x27;%s&#x27;&quot;</span>, modified_file);</span><br><span class="line"></span><br><span class="line">  outf = fdopen(outfd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!outf) PFATAL(<span class="string">&quot;fdopen() failed&quot;</span>);  </span><br></pre></td></tr></table></figure>
<p>然后开始循环遍历input文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">while</span> (fgets(line, MAX_LINE, inf)) &#123;</span><br></pre></td></tr></table></figure>
<p>在特定位置插桩代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;</span><br><span class="line">    instrument_next &amp;&amp; line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; <span class="built_in">isalpha</span>(line[<span class="number">1</span>])) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">          R(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">  instrument_next = <span class="number">0</span>;</span><br><span class="line">  ins_lines++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将原行写回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(line, outf);</span><br></pre></td></tr></table></figure>
<p>由于一般只在text段插桩，所以要在找到此段，并且用 <code>instr_ok</code> 来标识</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pass_thru) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* All right, this is where the actual fun begins. For one, we only want to</span></span><br><span class="line"><span class="comment">   instrument the .text section. So, let&#x27;s keep track of that in processed</span></span><br><span class="line"><span class="comment">   files - and let&#x27;s set instr_ok accordingly. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; line[<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* OpenBSD puts jump tables directly inline with the code, which is</span></span><br><span class="line"><span class="comment">     a bit annoying. They use a specific format of p2align directives</span></span><br><span class="line"><span class="comment">     around them, so we use that as a signal. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!clang_mode &amp;&amp; instr_ok &amp;&amp; !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;p2align &quot;</span>, <span class="number">8</span>) &amp;&amp;</span><br><span class="line">      <span class="built_in">isdigit</span>(line[<span class="number">10</span>]) &amp;&amp; line[<span class="number">11</span>] == <span class="string">&#x27;\n&#x27;</span>) skip_next_label = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;text\n&quot;</span>, <span class="number">5</span>) ||</span><br><span class="line">      !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t.text&quot;</span>, <span class="number">13</span>) ||</span><br><span class="line">      !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t__TEXT,__text&quot;</span>, <span class="number">21</span>) ||</span><br><span class="line">      !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section __TEXT,__text&quot;</span>, <span class="number">21</span>)) &#123;</span><br><span class="line">    instr_ok = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">continue</span>; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t&quot;</span>, <span class="number">8</span>) ||</span><br><span class="line">      !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section &quot;</span>, <span class="number">8</span>) ||</span><br><span class="line">      !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;bss\n&quot;</span>, <span class="number">4</span>) ||</span><br><span class="line">      !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;data\n&quot;</span>, <span class="number">5</span>)) &#123;</span><br><span class="line">    instr_ok = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>skip_csect</code> 用来跳过无用段，比如64位程序中的.code32段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code32&quot;</span>)) skip_csect = use_64bit;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code64&quot;</span>)) skip_csect = !use_64bit;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跳过intel 风格的汇编</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.intel_syntax&quot;</span>)) skip_intel = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.att_syntax&quot;</span>)) skip_intel = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>跳过 ad-hoc __asm__  字段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || line[<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#APP&quot;</span>)) skip_app = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#NO_APP&quot;</span>)) skip_app = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，对于条件跳转，直接插桩</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (line[<span class="number">1</span>] == <span class="string">&#x27;j&#x27;</span> &amp;&amp; line[<span class="number">2</span>] != <span class="string">&#x27;m&#x27;</span> &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">            R(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">    ins_lines++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>识别跳转标签来插桩，并且针对不同平台进行处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Apple: L&lt;whatever&gt;&lt;digit&gt;: */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((colon_pos = <span class="built_in">strstr</span>(line, <span class="string">&quot;:&quot;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;L&#x27;</span> &amp;&amp; <span class="built_in">isdigit</span>(*(colon_pos - <span class="number">1</span>))) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Everybody else: .L&lt;whatever&gt;: */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* .L0: or LBB0_0: style jump destination */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Apple: L&lt;num&gt; / LBB&lt;num&gt; */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">isdigit</span>(line[<span class="number">1</span>]) || (clang_mode &amp;&amp; !<span class="built_in">strncmp</span>(line, <span class="string">&quot;LBB&quot;</span>, <span class="number">3</span>)))</span><br><span class="line">            &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Apple: .L&lt;num&gt; / .LBB&lt;num&gt; */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">isdigit</span>(line[<span class="number">2</span>]) || (clang_mode &amp;&amp; !<span class="built_in">strncmp</span>(line + <span class="number">1</span>, <span class="string">&quot;LBB&quot;</span>, <span class="number">3</span>)))</span><br><span class="line">            &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* An optimization is possible here by adding the code only if the</span></span><br><span class="line"><span class="comment">             label is mentioned in the code in contexts other than call / jmp.</span></span><br><span class="line"><span class="comment">             That said, this complicates the code by requiring two-pass</span></span><br><span class="line"><span class="comment">             processing (messy with stdin), and results in a speed gain</span></span><br><span class="line"><span class="comment">             typically under 10%, because compilers are generally pretty good</span></span><br><span class="line"><span class="comment">             about not generating spurious intra-function jumps.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             We use deferred output chiefly to avoid disrupting</span></span><br><span class="line"><span class="comment">             .Lfunc_begin0-style exception handling calculations (a problem on</span></span><br><span class="line"><span class="comment">             MacOS X). */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!skip_next_label) instrument_next = <span class="number">1</span>; <span class="keyword">else</span> skip_next_label = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Function label (always instrumented, deferred mode). */</span></span><br><span class="line"></span><br><span class="line">        instrument_next = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>最后，如果进行了插桩，再插入<code>main_payload</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ins_lines)</span><br><span class="line">  <span class="built_in">fputs</span>(use_64bit ? main_payload_64 : main_payload_32, outf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (input_file) fclose(inf);</span><br><span class="line">fclose(outf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!be_quiet) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!ins_lines) WARNF(<span class="string">&quot;No instrumentation targets found%s.&quot;</span>,</span><br><span class="line">                        pass_thru ? <span class="string">&quot; (pass-thru mode)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> OKF(<span class="string">&quot;Instrumented %u locations (%s-bit, %s mode, ratio %u%%).&quot;</span>,</span><br><span class="line">           ins_lines, use_64bit ? <span class="string">&quot;64&quot;</span> : <span class="string">&quot;32&quot;</span>,</span><br><span class="line">           getenv(<span class="string">&quot;AFL_HARDEN&quot;</span>) ? <span class="string">&quot;hardened&quot;</span> : </span><br><span class="line">           (sanitizer ? <span class="string">&quot;ASAN/MSAN&quot;</span> : <span class="string">&quot;non-hardened&quot;</span>),</span><br><span class="line">           inst_ratio);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，综合来看，其实最终就是插入了两个部分：</p>
<ul>
<li>trampoline_fmt</li>
<li>main_payload</li>
</ul>
<h2 id="trampoline-fmt-64">trampoline_fmt_64</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> u8* trampoline_fmt_64 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq -(128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rdx,  0(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rcx,  8(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rax, 16(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq $0x%08x, %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq 16(%%rsp), %%rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  8(%%rsp), %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  0(%%rsp), %%rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq (128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这是一段跳转代码， 前面用于保存参数，核心在于</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;movq $0x%08x, %%rcx\n&quot;</span></span><br><span class="line"><span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br></pre></td></tr></table></figure>
<p>在上文中可以看到，这里的rcx的值是fprintf 格式化的一个随机值，用来标识代码块，笔者其实有点疑惑为什么不用一个从0开始的值，然后一个个加上去，避免重复。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">        R(MAP_SIZE));</span><br></pre></td></tr></table></figure>
<p>核心调用的<code>__afl_maybe_log</code> 在 <code>main_payload</code> 中实现</p>
<h2 id="main-payload-64">main_payload_64</h2>
<p>这里整个流程大致如下(图源ScUpax0s师傅)</p>
<p>![[Pasted image 20240228220636.png]]</p>
<h3 id="第一次运行">第一次运行</h3>
<h4 id="初始化">初始化</h4>
<p>首先是检查共享内存是否初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;  seto  %al\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Check if SHM region is already mapped. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq  __afl_area_ptr(%rip), %rdx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  testq %rdx, %rdx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  je    __afl_setup\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果没有，初始化共享内存并将指针保存至 <code>__afl_area_ptr</code>  和 <code>__afl_global_area</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">  <span class="string">&quot;__afl_setup:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Do not retry setup if we had previous failures. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpb $0, __afl_setup_failure(%rip)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jne __afl_return\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Check out if we have a global pointer on file. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __APPLE__</span></span><br><span class="line">  <span class="string">&quot;  movq  __afl_global_area_ptr@GOTPCREL(%rip), %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq  (%rdx), %rdx\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  movq  __afl_global_area_ptr(%rip), %rdx\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !^__APPLE__ */</span></span></span><br><span class="line">  <span class="string">&quot;  testq %rdx, %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je    __afl_setup_first\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rdx, __afl_area_ptr(%rip)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jmp  __afl_store\n&quot;</span> </span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;__afl_setup_first:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Save everything that is not yet saved and that may be touched by\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     getenv() and several other libcalls we&#x27;ll be relying on. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq -352(%rsp), %rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rax,   0(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rcx,   8(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rdi,  16(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rsi,  32(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %r8,   40(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %r9,   48(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %r10,  56(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %r11,  64(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm0,  96(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm1,  112(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm2,  128(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm3,  144(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm4,  160(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm5,  176(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm6,  192(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm7,  208(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm8,  224(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm9,  240(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm10, 256(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm11, 272(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm12, 288(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm13, 304(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm14, 320(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm15, 336(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Map SHM, jumping to __afl_setup_abort if something goes wrong. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* The 64-bit ABI requires 16-byte stack alignment. We&#x27;ll keep the\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     original stack ptr in the callee-saved r12. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushq %r12\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq  %rsp, %r12\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  subq  $16, %rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  andq  $0xfffffffffffffff0, %rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq .AFL_SHM_ENV(%rip), %rdi\n&quot;</span></span><br><span class="line">  CALL_L64(<span class="string">&quot;getenv&quot;</span>)</span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  testq %rax, %rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je    __afl_setup_abort\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq  %rax, %rdi\n&quot;</span></span><br><span class="line">  CALL_L64(<span class="string">&quot;atoi&quot;</span>)</span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  xorq %rdx, %rdx   /* shmat flags    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  xorq %rsi, %rsi   /* requested addr */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rax, %rdi   /* SHM ID         */\n&quot;</span></span><br><span class="line">  CALL_L64(<span class="string">&quot;shmat&quot;</span>)</span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpq $-1, %rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je   __afl_setup_abort\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Store the address of the SHM region. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rax, %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rax, __afl_area_ptr(%rip)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line">  <span class="string">&quot;  movq %rax, __afl_global_area_ptr(%rip)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  movq __afl_global_area_ptr@GOTPCREL(%rip), %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rax, (%rdx)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line">  <span class="string">&quot;  movq %rax, %rdx\n&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后通过管道通知主进程此进程已经准备好了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__afl_forkserver:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Enter the fork server mode to avoid the overhead of execve() calls. We\n&quot;</span></span><br><span class="line"><span class="string">&quot;     push rdx (area ptr) twice to keep stack alignment neat. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  pushq %rdx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  pushq %rdx\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Phone home and tell the parent that we&#x27;re OK. (Note that signals with\n&quot;</span></span><br><span class="line"><span class="string">&quot;     no SA_RESTART will mess it up). If this fails, assume that the fd is\n&quot;</span></span><br><span class="line"><span class="string">&quot;     closed because we were execve()d from an instrumented binary, or because\n&quot;</span></span><br><span class="line"><span class="string">&quot;     the parent doesn&#x27;t want to use the fork server. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq $4, %rdx               /* length    */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  leaq __afl_temp(%rip), %rsi /* data      */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;, %rdi       /* file desc */\n&quot;</span></span><br><span class="line">CALL_L64(<span class="string">&quot;write&quot;</span>)</span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  cmpq $4, %rax\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jne  __afl_fork_resume\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="afl-fork-wait-loop"><code>__afl_fork_wait_loop</code></h4>
<p><code>__afl_fork_wait_loop</code> 的作用是阻塞当前进程，直到从管道收到主进程发来的运行命令，如果收到了信号，则fork一个子进程，并调用 <code>__afl_fork_resume</code> 继续运行，否则继续阻塞</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__afl_fork_wait_loop:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Wait for parent by reading from the pipe. Abort if read fails. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq $4, %rdx               /* length    */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  leaq __afl_temp(%rip), %rsi /* data      */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq $&quot;</span> STRINGIFY(FORKSRV_FD) <span class="string">&quot;, %rdi             /* file desc */\n&quot;</span></span><br><span class="line">CALL_L64(<span class="string">&quot;read&quot;</span>)</span><br><span class="line"><span class="string">&quot;  cmpq $4, %rax\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jne  __afl_die\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Once woken up, create a clone of our process. This is an excellent use\n&quot;</span></span><br><span class="line"><span class="string">&quot;     case for syscall(__NR_clone, 0, CLONE_PARENT), but glibc boneheadedly\n&quot;</span></span><br><span class="line"><span class="string">&quot;     caches getpid() results and offers no way to update the value, breaking\n&quot;</span></span><br><span class="line"><span class="string">&quot;     abort(), raise(), and a bunch of other things :-( */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line">CALL_L64(<span class="string">&quot;fork&quot;</span>)</span><br><span class="line"><span class="string">&quot;  cmpq $0, %rax\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jl   __afl_die\n&quot;</span></span><br><span class="line"><span class="string">&quot;  je   __afl_fork_resume\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* In parent process: write PID to pipe, then wait for child. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movl %eax, __afl_fork_pid(%rip)\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq $4, %rdx                   /* length    */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  leaq __afl_fork_pid(%rip), %rsi /* data      */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;, %rdi             /* file desc */\n&quot;</span></span><br><span class="line">CALL_L64(<span class="string">&quot;write&quot;</span>)</span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq $0, %rdx                   /* no flags  */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  leaq __afl_temp(%rip), %rsi     /* status    */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq __afl_fork_pid(%rip), %rdi /* PID       */\n&quot;</span></span><br><span class="line">CALL_L64(<span class="string">&quot;waitpid&quot;</span>)</span><br><span class="line"><span class="string">&quot;  cmpq $0, %rax\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jle  __afl_die\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Relay wait status to pipe, then loop back. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq $4, %rdx               /* length    */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  leaq __afl_temp(%rip), %rsi /* data      */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;, %rdi         /* file desc */\n&quot;</span></span><br><span class="line">CALL_L64(<span class="string">&quot;write&quot;</span>)</span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jmp  __afl_fork_wait_loop\n&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>__afl_fork_resume</code> 用于恢复运行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__afl_fork_resume:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* In child process: close fds, resume execution. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq $&quot;</span> STRINGIFY(FORKSRV_FD) <span class="string">&quot;, %rdi\n&quot;</span></span><br><span class="line">CALL_L64(<span class="string">&quot;close&quot;</span>)</span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;, %rdi\n&quot;</span></span><br><span class="line">CALL_L64(<span class="string">&quot;close&quot;</span>)</span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  popq %rdx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  popq %rdx\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %r12, %rsp\n&quot;</span></span><br><span class="line"><span class="string">&quot;  popq %r12\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq  0(%rsp), %rax\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq  8(%rsp), %rcx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 16(%rsp), %rdi\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 32(%rsp), %rsi\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 40(%rsp), %r8\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 48(%rsp), %r9\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 56(%rsp), %r10\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 64(%rsp), %r11\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq  96(%rsp), %xmm0\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 112(%rsp), %xmm1\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 128(%rsp), %xmm2\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 144(%rsp), %xmm3\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 160(%rsp), %xmm4\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 176(%rsp), %xmm5\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 192(%rsp), %xmm6\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 208(%rsp), %xmm7\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 224(%rsp), %xmm8\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 240(%rsp), %xmm9\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 256(%rsp), %xmm10\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 272(%rsp), %xmm11\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 288(%rsp), %xmm12\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 304(%rsp), %xmm13\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 320(%rsp), %xmm14\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 336(%rsp), %xmm15\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  leaq 352(%rsp), %rsp\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jmp  __afl_store\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;__afl_die:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  xorq %rax, %rax\n&quot;</span></span><br><span class="line">CALL_L64(<span class="string">&quot;_exit&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="afl-store"><code>__afl_store</code></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="string">&quot;__afl_store:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Calculate and store hit for the code location specified in rcx. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> COVERAGE_ONLY</span></span><br><span class="line">  <span class="string">&quot;  xorq __afl_prev_loc(%rip), %rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  xorq %rcx, __afl_prev_loc(%rip)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  shrq $1, __afl_prev_loc(%rip)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^!COVERAGE_ONLY */</span></span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SKIP_COUNTS</span></span><br><span class="line">  <span class="string">&quot;  orb  $1, (%rdx, %rcx, 1)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  incb (%rdx, %rcx, 1)\n&quot;</span></span><br></pre></td></tr></table></figure>
<p>这是一段非常简单的代码</p>
<p>但是笔者其实还没有完全理解，此处的代码用 随机id异或上一个桩的随机id来作为当前块在bitmap里的offset，并将此offset处的计数加一，同时，将此id存入 <code>__afl_prev_loc</code> 使用，并右移一位。</p>
<p>这里offset是怎么保证不重复的呢，笔者感觉应该是跟线性同余算法的特性有关，不过由于不是笔者的重点，所以笔者暂且不过多探究。</p>
<h1 id="afl-fuzz-一次fuzz的标准流程">afl-fuzz | 一次fuzz的标准流程</h1>
<h2 id="全局变量">全局变量</h2>
<p>首先是bitmap相关</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXP_ST u8 *trace_bits; <span class="comment">// 和子进程共享的bitmap，程序运行的结果就存在于此bitmap中</span></span><br><span class="line"></span><br><span class="line">EXP_ST u8 virgin_bits[MAP_SIZE], <span class="comment">// 标记仍然没有被触及到的区域</span></span><br><span class="line">    virgin_tmout[MAP_SIZE],      <span class="comment">// 标记还没有出现在tmout的区域</span></span><br><span class="line">    virgin_crash[MAP_SIZE];      <span class="comment">// 标记还没有出现在crash的区域</span></span><br></pre></td></tr></table></figure>
<p>然后是testcase组成的队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">  u8 *fname; <span class="comment">/* File name for the test case      */</span></span><br><span class="line">  u32 len;   <span class="comment">/* Input length                     */</span></span><br><span class="line"></span><br><span class="line">  u8 cal_failed,    <span class="comment">/* Calibration failed?              */</span></span><br><span class="line">      trim_done,    <span class="comment">/* Trimmed?                         */</span></span><br><span class="line">      was_fuzzed,   <span class="comment">/* Had any fuzzing done yet?        */</span></span><br><span class="line">      passed_det,   <span class="comment">/* Deterministic stages passed?     */</span></span><br><span class="line">      has_new_cov,  <span class="comment">/* Triggers new coverage?           */</span></span><br><span class="line">      var_behavior, <span class="comment">/* Variable behavior?               */</span></span><br><span class="line">      favored,      <span class="comment">/* Currently favored?               */</span></span><br><span class="line">      fs_redundant; <span class="comment">/* Marked as redundant in the fs?   */</span></span><br><span class="line"></span><br><span class="line">  u32 bitmap_size, <span class="comment">/* Number of bits set in bitmap     */</span></span><br><span class="line">      exec_cksum;  <span class="comment">/* Checksum of the execution trace  */</span></span><br><span class="line"></span><br><span class="line">  u64 exec_us,  <span class="comment">/* Execution time (us)              */</span></span><br><span class="line">      handicap, <span class="comment">/* Number of queue cycles behind    */</span></span><br><span class="line">      depth;    <span class="comment">/* Path depth                       */</span></span><br><span class="line"></span><br><span class="line">  u8 *trace_mini; <span class="comment">/* Trace bytes, if kept             */</span></span><br><span class="line">  u32 tc_ref;     <span class="comment">/* Trace bytes ref count            */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> *<span class="title">next</span>, /* <span class="title">Next</span> <span class="title">element</span>, <span class="title">if</span> <span class="title">any</span>             */</span></span><br><span class="line"><span class="class">      *<span class="title">next_100</span>;</span>            <span class="comment">/* 100 elements ahead               */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> *<span class="title">queue</span>, /* <span class="title">Fuzzing</span> <span class="title">queue</span> (<span class="title">linked</span> <span class="title">list</span>)      */</span></span><br><span class="line"><span class="class">    *<span class="title">queue_cur</span>,                   // 当前处理的<span class="title">testscase</span></span></span><br><span class="line"><span class="class">    *<span class="title">queue_top</span>,                   // <span class="title">testcase</span> <span class="title">list</span>的顶部</span></span><br><span class="line"><span class="class">    *<span class="title">q_prev100</span>;</span>                   <span class="comment">// 前100标记</span></span><br></pre></td></tr></table></figure>
<p>然后是与queue相关的一些变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">EXP_ST u32 queued_paths,  <span class="comment">// </span></span><br><span class="line">    queued_variable,     <span class="comment">// 存在可变区域的testcase的数量</span></span><br><span class="line">    queued_at_start,     <span class="comment">// testcase 的初始数量</span></span><br><span class="line">    queued_discovered,   <span class="comment">// 运行时发现的数量</span></span><br><span class="line">    queued_imported,     <span class="comment">// 通过-S引入的数量</span></span><br><span class="line">    queued_favored,      <span class="comment">// favored_queue 的数量</span></span><br><span class="line">    queued_with_cov,     <span class="comment">// 存在新覆盖的queue的数量</span></span><br><span class="line">    pending_not_fuzzed,  <span class="comment">// 还没有被fuzz的数量</span></span><br><span class="line">    pending_favored,     <span class="comment">// 还没有被fuzz的favored_queue的数量</span></span><br><span class="line">    cur_skipped_paths,   <span class="comment">/* Abandoned inputs in cur cycle    */</span></span><br><span class="line">    cur_depth,           <span class="comment">/* Current path depth               */</span></span><br><span class="line">    max_depth,           <span class="comment">/* Max path depth                   */</span></span><br><span class="line">    useless_at_start,    <span class="comment">/* Number of useless starting paths */</span></span><br><span class="line">    var_byte_count,      <span class="comment">/* Bitmap bytes with var behavior   */</span></span><br><span class="line">    current_entry,       <span class="comment">/* Current queue entry ID           */</span></span><br><span class="line">    havoc_div = <span class="number">1</span>;       <span class="comment">/* Cycle count divisor for havoc    */</span></span><br></pre></td></tr></table></figure>
<h2 id="main">main</h2>
<p>fuzz的开始是对于参数的解析</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>: <span class="comment">/* input dir */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_dir) FATAL(<span class="string">&quot;Multiple -i options not supported&quot;</span>);</span><br><span class="line">  in_dir = optarg;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(in_dir, <span class="string">&quot;-&quot;</span>)) in_place_resume = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">  ....</span><br></pre></td></tr></table></figure>
<p>在完成参数的解析后， 开始设置对应的信号处理的handle, 这一部分将在之后进行分析</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setup_signal_handlers();</span><br></pre></td></tr></table></figure>
<p>以及检查ASAN参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check_asan_opts();</span><br></pre></td></tr></table></figure>
<p>然后开始对应环境变量的解析</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sync_id) fix_up_sync();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(in_dir, out_dir))</span><br><span class="line">  FATAL(<span class="string">&quot;Input and output directories can&#x27;t be the same&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dumb_mode) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (crash_mode) FATAL(<span class="string">&quot;-C and -n are mutually exclusive&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (qemu_mode)  FATAL(<span class="string">&quot;-Q and -n are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_NO_FORKSRV&quot;</span>))    no_forkserver    = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_NO_CPU_RED&quot;</span>))    no_cpu_meter_red = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_NO_ARITH&quot;</span>))      no_arith         = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_SHUFFLE_QUEUE&quot;</span>)) shuffle_queue    = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_FAST_CAL&quot;</span>))      fast_cal         = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_HANG_TMOUT&quot;</span>)) &#123;</span><br><span class="line">  hang_tmout = atoi(getenv(<span class="string">&quot;AFL_HANG_TMOUT&quot;</span>));</span><br><span class="line">  <span class="keyword">if</span> (!hang_tmout) FATAL(<span class="string">&quot;Invalid value of AFL_HANG_TMOUT&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dumb_mode == <span class="number">2</span> &amp;&amp; no_forkserver)</span><br><span class="line">  FATAL(<span class="string">&quot;AFL_DUMB_FORKSRV and AFL_NO_FORKSRV are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_PRELOAD&quot;</span>)) &#123;</span><br><span class="line">  setenv(<span class="string">&quot;LD_PRELOAD&quot;</span>, getenv(<span class="string">&quot;AFL_PRELOAD&quot;</span>), <span class="number">1</span>);</span><br><span class="line">  setenv(<span class="string">&quot;DYLD_INSERT_LIBRARIES&quot;</span>, getenv(<span class="string">&quot;AFL_PRELOAD&quot;</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_LD_PRELOAD&quot;</span>))</span><br><span class="line">  FATAL(<span class="string">&quot;Use AFL_PRELOAD instead of AFL_LD_PRELOAD&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>对于此处涉及到的环境变量将在后面一一说明</p>
<p>接下来将原来的命令行参数保存起来</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save_cmdline(argc, argv);</span><br></pre></td></tr></table></figure>
<p>设置用户态banner</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fix_up_banner(argv[optind]);</span><br></pre></td></tr></table></figure>
<p>检查是否在tty模式下运行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check_if_tty();</span><br></pre></td></tr></table></figure>
<p>获取核心数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_core_count();</span><br></pre></td></tr></table></figure>
<p>如果设置了 AFFINITY</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_AFFINITY</span></span><br><span class="line">  bind_to_free_cpu();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* HAVE_AFFINITY */</span></span></span><br></pre></td></tr></table></figure>
<p>然后是一些对于机器和架构的检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">check_crash_handling();</span><br><span class="line">check_cpu_governor();</span><br></pre></td></tr></table></figure>
<p>设置postprocessor</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setup_post();</span><br></pre></td></tr></table></figure>
<p>设置共享内存用于消息的传递</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setup_shm();</span><br></pre></td></tr></table></figure>
<p>对于class16数据进行分类</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init_count_class16();</span><br></pre></td></tr></table></figure>
<p>为输出文件设置dir以及fd</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setup_dirs_fds();</span><br></pre></td></tr></table></figure>
<p>读取初始测试用例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read_testcases();</span><br><span class="line">load_auto();</span><br></pre></td></tr></table></figure>
<p>对输入目录进行一些处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pivot_inputs();</span><br></pre></td></tr></table></figure>
<p>接下来又是一连串的处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (extras_dir) load_extras(extras_dir);</span><br><span class="line"><span class="comment">// 如果设置了extras，那么加载extras</span></span><br><span class="line"><span class="comment">// 类似于字典</span></span><br><span class="line"><span class="keyword">if</span> (!timeout_given) find_timeout();</span><br><span class="line"><span class="comment">// 如果设置了timeout，设置给定timeout</span></span><br><span class="line">detect_file_args(argv + optind + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 检查运行参数，找到@@</span></span><br><span class="line"><span class="keyword">if</span> (!out_file) setup_stdio_file();</span><br><span class="line"><span class="comment">// 设置输出文件</span></span><br><span class="line">check_binary(argv[optind]);</span><br><span class="line"><span class="comment">// 检查目标程序</span></span><br><span class="line">start_time = get_cur_time();</span><br><span class="line"><span class="comment">// 设置起始时间</span></span><br><span class="line"><span class="keyword">if</span> (qemu_mode)</span><br><span class="line"><span class="comment">// 如果使用了qemu_mode</span></span><br><span class="line">  use_argv = get_qemu_argv(argv[<span class="number">0</span>], argv + optind, argc - optind);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  use_argv = argv + optind;</span><br></pre></td></tr></table></figure>
<p>对于输入进行试运行，确保所有输入符合预期</p>
<p>接下来cull_queue，在之后继续分析</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cull_queue();</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">show_init_stats();</span><br><span class="line"><span class="comment">// 输出初始状态</span></span><br><span class="line">seek_to = find_start_position();</span><br><span class="line"><span class="comment">// 针对resume状态而言，快速回复到终止位置</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">write_stats_file(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 将初始状态保存在stat文件中</span></span><br><span class="line">save_auto();</span><br><span class="line"><span class="comment">// 保存自动生成的extras </span></span><br></pre></td></tr></table></figure>
<p>接下来是针对stop的处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (stop_soon) <span class="keyword">goto</span> stop_fuzzing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!not_on_tty) &#123;</span><br><span class="line">  sleep(<span class="number">4</span>);</span><br><span class="line">  start_time += <span class="number">4000</span>;</span><br><span class="line">  <span class="keyword">if</span> (stop_soon) <span class="keyword">goto</span> stop_fuzzing;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后正式进入fuzz循环</p>
<p>在循环前还要cull_queue 一次</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">   u8 skipped_fuzz;</span><br><span class="line"></span><br><span class="line">   cull_queue();</span><br><span class="line"><span class="comment">// 再次进行cull_queue 操作</span></span><br><span class="line">   <span class="keyword">if</span> (!queue_cur) &#123;</span><br><span class="line">   </span><br><span class="line">     queue_cycle++;</span><br><span class="line">     current_entry     = <span class="number">0</span>;</span><br><span class="line">     cur_skipped_paths = <span class="number">0</span>;</span><br><span class="line">     queue_cur         = <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (seek_to) &#123;</span><br><span class="line">       current_entry++;</span><br><span class="line">       seek_to--;</span><br><span class="line">       queue_cur = queue_cur-&gt;next;</span><br><span class="line">     &#125;</span><br><span class="line">  <span class="comment">// 当存在seek_to时，直接跳到对应的testcase</span></span><br><span class="line">     show_stats();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (not_on_tty) &#123;</span><br><span class="line">       ACTF(<span class="string">&quot;Entering queue cycle %llu.&quot;</span>, queue_cycle);</span><br><span class="line">       fflush(<span class="built_in">stdout</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* If we had a full queue cycle with no new finds, try</span></span><br><span class="line"><span class="comment">        recombination strategies next. */</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (queued_paths == prev_queued) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (use_splicing) cycles_wo_finds++; <span class="keyword">else</span> use_splicing = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> cycles_wo_finds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     prev_queued = queued_paths;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (sync_id &amp;&amp; queue_cycle == <span class="number">1</span> &amp;&amp; getenv(<span class="string">&quot;AFL_IMPORT_FIRST&quot;</span>))</span><br><span class="line">       sync_fuzzers(use_argv);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   skipped_fuzz = fuzz_one(use_argv);</span><br><span class="line"><span class="comment">// 运行一次fuzz，并完成种子的变异阶段</span></span><br><span class="line">   <span class="keyword">if</span> (!stop_soon &amp;&amp; sync_id &amp;&amp; !skipped_fuzz) &#123;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> (!(sync_interval_cnt++ % SYNC_INTERVAL))</span><br><span class="line">       sync_fuzzers(use_argv);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!stop_soon &amp;&amp; exit_1) stop_soon = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (stop_soon) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">   queue_cur = queue_cur-&gt;next;</span><br><span class="line">   current_entry++;</span><br><span class="line">   <span class="comment">// 测试下一个种子</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="setup-shm-基于共享内存的消息传递">setup_shm | 基于共享内存的消息传递</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">EXP_ST <span class="type">void</span> <span class="title function_">setup_shm</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u8* shm_str;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!in_bitmap) <span class="built_in">memset</span>(virgin_bits, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(virgin_tmout, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(virgin_crash, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;shmget() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  atexit(remove_shm);</span><br><span class="line"></span><br><span class="line">  shm_str = alloc_printf(<span class="string">&quot;%d&quot;</span>, shm_id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If somebody is asking us to fuzz instrumented binaries in dumb mode,</span></span><br><span class="line"><span class="comment">     we don&#x27;t want them to detect instrumentation, since we won&#x27;t be sending</span></span><br><span class="line"><span class="comment">     fork server commands. This should be replaced with better auto-detection</span></span><br><span class="line"><span class="comment">     later on, perhaps? */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode) setenv(SHM_ENV_VAR, shm_str, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  ck_free(shm_str);</span><br><span class="line"></span><br><span class="line">  trace_bits = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (trace_bits == (<span class="type">void</span> *)<span class="number">-1</span>) PFATAL(<span class="string">&quot;shmat() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里直接创建一个共享内存，同子进程forkserver中 <code>__afl_global_area</code> 指向的区域进行共享</p>
<h2 id="对于testcase的预处理">对于testcase的预处理</h2>
<p>主要包含三个函数：</p>
<ul>
<li>read_testcase: 从文件中读取testcases</li>
<li>perform_dry_run: 对于testcase的试运行</li>
<li>cull_queue:</li>
</ul>
<h3 id="read-testcases-读取testcase">read_testcases | 读取testcase</h3>
<p>用来从文件中读取testcase</p>
<p>首先创建了一些局部变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> **<span class="title">nl</span>;</span></span><br><span class="line">s32 nl_cnt;</span><br><span class="line">u32 i;</span><br><span class="line">u8* fn;</span><br></pre></td></tr></table></figure>
<p>找到queue文件夹:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn = alloc_printf(<span class="string">&quot;%s/queue&quot;</span>, in_dir);</span><br><span class="line"><span class="keyword">if</span> (!access(fn, F_OK)) in_dir = fn; <span class="keyword">else</span> ck_free(fn);</span><br><span class="line"></span><br><span class="line">ACTF(<span class="string">&quot;Scanning &#x27;%s&#x27;...&quot;</span>, in_dir);</span><br></pre></td></tr></table></figure>
<p>通过scandir获取字母序的目录文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nl_cnt = scandir(in_dir, &amp;nl, <span class="literal">NULL</span>, alphasort);</span><br></pre></td></tr></table></figure>
<p>如果设置了shullle_queue，并且queue数量大于1，那就打乱此nl数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shuffle_queue &amp;&amp; nl_cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">  ACTF(<span class="string">&quot;Shuffling queue...&quot;</span>);</span><br><span class="line">  shuffle_ptrs((<span class="type">void</span>**)nl, nl_cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>shuffle的逻辑也很简单，就是进行n次的随机交换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">shuffle_ptrs</span><span class="params">(<span class="type">void</span>** ptrs, u32 cnt)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt - <span class="number">2</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    u32 j = i + UR(cnt - i);</span><br><span class="line">    <span class="type">void</span> *s = ptrs[i];</span><br><span class="line">    ptrs[i] = ptrs[j];</span><br><span class="line">    ptrs[j] = s;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是一个大循环，用来对于testcase一个个进行初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nl_cnt; i++) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">   u8* fn = alloc_printf(<span class="string">&quot;%s/%s&quot;</span>, in_dir, nl[i]-&gt;d_name);</span><br><span class="line">   u8* dfn = alloc_printf(<span class="string">&quot;%s/.state/deterministic_done/%s&quot;</span>, in_dir, nl[i]-&gt;d_name);</span><br><span class="line">   <span class="comment">// 首先找到两个对应文件</span></span><br><span class="line">   u8  passed_det = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">   <span class="built_in">free</span>(nl[i]); <span class="comment">/* not tracked */</span></span><br><span class="line">   <span class="comment">// 然后释放文件nl对象内存 </span></span><br><span class="line">   <span class="keyword">if</span> (lstat(fn, &amp;st) || access(fn, R_OK))</span><br><span class="line">     PFATAL(<span class="string">&quot;Unable to access &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line"><span class="comment">// 判断是否可以存在相应文件</span></span><br><span class="line">   <span class="comment">/* This also takes care of . and .. */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!S_ISREG(st.st_mode) || !st.st_size || <span class="built_in">strstr</span>(fn, <span class="string">&quot;/README.testcases&quot;</span>)) &#123;</span><br><span class="line">     <span class="comment">// 剔除 &quot;.&quot;、&quot;..&quot; 和 README.testcases </span></span><br><span class="line">     <span class="comment">// 以及空文件 等无效文件</span></span><br><span class="line">     ck_free(fn);</span><br><span class="line">     ck_free(dfn);</span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (st.st_size &gt; MAX_FILE) </span><br><span class="line">     FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; is too big (%s, limit is %s)&quot;</span>, fn,</span><br><span class="line">           DMS(st.st_size), DMS(MAX_FILE));</span><br><span class="line">   <span class="comment">// 如果testcase太大</span></span><br><span class="line">   <span class="comment">/* Check for metadata that indicates that deterministic fuzzing</span></span><br><span class="line"><span class="comment">      is complete for this entry. We don&#x27;t want to repeat deterministic</span></span><br><span class="line"><span class="comment">      fuzzing when resuming aborted scans, because it would be pointless</span></span><br><span class="line"><span class="comment">      and probably very time-consuming. */</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">// 通过是否存在deterministic_done文件，来判断是否是resuming </span></span><br><span class="line"><span class="comment">// 如果是resume，则跳过deterministic fuzz 阶段</span></span><br><span class="line">   <span class="keyword">if</span> (!access(dfn, F_OK)) passed_det = <span class="number">1</span>;</span><br><span class="line">   ck_free(dfn);</span><br><span class="line">   <span class="comment">// 将testcase添加进queue </span></span><br><span class="line">   add_to_queue(fn, st.st_size, passed_det);</span><br><span class="line">   </span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后是收尾的一些处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(nl); <span class="comment">/* not tracked */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!queued_paths)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">       <span class="string">&quot;Looks like there are no valid test cases in the input directory! The fuzzer\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    needs one or more test case to start with - ideally, a small file under\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    1 kB or so. The cases must be stored as regular files directly in the\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    input directory.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  FATAL(<span class="string">&quot;No usable test cases in &#x27;%s&#x27;&quot;</span>, in_dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">last_path_time = <span class="number">0</span>;</span><br><span class="line">queued_at_start = queued_paths;</span><br></pre></td></tr></table></figure>
<h4 id="add-to-queue">add_to_queue</h4>
<p>通过add_to_queue 将testcase加入queue</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">add_to_queue</span><span class="params">(u8* fname, u32 len, u8 passed_det)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">q</span> =</span> ck_alloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> queue_entry));</span><br><span class="line"></span><br><span class="line">  q-&gt;fname        = fname;</span><br><span class="line">  q-&gt;len          = len;</span><br><span class="line">  q-&gt;depth        = cur_depth + <span class="number">1</span>;</span><br><span class="line">  q-&gt;passed_det   = passed_det;</span><br><span class="line">  <span class="comment">// 设置queue的各个成员信息</span></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;depth &gt; max_depth) max_depth = q-&gt;depth;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_top) &#123;</span><br><span class="line"></span><br><span class="line">    queue_top-&gt;next = q;</span><br><span class="line">    queue_top = q;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> q_prev100 = <span class="built_in">queue</span> = queue_top = q;</span><br><span class="line">  <span class="comment">// 将此queue_entry加入队列</span></span><br><span class="line">  <span class="comment">// 将此queue_entry放入queue_top</span></span><br><span class="line">  queued_paths++;</span><br><span class="line">  <span class="comment">// 增加queue路径</span></span><br><span class="line">  pending_not_fuzzed++;</span><br><span class="line">  <span class="comment">// 增加等待fuzz 计数</span></span><br><span class="line">  cycles_wo_finds = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Set next_100 pointer for every 100th element (index 0, 100, etc) to allow faster iteration. */</span></span><br><span class="line">  <span class="keyword">if</span> ((queued_paths - <span class="number">1</span>) % <span class="number">100</span> == <span class="number">0</span> &amp;&amp; queued_paths &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// q_prev100 是一个相对于普通queue间隔100的queue，</span></span><br><span class="line">  <span class="comment">// 用来快速访问</span></span><br><span class="line">    q_prev100-&gt;next_100 = q;</span><br><span class="line">    q_prev100 = q;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  last_path_time = get_cur_time();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中最核心的部分就是设置了两个queue</p>
<h3 id="perform-dry-run-对于testcase的试运行">perform_dry_run | 对于testcase的试运行</h3>
<p>首先创建了一些局部变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> *<span class="title">q</span> =</span> <span class="built_in">queue</span>;</span><br><span class="line">u32 cal_failures = <span class="number">0</span>;</span><br><span class="line">u8 *skip_crashes = getenv(<span class="string">&quot;AFL_SKIP_CRASHES&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>然后进入了一个循环</strong></p>
<p>循环的开始是通过queue的文件名读取了输入用例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (q)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  u8 *use_mem;</span><br><span class="line">  u8 res;</span><br><span class="line">  s32 fd;</span><br><span class="line"></span><br><span class="line">  u8 *fn = <span class="built_in">strrchr</span>(q-&gt;fname, <span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  ACTF(<span class="string">&quot;Attempting dry run with &#x27;%s&#x27;...&quot;</span>, fn);</span><br><span class="line">  </span><br><span class="line">  fd = open(q-&gt;fname, O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, q-&gt;fname);</span><br><span class="line"> </span><br><span class="line">  use_mem = ck_alloc_nozero(q-&gt;len);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read(fd, use_mem, q-&gt;len) != q-&gt;len)</span><br><span class="line">    FATAL(<span class="string">&quot;Short read from &#x27;%s&#x27;&quot;</span>, q-&gt;fname);</span><br><span class="line"></span><br><span class="line">  close(fd);</span><br></pre></td></tr></table></figure>
<p>然后通过 <code>calibrate_case</code> 对testcase进行了处理并尝试运行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = calibrate_case(argv, q, use_mem, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">ck_free(use_mem);</span><br></pre></td></tr></table></figure>
<p>根据运行结果进行相应错误处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (res == crash_mode || res == FAULT_NOBITS)</span><br><span class="line">      SAYF(cGRA <span class="string">&quot;    len = %u, map size = %u, exec speed = %llu us\n&quot;</span> cRST,</span><br><span class="line">           q-&gt;len, q-&gt;bitmap_size, q-&gt;exec_us);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (res)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_NONE:</span><br><span class="line">      <span class="comment">// 如果没有错误，并且是queue的第一个testcase</span></span><br><span class="line">      <span class="keyword">if</span> (q == <span class="built_in">queue</span>)</span><br><span class="line">        check_map_coverage();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (crash_mode)</span><br><span class="line">        FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; does *NOT* crash&quot;</span>, fn);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_TMOUT:</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (timeout_given)</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The -t nn+ syntax in the command line sets timeout_given to &#x27;2&#x27; and</span></span><br><span class="line"><span class="comment">           instructs afl-fuzz to tolerate but skip queue entries that time</span></span><br><span class="line"><span class="comment">           out. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout_given &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          WARNF(<span class="string">&quot;Test case results in a timeout (skipping)&quot;</span>);</span><br><span class="line">          q-&gt;cal_failed = CAL_CHANCES;</span><br><span class="line">          cal_failures++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">             <span class="string">&quot;The program took more than %u ms to process one of the initial test cases.\n&quot;</span></span><br><span class="line">             <span class="string">&quot;    Usually, the right thing to do is to relax the -t option - or to delete it\n&quot;</span></span><br><span class="line">             <span class="string">&quot;    altogether and allow the fuzzer to auto-calibrate. That said, if you know\n&quot;</span></span><br><span class="line">             <span class="string">&quot;    what you are doing and want to simply skip the unruly test cases, append\n&quot;</span></span><br><span class="line">             <span class="string">&quot;    &#x27;+&#x27; at the end of the value passed to -t (&#x27;-t %u+&#x27;).\n&quot;</span>,</span><br><span class="line">             exec_tmout,</span><br><span class="line">             exec_tmout);</span><br><span class="line"></span><br><span class="line">        FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; results in a timeout&quot;</span>, fn);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">             <span class="string">&quot;The program took more than %u ms to process one of the initial test cases.\n&quot;</span></span><br><span class="line">             <span class="string">&quot;    This is bad news; raising the limit with the -t option is possible, but\n&quot;</span></span><br><span class="line">             <span class="string">&quot;    will probably make the fuzzing process extremely slow.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">             <span class="string">&quot;    If this test case is just a fluke, the other option is to just avoid it\n&quot;</span></span><br><span class="line">             <span class="string">&quot;    altogether, and find one that is less of a CPU hog.\n&quot;</span>,</span><br><span class="line">             exec_tmout);</span><br><span class="line"></span><br><span class="line">        FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; results in a timeout&quot;</span>, fn);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_CRASH:</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (crash_mode)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (skip_crashes)</span><br><span class="line">      &#123;</span><br><span class="line">        WARNF(<span class="string">&quot;Test case results in a crash (skipping)&quot;</span>);</span><br><span class="line">        q-&gt;cal_failed = CAL_CHANCES;</span><br><span class="line">        cal_failures++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (mem_limit)</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">             <span class="string">&quot;Oops, the program crashed with one of the test cases provided. There are\n&quot;</span></span><br><span class="line">             <span class="string">&quot;    several possible explanations:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">             <span class="string">&quot;    - The test case causes known crashes under normal working conditions. If\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      so, please remove it. The fuzzer should be seeded with interesting\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      inputs - but not ones that cause an outright crash.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">             <span class="string">&quot;    - The current memory limit (%s) is too low for this program, causing\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      it to die due to OOM when parsing valid files. To fix this, try\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      bumping it up with the -m setting in the command line. If in doubt,\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      try something along the lines of:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line">             <span class="string">&quot;      ( ulimit -Sv $[%llu &lt;&lt; 10]; /path/to/binary [...] &lt;testcase )\n\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">             <span class="string">&quot;      ( ulimit -Sd $[%llu &lt;&lt; 10]; /path/to/binary [...] &lt;testcase )\n\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^RLIMIT_AS */</span></span></span><br><span class="line"></span><br><span class="line">             <span class="string">&quot;      Tip: you can use http://jwilk.net/software/recidivm to quickly\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      estimate the required amount of virtual memory for the binary. Also,\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      if you are using ASAN, see %s/notes_for_asan.txt.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">             <span class="string">&quot;    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      break afl-fuzz performance optimizations when running platform-specific\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      binaries. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">             <span class="string">&quot;    - Least likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>,</span><br><span class="line">             DMS(mem_limit &lt;&lt; <span class="number">20</span>), mem_limit - <span class="number">1</span>, doc_path);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">             <span class="string">&quot;Oops, the program crashed with one of the test cases provided. There are\n&quot;</span></span><br><span class="line">             <span class="string">&quot;    several possible explanations:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">             <span class="string">&quot;    - The test case causes known crashes under normal working conditions. If\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      so, please remove it. The fuzzer should be seeded with interesting\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      inputs - but not ones that cause an outright crash.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">             <span class="string">&quot;    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      break afl-fuzz performance optimizations when running platform-specific\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      binaries. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">             <span class="string">&quot;    - Least likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; results in a crash&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_ERROR:</span><br><span class="line"></span><br><span class="line">      FATAL(<span class="string">&quot;Unable to execute target application (&#x27;%s&#x27;)&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_NOINST:</span><br><span class="line"></span><br><span class="line">      FATAL(<span class="string">&quot;No instrumentation detected&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_NOBITS:</span><br><span class="line"></span><br><span class="line">      useless_at_start++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!in_bitmap &amp;&amp; !shuffle_queue)</span><br><span class="line">        WARNF(<span class="string">&quot;No new instrumentation output, test case may be useless.&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>结束了循环</strong></p>
<p>最后进行了错误处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cal_failures)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cal_failures == queued_paths)</span><br><span class="line">    FATAL(<span class="string">&quot;All test cases time out%s, giving up!&quot;</span>,</span><br><span class="line">          skip_crashes ? <span class="string">&quot; or crash&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  WARNF(<span class="string">&quot;Skipped %u test cases (%0.02f%%) due to timeouts%s.&quot;</span>, cal_failures,</span><br><span class="line">        ((<span class="type">double</span>)cal_failures) * <span class="number">100</span> / queued_paths,</span><br><span class="line">        skip_crashes ? <span class="string">&quot; or crashes&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cal_failures * <span class="number">5</span> &gt; queued_paths)</span><br><span class="line">    WARNF(cLRD <span class="string">&quot;High percentage of rejected test cases, check settings!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OKF(<span class="string">&quot;All test cases processed.&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="calibrate-case">calibrate_case</h4>
<p>用来运行一次</p>
<p>首先创建了一些局部变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u8 <span class="title function_">calibrate_case</span><span class="params">(<span class="type">char</span> **argv, <span class="keyword">struct</span> queue_entry *q, u8 *use_mem,</span></span><br><span class="line"><span class="params">                         u32 handicap, u8 from_queue)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8 first_trace[MAP_SIZE];</span><br><span class="line"></span><br><span class="line">  u8 fault = <span class="number">0</span>, new_bits = <span class="number">0</span>, var_detected = <span class="number">0</span>, hnb = <span class="number">0</span>,</span><br><span class="line">     first_run = (q-&gt;exec_cksum == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  u64 start_us, stop_us;</span><br><span class="line"></span><br><span class="line">  s32 old_sc = stage_cur, old_sm = stage_max;</span><br><span class="line">  u32 use_tmout = exec_tmout;</span><br><span class="line">  u8 *old_sn = stage_name;</span><br></pre></td></tr></table></figure>
<p>然后判断testcase时是否来自queue，或者是否是resume一个fuzzjob，如果是，则更新use_tmout</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!from_queue || resuming_fuzz)</span><br><span class="line">  use_tmout = MAX(exec_tmout + CAL_TMOUT_ADD,</span><br><span class="line">                  exec_tmout * CAL_TMOUT_PERC / <span class="number">100</span>);</span><br><span class="line">                  <span class="comment">// 提升tmout的值</span></span><br></pre></td></tr></table></figure>
<p>更新cal_failed 的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q-&gt;cal_failed++;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stage_name = <span class="string">&quot;calibration&quot;</span>;</span><br><span class="line"><span class="comment">// 更新stage_name </span></span><br><span class="line">stage_max = fast_cal ? <span class="number">3</span> : CAL_CYCLES;</span><br><span class="line"><span class="comment">// 设置cal的最大论数，如果需要fast_cal则设置最大3论</span></span><br></pre></td></tr></table></figure>
<p>确保没有forkserver并且非dump_mode时，创建一个forkserver</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dumb_mode != <span class="number">1</span> &amp;&amp; !no_forkserver &amp;&amp; !forksrv_pid)</span><br><span class="line">  init_forkserver(argv);</span><br></pre></td></tr></table></figure>
<p>什么是dump_mode呢？</p>
<p>dump_mode即没有插桩和确定性(deterministic)变异阶段的模式</p>
<p><code>q-&gt;exec_cksum</code> 初始时为0，因此此处是用来判断是否是初次运行</p>
<p>virgin_bits是一个bitmap，用来记录没有触及的block</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (q-&gt;exec_cksum)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 如果不是初次运行</span></span><br><span class="line">  <span class="built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line">  </span><br><span class="line">  hnb = has_new_bits(virgin_bits);</span><br><span class="line">  <span class="keyword">if</span> (hnb &gt; new_bits)</span><br><span class="line">    new_bits = hnb;</span><br><span class="line">    <span class="comment">// 更新new_bits数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置起始时间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start_us = get_cur_time_us();</span><br></pre></td></tr></table></figure>
<p>接下来进入循环轮次:</p>
<p>这里的可变分支，指的是，对于同样的输入，可能可以到达也可能不能到达的分支。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="comment">// 循环轮次由前面的代码确定</span></span><br><span class="line">   u32 cksum;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!first_run &amp;&amp; !(stage_cur % stats_update_freq))</span><br><span class="line">     show_stats();</span><br><span class="line">   <span class="comment">// 如果不是第一次运行 并且state_cur 隔 stats_update_freq 次</span></span><br><span class="line">   <span class="comment">// 则show_stats </span></span><br><span class="line">   write_to_testcase(use_mem, q-&gt;len);</span><br><span class="line">   <span class="comment">// 将testcase写入out_file </span></span><br><span class="line">   fault = run_target(argv, use_tmout);</span><br><span class="line">   <span class="comment">// 运行目标程序</span></span><br><span class="line">   <span class="comment">/* stop_soon is set by the handler for Ctrl+C. When it&#x27;s pressed,</span></span><br><span class="line"><span class="comment">      we want to bail out quickly. */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (stop_soon || fault != crash_mode)</span><br><span class="line">     <span class="keyword">goto</span> abort_calibration;</span><br><span class="line">   <span class="comment">// 如果收到终止signal </span></span><br><span class="line">   <span class="keyword">if</span> (!dumb_mode &amp;&amp; !stage_cur &amp;&amp; !count_bytes(trace_bits))</span><br><span class="line">   &#123;</span><br><span class="line">     fault = FAULT_NOINST;</span><br><span class="line">     <span class="keyword">goto</span> abort_calibration;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line">   <span class="comment">// 计算bitmap的hash </span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (q-&gt;exec_cksum != cksum)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="comment">// bitmap发生变化</span></span><br><span class="line">   <span class="comment">// 一般在第一次运行，或者在同样的参数下，分支可变的情形</span></span><br><span class="line">     hnb = has_new_bits(virgin_bits);</span><br><span class="line">     <span class="comment">// 计算virgin_bits的更新</span></span><br><span class="line">     <span class="keyword">if</span> (hnb &gt; new_bits)</span><br><span class="line">       new_bits = hnb;</span><br><span class="line">   </span><br><span class="line">     <span class="keyword">if</span> (q-&gt;exec_cksum)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="comment">// 如果是分支可变的情形</span></span><br><span class="line">       u32 i;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)</span><br><span class="line">       &#123;</span><br><span class="line">	<span class="comment">// 循环遍历，找到可变的region，如果找到了，就延长轮次</span></span><br><span class="line">	<span class="comment">// 以便进行更多的遍历</span></span><br><span class="line">         <span class="keyword">if</span> (!var_bytes[i] &amp;&amp; first_trace[i] != trace_bits[i])</span><br><span class="line">         &#123;</span><br><span class="line">           var_bytes[i] = <span class="number">1</span>;</span><br><span class="line">           stage_max = CAL_CYCLES_LONG;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       var_detected = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">// 检测到可变</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">     <span class="comment">// 如果是第一次运行</span></span><br><span class="line">       q-&gt;exec_cksum = cksum;</span><br><span class="line">       <span class="built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>增加总运行时间和轮次计算</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stop_us = get_cur_time_us();</span><br><span class="line"></span><br><span class="line">total_cal_us += stop_us - start_us;</span><br><span class="line">total_cal_cycles += stage_max;</span><br></pre></td></tr></table></figure>
<p>更新queue的相关成员</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">q-&gt;exec_us = (stop_us - start_us) / stage_max;</span><br><span class="line"><span class="comment">// 平均每轮的执行时间</span></span><br><span class="line">q-&gt;bitmap_size = count_bytes(trace_bits);</span><br><span class="line">q-&gt;handicap = handicap;</span><br><span class="line">q-&gt;cal_failed = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 将之前的设置的1还原为0，表示没有失败</span></span><br></pre></td></tr></table></figure>
<p>更新bitmap的分数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">total_bitmap_size += q-&gt;bitmap_size;</span><br><span class="line">total_bitmap_entries++;</span><br><span class="line"></span><br><span class="line">update_bitmap_score(q);</span><br></pre></td></tr></table></figure>
<p>如果没有产生新bit</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!dumb_mode &amp;&amp; first_run &amp;&amp; !fault &amp;&amp; !new_bits)</span><br><span class="line">  fault = FAULT_NOBITS;</span><br></pre></td></tr></table></figure>
<p>进入最后的收尾的处理阶段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">abort_calibration:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_bits == <span class="number">2</span> &amp;&amp; !q-&gt;has_new_cov)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">// has_new_bits在存在new bit下的返回值就是2</span></span><br><span class="line">    q-&gt;has_new_cov = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 有新的覆盖率</span></span><br><span class="line">    queued_with_cov++;</span><br><span class="line">    <span class="comment">// 有新覆盖率的queue加一</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark variable paths. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (var_detected)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 计算可变bytes的数量</span></span><br><span class="line">    var_byte_count = count_bytes(var_bytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!q-&gt;var_behavior)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 如果可变</span></span><br><span class="line">      mark_as_variable(q);</span><br><span class="line">      <span class="comment">// 通过创建一个variable_behavior文件标记其可变</span></span><br><span class="line">      queued_variable++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 恢复之前的stage相关的全局变量</span></span><br><span class="line">  stage_name = old_sn;</span><br><span class="line">  stage_cur = old_sc;</span><br><span class="line">  stage_max = old_sm;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!first_run)</span><br><span class="line">    show_stats();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fault;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="init-forkserver">init_forkserver</h4>
<p>用来创建一个forkserver，避免频繁的execve</p>
<p>首先创建两个管道，<code>st_pipe</code> 和 <code>ctl_pipe</code> ， 分别用于传递状态和命令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">EXP_ST <span class="type">void</span> <span class="title function_">init_forkserver</span><span class="params">(<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>;</span></span><br><span class="line">  <span class="type">int</span> st_pipe[<span class="number">2</span>], ctl_pipe[<span class="number">2</span>];</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  s32 rlen;</span><br><span class="line"></span><br><span class="line">  ACTF(<span class="string">&quot;Spinning up the fork server...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pipe(st_pipe) || pipe(ctl_pipe))</span><br><span class="line">    PFATAL(<span class="string">&quot;pipe() failed&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>接下来通过fork产生一个子进程，父进程是fuzzer，子进程是forkserver</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">forksrv_pid = fork(); </span><br><span class="line"><span class="keyword">if</span> (forksrv_pid &lt; <span class="number">0</span>)</span><br><span class="line">    PFATAL(<span class="string">&quot;fork() failed&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>通过pid控制子进程<strong>进入</strong>如下if语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!forksrv_pid)</span><br><span class="line"> &#123; </span><br><span class="line">   <span class="comment">// 省略部分对于openbsd的特殊处理</span></span><br><span class="line">   setsid();</span><br><span class="line">   <span class="comment">// 通过setsid使得子进程成为一个单独进程组</span></span><br><span class="line">   dup2(dev_null_fd, <span class="number">1</span>);</span><br><span class="line">   dup2(dev_null_fd, <span class="number">2</span>);</span><br><span class="line">   <span class="comment">// 将标准输出和标准错误重定向到/dev/null </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有设置输出文件 </span></span><br><span class="line"><span class="comment">// 将标准输入重定向到此文件</span></span><br><span class="line"><span class="comment">// 此处笔者还没有搞清楚为什么</span></span><br><span class="line">   <span class="keyword">if</span> (out_file)</span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">     dup2(dev_null_fd, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">     dup2(out_fd, <span class="number">0</span>);</span><br><span class="line">     close(out_fd);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>接下来设置状态和控制管道的文件描述符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dup2(ctl_pipe[<span class="number">0</span>], FORKSRV_FD) &lt; <span class="number">0</span>)</span><br><span class="line">  PFATAL(<span class="string">&quot;dup2() failed&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (dup2(st_pipe[<span class="number">1</span>], FORKSRV_FD + <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">  PFATAL(<span class="string">&quot;dup2() failed&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>关闭多余描述符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">close(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line">close(ctl_pipe[<span class="number">1</span>]);</span><br><span class="line">close(st_pipe[<span class="number">0</span>]);</span><br><span class="line">close(st_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">close(out_dir_fd);</span><br><span class="line">close(dev_null_fd);</span><br><span class="line">close(dev_urandom_fd);</span><br><span class="line">close(fileno(plot_file));</span><br></pre></td></tr></table></figure>
<p>设置延迟绑定</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!getenv(<span class="string">&quot;LD_BIND_LAZY&quot;</span>))</span><br><span class="line">  setenv(<span class="string">&quot;LD_BIND_NOW&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>设置ASAN相关环境变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setenv(<span class="string">&quot;ASAN_OPTIONS&quot;</span>, <span class="string">&quot;abort_on_error=1:&quot;</span></span><br><span class="line">                       <span class="string">&quot;detect_leaks=0:&quot;</span></span><br><span class="line">                       <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                       <span class="string">&quot;allocator_may_return_null=1&quot;</span>,</span><br><span class="line">       <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>设置MSAN相关环境变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setenv(<span class="string">&quot;MSAN_OPTIONS&quot;</span>, <span class="string">&quot;exit_code=&quot;</span> STRINGIFY(MSAN_ERROR) <span class="string">&quot;:&quot;</span></span><br><span class="line">                                                          <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                                                          <span class="string">&quot;abort_on_error=1:&quot;</span></span><br><span class="line">                                                          <span class="string">&quot;allocator_may_return_null=1:&quot;</span></span><br><span class="line">                                                          <span class="string">&quot;msan_track_origins=0&quot;</span>,</span><br><span class="line">       <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>通过execv执行子进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execv(target_path, argv);</span><br></pre></td></tr></table></figure>
<p>此时之后目标程序的运行空间会覆盖当前运行时</p>
<p>如果execv失败，通知父进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  *(u32 *)trace_bits = EXEC_FAIL_SIG;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子进程if结束</p>
<p>父进程通过状态管道读取四个字节，来判断子进程的开始，并针对性完成错误处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">  close(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line">  close(st_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  fsrv_ctl_fd = ctl_pipe[<span class="number">1</span>];</span><br><span class="line">  fsrv_st_fd = st_pipe[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Wait for the fork server to come up, but don&#x27;t wait too long. */</span></span><br><span class="line"></span><br><span class="line">  it.it_value.tv_sec = ((exec_tmout * FORK_WAIT_MULT) / <span class="number">1000</span>);</span><br><span class="line">  it.it_value.tv_usec = ((exec_tmout * FORK_WAIT_MULT) % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  setitimer(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  rlen = read(fsrv_st_fd, &amp;status, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  it.it_value.tv_sec = <span class="number">0</span>;</span><br><span class="line">  it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  setitimer(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we have a four-byte &quot;hello&quot; message from the server, we&#x27;re all set.</span></span><br><span class="line"><span class="comment">     Otherwise, try to figure out what went wrong. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rlen == <span class="number">4</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    OKF(<span class="string">&quot;All right - fork server is up.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child_timed_out)</span><br><span class="line">    FATAL(<span class="string">&quot;Timeout while initializing fork server (adjusting -t may help)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (waitpid(forksrv_pid, &amp;status, <span class="number">0</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">    PFATAL(<span class="string">&quot;waitpid() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (WIFSIGNALED(status))</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem_limit &amp;&amp; mem_limit &lt; <span class="number">500</span> &amp;&amp; uses_asan)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;Whoops, the target binary crashed suddenly, before receiving any input\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    from the fuzzer! Since it seems to be built with ASAN and you have a\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    restrictive memory limit configured, this is expected; please read\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    %s/notes_for_asan.txt for help.\n&quot;</span>,</span><br><span class="line">           doc_path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!mem_limit)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;Whoops, the target binary crashed suddenly, before receiving any input\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    from the fuzzer! There are several probable explanations:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - The binary is just buggy and explodes entirely on its own. If so, you\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      need to fix the underlying problem or find a better replacement.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      break afl-fuzz performance optimizations when running platform-specific\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      targets. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - Less likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;Whoops, the target binary crashed suddenly, before receiving any input\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    from the fuzzer! There are several probable explanations:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - The current memory limit (%s) is too restrictive, causing the\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      target to hit an OOM condition in the dynamic linker. Try bumping up\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      the limit with the -m setting in the command line. A simple way confirm\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      this diagnosis would be:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line">           <span class="string">&quot;      ( ulimit -Sv $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">           <span class="string">&quot;      ( ulimit -Sd $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^RLIMIT_AS */</span></span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;      Tip: you can use http://jwilk.net/software/recidivm to quickly\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      estimate the required amount of virtual memory for the binary.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - The binary is just buggy and explodes entirely on its own. If so, you\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      need to fix the underlying problem or find a better replacement.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      break afl-fuzz performance optimizations when running platform-specific\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      targets. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - Less likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>,</span><br><span class="line">           DMS(mem_limit &lt;&lt; <span class="number">20</span>), mem_limit - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FATAL(<span class="string">&quot;Fork server crashed with signal %d&quot;</span>, WTERMSIG(status));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*(u32 *)trace_bits == EXEC_FAIL_SIG)</span><br><span class="line">    FATAL(<span class="string">&quot;Unable to execute target application (&#x27;%s&#x27;)&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem_limit &amp;&amp; mem_limit &lt; <span class="number">500</span> &amp;&amp; uses_asan)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Hmm, looks like the target binary terminated before we could complete a\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    handshake with the injected code. Since it seems to be built with ASAN and\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    you have a restrictive memory limit configured, this is expected; please\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    read %s/notes_for_asan.txt for help.\n&quot;</span>,</span><br><span class="line">         doc_path);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!mem_limit)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Hmm, looks like the target binary terminated before we could complete a\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    handshake with the injected code. Perhaps there is a horrible bug in the\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    fuzzer. Poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Hmm, looks like the target binary terminated before we could complete a\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    handshake with the injected code. There are %s probable explanations:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;%s&quot;</span></span><br><span class="line">         <span class="string">&quot;    - The current memory limit (%s) is too restrictive, causing an OOM\n&quot;</span></span><br><span class="line">         <span class="string">&quot;      fault in the dynamic linker. This can be fixed with the -m option. A\n&quot;</span></span><br><span class="line">         <span class="string">&quot;      simple way to confirm the diagnosis may be:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line">         <span class="string">&quot;      ( ulimit -Sv $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">         <span class="string">&quot;      ( ulimit -Sd $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^RLIMIT_AS */</span></span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;      Tip: you can use http://jwilk.net/software/recidivm to quickly\n&quot;</span></span><br><span class="line">         <span class="string">&quot;      estimate the required amount of virtual memory for the binary.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;    - Less likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span></span><br><span class="line">         <span class="string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>,</span><br><span class="line">         getenv(DEFER_ENV_VAR) ? <span class="string">&quot;three&quot;</span> : <span class="string">&quot;two&quot;</span>,</span><br><span class="line">         getenv(DEFER_ENV_VAR) ? <span class="string">&quot;    - You are using deferred forkserver, but __AFL_INIT() is never\n&quot;</span></span><br><span class="line">                                 <span class="string">&quot;      reached before the program terminates.\n\n&quot;</span></span><br><span class="line">                               : <span class="string">&quot;&quot;</span>,</span><br><span class="line">         DMS(mem_limit &lt;&lt; <span class="number">20</span>), mem_limit - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  FATAL(<span class="string">&quot;Fork server handshake failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="run-target">run_target</h4>
<p>用来运行一次目标</p>
<p>首先初始化了trace_bits，并设置了内存屏障</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u8 <span class="title function_">run_target</span><span class="params">(<span class="type">char</span> **argv, u32 timeout)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>;</span></span><br><span class="line">  <span class="type">static</span> u32 prev_timed_out = <span class="number">0</span>;</span><br><span class="line">  <span class="type">static</span> u64 exec_ms = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">  u32 tb4;</span><br><span class="line"></span><br><span class="line">  child_timed_out = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* After this memset, trace_bits[] are effectively volatile, so we</span></span><br><span class="line"><span class="comment">     must prevent any earlier operations from venturing into that</span></span><br><span class="line"><span class="comment">     territory. */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(trace_bits, <span class="number">0</span>, MAP_SIZE);</span><br><span class="line">  MEM_BARRIER();</span><br></pre></td></tr></table></figure>
<p>如果是dump_mode 并且没有forkserver， 就需要先类似init_forkserver 中的部分操作，来创建子进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (dumb_mode == <span class="number">1</span> || no_forkserver)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    child_pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>)</span><br><span class="line">      PFATAL(<span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!child_pid)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (mem_limit)</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        r.rlim_max = r.rlim_cur = ((<span class="type">rlim_t</span>)mem_limit) &lt;&lt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line"></span><br><span class="line">        setrlimit(RLIMIT_AS, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">        setrlimit(RLIMIT_DATA, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^RLIMIT_AS */</span></span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      r.rlim_max = r.rlim_cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      setrlimit(RLIMIT_CORE, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Isolate the process and configure standard descriptors. If out_file is</span></span><br><span class="line"><span class="comment">         specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */</span></span><br><span class="line"></span><br><span class="line">      setsid();</span><br><span class="line"></span><br><span class="line">      dup2(dev_null_fd, <span class="number">1</span>);</span><br><span class="line">      dup2(dev_null_fd, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (out_file)</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        dup2(dev_null_fd, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        dup2(out_fd, <span class="number">0</span>);</span><br><span class="line">        close(out_fd);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* On Linux, would be faster to use O_CLOEXEC. Maybe TODO. */</span></span><br><span class="line"></span><br><span class="line">      close(dev_null_fd);</span><br><span class="line">      close(out_dir_fd);</span><br><span class="line">      close(dev_urandom_fd);</span><br><span class="line">      close(fileno(plot_file));</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Set sane defaults for ASAN if nothing else specified. */</span></span><br><span class="line"></span><br><span class="line">      setenv(<span class="string">&quot;ASAN_OPTIONS&quot;</span>, <span class="string">&quot;abort_on_error=1:&quot;</span></span><br><span class="line">                             <span class="string">&quot;detect_leaks=0:&quot;</span></span><br><span class="line">                             <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                             <span class="string">&quot;allocator_may_return_null=1&quot;</span>,</span><br><span class="line">             <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      setenv(<span class="string">&quot;MSAN_OPTIONS&quot;</span>, <span class="string">&quot;exit_code=&quot;</span> STRINGIFY(MSAN_ERROR) <span class="string">&quot;:&quot;</span></span><br><span class="line">                                                                <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                                                                <span class="string">&quot;msan_track_origins=0&quot;</span>,</span><br><span class="line">             <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      execv(target_path, argv);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Use a distinctive bitmap value to tell the parent about execv()</span></span><br><span class="line"><span class="comment">         falling through. */</span></span><br><span class="line"></span><br><span class="line">      *(u32 *)trace_bits = EXEC_FAIL_SIG;</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>反之如果在 非dump mode，那么通过控制管道通知子进程运行，并获取其pid</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">   s32 res;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* In non-dumb mode, we have the fork server up and running, so simply</span></span><br><span class="line"><span class="comment">      tell it to have at it, and then read back PID. */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ((res = write(fsrv_ctl_fd, &amp;prev_timed_out, <span class="number">4</span>)) != <span class="number">4</span>)</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="comment">// 向forkserver发送消息</span></span><br><span class="line">    <span class="keyword">if</span> (stop_soon)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     RPFATAL(res, <span class="string">&quot;Unable to request new process from fork server (OOM?)&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ((res = read(fsrv_st_fd, &amp;child_pid, <span class="number">4</span>)) != <span class="number">4</span>)</span><br><span class="line">   &#123;</span><br><span class="line"><span class="comment">// 接受子进程pid</span></span><br><span class="line">     <span class="keyword">if</span> (stop_soon)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     RPFATAL(res, <span class="string">&quot;Unable to request new process from fork server (OOM?)&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (child_pid &lt;= <span class="number">0</span>)</span><br><span class="line">     FATAL(<span class="string">&quot;Fork server is misbehaving (OOM?)&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>设置timeout</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">it.it_value.tv_sec = (timeout / <span class="number">1000</span>);</span><br><span class="line">it.it_value.tv_usec = (timeout % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">setitimer(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>阻塞，等待子进程运行结束</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (dumb_mode == <span class="number">1</span> || no_forkserver)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="comment">// 如果在dumpmode，通过waitpid阻塞</span></span><br><span class="line">   <span class="keyword">if</span> (waitpid(child_pid, &amp;status, <span class="number">0</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">     PFATAL(<span class="string">&quot;waitpid() failed&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">   s32 res;</span><br><span class="line">   <span class="comment">// 如果存在forkserver </span></span><br><span class="line">   <span class="comment">// 通过读管道阻塞</span></span><br><span class="line">   <span class="keyword">if</span> ((res = read(fsrv_st_fd, &amp;status, <span class="number">4</span>)) != <span class="number">4</span>)</span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (stop_soon)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     RPFATAL(res, <span class="string">&quot;Unable to communicate with fork server (OOM?)&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>接下来根据子进程返回的status，进行对应的错误处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (!WIFSTOPPED(status))</span><br><span class="line">    child_pid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  getitimer(ITIMER_REAL, &amp;it);</span><br><span class="line">  exec_ms = (u64)timeout - (it.it_value.tv_sec * <span class="number">1000</span> +</span><br><span class="line">                            it.it_value.tv_usec / <span class="number">1000</span>);</span><br><span class="line">  <span class="comment">// 计算运行时间</span></span><br><span class="line">  it.it_value.tv_sec = <span class="number">0</span>;</span><br><span class="line">  it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">  setitimer(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  total_execs++;</span><br><span class="line">  <span class="comment">// 总运行次数加一</span></span><br><span class="line">  <span class="comment">/* Any subsequent operations on trace_bits must not be moved by the</span></span><br><span class="line"><span class="comment">     compiler below this point. Past this location, trace_bits[] behave</span></span><br><span class="line"><span class="comment">     very normally and do not have to be treated as volatile. */</span></span><br><span class="line"></span><br><span class="line">  MEM_BARRIER();</span><br><span class="line"></span><br><span class="line">  tb4 = *(u32 *)trace_bits;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line">  classify_counts((u64 *)trace_bits);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  classify_counts((u32 *)trace_bits);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line">  </span><br><span class="line">  prev_timed_out = child_timed_out;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Report outcome to caller. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (WIFSIGNALED(status) &amp;&amp; !stop_soon)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">// 根据信号判断错误类型</span></span><br><span class="line">    kill_signal = WTERMSIG(status);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_timed_out &amp;&amp; kill_signal == SIGKILL)</span><br><span class="line">      <span class="keyword">return</span> FAULT_TMOUT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FAULT_CRASH;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* A somewhat nasty hack for MSAN, which doesn&#x27;t support abort_on_error and</span></span><br><span class="line"><span class="comment">     must use a special exit code. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (uses_asan &amp;&amp; WEXITSTATUS(status) == MSAN_ERROR)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">// 根据exitstatus判断错误类型</span></span><br><span class="line">    kill_signal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> FAULT_CRASH;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((dumb_mode == <span class="number">1</span> || no_forkserver) &amp;&amp; tb4 == EXEC_FAIL_SIG)</span><br><span class="line">    <span class="keyword">return</span> FAULT_ERROR;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* It makes sense to account for the slowest units only if the testcase was run</span></span><br><span class="line"><span class="comment">  under the user defined timeout. */</span></span><br><span class="line">  <span class="keyword">if</span> (!(timeout &gt; exec_tmout) &amp;&amp; (slowest_exec_ms &lt; exec_ms))</span><br><span class="line">  &#123;</span><br><span class="line">    slowest_exec_ms = exec_ms;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果顺利运行到最后，说明没有错误</span></span><br><span class="line">  <span class="keyword">return</span> FAULT_NONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="update-bitmap-score">update_bitmap_score</h4>
<p>这部分涉及到了AFL维护的一个<code>static struct queue_entry *top_rated[MAP_SIZE]</code><br>
数组，这个数组记录了每个bitmap中的一项对应的最favored的testcase。</p>
<p>这个favored score由执行时间和长度相乘得到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">update_bitmap_score</span><span class="params">(<span class="keyword">struct</span> queue_entry *q)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  u32 i;</span><br><span class="line">  u64 fav_factor = q-&gt;exec_us * q-&gt;len;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* For every byte set in trace_bits[], see if there is a previous winner,</span></span><br><span class="line"><span class="comment">     and how it compares to us. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trace_bits[i])</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (top_rated[i])</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Faster-executing or smaller test cases are favored. */</span></span><br><span class="line">		<span class="comment">// favored score由执行时间和长度相乘得到。越小越好</span></span><br><span class="line">        <span class="keyword">if</span> (fav_factor &gt; top_rated[i]-&gt;exec_us * top_rated[i]-&gt;len)</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Looks like we&#x27;re going to win. Decrease ref count for the</span></span><br><span class="line"><span class="comment">           previous winner, discard its trace_bits[] if necessary. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!--top_rated[i]-&gt;tc_ref)</span><br><span class="line">        &#123;</span><br><span class="line">          ck_free(top_rated[i]-&gt;trace_mini);</span><br><span class="line">          top_rated[i]-&gt;trace_mini = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Insert ourselves as the new winner. */</span></span><br><span class="line"></span><br><span class="line">      top_rated[i] = q;</span><br><span class="line">      q-&gt;tc_ref++;</span><br><span class="line">	  <span class="comment">// 如果更favored，则更新top_rated数组</span></span><br><span class="line">      <span class="keyword">if</span> (!q-&gt;trace_mini)</span><br><span class="line">      &#123;</span><br><span class="line">        q-&gt;trace_mini = ck_alloc(MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line">        minimize_bits(q-&gt;trace_mini, trace_bits);</span><br><span class="line">        <span class="comment">// 压缩trace_bits为bitmap</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      score_changed = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 设置flag为1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="cull-queue-对于queue的修剪">cull_queue | 对于queue的修剪</h3>
<p>此函数通过标记更favored 的种子，使得favored的种子得到更大的运行概率</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cull_queue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> *<span class="title">q</span>;</span></span><br><span class="line">  <span class="type">static</span> u8 temp_v[MAP_SIZE &gt;&gt; <span class="number">3</span>];</span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode || !score_changed)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  score_changed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(temp_v, <span class="number">255</span>, MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  queued_favored = <span class="number">0</span>;</span><br><span class="line">  pending_favored = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  q = <span class="built_in">queue</span>;</span><br></pre></td></tr></table></figure>
<p>首先清空每个queue实体的favored</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (q)</span><br><span class="line">&#123;</span><br><span class="line">  q-&gt;favored = <span class="number">0</span>;</span><br><span class="line">  q = q-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tmep_v数组用来标识没有遍历到的区域，以下循环将所有存在不同分支的种子筛选出来，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)</span><br><span class="line">   <span class="keyword">if</span> (top_rated[i] &amp;&amp; (temp_v[i &gt;&gt; <span class="number">3</span>] &amp; (<span class="number">1</span> &lt;&lt; (i &amp; <span class="number">7</span>))))</span><br><span class="line">   &#123;</span><br><span class="line"><span class="comment">// 判断favored种子遍历的区域，是否已经在之前筛选出了（将对应的temp_v置为0了）</span></span><br><span class="line">     u32 j = MAP_SIZE &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Remove all bits belonging to the current entry from temp_v. */</span></span><br><span class="line">  <span class="comment">// 然后将所有当前种子遍历过的区域从temp_v中去除</span></span><br><span class="line">     <span class="keyword">while</span> (j--)</span><br><span class="line">       <span class="keyword">if</span> (top_rated[i]-&gt;trace_mini[j])</span><br><span class="line">         temp_v[j] &amp;= ~top_rated[i]-&gt;trace_mini[j];</span><br><span class="line"></span><br><span class="line">     top_rated[i]-&gt;favored = <span class="number">1</span>;</span><br><span class="line">     <span class="comment">// 然后增加其favored值</span></span><br><span class="line">     queued_favored++;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!top_rated[i]-&gt;was_fuzzed)</span><br><span class="line">       pending_favored++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">q = <span class="built_in">queue</span>;</span><br><span class="line"><span class="comment">// 对于不favored的，通过创建redundant文件的方式表明此种子是多余的</span></span><br><span class="line"><span class="keyword">while</span> (q)</span><br><span class="line">&#123;</span><br><span class="line">  mark_as_redundant(q, !q-&gt;favored);</span><br><span class="line">  q = q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="fuzz-one-种子的变异">fuzz_one | 种子的变异</h2>
<p>此函数用于从queue中选取一个种子，运行一次fuzz，返回0说明运行成功，否则运行失败</p>
<p>首先进行了一些细节的处理, 包括:</p>
<ol>
<li>首先判断是否要跳过当前testcase给favored的testcase更多运行机会
<ul>
<li>如果存在，<code>pending_favored</code> ， 并且当前queue已经运行过或者不favored，那么为了将时间留给pending_favored的testcase, 有99%的几率直接跳过</li>
<li>如果无<code>pending_favored</code>， 对于不是favored的testcase, 如果已经fuzz过, 95%概率跳过, 如果没有fuzz过, 75%概率跳过</li>
<li>如果是favored， 不跳过</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u8 <span class="title function_">fuzz_one</span><span class="params">(<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  s32 len, fd, temp_len, i, j;</span><br><span class="line">  u8 *in_buf, *out_buf, *orig_in, *ex_tmp, *eff_map = <span class="number">0</span>;</span><br><span class="line">  u64 havoc_queued, orig_hit_cnt, new_hit_cnt;</span><br><span class="line">  u32 splice_cycle = <span class="number">0</span>, perf_score = <span class="number">100</span>, orig_perf, prev_cksum, eff_cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  u8 ret_val = <span class="number">1</span>, doing_det = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  u8 a_collect[MAX_AUTO_EXTRA];</span><br><span class="line">  u32 a_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> IGNORE_FINDS</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In IGNORE_FINDS mode, skip any entries that weren&#x27;t in the</span></span><br><span class="line"><span class="comment">     initial data set. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_cur-&gt;depth &gt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pending_favored)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we have any favored, non-fuzzed new arrivals in the queue,</span></span><br><span class="line"><span class="comment">       possibly skip to them at the expense of already-fuzzed or non-favored</span></span><br><span class="line"><span class="comment">       cases. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((queue_cur-&gt;was_fuzzed || !queue_cur-&gt;favored) &amp;&amp;</span><br><span class="line">        UR(<span class="number">100</span>) &lt; SKIP_TO_NEW_PROB)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!dumb_mode &amp;&amp; !queue_cur-&gt;favored &amp;&amp; queued_paths &gt; <span class="number">10</span>)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Otherwise, still possibly skip non-favored cases, albeit less often.</span></span><br><span class="line"><span class="comment">       The odds of skipping stuff are higher for already-fuzzed inputs and</span></span><br><span class="line"><span class="comment">       lower for never-fuzzed entries. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (queue_cycle &gt; <span class="number">1</span> &amp;&amp; !queue_cur-&gt;was_fuzzed)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (UR(<span class="number">100</span>) &lt; SKIP_NFAV_NEW_PROB)</span><br><span class="line">      <span class="comment">// random(0, 100) &lt; 75 ; 75%</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (UR(<span class="number">100</span>) &lt; SKIP_NFAV_OLD_PROB)</span><br><span class="line">      <span class="comment">// random(0, 100) &lt; 95 ; 95%</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断需要跳过的情形</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^IGNORE_FINDS */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (not_on_tty)</span><br><span class="line">  &#123;</span><br><span class="line">    ACTF(<span class="string">&quot;Fuzzing test case #%u (%u total, %llu uniq crashes found)...&quot;</span>,</span><br><span class="line">         current_entry, queued_paths, unique_crashes);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Map the test case into memory. */</span></span><br><span class="line">  <span class="comment">// 将testcase映射进内存</span></span><br><span class="line">  fd = open(queue_cur-&gt;fname, O_RDONLY);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, queue_cur-&gt;fname);</span><br><span class="line"></span><br><span class="line">  len = queue_cur-&gt;len;</span><br><span class="line"></span><br><span class="line">  orig_in = in_buf = mmap(<span class="number">0</span>, len, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (orig_in == MAP_FAILED)</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to mmap &#x27;%s&#x27;&quot;</span>, queue_cur-&gt;fname);</span><br><span class="line"></span><br><span class="line">  close(fd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We could mmap() out_buf as MAP_PRIVATE, but we end up clobbering every</span></span><br><span class="line"><span class="comment">     single byte anyway, so it wouldn&#x27;t give us any performance or memory usage</span></span><br><span class="line"><span class="comment">     benefits. */</span></span><br><span class="line"></span><br><span class="line">  out_buf = ck_alloc_nozero(len);</span><br><span class="line"></span><br><span class="line">  subseq_tmouts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  cur_depth = queue_cur-&gt;depth;</span><br></pre></td></tr></table></figure>
<p>如果之前cal_failed， 那么要再运行一次 <code>calibrate_case</code> 来校准testcase</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (queue_cur-&gt;cal_failed)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  u8 res = FAULT_TMOUT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_cur-&gt;cal_failed &lt; CAL_CHANCES)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reset exec_cksum to tell calibrate_case to re-execute the testcase</span></span><br><span class="line"><span class="comment">       avoiding the usage of an invalid trace_bits.</span></span><br><span class="line"><span class="comment">       For more info: https://github.com/AFLplusplus/AFLplusplus/pull/425 */</span></span><br><span class="line"></span><br><span class="line">    queue_cur-&gt;exec_cksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    res = calibrate_case(argv, queue_cur, in_buf, queue_cycle - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == FAULT_ERROR)</span><br><span class="line">      FATAL(<span class="string">&quot;Unable to execute target application&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stop_soon || res != crash_mode)</span><br><span class="line">  &#123;</span><br><span class="line">    cur_skipped_paths++;</span><br><span class="line">    <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来通过<code>trim_case</code>  来修剪并运行testcase</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!dumb_mode &amp;&amp; !queue_cur-&gt;trim_done)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  u8 res = trim_case(argv, queue_cur, in_buf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (res == FAULT_ERROR)</span><br><span class="line">    FATAL(<span class="string">&quot;Unable to execute target application&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stop_soon)</span><br><span class="line">  &#123;</span><br><span class="line">    cur_skipped_paths++;</span><br><span class="line">    <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Don&#x27;t retry trimming, even if it failed. */</span></span><br><span class="line"></span><br><span class="line">  queue_cur-&gt;trim_done = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (len != queue_cur-&gt;len)</span><br><span class="line">    len = queue_cur-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(out_buf, in_buf, len);</span><br></pre></td></tr></table></figure>
<p>通过calculate_score 计算分数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orig_perf = perf_score = calculate_score(queue_cur);</span><br></pre></td></tr></table></figure>
<p>接下来进入真正的变异阶段</p>
<h3 id="确定性变异">确定性变异</h3>
<p>首先判断是否需要跳过确定性变异阶段，这部分变异没有随机性，是所有种子都要经历的阶段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (skip_deterministic || queue_cur-&gt;was_fuzzed || queue_cur-&gt;passed_det)</span><br><span class="line">  <span class="keyword">goto</span> havoc_stage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Skip deterministic fuzzing if exec path checksum puts this out of scope</span></span><br><span class="line"><span class="comment">   for this master instance. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (master_max &amp;&amp; (queue_cur-&gt;exec_cksum % master_max) != master_id - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">goto</span> havoc_stage;</span><br><span class="line"></span><br><span class="line">doing_det = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>deterministic 阶段分为以下几个部分：</p>
<h4 id="bitflip">bitflip</h4>
<p>bitflip阶段是对于testcase的bit位进行翻转</p>
<p><strong>bitflip 1/1</strong></p>
<p>通过每次翻转一个bit，来检查是否具有类似于 “ELF” 此类魔数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"> stage_short = <span class="string">&quot;flip1&quot;</span>;</span><br><span class="line"> stage_max = len &lt;&lt; <span class="number">3</span>;</span><br><span class="line"> stage_name = <span class="string">&quot;bitflip 1/1&quot;</span>;</span><br><span class="line"></span><br><span class="line"> stage_val_type = STAGE_VAL_NONE;</span><br><span class="line"></span><br><span class="line"> orig_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"> </span><br><span class="line"> prev_cksum = queue_cur-&gt;exec_cksum;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++)</span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">   stage_cur_byte = stage_cur &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">   FLIP_BIT(out_buf, stage_cur);</span><br><span class="line"><span class="comment">// 每次翻转一个 bit</span></span><br><span class="line">   <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">   <span class="comment">// 运行一次fuzz测试</span></span><br><span class="line">     <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">   FLIP_BIT(out_buf, stage_cur);</span><br><span class="line"><span class="comment">// 翻转回来</span></span><br><span class="line">   <span class="keyword">if</span> (!dumb_mode &amp;&amp; (stage_cur &amp; <span class="number">7</span>) == <span class="number">7</span>)</span><br><span class="line">   &#123;</span><br><span class="line"><span class="comment">// 根据经验，通常检查最低位的翻转最有效率</span></span><br><span class="line">     u32 cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line">  <span class="comment">// 获取cksum</span></span><br><span class="line">     <span class="keyword">if</span> (stage_cur == stage_max - <span class="number">1</span> &amp;&amp; cksum == prev_cksum)</span><br><span class="line">     &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* If at end of file and we are still collecting a string, grab the</span></span><br><span class="line"><span class="comment">          final character and force output. */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (a_len &lt; MAX_AUTO_EXTRA)</span><br><span class="line">         a_collect[a_len] = out_buf[stage_cur &gt;&gt; <span class="number">3</span>];</span><br><span class="line">       a_len++;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (a_len &gt;= MIN_AUTO_EXTRA &amp;&amp; a_len &lt;= MAX_AUTO_EXTRA)</span><br><span class="line">         maybe_add_auto(a_collect, a_len);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (cksum != prev_cksum)</span><br><span class="line">     &#123;</span><br><span class="line">  <span class="comment">// 如果cksum不等于prev_cksum，可能是一个魔数的开始或者结束</span></span><br><span class="line">       <span class="comment">/* Otherwise, if the checksum has changed, see if we have something</span></span><br><span class="line"><span class="comment">          worthwhile queued up, and collect that if the answer is yes. */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (a_len &gt;= MIN_AUTO_EXTRA &amp;&amp; a_len &lt;= MAX_AUTO_EXTRA)</span><br><span class="line">         maybe_add_auto(a_collect, a_len);</span><br><span class="line">	<span class="comment">// 如果是一个魔数的结束</span></span><br><span class="line">	<span class="comment">// 那么调用 may_add_auto收集起来</span></span><br><span class="line">       a_len = <span class="number">0</span>;</span><br><span class="line">       prev_cksum = cksum;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Continue collecting string, but only if the bit flip actually made</span></span><br><span class="line"><span class="comment">        any difference - we don&#x27;t want no-op tokens. */</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (cksum != queue_cur-&gt;exec_cksum)</span><br><span class="line">     &#123;</span><br><span class="line">	<span class="comment">// 需要cksum不等于原来才需要增加a_len并记录</span></span><br><span class="line">       <span class="keyword">if</span> (a_len &lt; MAX_AUTO_EXTRA)</span><br><span class="line">         a_collect[a_len] = out_buf[stage_cur &gt;&gt; <span class="number">3</span>];</span><br><span class="line">       a_len++;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>bitflip 2/1</strong></p>
<p>每次翻转两个bit，运行并保留有价值的种子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">stage_name = <span class="string">&quot;bitflip 2/1&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;flip2&quot;</span>;</span><br><span class="line">stage_max = (len &lt;&lt; <span class="number">3</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = stage_cur &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">  FLIP_BIT(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 翻转两个bit</span></span><br><span class="line">  <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">    <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">  FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">  FLIP_BIT(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_FLIP2] += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_FLIP2] += stage_max;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>bitflip 4/1</strong></p>
<p>每次翻转4个bit，运行并保留有价值的种子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">stage_name = <span class="string">&quot;bitflip 4/1&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;flip4&quot;</span>;</span><br><span class="line">stage_max = (len &lt;&lt; <span class="number">3</span>) - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = stage_cur &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">  FLIP_BIT(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line">  FLIP_BIT(out_buf, stage_cur + <span class="number">2</span>);</span><br><span class="line">  FLIP_BIT(out_buf, stage_cur + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">    <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">  FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">  FLIP_BIT(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line">  FLIP_BIT(out_buf, stage_cur + <span class="number">2</span>);</span><br><span class="line">  FLIP_BIT(out_buf, stage_cur + <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_FLIP4] += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_FLIP4] += stage_max;</span><br></pre></td></tr></table></figure>
<p><strong>bitflip 8/8</strong></p>
<p>每次反转一整个byte，并记录那些即使全部翻转也对执行路径没有影响的byte，避免在之后花费时间去测试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Walking byte. */</span></span><br><span class="line"></span><br><span class="line">stage_name = <span class="string">&quot;bitflip 8/8&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;flip8&quot;</span>;</span><br><span class="line">stage_max = len;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = stage_cur;</span><br><span class="line"></span><br><span class="line">  out_buf[stage_cur] ^= <span class="number">0xFF</span>;</span><br><span class="line">  <span class="comment">// 每次翻转一个byte</span></span><br><span class="line">  <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">    <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">  <span class="comment">// 运行测试</span></span><br><span class="line">  <span class="comment">/* We also use this stage to pull off a simple trick: we identify</span></span><br><span class="line"><span class="comment">     bytes that seem to have no effect on the current execution path</span></span><br><span class="line"><span class="comment">     even when fully flipped - and we skip them during more expensive</span></span><br><span class="line"><span class="comment">     deterministic stages, such as arithmetics or known ints. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!eff_map[EFF_APOS(stage_cur)])</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    u32 cksum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If in dumb mode or if the file is very short, just flag everything</span></span><br><span class="line"><span class="comment">       without wasting time on checksums. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dumb_mode &amp;&amp; len &gt;= EFF_MIN_LEN)</span><br><span class="line">      cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      cksum = ~queue_cur-&gt;exec_cksum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cksum != queue_cur-&gt;exec_cksum)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 用来区分一些无效byte，为后面的阶段做准备</span></span><br><span class="line">      eff_map[EFF_APOS(stage_cur)] = <span class="number">1</span>;</span><br><span class="line">      eff_cnt++;</span><br><span class="line">      <span class="comment">// 通过一个eff_map 来标记有效byte</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  out_buf[stage_cur] ^= <span class="number">0xFF</span>;</span><br><span class="line">  <span class="comment">// 还原byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the effector map is more than EFF_MAX_PERC dense, just flag the</span></span><br><span class="line"><span class="comment">   whole thing as worth fuzzing, since we wouldn&#x27;t be saving much time</span></span><br><span class="line"><span class="comment">   anyway. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (eff_cnt != EFF_ALEN(len) &amp;&amp;</span><br><span class="line">    eff_cnt * <span class="number">100</span> / EFF_ALEN(len) &gt; EFF_MAX_PERC)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果eff_map 大于 EFF_MAX_PERC </span></span><br><span class="line">  <span class="comment">// 那么直接把整个testcase标记为值得fuzz的，这不会多浪费多少时间</span></span><br><span class="line">  <span class="built_in">memset</span>(eff_map, <span class="number">1</span>, EFF_ALEN(len));</span><br><span class="line"></span><br><span class="line">  blocks_eff_select += EFF_ALEN(len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  blocks_eff_select += eff_cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">blocks_eff_total += EFF_ALEN(len);</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_FLIP8] += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_FLIP8] += stage_max;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来是 <strong>bitflip 16/8</strong></p>
<p>处理类似</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">goto</span> skip_bitflip;</span><br><span class="line"></span><br><span class="line">stage_name  = <span class="string">&quot;bitflip 16/8&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;flip16&quot;</span>;</span><br><span class="line">stage_cur   = <span class="number">0</span>;</span><br><span class="line">stage_max   = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Let&#x27;s consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!eff_map[EFF_APOS(i)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="number">1</span>)]) &#123;</span><br><span class="line">    stage_max--;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">  *(u16*)(out_buf + i) ^= <span class="number">0xFFFF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">  stage_cur++;</span><br><span class="line"></span><br><span class="line">  *(u16*)(out_buf + i) ^= <span class="number">0xFFFF</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_FLIP16]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_FLIP16] += stage_max;</span><br></pre></td></tr></table></figure>
<p>然后是 <strong>bitflip 32/8</strong>，逻辑相同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">4</span>) <span class="keyword">goto</span> skip_bitflip;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Four walking bytes. */</span></span><br><span class="line"></span><br><span class="line">stage_name  = <span class="string">&quot;bitflip 32/8&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;flip32&quot;</span>;</span><br><span class="line">stage_cur   = <span class="number">0</span>;</span><br><span class="line">stage_max   = len - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Let&#x27;s consult the effector map... */</span></span><br><span class="line">  <span class="keyword">if</span> (!eff_map[EFF_APOS(i)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="number">1</span>)] &amp;&amp;</span><br><span class="line">      !eff_map[EFF_APOS(i + <span class="number">2</span>)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="number">3</span>)]) &#123;</span><br><span class="line">    stage_max--;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">  *(u32*)(out_buf + i) ^= <span class="number">0xFFFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">  stage_cur++;</span><br><span class="line"></span><br><span class="line">  *(u32*)(out_buf + i) ^= <span class="number">0xFFFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_FLIP32]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_FLIP32] += stage_max;</span><br></pre></td></tr></table></figure>
<p>以上，第一个bitflip阶段就完成了</p>
<h4 id="ARITHMETIC-INC-DEC">ARITHMETIC INC/DEC</h4>
<p>这个阶段是算数加减阶段</p>
<p>首先是 <strong>arith 8/8</strong> ， 对一个byte大小的数据进行加减</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"> stage_name  = <span class="string">&quot;arith 8/8&quot;</span>;</span><br><span class="line"> stage_short = <span class="string">&quot;arith8&quot;</span>;</span><br><span class="line"> stage_cur   = <span class="number">0</span>;</span><br><span class="line"> stage_max   = <span class="number">2</span> * len * ARITH_MAX;</span><br><span class="line"></span><br><span class="line"> stage_val_type = STAGE_VAL_LE;</span><br><span class="line"></span><br><span class="line"> orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">   u8 orig = out_buf[i];</span><br><span class="line">	</span><br><span class="line">   <span class="comment">/* Let&#x27;s consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!eff_map[EFF_APOS(i)]) &#123;</span><br><span class="line">     stage_max -= <span class="number">2</span> * ARITH_MAX;</span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line">     <span class="comment">// 如果不是有效位置，那么就避免进行变异</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= ARITH_MAX; j++) &#123;</span><br><span class="line">   <span class="comment">// 这里的 ARITH_MAX 是35</span></span><br><span class="line">     u8 r = orig ^ (orig + j);</span><br><span class="line">	</span><br><span class="line">     <span class="comment">/* Do arithmetic operations only if the result couldn&#x27;t be a product</span></span><br><span class="line"><span class="comment">        of a bitflip. */</span></span><br><span class="line">     <span class="comment">// 并且要确保进行算术运算后的值不可以经过bitflip得到，避免重复变异</span></span><br><span class="line">     <span class="keyword">if</span> (!could_be_bitflip(r)) &#123;</span><br><span class="line"></span><br><span class="line">       stage_cur_val = j;</span><br><span class="line">       out_buf[i] = orig + j;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">       stage_cur++;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">     r =  orig ^ (orig - j);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!could_be_bitflip(r)) &#123;</span><br><span class="line"></span><br><span class="line">       stage_cur_val = -j;</span><br><span class="line">       out_buf[i] = orig - j;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">       stage_cur++;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">     out_buf[i] = orig;</span><br><span class="line"><span class="comment">// 加减法都尝试一次</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line"> stage_finds[STAGE_ARITH8]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line"> stage_cycles[STAGE_ARITH8] += stage_max;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后还有</p>
<ul>
<li>arith 16/8</li>
<li>arith 32/8<br>
分别进行16位和32位的加减， 这里不过多赘述</li>
</ul>
<h4 id="INTERESTING-VALUES">INTERESTING VALUES</h4>
<p>这一步主要是使用一些有意义的值来替换</p>
<p>首先是 <strong>interest 8/8</strong></p>
<p>用interest值替换一个8位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">stage_name  = <span class="string">&quot;interest 8/8&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;int8&quot;</span>;</span><br><span class="line">stage_cur   = <span class="number">0</span>;</span><br><span class="line">stage_max   = len * <span class="keyword">sizeof</span>(interesting_8);</span><br><span class="line"></span><br><span class="line">stage_val_type = STAGE_VAL_LE;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Setting 8-bit integers. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">  u8 orig = out_buf[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Let&#x27;s consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!eff_map[EFF_APOS(i)]) &#123;</span><br><span class="line">    stage_max -= <span class="keyword">sizeof</span>(interesting_8);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="keyword">sizeof</span>(interesting_8); j++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Skip if the value could be a product of bitflips or arithmetics. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (could_be_bitflip(orig ^ (u8)interesting_8[j]) ||</span><br><span class="line">        could_be_arith(orig, (u8)interesting_8[j], <span class="number">1</span>)) &#123;</span><br><span class="line">      stage_max--;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stage_cur_val = interesting_8[j];</span><br><span class="line">    out_buf[i] = interesting_8[j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    out_buf[i] = orig;</span><br><span class="line">    stage_cur++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，还有:</p>
<ul>
<li>interest 16/8</li>
<li>interest 32/8</li>
</ul>
<h4 id="DICTIONARY-STUFF">DICTIONARY STUFF</h4>
<p>字典或者之前得到的有意义的extras替换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************</span></span><br><span class="line"><span class="comment"> * DICTIONARY STUFF *</span></span><br><span class="line"><span class="comment"> ********************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!extras_cnt) <span class="keyword">goto</span> skip_user_extras;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Overwrite with user-supplied extras. */</span></span><br><span class="line"></span><br><span class="line">stage_name  = <span class="string">&quot;user extras (over)&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;ext_UO&quot;</span>;</span><br><span class="line">stage_cur   = <span class="number">0</span>;</span><br><span class="line">stage_max   = extras_cnt * len;</span><br><span class="line"></span><br><span class="line">stage_val_type = STAGE_VAL_NONE;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">  u32 last_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Extras are sorted by size, from smallest to largest. This means</span></span><br><span class="line"><span class="comment">     that we don&#x27;t have to worry about restoring the buffer in</span></span><br><span class="line"><span class="comment">     between writes at a particular offset determined by the outer</span></span><br><span class="line"><span class="comment">     loop. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; extras_cnt; j++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Skip extras probabilistically if extras_cnt &gt; MAX_DET_EXTRAS. Also</span></span><br><span class="line"><span class="comment">       skip them if there&#x27;s no room to insert the payload, if the token</span></span><br><span class="line"><span class="comment">       is redundant, or if its entire span has no bytes set in the effector</span></span><br><span class="line"><span class="comment">       map. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((extras_cnt &gt; MAX_DET_EXTRAS &amp;&amp; UR(extras_cnt) &gt;= MAX_DET_EXTRAS) ||</span><br><span class="line">        extras[j].len &gt; len - i ||</span><br><span class="line">        !<span class="built_in">memcmp</span>(extras[j].data, out_buf + i, extras[j].len) ||</span><br><span class="line">        !<span class="built_in">memchr</span>(eff_map + EFF_APOS(i), <span class="number">1</span>, EFF_SPAN_ALEN(i, extras[j].len))) &#123;</span><br><span class="line"></span><br><span class="line">      stage_max--;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    last_len = extras[j].len;</span><br><span class="line">    <span class="built_in">memcpy</span>(out_buf + i, extras[j].data, last_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    stage_cur++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Restore all the clobbered memory. */</span></span><br><span class="line">  <span class="built_in">memcpy</span>(out_buf + i, in_buf + i, last_len);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_EXTRAS_UO]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_EXTRAS_UO] += stage_max;</span><br></pre></td></tr></table></figure>
<p>或者插入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_EXTRAS_UO]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_EXTRAS_UO] += stage_max;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insertion of user-supplied extras. */</span></span><br><span class="line"></span><br><span class="line">stage_name  = <span class="string">&quot;user extras (insert)&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;ext_UI&quot;</span>;</span><br><span class="line">stage_cur   = <span class="number">0</span>;</span><br><span class="line">stage_max   = extras_cnt * (len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">ex_tmp = ck_alloc(len + MAX_DICT_FILE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; extras_cnt; j++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len + extras[j].len &gt; MAX_FILE) &#123;</span><br><span class="line">      stage_max--; </span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Insert token */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ex_tmp + i, extras[j].data, extras[j].len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy tail */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ex_tmp + i + extras[j].len, out_buf + i, len - i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, ex_tmp, len + extras[j].len)) &#123;</span><br><span class="line">      ck_free(ex_tmp);</span><br><span class="line">      <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stage_cur++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Copy head */</span></span><br><span class="line">  ex_tmp[i] = out_buf[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ck_free(ex_tmp);</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_EXTRAS_UI]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_EXTRAS_UI] += stage_max;</span><br></pre></td></tr></table></figure>
<p>还有fuzz得到的extras:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!a_extras_cnt) <span class="keyword">goto</span> skip_extras;</span><br><span class="line"></span><br><span class="line">stage_name  = <span class="string">&quot;auto extras (over)&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;ext_AO&quot;</span>;</span><br><span class="line">stage_cur   = <span class="number">0</span>;</span><br><span class="line">stage_max   = MIN(a_extras_cnt, USE_AUTO_EXTRAS) * len;</span><br><span class="line"></span><br><span class="line">stage_val_type = STAGE_VAL_NONE;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">  u32 last_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; MIN(a_extras_cnt, USE_AUTO_EXTRAS); j++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* See the comment in the earlier code; extras are sorted by size. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a_extras[j].len &gt; len - i ||</span><br><span class="line">        !<span class="built_in">memcmp</span>(a_extras[j].data, out_buf + i, a_extras[j].len) ||</span><br><span class="line">        !<span class="built_in">memchr</span>(eff_map + EFF_APOS(i), <span class="number">1</span>, EFF_SPAN_ALEN(i, a_extras[j].len))) &#123;</span><br><span class="line"></span><br><span class="line">      stage_max--;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    last_len = a_extras[j].len;</span><br><span class="line">    <span class="built_in">memcpy</span>(out_buf + i, a_extras[j].data, last_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    stage_cur++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Restore all the clobbered memory. */</span></span><br><span class="line">  <span class="built_in">memcpy</span>(out_buf + i, in_buf + i, last_len);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_EXTRAS_AO]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_EXTRAS_AO] += stage_max;</span><br></pre></td></tr></table></figure>
<h3 id="Havoc-Stage">Havoc Stage</h3>
<p>havoc是不确定的大变异</p>
<p>首先，由于splice阶段也会进行havoc，所以要进行区分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">stage_cur_byte = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The havoc stage mutation code is also invoked when splicing files; if the</span></span><br><span class="line"><span class="comment">   splice_cycle variable is set, generate different descriptions and such. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!splice_cycle) &#123;</span><br><span class="line"></span><br><span class="line">  stage_name  = <span class="string">&quot;havoc&quot;</span>;</span><br><span class="line">  stage_short = <span class="string">&quot;havoc&quot;</span>;</span><br><span class="line">  stage_max   = (doing_det ? HAVOC_CYCLES_INIT : HAVOC_CYCLES) *</span><br><span class="line">                perf_score / havoc_div / <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8 tmp[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">  perf_score = orig_perf;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;splice %u&quot;</span>, splice_cycle);</span><br><span class="line">  stage_name  = tmp;</span><br><span class="line">  stage_short = <span class="string">&quot;splice&quot;</span>;</span><br><span class="line">  stage_max   = SPLICE_HAVOC * perf_score / havoc_div / <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (stage_max &lt; HAVOC_MIN) stage_max = HAVOC_MIN;</span><br><span class="line"></span><br><span class="line">temp_len = len;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">havoc_queued = queued_paths;</span><br></pre></td></tr></table></figure>
<p>接下来是一系列变异循环：</p>
<p>首先，这里有两个循环，外层循环控制测试运行次数，内层循环控制变异个数</p>
<p>在内层循环中，通过随机数来选择一种变异策略，策略包括翻转、加减、随机插入等等</p>
<p>在经过n次随机变异后，再通过<code>common_fuzz_stuff</code> 运行测试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">  u32 use_stacking = <span class="number">1</span> &lt;&lt; (<span class="number">1</span> + UR(HAVOC_STACK_POW2));</span><br><span class="line"></span><br><span class="line">  stage_cur_val = use_stacking;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; use_stacking; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (UR(<span class="number">15</span> + ((extras_cnt + a_extras_cnt) ? <span class="number">2</span> : <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Flip a single bit somewhere. Spooky! */</span></span><br><span class="line"></span><br><span class="line">        FLIP_BIT(out_buf, UR(temp_len &lt;&lt; <span class="number">3</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set byte to interesting value. */</span></span><br><span class="line"></span><br><span class="line">        out_buf[UR(temp_len)] = interesting_8[UR(<span class="keyword">sizeof</span>(interesting_8))];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set word to interesting value, randomly choosing endian. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp_len &lt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (UR(<span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">          *(u16*)(out_buf + UR(temp_len - <span class="number">1</span>)) =</span><br><span class="line">            interesting_16[UR(<span class="keyword">sizeof</span>(interesting_16) &gt;&gt; <span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">          *(u16*)(out_buf + UR(temp_len - <span class="number">1</span>)) = SWAP16(</span><br><span class="line">            interesting_16[UR(<span class="keyword">sizeof</span>(interesting_16) &gt;&gt; <span class="number">1</span>)]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set dword to interesting value, randomly choosing endian. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp_len &lt; <span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (UR(<span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">          *(u32*)(out_buf + UR(temp_len - <span class="number">3</span>)) =</span><br><span class="line">            interesting_32[UR(<span class="keyword">sizeof</span>(interesting_32) &gt;&gt; <span class="number">2</span>)];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">          *(u32*)(out_buf + UR(temp_len - <span class="number">3</span>)) = SWAP32(</span><br><span class="line">            interesting_32[UR(<span class="keyword">sizeof</span>(interesting_32) &gt;&gt; <span class="number">2</span>)]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Randomly subtract from byte. */</span></span><br><span class="line"></span><br><span class="line">        out_buf[UR(temp_len)] -= <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Randomly add to byte. */</span></span><br><span class="line"></span><br><span class="line">        out_buf[UR(temp_len)] += <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Randomly subtract from word, random endian. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp_len &lt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (UR(<span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">          u32 pos = UR(temp_len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">          *(u16*)(out_buf + pos) -= <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">          u32 pos = UR(temp_len - <span class="number">1</span>);</span><br><span class="line">          u16 num = <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">          *(u16*)(out_buf + pos) =</span><br><span class="line">            SWAP16(SWAP16(*(u16*)(out_buf + pos)) - num);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Randomly add to word, random endian. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp_len &lt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (UR(<span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">          u32 pos = UR(temp_len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">          *(u16*)(out_buf + pos) += <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">          u32 pos = UR(temp_len - <span class="number">1</span>);</span><br><span class="line">          u16 num = <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">          *(u16*)(out_buf + pos) =</span><br><span class="line">            SWAP16(SWAP16(*(u16*)(out_buf + pos)) + num);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Randomly subtract from dword, random endian. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp_len &lt; <span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (UR(<span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">          u32 pos = UR(temp_len - <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">          *(u32*)(out_buf + pos) -= <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">          u32 pos = UR(temp_len - <span class="number">3</span>);</span><br><span class="line">          u32 num = <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">          *(u32*)(out_buf + pos) =</span><br><span class="line">            SWAP32(SWAP32(*(u32*)(out_buf + pos)) - num);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Randomly add to dword, random endian. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp_len &lt; <span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (UR(<span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">          u32 pos = UR(temp_len - <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">          *(u32*)(out_buf + pos) += <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">          u32 pos = UR(temp_len - <span class="number">3</span>);</span><br><span class="line">          u32 num = <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">          *(u32*)(out_buf + pos) =</span><br><span class="line">            SWAP32(SWAP32(*(u32*)(out_buf + pos)) + num);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Just set a random byte to a random value. Because,</span></span><br><span class="line"><span class="comment">           why not. We use XOR with 1-255 to eliminate the</span></span><br><span class="line"><span class="comment">           possibility of a no-op. */</span></span><br><span class="line"></span><br><span class="line">        out_buf[UR(temp_len)] ^= <span class="number">1</span> + UR(<span class="number">255</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">11</span> ... <span class="number">12</span>: &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Delete bytes. We&#x27;re making this a bit more likely</span></span><br><span class="line"><span class="comment">             than insertion (the next option) in hopes of keeping</span></span><br><span class="line"><span class="comment">             files reasonably small. */</span></span><br><span class="line"></span><br><span class="line">          u32 del_from, del_len;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (temp_len &lt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Don&#x27;t delete too much. */</span></span><br><span class="line"></span><br><span class="line">          del_len = choose_block_len(temp_len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">          del_from = UR(temp_len - del_len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">          memmove(out_buf + del_from, out_buf + del_from + del_len,</span><br><span class="line">                  temp_len - del_from - del_len);</span><br><span class="line"></span><br><span class="line">          temp_len -= del_len;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp_len + HAVOC_BLK_XL &lt; MAX_FILE) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Clone bytes (75%) or insert a block of constant bytes (25%). */</span></span><br><span class="line"></span><br><span class="line">          u8  actually_clone = UR(<span class="number">4</span>);</span><br><span class="line">          u32 clone_from, clone_to, clone_len;</span><br><span class="line">          u8* new_buf;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (actually_clone) &#123;</span><br><span class="line"></span><br><span class="line">            clone_len  = choose_block_len(temp_len);</span><br><span class="line">            clone_from = UR(temp_len - clone_len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            clone_len = choose_block_len(HAVOC_BLK_XL);</span><br><span class="line">            clone_from = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          clone_to   = UR(temp_len);</span><br><span class="line"></span><br><span class="line">          new_buf = ck_alloc_nozero(temp_len + clone_len);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Head */</span></span><br><span class="line"></span><br><span class="line">          <span class="built_in">memcpy</span>(new_buf, out_buf, clone_to);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Inserted part */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (actually_clone)</span><br><span class="line">            <span class="built_in">memcpy</span>(new_buf + clone_to, out_buf + clone_from, clone_len);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">memset</span>(new_buf + clone_to,</span><br><span class="line">                   UR(<span class="number">2</span>) ? UR(<span class="number">256</span>) : out_buf[UR(temp_len)], clone_len);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Tail */</span></span><br><span class="line">          <span class="built_in">memcpy</span>(new_buf + clone_to + clone_len, out_buf + clone_to,</span><br><span class="line">                 temp_len - clone_to);</span><br><span class="line"></span><br><span class="line">          ck_free(out_buf);</span><br><span class="line">          out_buf = new_buf;</span><br><span class="line">          temp_len += clone_len;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">14</span>: &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Overwrite bytes with a randomly selected chunk (75%) or fixed</span></span><br><span class="line"><span class="comment">             bytes (25%). */</span></span><br><span class="line"></span><br><span class="line">          u32 copy_from, copy_to, copy_len;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (temp_len &lt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          copy_len  = choose_block_len(temp_len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">          copy_from = UR(temp_len - copy_len + <span class="number">1</span>);</span><br><span class="line">          copy_to   = UR(temp_len - copy_len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (UR(<span class="number">4</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (copy_from != copy_to)</span><br><span class="line">              memmove(out_buf + copy_to, out_buf + copy_from, copy_len);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="built_in">memset</span>(out_buf + copy_to,</span><br><span class="line">                        UR(<span class="number">2</span>) ? UR(<span class="number">256</span>) : out_buf[UR(temp_len)], copy_len);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Values 15 and 16 can be selected only if there are any extras</span></span><br><span class="line"><span class="comment">         present in the dictionaries. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">15</span>: &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Overwrite bytes with an extra. */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!extras_cnt || (a_extras_cnt &amp;&amp; UR(<span class="number">2</span>))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* No user-specified extras or odds in our favor. Let&#x27;s use an</span></span><br><span class="line"><span class="comment">               auto-detected one. */</span></span><br><span class="line"></span><br><span class="line">            u32 use_extra = UR(a_extras_cnt);</span><br><span class="line">            u32 extra_len = a_extras[use_extra].len;</span><br><span class="line">            u32 insert_at;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (extra_len &gt; temp_len) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            insert_at = UR(temp_len - extra_len + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">memcpy</span>(out_buf + insert_at, a_extras[use_extra].data, extra_len);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* No auto extras or odds in our favor. Use the dictionary. */</span></span><br><span class="line"></span><br><span class="line">            u32 use_extra = UR(extras_cnt);</span><br><span class="line">            u32 extra_len = extras[use_extra].len;</span><br><span class="line">            u32 insert_at;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (extra_len &gt; temp_len) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            insert_at = UR(temp_len - extra_len + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">memcpy</span>(out_buf + insert_at, extras[use_extra].data, extra_len);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">16</span>: &#123;</span><br><span class="line"></span><br><span class="line">          u32 use_extra, extra_len, insert_at = UR(temp_len + <span class="number">1</span>);</span><br><span class="line">          u8* new_buf;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Insert an extra. Do the same dice-rolling stuff as for the</span></span><br><span class="line"><span class="comment">             previous case. */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!extras_cnt || (a_extras_cnt &amp;&amp; UR(<span class="number">2</span>))) &#123;</span><br><span class="line"></span><br><span class="line">            use_extra = UR(a_extras_cnt);</span><br><span class="line">            extra_len = a_extras[use_extra].len;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp_len + extra_len &gt;= MAX_FILE) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            new_buf = ck_alloc_nozero(temp_len + extra_len);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Head */</span></span><br><span class="line">            <span class="built_in">memcpy</span>(new_buf, out_buf, insert_at);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Inserted part */</span></span><br><span class="line">            <span class="built_in">memcpy</span>(new_buf + insert_at, a_extras[use_extra].data, extra_len);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            use_extra = UR(extras_cnt);</span><br><span class="line">            extra_len = extras[use_extra].len;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp_len + extra_len &gt;= MAX_FILE) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            new_buf = ck_alloc_nozero(temp_len + extra_len);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Head */</span></span><br><span class="line">            <span class="built_in">memcpy</span>(new_buf, out_buf, insert_at);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Inserted part */</span></span><br><span class="line">            <span class="built_in">memcpy</span>(new_buf + insert_at, extras[use_extra].data, extra_len);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Tail */</span></span><br><span class="line">          <span class="built_in">memcpy</span>(new_buf + insert_at + extra_len, out_buf + insert_at,</span><br><span class="line">                 temp_len - insert_at);</span><br><span class="line"></span><br><span class="line">          ck_free(out_buf);</span><br><span class="line">          out_buf   = new_buf;</span><br><span class="line">          temp_len += extra_len;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, temp_len))</span><br><span class="line">    <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* out_buf might have been mangled a bit, so let&#x27;s restore it to its</span></span><br><span class="line"><span class="comment">     original size and shape. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (temp_len &lt; len) out_buf = ck_realloc(out_buf, len);</span><br><span class="line">  temp_len = len;</span><br><span class="line">  <span class="built_in">memcpy</span>(out_buf, in_buf, len);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we&#x27;re finding new stuff, let&#x27;s run for a bit longer, limits</span></span><br><span class="line"><span class="comment">     permitting. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queued_paths != havoc_queued) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (perf_score &lt;= HAVOC_MAX_MULT * <span class="number">100</span>) &#123;</span><br><span class="line">      stage_max  *= <span class="number">2</span>;</span><br><span class="line">      perf_score *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    havoc_queued = queued_paths;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Splice-Stage">Splice Stage</h3>
<p>这一部分是铰接阶段，用来将几个testcase的不同部分拼接在一起，并在之后通过havoc阶段进行变异</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (use_splicing &amp;&amp; splice_cycle++ &lt; SPLICE_CYCLES &amp;&amp;</span><br><span class="line">     queued_paths &gt; <span class="number">1</span> &amp;&amp; queue_cur-&gt;len &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">target</span>;</span></span><br><span class="line">   u32 tid, split_at;</span><br><span class="line">   u8* new_buf;</span><br><span class="line">   s32 f_diff, l_diff;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* First of all, if we&#x27;ve modified in_buf for havoc, let&#x27;s clean that</span></span><br><span class="line"><span class="comment">      up... */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (in_buf != orig_in) &#123;</span><br><span class="line">     ck_free(in_buf);</span><br><span class="line">     in_buf = orig_in;</span><br><span class="line">     len = queue_cur-&gt;len;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 首先为了havoc清理in_buf</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Pick a random queue entry and seek to it. Don&#x27;t splice with yourself. */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">do</span> &#123; tid = UR(queued_paths); &#125; <span class="keyword">while</span> (tid == current_entry);</span><br><span class="line">   <span class="comment">// 选择一个随机queue内实例</span></span><br><span class="line">   splicing_with = tid;</span><br><span class="line">   target = <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (tid &gt;= <span class="number">100</span>) &#123; target = target-&gt;next_100; tid -= <span class="number">100</span>; &#125;</span><br><span class="line">   <span class="keyword">while</span> (tid--) target = target-&gt;next;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Make sure that the target has a reasonable length. */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (target &amp;&amp; (target-&gt;len &lt; <span class="number">2</span> || target == queue_cur)) &#123;</span><br><span class="line">     target = target-&gt;next;</span><br><span class="line">     splicing_with++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 对长度的检查</span></span><br><span class="line">   <span class="keyword">if</span> (!target) <span class="keyword">goto</span> retry_splicing;</span><br><span class="line"><span class="comment">// 如果直到遍历到最后都没有找到适合长度的，就重试</span></span><br><span class="line">   <span class="comment">/* Read the testcase into a new buffer. */</span></span><br><span class="line"></span><br><span class="line">   fd = open(target-&gt;fname, O_RDONLY);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, target-&gt;fname);</span><br><span class="line"></span><br><span class="line">   new_buf = ck_alloc_nozero(target-&gt;len);</span><br><span class="line"></span><br><span class="line">   ck_read(fd, new_buf, target-&gt;len, target-&gt;fname);</span><br><span class="line"></span><br><span class="line">   close(fd);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Find a suitable splicing location, somewhere between the first and</span></span><br><span class="line"><span class="comment">      the last differing byte. Bail out if the difference is just a single</span></span><br><span class="line"><span class="comment">      byte or so. */</span></span><br><span class="line"></span><br><span class="line">   locate_diffs(in_buf, new_buf, MIN(len, target-&gt;len), &amp;f_diff, &amp;l_diff);</span><br><span class="line">   <span class="comment">// 找到适合的拼接位置， </span></span><br><span class="line">   <span class="comment">// 首先找到第一个和最后一个不同的byte之间，并且避免只是单byte的不同</span></span><br><span class="line">   <span class="keyword">if</span> (f_diff &lt; <span class="number">0</span> || l_diff &lt; <span class="number">2</span> || f_diff == l_diff) &#123;</span><br><span class="line">     ck_free(new_buf);</span><br><span class="line">     <span class="keyword">goto</span> retry_splicing;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Split somewhere between the first and last differing byte. */</span></span><br><span class="line">   <span class="comment">// 然后在这个区间随机选择一个位置来进行拼接 </span></span><br><span class="line">   split_at = f_diff + UR(l_diff - f_diff);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Do the thing. */</span></span><br><span class="line"></span><br><span class="line">   len = target-&gt;len;</span><br><span class="line">   <span class="built_in">memcpy</span>(new_buf, in_buf, split_at);</span><br><span class="line">   in_buf = new_buf;</span><br><span class="line"></span><br><span class="line">   ck_free(out_buf);</span><br><span class="line">   out_buf = ck_alloc_nozero(len);</span><br><span class="line">   <span class="built_in">memcpy</span>(out_buf, in_buf, len);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">goto</span> havoc_stage;</span><br><span class="line">   <span class="comment">// 最后通过havoc阶段进行变异</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在之后再一次运行到此时由于不再满足此if判断，于是结束循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (use_splicing &amp;&amp; splice_cycle++ &lt; SPLICE_CYCLES &amp;&amp;</span><br><span class="line">     queued_paths &gt; <span class="number">1</span> &amp;&amp; queue_cur-&gt;len &gt; <span class="number">1</span>) </span><br></pre></td></tr></table></figure>
<p>最终清理资源，并结束fuzz_one的运行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ret_val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">abandon_entry:</span><br><span class="line"></span><br><span class="line">  splicing_with = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Update pending_not_fuzzed count if we made it through the calibration</span></span><br><span class="line"><span class="comment">     cycle and have not seen this entry before. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!stop_soon &amp;&amp; !queue_cur-&gt;cal_failed &amp;&amp; !queue_cur-&gt;was_fuzzed) &#123;</span><br><span class="line">    queue_cur-&gt;was_fuzzed = <span class="number">1</span>;</span><br><span class="line">    pending_not_fuzzed--;</span><br><span class="line">    <span class="keyword">if</span> (queue_cur-&gt;favored) pending_favored--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  munmap(orig_in, queue_cur-&gt;len);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_buf != orig_in) ck_free(in_buf);</span><br><span class="line">  ck_free(out_buf);</span><br><span class="line">  ck_free(eff_map);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret_val;</span><br></pre></td></tr></table></figure>
<h3 id="trim-case-对于testcase的修剪">trim_case | 对于testcase的修剪</h3>
<p>trim_case以2的幂次位置为单位进行裁剪,  每次修减后通过run_target 运行,  测试结果是否与原来相同。</p>
<p>最后如果发生了修剪，再更新bitmap_score</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u8 <span class="title function_">trim_case</span><span class="params">(<span class="type">char</span> **argv, <span class="keyword">struct</span> queue_entry *q, u8 *in_buf)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8 tmp[<span class="number">64</span>];</span><br><span class="line">  <span class="type">static</span> u8 clean_trace[MAP_SIZE];</span><br><span class="line"></span><br><span class="line">  u8 needs_write = <span class="number">0</span>, fault = <span class="number">0</span>;</span><br><span class="line">  u32 trim_exec = <span class="number">0</span>;</span><br><span class="line">  u32 remove_len;</span><br><span class="line">  u32 len_p2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Although the trimmer will be less useful when variable behavior is</span></span><br><span class="line"><span class="comment">     detected, it will still work to some extent, so we don&#x27;t check for</span></span><br><span class="line"><span class="comment">     this. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;len &lt; <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  stage_name = tmp;</span><br><span class="line">  bytes_trim_in += q-&gt;len;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Select initial chunk len, starting with large steps. */</span></span><br><span class="line"></span><br><span class="line">  len_p2 = next_p2(q-&gt;len);</span><br><span class="line">  <span class="comment">// 以2的幂次向上取整</span></span><br><span class="line">  remove_len = MAX(len_p2 / TRIM_START_STEPS, TRIM_MIN_BYTES);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Continue until the number of steps gets too high or the stepover</span></span><br><span class="line"><span class="comment">     gets too small. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (remove_len &gt;= MAX(len_p2 / TRIM_END_STEPS, TRIM_MIN_BYTES))</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    u32 remove_pos = remove_len;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;trim %s/%s&quot;</span>, DI(remove_len), DI(remove_len));</span><br><span class="line"></span><br><span class="line">    stage_cur = <span class="number">0</span>;</span><br><span class="line">    stage_max = q-&gt;len / remove_len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (remove_pos &lt; q-&gt;len)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      u32 trim_avail = MIN(remove_len, q-&gt;len - remove_pos);</span><br><span class="line">      u32 cksum;</span><br><span class="line"></span><br><span class="line">      write_with_gap(in_buf, q-&gt;len, remove_pos, trim_avail);</span><br><span class="line">      <span class="comment">// 将修剪后的输入写入outfile</span></span><br><span class="line">      fault = run_target(argv, exec_tmout);</span><br><span class="line">      <span class="comment">// 运行fuzz </span></span><br><span class="line">      trim_execs++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stop_soon || fault == FAULT_ERROR)</span><br><span class="line">        <span class="keyword">goto</span> abort_trimming;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Note that we don&#x27;t keep track of crashes or hangs here; maybe TODO? */</span></span><br><span class="line"></span><br><span class="line">      cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* If the deletion had no impact on the trace, make it permanent. This</span></span><br><span class="line"><span class="comment">         isn&#x27;t perfect for variable-path inputs, but we&#x27;re just making a</span></span><br><span class="line"><span class="comment">         best-effort pass, so it&#x27;s not a big deal if we end up with false</span></span><br><span class="line"><span class="comment">         negatives every now and then. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cksum == q-&gt;exec_cksum)</span><br><span class="line">      &#123;</span><br><span class="line">      <span class="comment">// 检查运行时bitmap是否与原来相等</span></span><br><span class="line">        u32 move_tail = q-&gt;len - remove_pos - trim_avail;</span><br><span class="line"></span><br><span class="line">        q-&gt;len -= trim_avail;</span><br><span class="line">        len_p2 = next_p2(q-&gt;len);</span><br><span class="line"></span><br><span class="line">        memmove(in_buf + remove_pos, in_buf + remove_pos + trim_avail,</span><br><span class="line">                move_tail);</span><br><span class="line">        <span class="comment">// 如果是，则更新testcase的len以及内存中的testcase </span></span><br><span class="line">        <span class="comment">/* Let&#x27;s save a clean trace, which will be needed by</span></span><br><span class="line"><span class="comment">           update_bitmap_score once we&#x27;re done with the trimming stuff. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!needs_write)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// 如果之前没有设置need_write，设置此标志 </span></span><br><span class="line">          needs_write = <span class="number">1</span>;</span><br><span class="line">          <span class="built_in">memcpy</span>(clean_trace, trace_bits, MAP_SIZE);</span><br><span class="line">          <span class="comment">// 保存trace_bits</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        remove_pos += remove_len;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Since this can be slow, update the screen every now and then. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!(trim_exec++ % stats_update_freq))</span><br><span class="line">        show_stats();</span><br><span class="line">      stage_cur++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remove_len &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we have made changes to in_buf, we also need to update the on-disk</span></span><br><span class="line"><span class="comment">     version of the test case. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (needs_write)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">// 如果发生了修剪，需要同步到磁盘里保存的testcase, 并且更新bitmap_score</span></span><br><span class="line">    s32 fd;</span><br><span class="line"></span><br><span class="line">    unlink(q-&gt;fname); <span class="comment">/* ignore errors */</span></span><br><span class="line"></span><br><span class="line">    fd = open(q-&gt;fname, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, q-&gt;fname);</span><br><span class="line"></span><br><span class="line">    ck_write(fd, in_buf, q-&gt;len, q-&gt;fname);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(trace_bits, clean_trace, MAP_SIZE);</span><br><span class="line">    update_bitmap_score(q);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">abort_trimming:</span><br><span class="line">  bytes_trim_out += q-&gt;len;</span><br><span class="line">  <span class="keyword">return</span> fault;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="calculate-score-对于testcase分数的计算">calculate_score | 对于testcase分数的计算</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u32 <span class="title function_">calculate_score</span><span class="params">(<span class="keyword">struct</span> queue_entry *q)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  u32 avg_exec_us = total_cal_us / total_cal_cycles;</span><br><span class="line">  u32 avg_bitmap_size = total_bitmap_size / total_bitmap_entries;</span><br><span class="line">  u32 perf_score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Adjust score based on execution speed of this path, compared to the</span></span><br><span class="line"><span class="comment">     global average. Multiplier ranges from 0.1x to 3x. Fast inputs are</span></span><br><span class="line"><span class="comment">     less expensive to fuzz, so we&#x27;re giving them more air time. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">0.1</span> &gt; avg_exec_us)</span><br><span class="line">    perf_score = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">0.25</span> &gt; avg_exec_us)</span><br><span class="line">    perf_score = <span class="number">25</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">0.5</span> &gt; avg_exec_us)</span><br><span class="line">    perf_score = <span class="number">50</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">0.75</span> &gt; avg_exec_us)</span><br><span class="line">    perf_score = <span class="number">75</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">4</span> &lt; avg_exec_us)</span><br><span class="line">    perf_score = <span class="number">300</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">3</span> &lt; avg_exec_us)</span><br><span class="line">    perf_score = <span class="number">200</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">2</span> &lt; avg_exec_us)</span><br><span class="line">    perf_score = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Adjust score based on bitmap size. The working theory is that better</span></span><br><span class="line"><span class="comment">     coverage translates to better targets. Multiplier from 0.25x to 3x. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">0.3</span> &gt; avg_bitmap_size)</span><br><span class="line">    perf_score *= <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">0.5</span> &gt; avg_bitmap_size)</span><br><span class="line">    perf_score *= <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">0.75</span> &gt; avg_bitmap_size)</span><br><span class="line">    perf_score *= <span class="number">1.5</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">3</span> &lt; avg_bitmap_size)</span><br><span class="line">    perf_score *= <span class="number">0.25</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">2</span> &lt; avg_bitmap_size)</span><br><span class="line">    perf_score *= <span class="number">0.5</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">1.5</span> &lt; avg_bitmap_size)</span><br><span class="line">    perf_score *= <span class="number">0.75</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Adjust score based on handicap. Handicap is proportional to how late</span></span><br><span class="line"><span class="comment">     in the game we learned about this path. Latecomers are allowed to run</span></span><br><span class="line"><span class="comment">     for a bit longer until they catch up with the rest. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;handicap &gt;= <span class="number">4</span>)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    perf_score *= <span class="number">4</span>;</span><br><span class="line">    q-&gt;handicap -= <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;handicap)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    perf_score *= <span class="number">2</span>;</span><br><span class="line">    q-&gt;handicap--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Final adjustment based on input depth, under the assumption that fuzzing</span></span><br><span class="line"><span class="comment">     deeper test cases is more likely to reveal stuff that can&#x27;t be</span></span><br><span class="line"><span class="comment">     discovered with traditional fuzzers. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (q-&gt;depth)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span> ... <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span> ... <span class="number">7</span>:</span><br><span class="line">    perf_score *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">8</span> ... <span class="number">13</span>:</span><br><span class="line">    perf_score *= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">14</span> ... <span class="number">25</span>:</span><br><span class="line">    perf_score *= <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    perf_score *= <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure that we don&#x27;t go over limit. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (perf_score &gt; HAVOC_MAX_MULT * <span class="number">100</span>)</span><br><span class="line">    perf_score = HAVOC_MAX_MULT * <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> perf_score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="common-fuzz-stuff-一个testcase的运行">common_fuzz_stuff | 一个testcase的运行</h3>
<p>在fuzz过程中，用来通知fork_server运行一次测试，并且保存有效的种子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">EXP_ST u8 <span class="title function_">common_fuzz_stuff</span><span class="params">(<span class="type">char</span> **argv, u8 *out_buf, u32 len)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  u8 fault;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (post_handler)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    out_buf = post_handler(out_buf, &amp;len);</span><br><span class="line">    <span class="comment">// 此handler通常是afl_processers</span></span><br><span class="line">    <span class="keyword">if</span> (!out_buf || !len)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  write_to_testcase(out_buf, len);</span><br><span class="line">  <span class="comment">// 保存此testcase</span></span><br><span class="line">  fault = run_target(argv, exec_tmout);</span><br><span class="line">  <span class="comment">// 运行一次测试</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回1说明需要快速终止</span></span><br><span class="line">  <span class="keyword">if</span> (stop_soon)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fault == FAULT_TMOUT)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subseq_tmouts++ &gt; TMOUT_LIMIT)</span><br><span class="line">    &#123;</span><br><span class="line">      cur_skipped_paths++;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    subseq_tmouts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Users can hit us with SIGUSR1 to request the current input</span></span><br><span class="line"><span class="comment">     to be abandoned. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (skip_requested)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    skip_requested = <span class="number">0</span>;</span><br><span class="line">    cur_skipped_paths++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This handles FAULT_ERROR for us: */</span></span><br><span class="line"></span><br><span class="line">  queued_discovered += save_if_interesting(argv, out_buf, len, fault);</span><br><span class="line">  <span class="comment">// 如果存在interesting 的种子，保存起来</span></span><br><span class="line">  <span class="keyword">if</span> (!(stage_cur % stats_update_freq) || stage_cur + <span class="number">1</span> == stage_max)</span><br><span class="line">    show_stats();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
            
          </div>
          <div class="archive-post-info">
            <time class="archive-post-time">
              2024-01-12
            </time>
            <a  class="archive-post-link" href="/Fuzz.AFL-All-in-One/">
              Fuzz.AFL-All-in-One
            </a>
          </div>
        </div>
      
      
        </section></section>
      
  </div>
  
  <nav class="pagination">
      <span class="page-number current">1</span>
  </nav>




        </div>
      </main>
      <footer class="footer syuanpi fadeIn" id="footer">
  <hr>
  <div class="footer-wrapper">
    <div class="left">
      <div class="contact-icon">
  
  
    <a target="_blank" rel="noopener" href="https://www.facebook.com/" class="iconfont icon-facebook" title="facebook"></a>
  
    <a target="_blank" rel="noopener" href="https://twitter.com/" class="iconfont icon-twitter" title="twitter"></a>
  
    <a target="_blank" rel="noopener" href="https://www.instagram.com/" class="iconfont icon-instagram" title="instagram"></a>
  
    <a target="_blank" rel="noopener" href="https://weibo.com/" class="iconfont icon-weibo" title="weibo"></a>
  
    <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/" class="iconfont icon-zhihu" title="zhihu"></a>
  
    <a target="_blank" rel="noopener" href="https://github.com/" class="iconfont icon-github" title="github"></a>
  
    <a target="_blank" rel="noopener" href="https://www.linkedin.com/in/" class="iconfont icon-linkedin" title="linkedin"></a>
  
    <a target="_blank" rel="noopener" href="https://www.douban.com/people/" class="iconfont icon-douban" title="douban"></a>
  
    <a target="_blank" rel="noopener" href="https://medium.com/" class="iconfont icon-medium" title="medium"></a>
  
    <a target="_blank" rel="noopener" href="https://www.yuque.com/" class="iconfont icon-yuque" title="yuque"></a>
  
</div>

    </div>
    <div class="right">
      <div class="copyright">
    <div class="info">
        <span>&copy;</span>
        <span>2016 ~ 2024</span>
        <span>❤</span>
        <span>V3rdant</span>
    </div>
    <div class="theme">
        <span>
            Powered by
            <a href="http://hexo.io/" target="_blank" rel="noopener">Hexo </a>
        </span>
        <span>
            Theme
            <a target="_blank" rel="noopener" href="https://github.com/ColMugX/hexo-theme-Nlvi"> Nlvi </a>
        </span>
    </div>
    
</div>

    </div>
  </div>
</footer>
    </div>
    <div class="tagcloud" id="tagcloud">
  <div class="tagcloud-taglist">
  
    <div class="tagcloud-tag">
      <button>Pwn</button>
    </div>
  
    <div class="tagcloud-tag">
      <button>linux</button>
    </div>
  
    <div class="tagcloud-tag">
      <button>io_uring</button>
    </div>
  
    <div class="tagcloud-tag">
      <button>shellcode</button>
    </div>
  
    <div class="tagcloud-tag">
      <button>CTF</button>
    </div>
  
    <div class="tagcloud-tag">
      <button>pwn</button>
    </div>
  
    <div class="tagcloud-tag">
      <button>Kernel</button>
    </div>
  
    <div class="tagcloud-tag">
      <button>Fuzz</button>
    </div>
  
    <div class="tagcloud-tag">
      <button>Coding</button>
    </div>
  
  </div>
  
    <div class="tagcloud-postlist active">
      <h2>Pwn</h2>
      
        <div class="tagcloud-post">
          <a href="/Linux.Seccomp-and-Ptrace/">
            <time class="tagcloud-posttime">2023 / 10 / 31</time>
            <span>Linux.Seccomp-and-Ptrace</span>
          </a>
        </div>
      
        <div class="tagcloud-post">
          <a href="/Pwn.Heap-Exploation-up-to-2.31/">
            <time class="tagcloud-posttime">2023 / 06 / 21</time>
            <span>Pwn.Heap-Exploation-up-to-2.31</span>
          </a>
        </div>
      
        <div class="tagcloud-post">
          <a href="/Pwn.I-Wanna-be-A-LLVM-Passer/">
            <time class="tagcloud-posttime">2023 / 06 / 23</time>
            <span>Pwn.I wanna be a llvm passer</span>
          </a>
        </div>
      
        <div class="tagcloud-post">
          <a href="/Pwn.Linux-Kernel-Pwn-All-in-One/">
            <time class="tagcloud-posttime">2024 / 01 / 11</time>
            <span>Pwn.Linux-Kernel-Pwn-All-in-One</span>
          </a>
        </div>
      
    </div>
  
    <div class="tagcloud-postlist ">
      <h2>linux</h2>
      
        <div class="tagcloud-post">
          <a href="/Linux.Seccomp-and-Ptrace/">
            <time class="tagcloud-posttime">2023 / 10 / 31</time>
            <span>Linux.Seccomp-and-Ptrace</span>
          </a>
        </div>
      
        <div class="tagcloud-post">
          <a href="/Linux.io_uring-Top-down-Approach/">
            <time class="tagcloud-posttime">2023 / 12 / 04</time>
            <span>Linux.io_uring-Top-down-Approch</span>
          </a>
        </div>
      
        <div class="tagcloud-post">
          <a href="/Pwn.Linux-Kernel-Pwn-All-in-One/">
            <time class="tagcloud-posttime">2024 / 01 / 11</time>
            <span>Pwn.Linux-Kernel-Pwn-All-in-One</span>
          </a>
        </div>
      
    </div>
  
    <div class="tagcloud-postlist ">
      <h2>io_uring</h2>
      
        <div class="tagcloud-post">
          <a href="/Linux.io_uring-Top-down-Approach/">
            <time class="tagcloud-posttime">2023 / 12 / 04</time>
            <span>Linux.io_uring-Top-down-Approch</span>
          </a>
        </div>
      
    </div>
  
    <div class="tagcloud-postlist ">
      <h2>shellcode</h2>
      
        <div class="tagcloud-post">
          <a href="/Linux.io_uring-Top-down-Approach/">
            <time class="tagcloud-posttime">2023 / 12 / 04</time>
            <span>Linux.io_uring-Top-down-Approch</span>
          </a>
        </div>
      
    </div>
  
    <div class="tagcloud-postlist ">
      <h2>CTF</h2>
      
        <div class="tagcloud-post">
          <a href="/Pwn.Heap-Exploation-up-to-2.31/">
            <time class="tagcloud-posttime">2023 / 06 / 21</time>
            <span>Pwn.Heap-Exploation-up-to-2.31</span>
          </a>
        </div>
      
        <div class="tagcloud-post">
          <a href="/Pwn.I-Wanna-be-A-LLVM-Passer/">
            <time class="tagcloud-posttime">2023 / 06 / 23</time>
            <span>Pwn.I wanna be a llvm passer</span>
          </a>
        </div>
      
        <div class="tagcloud-post">
          <a href="/Pwn.Linux-Kernel-Pwn-All-in-One/">
            <time class="tagcloud-posttime">2024 / 01 / 11</time>
            <span>Pwn.Linux-Kernel-Pwn-All-in-One</span>
          </a>
        </div>
      
    </div>
  
    <div class="tagcloud-postlist ">
      <h2>pwn</h2>
      
        <div class="tagcloud-post">
          <a href="/Pwn.Stack-Overflow-Overview/">
            <time class="tagcloud-posttime">2022 / 08 / 03</time>
            <span>Pwn.Stack-Overflow-Overview</span>
          </a>
        </div>
      
        <div class="tagcloud-post">
          <a href="/Pwn.The-Art-of-Shellcode/">
            <time class="tagcloud-posttime">2022 / 07 / 31</time>
            <span>Pwn.the-Art-of-Shellcode</span>
          </a>
        </div>
      
    </div>
  
    <div class="tagcloud-postlist ">
      <h2>Kernel</h2>
      
        <div class="tagcloud-post">
          <a href="/Pwn.Linux-Kernel-Pwn-All-in-One/">
            <time class="tagcloud-posttime">2024 / 01 / 11</time>
            <span>Pwn.Linux-Kernel-Pwn-All-in-One</span>
          </a>
        </div>
      
    </div>
  
    <div class="tagcloud-postlist ">
      <h2>Fuzz</h2>
      
        <div class="tagcloud-post">
          <a href="/Fuzz.AFL-All-in-One/">
            <time class="tagcloud-posttime">2024 / 01 / 12</time>
            <span>Fuzz.AFL-All-in-One</span>
          </a>
        </div>
      
    </div>
  
    <div class="tagcloud-postlist ">
      <h2>Coding</h2>
      
        <div class="tagcloud-post">
          <a href="/Fuzz.AFL-All-in-One/">
            <time class="tagcloud-posttime">2024 / 01 / 12</time>
            <span>Fuzz.AFL-All-in-One</span>
          </a>
        </div>
      
    </div>
  
</div>

  </div>
  <div class="backtop syuanpi melt toTop" id="backtop">
    <i class="iconfont icon-up"></i>
    <span style="text-align:center;font-family:Georgia;"><span style="font-family:Georgia;" id="scrollpercent">1</span>%</span>
</div>

  <div class="search" id="search">
    <div class="input">
      <input type="text" id="search-input" placeholder="搜索一下？" autofocus>
    </div>
    <div id="search-result"></div>
  </div>



<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>



  <script></script>
  <script src="/script/lib/lightbox/js/lightbox.min.js" async></script>











  
<script src="/script/scheme/banderole.js"></script>




<script src="/script/bootstarp.js"></script>





</body>
</html>
