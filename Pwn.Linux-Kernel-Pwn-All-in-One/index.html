<!DOCTYPE html>
<html lang="en" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="V3rdant" />
  <!-- Open Graph Description 简短摘要-->
  
  <!-- 用于搜索引擎的文章摘要 -->
  
  
  
  <title>
    
      Pwn.Linux-Kernel-Pwn-All-in-One 
      
      
      |
    
     V3rdant&#39;s Blog
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WT6LFRH6M0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WT6LFRH6M0');
    </script>
  

  
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="V3rdant's Blog" type="application/atom+xml">
</head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">V3rdant</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">Pwn.Linux-Kernel-Pwn-All-in-One</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2024-03-03 16:21:36
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="Categories"></i>
                
                <span class="span--category">
                  <a href="/categories/Pwn/" title="Pwn">
                    <b>#</b> Pwn
                  </a>
                </span>
                
              </span>
          
              <span class="post-tags">
                <i class="iconfont icon-tags mr-10" title="Tags"></i>
                
                <span class="span--tag mr-8">
                  <a href="/tags/Pwn/" title="Pwn">
                    #Pwn
                  </a>
                </span>
                
                <span class="span--tag mr-8">
                  <a href="/tags/linux/" title="linux">
                    #linux
                  </a>
                </span>
                
                <span class="span--tag mr-8">
                  <a href="/tags/CTF/" title="CTF">
                    #CTF
                  </a>
                </span>
                
                <span class="span--tag mr-8">
                  <a href="/tags/Kernel/" title="Kernel">
                    #Kernel
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h1 id="overview">overview</h1>
<p>笔者厌倦了用户态堆的种种tricks，于是决定进入kernel pwn的大坑😊</p>
<h1 id="安全机制">安全机制</h1>
<p><strong>CONFIG_CFI_CLANG=y</strong></p>
<p>控制流完整性校验，限制ROP</p>
<p><strong>CONFIG_SLAB_FREELIST_HARDENED=y</strong></p>
<p>类似于用户态下 glibc 中的 safe-linking 机制，在内核中的 slab/slub 分配器当中也存在着类似的机制保护着 freelist—— <code>SLAB_FREELIST_HARDENED</code>：</p>
<p>类似于 glibc 2.32 版本引入的保护，在开启这种保护之前，slub 中的 free object 的 next 指针直接存放着 next free object 的地址，攻击者可以通过读取 freelist 泄露出内核线性映射区的地址，在开启了该保护之后 free object 的 next 指针存放的是由以下三个值进行异或操作后的值：</p>
<ul>
<li>当前 free object 的地址</li>
<li>下一个 free object 的地址</li>
<li>由 kmem_cache 指定的一个 random 值</li>
</ul>
<p><strong>CONFIG_HARDENED_USERCOPY=y</strong></p>
<p>hardened usercopy 是用以在用户空间与内核空间之间拷贝数据时进行越界检查的一种防护机制，<strong>主要检查拷贝过程中对内核空间中数据的读写是否会越界</strong>：</p>
<ul>
<li>读取的数据长度是否超出源 object 范围</li>
<li>写入的数据长度是否超出目的 object 范围</li>
</ul>
<p>不过这种保护 <em>不适用于内核空间内的数据拷贝</em> ，这也是目前主流的绕过手段</p>
<p>这一保护被用于 <code>copy_to_user()</code> 与 <code>copy_from_user()</code> 等数据交换 API 中</p>
<p><strong>CONFIG_SLAB_FREELIST_RANDOM=y</strong></p>
<p>这种保护主要发生在 slub allocator 向 buddy system 申请到页框之后的处理过程中，对于未开启这种保护的一张完整的 slub，其上的 object 的连接顺序是线性连续的，但在开启了这种保护之后其上的 object 之间的连接顺序是随机的，这让攻击者无法直接预测下一个分配的 object 的地址</p>
<p>需要注意的是这种保护发生在<strong>slub allocator 刚从 buddy system 拿到新 slub 的时候，运行时 freelist 的构成仍遵循 LIFO</strong></p>
<p><strong>CONFIG_INIT_ON_ALLOC_DEFAULT_ON=y</strong></p>
<p>当编译内核时开启了这个选项时，在内核进行“堆内存”分配时（包括 buddy system 和 slab allocator），<strong>会将被分配的内存上的内容进行清零</strong>，从而防止了利用未初始化内存进行数据泄露的情况</p>
<p><strong>CONFIG_RANDOMIZE_KSTACK_OFFSET</strong></p>
<p>决定内核栈是否存在随机偏移</p>
<p><strong>CONFIG_MEMCG_KMEM</strong></p>
<p>决定<code>GFP_KERNEL</code> 与 <code>GFP_KERNEL_ACCOUNT</code> 是否会从同样的 <code>kmalloc-xx</code> 中进行分配</p>
<p><strong>CONFIG_CFI_CLANG</strong></p>
<p>决定是否开启CFI(控制流完整性)， 限制了ROP</p>
<p><strong>CONFIG_STATIC_USERMODEHELPER</strong></p>
<p>决定modprobe_path 是否可写</p>
<h1 id="信息搜集">信息搜集</h1>
<ol>
<li>查看内核版本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/version</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>检查各种基础保护</li>
</ol>
<ul>
<li>启动脚本
<ul>
<li>pti=on</li>
<li>smep,smap</li>
<li>kaslr</li>
</ul>
</li>
<li>.config</li>
<li>检查分配方式</li>
</ul>
<h1 id="Target">Target</h1>
<p>以下部分来自 ctf-wiki, 笔者会添加一些自己的理解。</p>
<h2 id="modify-cred">modify cred</h2>
<p>内核pwn的大部分目标都是实现提权，而一个进程的权限是由其对应的cred结构体决定的，因此。</p>
<p>kernel通过task_struct 中的cred的指针来索引cred结构体，<br>
更进一步地，通过cred的结构体来识别当前user，因此可以通过修改当前cred结构体或者task_struct的指针来达成提权的效果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>    usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="type">atomic_t</span>    subscribers;    <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">    <span class="type">void</span>        *put_addr;</span><br><span class="line">    <span class="type">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">kuid_t</span>      uid;        <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      gid;        <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      suid;       <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      sgid;       <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      euid;       <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      egid;       <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      fsuid;      <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="type">kgid_t</span>      fsgid;      <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="直接定位cred">直接定位cred</h3>
<p>当拥有内存读写的能力后，可以通过在内存中搜索magic 来查找cred结构体。</p>
<p>// 笔者尝试搜索后，发现不知道为什么，有些cred结构体，magic字段为空 #TODO</p>
<p>笔者给出另一个cred定位方法，在内核态下， GS 段 存储着进程相关控制信息，在其固定偏移，可以找到当前cred结构体的指针。</p>
<p>当然，显然大部分情况，是基本不可能找到恰好访问gs目标偏移地址的gadget的，因此这个方法并不是非常实用。</p>
<h3 id="commit-creds"><code>commit_creds</code></h3>
<p><code>commit_creds()</code> 函数被用以将一个新的 cred 设为当前进程 task_struct 的 real_cred 与 cred 字段，因此若是我们能够劫持内核执行流调用该函数并传入一个具有 root 权限的 cred，则能直接完成对当前进程的提权工作</p>
<p>// 笔者目前还没有看过<code>commit_creds()</code>的源代码，并不清楚对cred有哪些检查<br>
// 在笔者看来，如果没有限制 传入的creds必须是相应 <code>slab_account</code> 的话，其实可以自己找一块内存区域来写</p>
<h4 id="prepare-kernel-cred"><code>prepare_kernel_cred()</code></h4>
<p>在内核当中提供了 <code>prepare_kernel_cred()</code> 函数用以拷贝指定进程的 cred 结构体，当我们传入的参数为 NULL 时，该函数会拷贝 <code>init_cred</code> 并返回一个有着 root 权限的 cred：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *daemon)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!new)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    kdebug(<span class="string">&quot;prepare_kernel_cred() alloc %p&quot;</span>, new);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (daemon)</span><br><span class="line">        old = get_task_cred(daemon);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        old = get_cred(&amp;init_cred);</span><br></pre></td></tr></table></figure>
<p>我们不难想到的是若是我们可以在内核空间中调用 <code>commit_creds(prepare_kernel_cred(NULL))</code>，则也能直接完成提权的工作</p>
<p>不过自从内核版本 6.2 起，<code>prepare_kernel_cred(NULL)</code> 将<strong>不再拷贝 init_cred，而是将其视为一个运行时错误并返回 NULL</strong>，这使得这种提权方法无法再应用于 6.2 及更高版本的内核</p>
<h4 id="init-cred"><code>init_cred</code></h4>
<p>在内核初始化过程当中会以 root 权限启动 <code>init</code> 进程，其 cred 结构体为<strong>静态定义</strong>的 <code>init_cred</code>，由此不难想到的是我们可以通过 <code>commit_creds(&amp;init_cred)</code> 来完成提权的工作</p>
<p>// 一个问题是，在高版本，init_cred本身不再作为一个符号导出，因此你直接<br>
// <code>kallsyms-finder</code> 是找不到相应地址的<br>
// 一个直接的方法是，在相应版本linux源代码里面直接搜索符号引用<br>
// 可以在内核代码段里面找到相应地址</p>
<p>// 这个方法不仅仅可以用于<code>init_cred</code>，一切内核data段的匿名结构体都可以通过这个方法查找， 除非内核在写的时候本身就没有直接访问</p>
<h2 id="modprobe-path">modprobe_path</h2>
<p>modprobe 是linux的一个用于执行不确定格式文件的一个机制，其会以root权限使用modprobe_path指向的解释器来实现相对应的程序，如果我们能够劫持相关的程序，就能以root权限执行一个程序，从而提权</p>
<ol>
<li>获取 modprobe_path 的地址。</li>
<li>修改 modprobe_path 为指定的程序。</li>
<li>触发执行 <code>call_modprobe</code>，从而实现提权 。这里我们可以利用以下几种方式来触发
<ol>
<li>执行一个非法的可执行文件。非法的可执行文件需要满足相应的要求（参考 call_usermodehelper 部分的介绍）。</li>
<li>使用未知协议来触发。</li>
</ol>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// step 1. modify modprobe_path to the target value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// step 2. create related file</span></span><br><span class="line">system(<span class="string">&quot;echo -ne &#x27;#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag\ncat flag&#x27; &gt; /home/pwn/catflag.sh&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /home/pwn/catflag.sh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 3. trigger it using unknown executable</span></span><br><span class="line">system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /home/pwn/dummy&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /home/pwn/dummy&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/home/pwn/dummy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 3. trigger it using unknown protocol</span></span><br><span class="line">socket(AF_INET,SOCK_STREAM,<span class="number">132</span>);</span><br></pre></td></tr></table></figure>
<p>在这个过程中，我们着重关注下如何定位 modprobe_path。</p>
<h5 id="直接定位">直接定位</h5>
<p>由于 modprobe_path 的取值是确定的，所以我们可以直接扫描内存，寻找对应的字符串。这需要我们具有扫描内存的能力。</p>
<h5 id="间接定位">间接定位</h5>
<p>考虑到 modprobe_path 相对于内核基地址的偏移是固定的，我们可以先获取到内核的基地址，然后根据相对偏移来得到 modprobe_path 的地址。</p>
<h2 id="poweroff-cmd">poweroff_cmd</h2>
<p>类似于modprobe_path</p>
<ol>
<li>修改 poweroff_cmd 为指定的程序。</li>
<li>劫持控制流执行 <code>__orderly_poweroff</code>。</li>
</ol>
<p>关于如何定位 poweroff_cmd，我们可以采用类似于定位 <code>modprobe_path</code> 的方法。</p>
<h1 id="一些宏">一些宏</h1>
<p>以下列出了常用的一些宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_DMA		0x01u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_HIGHMEM		0x02u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_DMA32		0x04u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_MOVABLE		0x08u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_RECLAIMABLE	0x10u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_HIGH		0x20u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_IO		0x40u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_FS		0x80u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_ZERO		0x100u</span></span><br><span class="line"><span class="comment">/* 0x200u unused */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_DIRECT_RECLAIM	0x400u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_KSWAPD_RECLAIM	0x800u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_WRITE		0x1000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_NOWARN		0x2000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_RETRY_MAYFAIL	0x4000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_NOFAIL		0x8000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_NORETRY		0x10000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_MEMALLOC		0x20000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_COMP		0x40000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_NOMEMALLOC	0x80000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_HARDWALL		0x100000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_THISNODE		0x200000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_ACCOUNT		0x400000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_ZEROTAGS		0x800000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KASAN_HW_TAGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_SKIP_ZERO	0x1000000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_SKIP_KASAN	0x2000000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_SKIP_ZERO	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_SKIP_KASAN	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_NOLOCKDEP	0x4000000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_NOLOCKDEP	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_DMA	((__force gfp_t)___GFP_DMA)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_HIGHMEM	((__force gfp_t)___GFP_HIGHMEM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_DMA32	((__force gfp_t)___GFP_DMA32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_MOVABLE	((__force gfp_t)___GFP_MOVABLE)  <span class="comment">/* ZONE_MOVABLE allowed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_ZONEMASK	(__GFP_DMA|__GFP_HIGHMEM|__GFP_DMA32|__GFP_MOVABLE)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_RECLAIMABLE ((__force gfp_t)___GFP_RECLAIMABLE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_WRITE	((__force gfp_t)___GFP_WRITE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_HARDWALL   ((__force gfp_t)___GFP_HARDWALL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_THISNODE	((__force gfp_t)___GFP_THISNODE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_ACCOUNT	((__force gfp_t)___GFP_ACCOUNT)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_HIGH	((__force gfp_t)___GFP_HIGH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_MEMALLOC	((__force gfp_t)___GFP_MEMALLOC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_NOMEMALLOC ((__force gfp_t)___GFP_NOMEMALLOC)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_IO	((__force gfp_t)___GFP_IO)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_FS	((__force gfp_t)___GFP_FS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_DIRECT_RECLAIM	((__force gfp_t)___GFP_DIRECT_RECLAIM) <span class="comment">/* Caller can reclaim */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_KSWAPD_RECLAIM	((__force gfp_t)___GFP_KSWAPD_RECLAIM) <span class="comment">/* kswapd can wake */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_RECLAIM ((__force gfp_t)(___GFP_DIRECT_RECLAIM|___GFP_KSWAPD_RECLAIM))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_RETRY_MAYFAIL	((__force gfp_t)___GFP_RETRY_MAYFAIL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_NOFAIL	((__force gfp_t)___GFP_NOFAIL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_NORETRY	((__force gfp_t)___GFP_NORETRY)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_NOWARN ((__force gfp_t)___GFP_NOWARN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_COMP ((__force gfp_t)___GFP_COMP)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_ZERO ((__force gfp_t)___GFP_ZERO)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_ZEROTAGS ((__force gfp_t)___GFP_ZEROTAGS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_SKIP_ZERO ((__force gfp_t)___GFP_SKIP_ZERO)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_SKIP_KASAN ((__force gfp_t)___GFP_SKIP_KASAN)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Disable lockdep for GFP context tracking */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_NOLOCKDEP ((__force gfp_t)___GFP_NOLOCKDEP)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Room for N __GFP_FOO bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_BITS_SHIFT (26 + IS_ENABLED(CONFIG_LOCKDEP))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_BITS_MASK ((__force gfp_t)((1 &lt;&lt; __GFP_BITS_SHIFT) - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_ATOMIC (__GFP_HIGH | __GFP_KSWAPD_RECLAIM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_KERNEL (__GFP_RECLAIM | __GFP_IO | __GFP_FS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_KERNEL_ACCOUNT (GFP_KERNEL | __GFP_ACCOUNT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_NOWAIT (__GFP_KSWAPD_RECLAIM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_NOIO (__GFP_RECLAIM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_NOFS (__GFP_RECLAIM | __GFP_IO)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_USER (__GFP_RECLAIM | __GFP_IO | __GFP_FS | __GFP_HARDWALL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_DMA __GFP_DMA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_DMA32 __GFP_DMA32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_HIGHUSER (GFP_USER | __GFP_HIGHMEM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_HIGHUSER_MOVABLE (GFP_HIGHUSER | __GFP_MOVABLE | __GFP_SKIP_KASAN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_TRANSHUGE_LIGHT ((GFP_HIGHUSER_MOVABLE | __GFP_COMP | \</span></span><br><span class="line"><span class="meta">                              __GFP_NOMEMALLOC | __GFP_NOWARN) &amp;  \</span></span><br><span class="line"><span class="meta">                             ~__GFP_RECLAIM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_TRANSHUGE (GFP_TRANSHUGE_LIGHT | __GFP_DIRECT_RECLAIM)</span></span><br></pre></td></tr></table></figure>
<p>此部分来自 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.7.8/source/include/linux/gfp_types.h">https://elixir.bootlin.com/linux/v6.7.8/source/include/linux/gfp_types.h</a></p>
<p>如果需要快速知道对应的宏的值，可以直接用C 来 printf</p>
<p>如GFP_KERNEL: 0x6000C0</p>
<h1 id="攻击方法">攻击方法</h1>
<ul>
<li>ROP
<ul>
<li>ret2usr</li>
<li>pt_regs</li>
<li>sycrop</li>
<li>ret2dir</li>
</ul>
</li>
<li>heap
<ul>
<li>heap spray</li>
<li>heap overflow</li>
<li>double free</li>
<li>Cross cache overflow</li>
<li>page level heap fenshui</li>
</ul>
</li>
<li>Race Condition</li>
<li>USMA</li>
<li>基于idt的内存搜索</li>
</ul>
<h2 id="ROP">ROP</h2>
<h3 id="ret2usr">ret2usr</h3>
<p>由于KPTI的出现，ret2usr实际上已经不可用了，这里介绍一下ret2usr仅仅是为了拓展了解。</p>
<p>简单来说，ret2usr的核心就是利用内核的ring 0权限，执行用户空间的代码来实现提权。</p>
<p>一个典型的ret2usr rop链：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rop_chain[i++] = (<span class="type">size_t</span>)getRootPrivilige;  </span><br><span class="line">rop_chain[i++] = SWAPGS_POPFQ_RET + offset;  </span><br><span class="line">rop_chain[i++] = <span class="number">0</span>;  </span><br><span class="line">rop_chain[i++] = IRETQ + offset;  </span><br><span class="line">rop_chain[i++] = (<span class="type">size_t</span>)getRootShell;  </span><br><span class="line">rop_chain[i++] = user_cs;  </span><br><span class="line">rop_chain[i++] = user_rflags;  </span><br><span class="line">rop_chain[i++] = user_sp;  </span><br><span class="line">rop_chain[i++] = user_ss;</span><br></pre></td></tr></table></figure>
<p>这里的getRootPrivilige就是用户态的 提权代码。</p>
<h4 id="绕过SMAP与SMEP">绕过SMAP与SMEP</h4>
<p>SMAP和SMEP是 <code>x64</code> 限制内核和用户空间的数据访问的一个架构功能，通过CR4寄存器的低位来判断是否开启。 开启后 从内核态访问用户态的数据会直接panic，因此通过在ROP链中插入 修改 <code>cr4</code> 寄存器的gadget即可绕过</p>
<h4 id="KPTI如何限制ret2usr">KPTI如何限制ret2usr</h4>
<p>最后讨论一下KPTI的实现</p>
<blockquote>
<p>When PTI is enabled, the kernel manages two sets of page tables. The first set is very similar to the single set which is present in kernels without PTI. This includes a complete mapping of userspace that the kernel can use for things like copy_to_user().<br>
Although <em>complete</em>, the user portion of the kernel page tables is crippled by setting the NX bit in the top level. This ensures that any missed kernel-&gt;user CR3 switch will immediately crash userspace upon executing its first instruction.<br>
The userspace page tables map only the kernel data needed to enter and exit the kernel. This data is entirely contained in the ‘struct cpu_entry_area’ structure which is placed in the fixmap which gives each CPU’s copy of the area a compile-time-fixed virtual address.<br>
For new userspace mappings, the kernel makes the entries in its page tables like normal. The only difference is when the kernel makes entries in the top (PGD) level. In addition to setting the entry in the main kernel PGD, a copy of the entry is made in the userspace page tables’ PGD.<br>
This sharing at the PGD level also inherently shares all the lower layers of the page tables. This leaves a single, shared set of userspace page tables to manage. One PTE to lock, one set of accessed bits, dirty bits, etc…</p>
</blockquote>
<p>KPTI维护两套页表，一套和没有开启KPTI 时的页表类似，拥有用户态和内核态的完整映射，这是给内核态使用的，不同的是， 此页表对于用户态内存空间的映射，是没有可执行权限的，这里权限的限制是通过页面来实现，因此ret2usr如果关闭了smap和smep，尽管可以访问到用户态数据，但是无法执行用户态代码；</p>
<p>此外，供给用户态的页表，拥有用户态的完整映射和内核的部分映射，这部分映射仅包含进入和离开内核态的代码。</p>
<h3 id="pt-regs-与-KROP">pt_regs 与 KROP</h3>
<p>在5.xx版本（笔者还没有检查具体是哪些版本），或者高版本没有开启如下选项时：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_RANDOMIZE_KSTACK_OFFSET</span><br></pre></td></tr></table></figure>
<p>pt_regs是进入内核态时，压入栈中的结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span>  </span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">* C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry  </span></span><br><span class="line"><span class="comment">* unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.  </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> r15;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> r14;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> r13;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> r12;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> rbp;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> rbx;  </span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span>  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> r11;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> r10;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> r9;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> r8;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> rax;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> rcx;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> rdx;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> rsi;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> rdi;  </span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">* On syscall entry, this is syscall#. On CPU exception, this is error code.  </span></span><br><span class="line"><span class="comment">* On hw interrupt, it&#x27;s IRQ number:  </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> orig_rax;  </span><br><span class="line"><span class="comment">/* Return frame for iretq */</span>  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> rip;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> cs;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> eflags;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> rsp;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ss;  </span><br><span class="line"><span class="comment">/* top of stack page */</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们注意到，这些内容，由用户态的寄存器决定，可以由我们控制。</p>
<p>因此这些部分可以用于布置ROP链， 当劫持到内核某个结构体的函数指针时，只需要<strong>寻找到一条形如 “add rsp, val ; ret” 的 gadget 便能够完成 ROP</strong></p>
<h3 id="ret2dir">ret2dir</h3>
<p>内核堆区 direct_mapping_arean 存在对于整个物理内存的映射，因此，通过mmap在用户态喷射的匿名页面，实际上也从此分配。</p>
<p>通过mmap大量分配，可以获取到 kernel 上一块近乎连续的物理内存，因此，通过不断堆喷布置gadget滑块，然后随机选择一个内核基地址进行栈迁移，最终就有很大概率命中我们写入的页面。</p>
<h3 id="sycrop">sycrop</h3>
<p>通过下硬件断点在用户态触发的方式，可以将寄存器内容推送到与 <code>per_cpu_entry_area</code> 固定偏移的DB stack上，而在linux 6.2之前， <code>per_cpu_entry_area</code> 没有加入随机化，地址固定，所以可以达到在内核固定地址造ROP链的手段</p>
<h3 id="work-for-cpu-fn"><code>work_for_cpu_fn</code></h3>
<p>这实际上是一个tricks，在内核很难ROP时，可以利用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">work_for_cpu_fn</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> *<span class="title">wfc</span> =</span> container_of(work, <span class="keyword">struct</span> work_for_cpu, work);</span><br><span class="line">  wfc-&gt;ret = wfc-&gt;fn(wfc-&gt;arg);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在劫持rsi的情况。</p>
<p>这个函数可以实现执行一次函数调用，并将返回值保存</p>
<h3 id="overview-2">overview</h3>
<p>注意到，上述列出的几个攻击方法，实际上核心问题就是ROP链写在哪些地方。</p>
<ul>
<li>pt_regs: 写在内核栈上</li>
<li>ret2dir： 写在direct mapping arena</li>
<li>sycrop</li>
</ul>
<p>由于ROP可以很方便劫持控制流，所用使用ROP攻击内核时，一般使用 <code>commit_cred</code> 进行提权</p>
<p>遗憾的是，在高版本内核，由于CFI的引入，很多时候难以找到完善的gadget进行利用，限制了ROP的使用</p>
<h2 id="heap">heap</h2>
<h3 id="UAF">UAF</h3>
<h4 id="有效大小Obj的UAF和良好的kmalloc-flag">有效大小Obj的UAF和良好的kmalloc flag</h4>
<p>这里主要指和内核关键结构体存在同样的分配size和flag的UAF， 如 <code>tty_operations</code> 或 <code>seq_operations</code> 等等。</p>
<p>利用这些结构的UAF可以直接leak 内核数据或者劫持控制流，这个攻击流程就不赘述了。</p>
<h4 id="任意大小的UAF">任意大小的UAF</h4>
<p>接下来讲述一下任意大小UAF(也没有那么任意)的利用</p>
<h5 id="CVE-2021-22555：-基于msg-msg的堆喷-GFP-KERNEL-ACCOUNT">CVE-2021-22555： 基于msg_msg的堆喷 | GFP_KERNEL_ACCOUNT</h5>
<h5 id="基于add-key的堆喷">基于add_key的堆喷</h5>
<h5 id="UASM">UASM</h5>
<p>见后文UASM的利用</p>
<h5 id="cross-cache-UAF">cross cache UAF</h5>
<p>#TODO</p>
<h3 id="heap-overflow">heap overflow</h3>
<h4 id="基础overflow">基础overflow</h4>
<p>同上文，存在特定结构体的Overflow， 因此可以非常方便地控制一个有效结构，此时的利用非常简单。</p>
<h4 id="cross-cache-overflow-打破slab隔离">cross_cache overflow  | 打破slab隔离</h4>
<p>众所周知，slab之间存在隔离，因此，如果溢出点在一个特定size的slab，此时，就无法通过直接的溢出劫持控制流。</p>
<p>但是，还是存在在buddy system溢出的办法。</p>
<p>考虑到堆喷耗尽buddy system的低位单页内存，那么之后从slab分配就会从高位连续的页面中切分，此时，就可以使得分配的页面来自一块近乎物理连续的内存，此时，如果在某个页面末尾的slab溢出，那么就可以溢出到下一个页面。</p>
<p>如果下一个页面，被另一个cache申请用来分配另外一种slab，此时就可以实现跨cache的溢出，从而控制有意义的cache.</p>
<h5 id="基于pipe-buffer的溢出通解">基于pipe_buffer的溢出通解</h5>
<p>#TODO</p>
<h2 id="Race-condition">Race condition</h2>
<h3 id="double-feach">double feach</h3>
<p>由于内核模块是全局的，如果对于内核模块的数据访问没有加锁，就很有可能出现竞态漏洞。</p>
<h3 id="userfault">userfault</h3>
<p>在linux 5.11以下可用。</p>
<p>主要是用来辅助条件竞争漏洞。</p>
<p>userfault是一个在用户态进行缺页处理接口。</p>
<p>在正常情况下， race condition的时间窗口是很短暂的，如果能够通过userfault 将操作停住，就能够将竞争的时间窗口扩大，实现竞争。</p>
<h3 id="fuse">fuse</h3>
<p>// 通过CVE分析fuse的利用<br>
#TODO</p>
<h2 id="UASM-2">UASM</h2>
<p>来自 <a target="_blank" rel="noopener" href="https://vul.360.net/archives/391">https://vul.360.net/archives/391</a> 的利用</p>
<p>这个利用笔者最初有点犹豫放在哪个部分。</p>
<p>最后笔者还是决定将内容单独列一个二级目录，因为笔者认为这代表了一种新的利用方法， 不仅仅是 pg_vec， 在io_uring中，同样存在着内核和用户地址的共同映射，有没有可能也利用此来利用呢。</p>
<p>甚至直接对内核页表进行修改，实际上也可以归结为这种利用的一部分。</p>
<p>更进一步的， 笔者认为，UASM 也许可以用在page level uaf中（由于笔者太菜了，暂时先码着）。</p>
<p>简单而言，在创建socket并设置packet后，此时，内核维护一个 <code>pg_vec</code> 数组，每一个数组地址对应着一个虚拟地址。</p>
<p>此时，如果能够通过UAF或者溢出修改pg_vec， 然后再在用户态调用mmap，内核实际上:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/net/packet/af_packet.c</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_mmap</span><span class="params">(file, sock, vma)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span> (rb = &amp;po-&gt;rx_ring; rb &lt;= &amp;po-&gt;tx_ring; rb++) &#123;</span><br><span class="line">       <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rb-&gt;pg_vec_len; i++) &#123;</span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">           <span class="type">void</span> *kaddr = rb-&gt;pg_vec[i].buffer;</span><br><span class="line">           <span class="keyword">for</span> (pg_num = <span class="number">0</span>; pg_num &lt; rb-&gt;pg_vec_pages; pg_num++) &#123;               page = pgv_to_page(kaddr);</span><br><span class="line">               err = vm_insert_page(vma, start, page);</span><br><span class="line">               <span class="keyword">if</span> (unlikely(err))           </span><br><span class="line">                   <span class="keyword">goto</span> out;     </span><br><span class="line">               start += PAGE_SIZE;</span><br><span class="line">              kaddr += PAGE_SIZE;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>vm_insert_page</code> 将这些页，插入了用户态地址空间。</p>
<p>这些页需要满足如下要求</p>
<ul>
<li>page不为匿名页</li>
<li>不为Slab子系统分配的页</li>
<li>page不含有type</li>
</ul>
<p>这就限制了使用内核堆的页面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/mm/memory.c</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">validate_page_before_insert</span><span class="params">(<span class="keyword">struct</span> page *page)</span>           </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span> (PageAnon(page) || PageSlab(page) || page_has_type(page))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;      </span><br><span class="line">    flush_dcache_page(page);        </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;      </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>值得一提的是，这里pg_vec原来的虚拟地址原来的权限是无所谓的，因为并没有对原来虚拟地址的内存权限（也即这个页表项的内存权限）进行检查。</p>
<p>因此我们可以直接修改内核代码段或者内核模块代码段、数据段。<br>
而且线性映射区域存在内核的全部映射，可以在这个地址范围找到上述页面。</p>
<p>更妙的是，pg_vec可以由用户态决定，不过其分配flag是<code>GFP_KERNEL</code></p>
<p>相比于ROP，利用更加简单，并且不受CFI的影响。</p>
<h2 id="dirtypagetable">dirtypagetable</h2>
<p>#TODO</p>
<h2 id="POP-page-level-ROP">POP | page level ROP</h2>
<p>来自blachhat2021的一种思路，主要是用来拓展脑洞，实际利用起来不如UASM直接改内核代码方便。但是很有传统利用的美感。</p>
<p>#TODO</p>
<h2 id="tricks">tricks</h2>
<ul>
<li>基于inter硬件漏洞的leak tricks</li>
<li>在内核“堆基址”（<code>page_offset_base</code>） + <code>0x9d000</code> 处存放着 <code>secondary_startup_64</code> 函数的地址</li>
</ul>
<h2 id="从CTF到实战利用的哲思">从CTF到实战利用的哲思</h2>
<p>#TODO</p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/Linux.io_uring-Top-down-Approach/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2024-03-03 16:21:36
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="Categories"></i>
                    
                    <span class="span--category">
                      <a href="/categories/Pwn/" title="Pwn">
                        <b>#</b> Pwn
                      </a>
                    </span>
                    
                  </span>
              
                  <span class="post-tags">
                    <i class="iconfont icon-tags mr-10" title="Tags"></i>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/Pwn/" title="Pwn">
                        #Pwn
                      </a>
                    </span>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/linux/" title="linux">
                        #linux
                      </a>
                    </span>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/CTF/" title="CTF">
                        #CTF
                      </a>
                    </span>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/Kernel/" title="Kernel">
                        #Kernel
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/Fuzz.AFL-All-in-One/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#overview"><span class="toc-text">overview</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="toc-text">安全机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86"><span class="toc-text">信息搜集</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Target"><span class="toc-text">Target</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#modify-cred"><span class="toc-text">modify cred</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%AE%9A%E4%BD%8Dcred"><span class="toc-text">直接定位cred</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#commit-creds"><span class="toc-text">commit_creds</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#prepare-kernel-cred"><span class="toc-text">prepare_kernel_cred()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#init-cred"><span class="toc-text">init_cred</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#modprobe-path"><span class="toc-text">modprobe_path</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%AE%9A%E4%BD%8D"><span class="toc-text">直接定位</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E5%AE%9A%E4%BD%8D"><span class="toc-text">间接定位</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#poweroff-cmd"><span class="toc-text">poweroff_cmd</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%AE%8F"><span class="toc-text">一些宏</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95"><span class="toc-text">攻击方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ROP"><span class="toc-text">ROP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ret2usr"><span class="toc-text">ret2usr</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%95%E8%BF%87SMAP%E4%B8%8ESMEP"><span class="toc-text">绕过SMAP与SMEP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KPTI%E5%A6%82%E4%BD%95%E9%99%90%E5%88%B6ret2usr"><span class="toc-text">KPTI如何限制ret2usr</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pt-regs-%E4%B8%8E-KROP"><span class="toc-text">pt_regs 与 KROP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ret2dir"><span class="toc-text">ret2dir</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sycrop"><span class="toc-text">sycrop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#work-for-cpu-fn"><span class="toc-text">work_for_cpu_fn</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#overview-2"><span class="toc-text">overview</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#heap"><span class="toc-text">heap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UAF"><span class="toc-text">UAF</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E5%A4%A7%E5%B0%8FObj%E7%9A%84UAF%E5%92%8C%E8%89%AF%E5%A5%BD%E7%9A%84kmalloc-flag"><span class="toc-text">有效大小Obj的UAF和良好的kmalloc flag</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%A4%A7%E5%B0%8F%E7%9A%84UAF"><span class="toc-text">任意大小的UAF</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CVE-2021-22555%EF%BC%9A-%E5%9F%BA%E4%BA%8Emsg-msg%E7%9A%84%E5%A0%86%E5%96%B7-GFP-KERNEL-ACCOUNT"><span class="toc-text">CVE-2021-22555： 基于msg_msg的堆喷 | GFP_KERNEL_ACCOUNT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Eadd-key%E7%9A%84%E5%A0%86%E5%96%B7"><span class="toc-text">基于add_key的堆喷</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UASM"><span class="toc-text">UASM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cross-cache-UAF"><span class="toc-text">cross cache UAF</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#heap-overflow"><span class="toc-text">heap overflow</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80overflow"><span class="toc-text">基础overflow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cross-cache-overflow-%E6%89%93%E7%A0%B4slab%E9%9A%94%E7%A6%BB"><span class="toc-text">cross_cache overflow  | 打破slab隔离</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Epipe-buffer%E7%9A%84%E6%BA%A2%E5%87%BA%E9%80%9A%E8%A7%A3"><span class="toc-text">基于pipe_buffer的溢出通解</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Race-condition"><span class="toc-text">Race condition</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#double-feach"><span class="toc-text">double feach</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#userfault"><span class="toc-text">userfault</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fuse"><span class="toc-text">fuse</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UASM-2"><span class="toc-text">UASM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dirtypagetable"><span class="toc-text">dirtypagetable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#POP-page-level-ROP"><span class="toc-text">POP | page level ROP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tricks"><span class="toc-text">tricks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8ECTF%E5%88%B0%E5%AE%9E%E6%88%98%E5%88%A9%E7%94%A8%E7%9A%84%E5%93%B2%E6%80%9D"><span class="toc-text">从CTF到实战利用的哲思</span></a></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        







      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          
              <a title="github" target="_blank" rel="noopener" href="https://github.com/Du-Mu">
                <i class="iconfont icon-github"></i>
              </a>
              
        </li>
        
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2024 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
    <div class="footer-views">
      
          本站总访问量<span id="busuanzi_value_site_pv"></span>次
        
      
          本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        
      
          本站访客数<span id="busuanzi_value_site_uv"></span>人
        
      
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + Pwn.Linux-Kernel-Pwn-All-in-One + '&url=' + https%3A%2F%2Fv3rdant.cn%2FPwn.Linux-Kernel-Pwn-All-in-One%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=https://v3rdant.cn/Pwn.Linux-Kernel-Pwn-All-in-One/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
